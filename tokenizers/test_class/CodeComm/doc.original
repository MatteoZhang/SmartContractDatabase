/** * @dev Returns the addition of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `+` operator. * * Requirements: * - Addition cannot overflow. */ 
/** * @dev Returns the subtraction of two unsigned integers, reverting on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * - Subtraction cannot overflow. */ 
/** * @dev Returns the subtraction of two unsigned integers, reverting with custom message on * overflow (when the result is negative). * * Counterpart to Solidity's `-` operator. * * Requirements: * - Subtraction cannot overflow. */ 
/** * @dev Returns the multiplication of two unsigned integers, reverting on * overflow. * * Counterpart to Solidity's `*` operator. * * Requirements: * - Multiplication cannot overflow. */ // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
/** * @dev Returns the integer division of two unsigned integers. Reverts on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ 
/** * @dev Returns the integer division of two unsigned integers. Reverts with custom message on * division by zero. The result is rounded towards zero. * * Counterpart to Solidity's `/` operator. Note: this function uses a * `revert` opcode (which leaves remaining gas untouched) while Solidity * uses an invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ // Solidity only automatically asserts when dividing by 0 // assert(a == b * c + a % b); // There is no case in which this doesn't hold
/** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ 
/** * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), * Reverts with custom message when dividing by zero. * * Counterpart to Solidity's `%` operator. This function uses a `revert` * opcode (which leaves remaining gas untouched) while Solidity uses an * invalid opcode to revert (consuming all remaining gas). * * Requirements: * - The divisor cannot be zero. */ 
/** * @dev Returns the amount of tokens in existence. */ 
/** * @dev Returns the amount of tokens owned by `account`. */ 
/** * @dev Moves `amount` tokens from the caller's account to `recipient`. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ 
/** * @dev Returns the remaining number of tokens that `spender` will be * allowed to spend on behalf of `owner` through {transferFrom}. This is * zero by default. * * This value changes when {approve} or {transferFrom} are called. */ 
/** * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. * * Returns a boolean value indicating whether the operation succeeded. * * IMPORTANT: Beware that changing an allowance with this method brings the risk * that someone may use both the old and the new allowance by unfortunate * transaction ordering. One possible solution to mitigate this race * condition is to first reduce the spender's allowance to 0 and set the * desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * Emits an {Approval} event. */ 
/** * @dev Moves `amount` tokens from `sender` to `recipient` using the * allowance mechanism. `amount` is then deducted from the caller's * allowance. * * Returns a boolean value indicating whether the operation succeeded. * * Emits a {Transfer} event. */ 
/** * @dev Emitted when `value` tokens are moved from one account (`from`) to * another (`to`). * * Note that `value` may be zero. */ 
/** * @dev Emitted when the allowance of a `spender` for an `owner` is set by * a call to {approve}. `value` is the new allowance. */ 
/** * @notice Emitted when the owner authorizes ownership transfer to a new address * @param authorizedAddress New owner address */ 
/** * @notice Emitted when the authorized address assumed ownership * @param oldValue Old owner * @param newValue New owner */ 
/** * @notice Retrieves the owner of the contract * @return The contract owner */ 
/** * @notice Retrieves the authorized new owner of the contract * @return The authorized new contract owner */ 
/** * @notice Authorizes the transfer of ownership from owner to the provided address. * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership(). * This authorization may be removed by another call to this function authorizing the zero * address. * @param _authorizedAddress The address authorized to become the new owner */ 
/** * @notice Transfers ownership of this contract to the _authorizedNewOwner * @dev Error invalid sender. */ 
/** * @notice Indicates whether the contract implements the interface `_interfaceHash` * for the address `_addr`. * @param _interfaceHash keccak256 hash of the name of the interface. * @return ERC1820_ACCEPT_MAGIC only if the contract implements `ìnterfaceHash` * for the address `_addr`. * @dev In this implementation, the `_addr` (the address for which the * contract will implement the interface) is always `address(this)`. */ address 
/** * @notice Internally set the fact this contract implements the interface * identified by `_interfaceLabel` * @param _interfaceLabel String representation of the interface. */ 
/** * @dev Report if the transfer will succeed from the pespective of the * token sender */ 
/** * @dev Hook executed upon a transfer on behalf of the sender */ 
/** * @dev Report if the recipient will successfully receive the tokens */ 
/** * @dev Hook executed upon a transfer to the recipient */ 
/** * @notice Retrieve the destination partition from the 'data' field. * A partition change is requested ONLY when 'data' starts with the flag: * *   0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff * * When the flag is detected, the destination partition is extracted from the * 32 bytes following the flag. * @param _data Information attached to the transfer. Will contain the * destination partition if a change is requested. * @param _fallbackPartition Partition value to return if a partition change * is not requested in the `_data`. * @return toPartition Destination partition. If the `_data` does not contain * the prefix and bytes32 partition in the first 64 bytes, the method will * return the provided `_fromPartition`. */ 
/** * @notice Helper to get the strategy identifying prefix from the `_partition`. * @param _partition Partition to get the prefix for. * @return 4 byte partition strategy prefix. */ 
/** * @notice Helper method to split the partition into the prefix, sub partition * and partition owner components. * @param _partition The partition to split into parts. * @return The 4 byte partition prefix, 8 byte sub partition, and final 20 * bytes representing an address. */ 
/** * @notice Helper method to get a partition strategy ERC1820 interface name * based on partition prefix. * @param _prefix 4 byte partition prefix. * @dev Each 4 byte prefix has a unique interface name so that an individual * hook implementation can be set for each prefix. */ 
/** * @notice Emitted when a transfer has been successfully completed. * @param fromPartition The partition the tokens were transfered from. * @param operator The address that initiated the transfer. * @param from The address the tokens were transferred from. * @param to The address the tokens were transferred to. * @param value The amount of tokens transferred. * @param data Additional metadata included with the transfer. Can include * the partition the tokens were transferred to (if different than * `fromPartition`). * @param operatorData Additional metadata included with the transfer on * behalf of the operator. */ 
/** * @notice Emitted when a transfer has been successfully completed and the * tokens that were transferred have changed partitions. * @param fromPartition The partition the tokens were transfered from. * @param toPartition The partition the tokens were transfered to. * @param value The amount of tokens transferred. */ 
/** * @notice Emitted when a token holder specifies an amount of tokens in a * a partition that an operator can transfer. * @param partition The partition of the tokens the holder has authorized the * operator to transfer from. * @param owner The token holder. * @param spender The operator the `owner` has authorized the allowance for. */ 
/** * @notice Emitted when a token holder has authorized an operator for their * tokens. * @dev This event applies to the token holder address across all partitions. * @param operator The address that was authorized to transfer tokens on * behalf of the `tokenHolder`. * @param tokenHolder The address that authorized the `operator` to transfer * their tokens. */ 
/** * @notice Emitted when a token holder has de-authorized an operator from * transferring their tokens. * @dev This event applies to the token holder address across all partitions. * @param operator The address that was de-authorized from transferring tokens * on behalf of the `tokenHolder`. * @param tokenHolder The address that revoked the `operator`'s permission * to transfer their tokens. */ 
/** * @notice Emitted when a token holder has authorized an operator to transfer * their tokens of one partition. * @param partition The partition the `operator` is allowed to transfer * tokens from. * @param operator The address that was authorized to transfer tokens on * behalf of the `tokenHolder`. * @param tokenHolder The address that authorized the `operator` to transfer * their tokens in `partition`. */ 
/** * @notice Emitted when a token holder has de-authorized an operator from * transferring their tokens from a specific partition. * @param partition The partition the `operator` is no longer allowed to * transfer tokens from on behalf of the `tokenHolder`. * @param operator The address that was de-authorized from transferring * tokens on behalf of the `tokenHolder`. * @param tokenHolder The address that revoked the `operator`'s permission * to transfer their tokens from `partition`. */ 
/** * @notice Emitted when a collateral manager has been registered. * @param collateralManager The address of the collateral manager. */ 
/** * @notice Emitted when a new partition strategy validator is set. * @param flag The 4 byte prefix of the partitions that the stratgy affects. * @param name The name of the partition strategy. * @param implementation The address of the partition strategy hook * implementation. */ 
/** * @notice Emitted when tokens are minted as a result of a token swap * @param operator Address that executed the swap that resulted in tokens being minted * @param to Address that received the newly minted tokens. * @param value Amount of tokens minted * @param data Empty bytes, required for interface compatibility */ 
/** * @notice Indicates tokens swapped for Amp. * @dev The tokens that are swapped for Amp will be transferred to a * graveyard address that is for all practical purposes inaccessible. * @param operator Address that executed the swap. * @param from Address that the tokens were swapped from, and Amp minted for. * @param value Amount of tokens swapped into Amp. */ 
/** * @notice Get the total number of issued tokens. * @return Total supply of tokens currently in circulation. */ 
/** * @notice Get the balance of the account with address `_tokenHolder`. * @dev This returns the balance of the holder across all partitions. Note * that due to other functionality in Amp, this figure should not be used * as the arbiter of the amount a token holder will successfully be able to * send via the ERC20 compatible `transfer` method. In order to get that * figure, use `balanceOfByParition` and to get the balance of the default * partition. * @param _tokenHolder Address for which the balance is returned. * @return Amount of token held by `_tokenHolder` in the default partition. */ 
/** * @notice Transfer token for a specified address. * @dev This method is for ERC20 compatibility, and only affects the * balance of the `msg.sender` address's default partition. * @param _to The address to transfer to. * @param _value The value to be transferred. * @return A boolean that indicates if the operation was successful. */ 
/** * @notice Transfer tokens from one address to another. * @dev This method is for ERC20 compatibility, and only affects the * balance and allowance of the `_from` address's default partition. * @param _from The address which you want to transfer tokens from. * @param _to The address which you want to transfer to. * @param _value The amount of tokens to be transferred. * @return A boolean that indicates if the operation was successful. */ 
/** * @notice Check the value of tokens that an owner allowed to a spender. * @dev This method is for ERC20 compatibility, and only affects the * allowance of the `msg.sender`'s default partition. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the value of tokens still available for the * spender. */ 
/** * @notice Approve the passed address to spend the specified amount of * tokens from the default partition on behalf of 'msg.sender'. * @dev This method is for ERC20 compatibility, and only affects the * allowance of the `msg.sender`'s default partition. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. * @return A boolean that indicates if the operation was successful. */ 
/** * @notice Atomically increases the allowance granted to `_spender` by the * for caller. * @dev This is an alternative to {approve} that can be used as a mitigation * problems described in {IERC20-approve}. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `_spender` cannot be the zero address. * @dev This method is for ERC20 compatibility, and only affects the * allowance of the `msg.sender`'s default partition. * @param _spender Operator allowed to transfer the tokens * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender` * is allowed to transfer * @return 'true' is successful, 'false' otherwise */ 
/** * @notice Atomically decreases the allowance granted to `_spender` by the * caller. * @dev This is an alternative to {approve} that can be used as a mitigation * for bugs caused by reentrancy. * Emits an {Approval} event indicating the updated allowance. * Requirements: * - `_spender` cannot be the zero address. * - `_spender` must have allowance for the caller of at least * `_subtractedValue`. * @dev This method is for ERC20 compatibility, and only affects the * allowance of the `msg.sender`'s default partition. * @param _spender Operator allowed to transfer the tokens * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender` * is no longer allowed to transfer * @return 'true' is successful, 'false' otherwise */ 
/** * @notice Swap tokens to mint AMP. * @dev Requires `_from` to have given allowance of swap token to contract. * Otherwise will throw error code 53 (Insuffient Allowance). * @param _from Token holder to execute the swap for. */ 
/** * @notice Get balance of a tokenholder for a specific partition. * @param _partition Name of the partition. * @param _tokenHolder Address for which the balance is returned. * @return Amount of token of partition `_partition` held by `_tokenHolder` in the token contract. */ 
/** * @notice Get partitions index of a token holder. * @param _tokenHolder Address for which the partitions index are returned. * @return Array of partitions index of '_tokenHolder'. */ 
/** * @notice Transfer tokens from a specific partition on behalf of a token * holder, optionally changing the parittion and optionally including * arbitrary data with the transfer. * @dev This can be used to transfer an address's own tokens, or transfer * a different addresses tokens by specifying the `_from` param. If * attempting to transfer from a different address than `msg.sender`, the * `msg.sender` will need to be an operator or have enough allowance for the * `_partition` of the `_from` address. * @param _partition Name of the partition to transfer from. * @param _from Token holder. * @param _to Token recipient. * @param _value Number of tokens to transfer. * @param _data Information attached to the transfer. Will contain the * destination partition (if changing partitions). * @param _operatorData Information attached to the transfer, by the operator. * @return Destination partition. */ 
/** * @notice Set a third party operator address as an operator of 'msg.sender' * to transfer and redeem tokens on its behalf. * @dev The msg.sender is always an operator for itself, and does not need to * be explicitly added. * @param _operator Address to set as an operator for 'msg.sender'. */ 
/** * @notice Remove the right of the operator address to be an operator for * 'msg.sender' and to transfer and redeem tokens on its behalf. * @dev The msg.sender is always an operator for itself, and cannot be * removed. * @param _operator Address to rescind as an operator for 'msg.sender'. */ 
/** * @notice Set `_operator` as an operator for 'msg.sender' for a given partition. * @dev The msg.sender is always an operator for itself, and does not need to * be explicitly added to a partition. * @param _partition Name of the partition. * @param _operator Address to set as an operator for 'msg.sender'. */ 
/** * @notice Remove the right of the operator address to be an operator on a * given partition for 'msg.sender' and to transfer and redeem tokens on its * behalf. * @dev The msg.sender is always an operator for itself, and cannot be * removed from a partition. * @param _partition Name of the partition. * @param _operator Address to rescind as an operator on given partition for * 'msg.sender'. */ 
/** * @notice Indicate whether the `_operator` address is an operator of the * `_tokenHolder` address. * @dev An operator in this case is an operator across all of the partitions * of the `msg.sender` address. * @param _operator Address which may be an operator of `_tokenHolder`. * @param _tokenHolder Address of a token holder which may have the * `_operator` address as an operator. * @return 'true' if operator is an operator of 'tokenHolder' and 'false' * otherwise. */ 
/** * @notice Indicate whether the operator address is an operator of the * `_tokenHolder` address for the given partition. * @param _partition Name of the partition. * @param _operator Address which may be an operator of tokenHolder for the * given partition. * @param _tokenHolder Address of a token holder which may have the * `_operator` address as an operator for the given partition. * @return 'true' if 'operator' is an operator of `_tokenHolder` for * partition '_partition' and 'false' otherwise. */ 
/** * @notice Indicate when the `_operator` address is an operator of the * `_collateralManager` address for the given partition. * @dev This method is the same as `isOperatorForPartition`, except that it * also requires the address that `_operator` is being checked for MUST be * a registered collateral manager, and this method will not execute * partition strategy operator check hooks. * @param _partition Name of the partition. * @param _operator Address which may be an operator of `_collateralManager` * for the given partition. * @param _collateralManager Address of a collateral manager which may have * the `_operator` address as an operator for the given partition. */ 
/** * @notice Get the name of the token (Amp). * @return Name of the token. */ 
/** * @notice Get the symbol of the token (AMP). * @return Symbol of the token. */ 
/** * @notice Get the number of decimals of the token. * @dev Hard coded to 18. * @return The number of decimals of the token (18). */ 
/** * @notice Get the smallest part of the token that’s not divisible. * @dev Hard coded to 1. * @return The smallest non-divisible part of the token. */ 
/** * @notice Get list of existing partitions. * @return Array of all exisiting partitions. */ 
/** * @notice Check the value of tokens that an owner allowed to a spender. * @param _partition Name of the partition. * @param _owner The address which owns the tokens. * @param _spender The address which will spend the tokens. * @return The value of tokens still for the spender to transfer. */ 
/** * @notice Approve the `_spender` address to spend the specified amount of * tokens in `_partition` on behalf of 'msg.sender'. * @param _partition Name of the partition. * @param _spender The address which will spend the tokens. * @param _value The amount of tokens to be tokens. * @return A boolean that indicates if the operation was successful. */ 
/** * @notice Atomically increases the allowance granted to `_spender` by the * caller. * @dev This is an alternative to {approveByPartition} that can be used as * a mitigation for bugs caused by reentrancy. * Emits an {ApprovalByPartition} event indicating the updated allowance. * Requirements: * - `_spender` cannot be the zero address. * @param _partition Name of the partition. * @param _spender Operator allowed to transfer the tokens * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender` * is allowed to transfer * @return 'true' is successful, 'false' otherwise */ 
/** * @notice Atomically decreases the allowance granted to `_spender` by the * caller. * @dev This is an alternative to {approveByPartition} that can be used as * a mitigation for bugs caused by reentrancy. * Emits an {ApprovalByPartition} event indicating the updated allowance. * Requirements: * - `_spender` cannot be the zero address. * - `_spender` must have allowance for the caller of at least * `_subtractedValue`. * @param _spender Operator allowed to transfer the tokens * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender` is * no longer allowed to transfer * @return 'true' is successful, 'false' otherwise */ // TOOD: Figure out if safe math will panic below 0
/** * @notice Allow a collateral manager to self-register. * @dev Error 0x5c. */ // Short circuit a double registry
/** * @notice Get the status of a collateral manager. * @param _collateralManager The address of the collateral mananger in question. * @return 'true' if `_collateralManager` has self registered, 'false' * otherwise. */ 
/** * @notice Sets an implementation for a partition strategy identified by prefix. * @dev This is an administration method, callable only by the owner of the * Amp contract. * @param _prefix The 4 byte partition prefix the strategy applies to. * @param _implementation The address of the implementation of the strategy hooks. */ 
/** * @notice Return if a partition strategy has been reserved and has an * implementation registered. * @param _prefix The partition strategy identifier. * @return 'true' if the strategy has been registered, 'false' if not. */ 
/** * @dev Transfer tokens from a specific partition. * @param _fromPartition Partition of the tokens to transfer. * @param _operator The address performing the transfer. * @param _from Token holder. * @param _to Token recipient. * @param _value Number of tokens to transfer. * @param _data Information attached to the transfer. Contains the destination * partition if a partition change is requested. * @param _operatorData Information attached to the transfer, by the operator * (if any). * @return Destination partition. */ // If the `_operator` is attempting to transfer from a different `_from` // address, first check that they have the requisite operator or // allowance permissions. // If the sender has an allowance for the partition, that should // be decremented
/** * @notice Transfer tokens from default partitions. * @dev Used as a helper method for ERC20 compatibility. * @param _operator The address performing the transfer. * @param _from Token holder. * @param _to Token recipient. * @param _value Number of tokens to transfer. * @param _data Information attached to the transfer, and intended for the * token holder (`_from`). Should contain the destination partition if * changing partitions. */ 
/** * @dev Remove a token from a specific partition. * @param _from Token holder. * @param _partition Name of the partition. * @param _value Number of tokens to transfer. */ // If the total supply is zero, finds and deletes the partition. // Do not delete the _defaultPartition from totalPartitions. // If the balance of the TokenHolder's partition is zero, finds and // deletes the partition. // move the last item into the index being vacated _partitionsOf[_from][index - 1] = lastValue; 
/** * @dev Add a token to a specific partition. * @param _to Token recipient. * @param _partition Name of the partition. * @param _value Number of tokens to transfer. */ 
/** * @dev Add a partition to the total partitions collection. * @param _partition Name of the partition. */ 
/** * @dev Remove a partition to the total partitions collection. * @param _partition Name of the partition. */ // move the last item into the index being vacated _totalPartitions[index - 1] = lastValue; 
/** * @notice Check for and call the 'AmpTokensSender' hook on the sender address * (`_from`), and, if `_fromPartition` is within the scope of a strategy, * check for and call the 'AmpPartitionStrategy.tokensFromPartitionToTransfer' * hook for the strategy. * @param _fromPartition Name of the partition to transfer tokens from. * @param _operator Address which triggered the balance decrease (through * transfer). * @param _from Token holder. * @param _to Token recipient for a transfer. * @param _value Number of tokens the token holder balance is decreased by. * @param _data Extra information, pertaining to the `_from` address. * @param _operatorData Extra information, attached by the operator (if any). */ // Used to ensure that hooks implemented by a collateral manager to validate // transfers from it's owned partitions are called
/** * @dev Check for 'AmpTokensRecipient' hook on the recipient and call it. * @param _toPartition Name of the partition the tokens were transferred to. * @param _operator Address which triggered the balance increase (through * transfer or mint). * @param _from Token holder for a transfer (0x when mint). * @param _to Token recipient. * @param _value Number of tokens the recipient balance is increased by. * @param _data Extra information related to the token holder (`_from`). * @param _operatorData Extra information attached by the operator (if any). */ 
/** * @notice Approve the `_spender` address to spend the specified amount of * tokens in `_partition` on behalf of 'msg.sender'. * @param _partition Name of the partition. * @param _tokenHolder Owner of the tokens. * @param _spender The address which will spend the tokens. * @param _amount The amount of tokens to be tokens. */ 
/** * @dev Indicate whether the operator address is an operator of the * tokenHolder address. An operator in this case is an operator across all * partitions of the `msg.sender` address. * @param _operator Address which may be an operator of '_tokenHolder'. * @param _tokenHolder Address of a token holder which may have the '_operator' * address as an operator. * @return 'true' if `_operator` is an operator of `_tokenHolder` and 'false' * otherwise. */ 
/** * @dev Indicate whether the operator address is an operator of the * tokenHolder address for the given partition. * @param _partition Name of the partition. * @param _operator Address which may be an operator of tokenHolder for the * given partition. * @param _tokenHolder Address of a token holder which may have the operator * address as an operator for the given partition. * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition * `_partition` and 'false' otherwise. */ 
/** * @notice Check if the `_partition` is within the scope of a strategy, and * call it's isOperatorForPartitionScope hook if so. * @dev This allows implicit granting of operatorByPartition permissions * based on the partition being used being of a strategy. * @param _partition The partition to check. * @param _operator The address to check if is an operator for `_tokenHolder`. * @param _tokenHolder The address to validate that `_operator` is an * operator for. */ // Not a partition format that imbues special operator rules
/** * @notice Perform the minting of tokens. * @dev The tokens will be minted on behalf of the `_to` address, and will be * minted to the address's default partition. * @param _operator Address which triggered the issuance. * @param _to Token recipient. * @param _value Number of tokens issued. */ 
/// @return total amount of tokens 
/// @param _owner The address from which the balance will be retrieved /// @return The balance 
/// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not 
/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not 
/// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not 
/// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent 
/** * Returns whether there is code in the target address * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address address to check * @return whether there is code in the target address */ 
/** * @dev Multiplies two numbers, throws on overflow. */ 
/** * @dev Integer division of two numbers, truncating the quotient. */ // assert(b > 0); // Solidity automatically throws when dividing by 0 // assert(a == b * c + a % b); // There is no case in which this doesn't hold
/** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ 
/** * @dev Adds two numbers, throws on overflow. */ 
/** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the owner. */ 
/** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ 
/** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ 
/** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ 
/** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ 
/** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ 
/** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existance of * @return whether the token exists */ 
/** * @dev Approves another address to transfer the given token ID * @dev The zero address indicates there is no approved address. * @dev There can only be one approved address per token at a given time. * @dev Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ 
/** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for a the given token ID */ 
/** * @dev Sets or unsets the approval of a given operator * @dev An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ 
/** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ 
/** * @dev Transfers the ownership of a given token ID to another address * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ 
/** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ 
/** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ 
/** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ 
/** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ 
/** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _tokenId uint256 ID of the token being burned by the msg.sender */ 
/** * @dev Internal function to clear current approval of a given token ID * @dev Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ 
/** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ 
/** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ 
/** * @dev Internal function to invoke `onERC721Received` on a target address * @dev The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ 
/** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient *  after a `safetransfer`. This function MAY throw to revert and reject the *  transfer. This function MUST use 50,000 gas or less. Return of other *  than the magic value MUST result in the transaction being reverted. *  Note: the contract address is always the message sender. * @param _from The sending address * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))` */ 
/** * @dev Constructor function */ 
/** * @dev Gets the token name * @return string representing the token name */ 
/** * @dev Gets the token symbol * @return string representing the token symbol */ 
/** * @dev Returns an URI for a given token ID * @dev Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ 
/** * @dev Internal function to set the token URI for a given token * @dev Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ 
/** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ 
/** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ 
/** * @dev Gets the token ID at a given index of all the tokens in this contract * @dev Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ 
/** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ 
/** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping // the lastToken to the first position, and then dropping the element placed in the last position of the list
/** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ 
/** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _owner owner of the token to burn * @param _tokenId uint256 ID of the token being burned by the msg.sender */ // Clear metadata (if any) // Reorg all tokens array
/** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the owner. */ 
/** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ 
/** * @dev Multiplies two numbers, throws on overflow. */ 
/** * @dev Integer division of two numbers, truncating the quotient. */ // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold
/** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ 
/** * @dev Adds two numbers, throws on overflow. */ 
/** * @dev total number of tokens in existence */ 
/** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ 
/** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ 
/** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ 
/** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ 
/** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ 
/** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ 
/** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ 
/** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ 
/** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval.
/** * @dev Constructor that gives WalletHolder all of existing tokens. */ 
/** * @dev  Don't accept ETH. */ 
/** * @dev Fix for the ERC20 short address attack. */ 
/** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ 
/** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint representing the amount owned by the passed address. */ 
/** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint the amout of tokens to be transfered */ // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // if (_value > _allowance) throw;
/** * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
/** * @dev Function to check the amount of tokens than an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint specifing the amount of tokens still avaible for the spender. */ 
/** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the owner. */ 
/** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ 
/** * @dev modifier to allow actions only when the contract IS paused */ 
/** * @dev modifier to allow actions only when the contract IS NOT paused */ 
/** * @dev called by the owner to pause, triggers stopped state */ 
/** * @dev called by the owner to unpause, returns to normal state */ 
/** * This method provides an extension to the standard ERC20 interface that allows to approve tokens * to be spent by another party or contract, similar to the standard `IERC20.approve` method. * * The difference is, that by using this method, the sender can pre-sign the approval off-chain, and * then let another party (the relayer) submit the transaction to the blockchain. Only the relayer * needs to have ETH to pay for gas, the off-chain sender does _not_ need any ETH. * * @param sender    The (off-chain) sender of tokens. * @param relayer   If given, the metatransaction can only be relayed from this address. * @param spender   The spender that will spend the tokens approved. * @param amount    Token amount to approve for the spender to spend. * @param expires   If given, the signature will expire at this block number. * @param nonce     Random nonce for metatransaction. * @param signature Signature over EIP712 data, signed by sender. */ // signature must be valid (signed by address in parameter "sender" - not the necessarily // the "msg.sender", the submitted of the transaction!) // relayer rules: //  1. always allow relaying if the specified "relayer" is 0 //  2. if the authority address is not a contract, allow it to relay //  3. if the authority address is a contract, allow its defined 'getAuthority()' delegate to relay // signature must not have been expired // signature must not have been used // mark signature as "consumed" // now to the actual approval. also see "contracts/token/ERC20/ERC20.sol#L136" // here https://github.com/OpenZeppelin/openzeppelin-contracts
/** * This method allows a sender that approved tokens via `approveFor` to burn the metatransaction * that was sent to the relayer - but only if the transaction has not yet been submitted by the relay. */ // signature must be valid (signed by address in parameter "sender" - not the necessarily // the "msg.sender", the submitted of the transaction!) // only the original signature creator can burn signature, not a relay // signature must not have been used // mark signature as "burned"
/** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the owner. */ 
/** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ 
/** * @dev The Authorizable constructor sets the first `authorized` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the authorized. */ 
/** * @dev Allows the current owner to set an authorization. * @param addressAuthorized The address to change authorization. */ 
/** * @dev The WhiteList constructor sets the first `whiteListed` of the contract to the sender * account. */ 
/** * @dev Throws if called by any account other than the whiteListed. */ 
/** * @dev Allows the current owner to set an whiteListStatus. * @param addressWhiteListed The address to change whiteListStatus. */ 
/** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ // SafeMath.sub will throw if there is not enough balance.
/** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ 
/** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ 
/** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ 
/** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ 
/** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ 
/** * set _destination to 0x0 if want to self airdrop */ 
/** * set _destination to 0x0 if want to self airdrop */ 
/** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ 
/** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ 
/** * help fix airdrop when holder > 100 * but need to calculate outer */ 
/** * WARN: if holders > 100 donot call this function it will crash */ // collect tokenHolding if (airDropDestinations[holdersList[i]] != address(0x0)) {  } else {  // go airdrop Transfer(owner, holdersList[i], tokens); 
/** * burn token if token is not sold out after ico */ 
/** * transfer token to presale investor who pay by cash */ 
/** * increase hard cap if previous dont sold out */ 
