COMMENT: @ notice get the address of the system contract whose code will be used in the system @ return the address of the system contract
CODE: function getRelayAuthority() external view returns (address);
COMMENT: @ dev returns the address https : github . com ethereum api
CODE: function hash (EIP712Approve memory obj) private view returns (bytes32) { bytes32 digestDomain = keccak256(abi.encode( EIP712_DOMAIN_TYPEHASH, keccak256(bytes("XBRToken")), keccak256(bytes("1")),  FIXME: read chain_id at run-time address(this) )); bytes32 digestApprove = keccak256(abi.encode( EIP712_APPROVE_TYPEHASH, obj.sender, obj.relayer, obj.spender, obj.amount, obj.expires, obj.nonce )); bytes32 digest = keccak256(abi.encodePacked( "\x19\x01", digestDomain, digestApprove )); return digest; }
COMMENT: @ dev returns true if a leaf can add a proposal ( @ param signer signer on the domain separator @ param signer the name to be executed @ return
CODE: function verify (address signer, EIP712Approve memory obj, bytes memory signature) private view returns (bool) { bytes32 digest = hash(obj); (uint8 v, bytes32 r, bytes32 s) = XBRTypes.splitSignature(signature); return ecrecover(digest, v, r, s) == signer; }
COMMENT: @ dev approves spender would transfer tokens for a given signature . @ param sender address of the account that will spend the approval of the token @ param expires
CODE: function approveFor (address sender, address relayer, address spender, uint256 amount, uint256 expires, uint256 nonce, bytes memory signature) public returns (bool) { EIP712Approve memory approve = EIP712Approve(sender, relayer, spender, amount, expires, nonce); require(verify(sender, approve, signature), "INVALID_SIGNATURE"); require( (relayer == address(0x0)) || (!XBRTypes.isContract(relayer) && msg.sender == relayer) || (XBRTypes.isContract(relayer) && msg.sender == IXBRTokenRelayInterface(relayer).getRelayAuthority()), "INVALID_RELAYER" ); require(block.number < expires || expires == 0, "SIGNATURE_EXPIRED"); bytes32 digest = hash(approve); require(burnedSignatures[digest] == 0x0, "SIGNATURE_REUSED"); burnedSignatures[digest] = 0x1; _approve(sender, spender, amount); return true; }
COMMENT: @ dev burn amount of tokens @ param sender sender address that can call this function @ param relayer the account whose tokens will be burnt . @ param amount
CODE: function burnSignature (address sender, address relayer, address spender, uint256 amount, uint256 expires, uint256 nonce, bytes memory signature) public returns (bool success) { EIP712Approve memory approve = EIP712Approve(sender, relayer, spender, amount, expires, nonce); require(verify(sender, approve, signature), "INVALID_SIGNATURE"); require(sender == msg.sender); bytes32 digest = hash(approve); require(burnedSignatures[digest] == 0x0, "SIGNATURE_REUSED"); burnedSignatures[digest] = 0x2; return true; }
