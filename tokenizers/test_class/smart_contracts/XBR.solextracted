function getRelayAuthority() external view returns (address);
function hash (EIP712Approve memory obj) private view returns (bytes32) { bytes32 digestDomain = keccak256(abi.encode( EIP712_DOMAIN_TYPEHASH, keccak256(bytes("XBRToken")), keccak256(bytes("1")),  FIXME: read chain_id at run-time address(this) )); bytes32 digestApprove = keccak256(abi.encode( EIP712_APPROVE_TYPEHASH, obj.sender, obj.relayer, obj.spender, obj.amount, obj.expires, obj.nonce )); bytes32 digest = keccak256(abi.encodePacked( "\x19\x01", digestDomain, digestApprove )); return digest; }
function verify (address signer, EIP712Approve memory obj, bytes memory signature) private view returns (bool) { bytes32 digest = hash(obj); (uint8 v, bytes32 r, bytes32 s) = XBRTypes.splitSignature(signature); return ecrecover(digest, v, r, s) == signer; }
function approveFor (address sender, address relayer, address spender, uint256 amount, uint256 expires, uint256 nonce, bytes memory signature) public returns (bool) { EIP712Approve memory approve = EIP712Approve(sender, relayer, spender, amount, expires, nonce); require(verify(sender, approve, signature), "INVALID_SIGNATURE"); require( (relayer == address(0x0)) || (!XBRTypes.isContract(relayer) && msg.sender == relayer) || (XBRTypes.isContract(relayer) && msg.sender == IXBRTokenRelayInterface(relayer).getRelayAuthority()), "INVALID_RELAYER" ); require(block.number < expires || expires == 0, "SIGNATURE_EXPIRED"); bytes32 digest = hash(approve); require(burnedSignatures[digest] == 0x0, "SIGNATURE_REUSED"); burnedSignatures[digest] = 0x1; _approve(sender, spender, amount); return true; }
function burnSignature (address sender, address relayer, address spender, uint256 amount, uint256 expires, uint256 nonce, bytes memory signature) public returns (bool success) { EIP712Approve memory approve = EIP712Approve(sender, relayer, spender, amount, expires, nonce); require(verify(sender, approve, signature), "INVALID_SIGNATURE"); require(sender == msg.sender); bytes32 digest = hash(approve); require(burnedSignatures[digest] == 0x0, "SIGNATURE_REUSED"); burnedSignatures[digest] = 0x2; return true; }
