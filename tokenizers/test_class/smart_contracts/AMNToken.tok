function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Ownership Transfer Authorization ( address indexed authorized Address ) ;
event Owner Update ( address indexed old Value , address indexed new Value ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function authorized New Owner ( ) public view returns ( address ) { return authorized New Owner ; }
function authorize Ownership Transfer ( address authorized Address ) external { require ( msg . sender owner , " Invalid sender " ) ; authorized New Owner authorized Address ; emit Ownership Transfer Authorization ( authorized New Owner ) ; }
function assume Ownership ( ) external { require ( msg . sender authorized New Owner , " Invalid sender " ) ; address old Value owner ; owner authorized New Owner ; authorized New Owner address ( 0 ) ; emit Owner Update ( old Value , owner ) ; }
function set Interface Implementer ( address addr , bytes32 interface Hash , address implementer ) external virtual ;
function get Interface Implementer ( address addr , bytes32 interface Hash )
function set Manager ( address addr , address new Manager ) external virtual ;
function get Manager ( address addr ) public virtual view returns ( address ) ;
function set Interface Implementation ( string memory interface Label , address implementation ) internal { bytes32 interface Hash keccak256 ( abi . encode Packed ( interface Label ) ) ; ERC1820REGISTRY . set Interface Implementer ( address ( this ) , interface Hash , implementation ) ; }
function interface Addr ( address addr , string memory interface Label )
function delegate Management ( address new Manager ) internal { ERC1820REGISTRY . set Manager ( address ( this ) , new Manager ) ; }
function can Implement Interface For Address ( bytes32 interface Hash , Comments to avoid compilation warnings for unused variables . addr ) external view returns ( bytes32 ) { if ( interface Hashes [ interface Hash ] ) { return ERC1820 ACCEPT MAGIC ; } else { return " " ; } }
function set Interface ( string memory interface Label ) internal { interface Hashes [ keccak256 ( abi . encode Packed ( interface Label ) ) ] true ; }
function can Transfer ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external view returns ( bool ) ;
function tokens To Transfer ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external ;
function can Receive ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external view returns ( bool ) ;
function tokens Received ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external ;
function tokens From Partition To Validate ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external ;
function tokens To Partition To Validate ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external ;
function is Operator For Partition Scope ( bytes32 partition , address operator , address token Holder ) external view returns ( bool ) ;
function get Destination Partition ( bytes memory data , bytes32 fallback Partition )
function get Partition Prefix ( bytes32 partition ) internal pure returns ( bytes4 ) { return bytes4 ( partition ) ; }
function split Partition ( bytes32 partition )
function get Partition Strategy Validator I Name ( bytes4 prefix )
function allowance ( address owner , address spender )
function transfer From ( address from , address to , uint256 value ) external returns ( bool success ) ;
event Transfer By Partition ( bytes32 indexed from Partition , address operator , address indexed from , address indexed to , uint256 value , bytes data , bytes operator Data ) ;
event Changed Partition ( bytes32 indexed from Partition , bytes32 indexed to Partition , uint256 value ) ;
event Approval By Partition ( bytes32 indexed partition , address indexed owner , address indexed spender , uint256 value ) ;
event Authorized Operator ( address indexed operator , address indexed token Holder ) ;
event Revoked Operator ( address indexed operator , address indexed token Holder ) ;
event Authorized Operator By Partition ( bytes32 indexed partition , address indexed operator , address indexed token Holder ) ;
event Revoked Operator By Partition ( bytes32 indexed partition , address indexed operator , address indexed token Holder ) ;
event Collateral Manager Registered ( address collateral Manager ) ;
event Partition Strategy Set ( bytes4 flag , string name , address indexed implementation ) ;
event Minted ( address indexed operator , address indexed to , uint256 value , bytes data ) ;
event Swap ( address indexed operator , address indexed from , uint256 value ) ;
function total Supply ( ) external override view returns ( uint256 ) { return total Supply ; }
function balance Of ( address token Holder ) external override view returns ( uint256 ) { return balances [ token Holder ] ; }
function transfer ( address to , uint256 value ) external override returns ( bool ) { transfer By Default Partition ( msg . sender , msg . sender , to , value , " " ) ; return true ; }
function transfer From ( address from , address to , uint256 value ) external override returns ( bool ) { transfer By Default Partition ( msg . sender , from , to , value , " " ) ; return true ; }
function allowance ( address owner , address spender )
function approve ( address spender , uint256 value ) external override returns ( bool ) { approve By Partition ( default Partition , msg . sender , spender , value ) ; return true ; }
function increase Allowance ( address spender , uint256 added Value )
function decrease Allowance ( address spender , uint256 subtracted Value )
function swap ( address from ) public { uint256 amount swap Token . allowance ( from , address ( this ) ) ; require ( amount > 0 , EC 53 INSUFFICIENT ALLOWANCE ) ; require ( swap Token . transfer From ( from , swap Token Graveyard , amount ) , EC 60 SWAP TRANSFER FAILURE ) ; mint ( msg . sender , from , amount ) ; emit Swap ( msg . sender , from , amount ) ; }
function balance Of By Partition ( bytes32 partition , address token Holder )
function partitions Of ( address token Holder ) external view returns ( bytes32 [ ] memory ) { return partitions Of [ token Holder ] ; }
function transfer By Partition ( bytes32 partition , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data ) external returns ( bytes32 ) { return transfer By Partition ( partition , msg . sender , from , to , value , data , operator Data ) ; }
function authorize Operator ( address operator ) external { require ( operator ! msg . sender , EC 58 INVALID OPERATOR ) ; authorized Operator [ msg . sender ] [ operator ] true ; emit Authorized Operator ( operator , msg . sender ) ; }
function revoke Operator ( address operator ) external { require ( operator ! msg . sender , EC 58 INVALID OPERATOR ) ; authorized Operator [ msg . sender ] [ operator ] false ; emit Revoked Operator ( operator , msg . sender ) ; }
function authorize Operator By Partition ( bytes32 partition , address operator )
function revoke Operator By Partition ( bytes32 partition , address operator ) external { require ( operator ! msg . sender , EC 58 INVALID OPERATOR ) ; authorized Operator By Partition [ msg . sender ] [ partition ] [ operator ] false ; emit Revoked Operator By Partition ( partition , operator , msg . sender ) ; }
function is Operator ( address operator , address token Holder )
function is Operator For Partition ( bytes32 partition , address operator , address token Holder ) external view returns ( bool ) { return is Operator For Partition ( partition , operator , token Holder ) ; }
function is Operator For Collateral Manager ( bytes32 partition , address operator , address collateral Manager ) external view returns ( bool ) { return is Collateral Manager [ collateral Manager ] & & ( is Operator ( operator , collateral Manager ) | | authorized Operator By Partition [ collateral Manager ] [ partition ] [ operator ] ) ; }
function name ( ) external view returns ( string memory ) { return name ; }
function symbol ( ) external view returns ( string memory ) { return symbol ; }
function decimals ( ) external pure returns ( uint8 ) { return uint8 ( 18 ) ; }
function granularity ( ) external pure returns ( uint256 ) { return granularity ; }
function total Partitions ( ) external view returns ( bytes32 [ ] memory ) { return total Partitions ; }
function allowance By Partition ( bytes32 partition , address owner , address spender ) external view returns ( uint256 ) { return allowed By Partition [ partition ] [ owner ] [ spender ] ; }
function approve By Partition ( bytes32 partition , address spender , uint256 value ) external returns ( bool ) { approve By Partition ( partition , msg . sender , spender , value ) ; return true ; }
function increase Allowance By Partition ( bytes32 partition , address spender , uint256 added Value ) external returns ( bool ) { approve By Partition ( partition , msg . sender , spender , allowed By Partition [ partition ] [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function decrease Allowance By Partition ( bytes32 partition , address spender , uint256 subtracted Value ) external returns ( bool ) { approve By Partition ( partition , msg . sender , spender , allowed By Partition [ partition ] [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function register Collateral Manager ( ) external { require ( ! is Collateral Manager [ msg . sender ] , EC 5C ADDRESS CONFLICT ) ; collateral Managers . push ( msg . sender ) ; is Collateral Manager [ msg . sender ] true ; emit Collateral Manager Registered ( msg . sender ) ; }
function is Collateral Manager ( address collateral Manager )
function set Partition Strategy ( bytes4 prefix , address implementation ) external { require ( msg . sender owner ( ) , EC 56 INVALID SENDER ) ; require ( ! is Partition Strategy [ prefix ] , EC 5E PARTITION PREFIX CONFLICT ) ; require ( prefix ! ZERO PREFIX , EC 5F INVALID PARTITION PREFIX 0 ) ; string memory iname Partition Utils . get Partition Strategy Validator I Name ( prefix ) ; ERC1820Client . set Interface Implementation ( iname , implementation ) ; partition Strategies . push ( prefix ) ; is Partition Strategy [ prefix ] true ; emit Partition Strategy Set ( prefix , iname , implementation ) ; }
function is Partition Strategy ( bytes4 prefix ) external view returns ( bool ) { return is Partition Strategy [ prefix ] ; }
function transfer By Partition ( bytes32 from Partition , address operator , address from , address to , uint256 value , bytes memory data , bytes memory operator Data ) internal returns ( bytes32 ) { require ( to ! address ( 0 ) , EC 57 INVALID RECEIVER ) ; if ( from ! operator ) { require ( is Operator For Partition ( from Partition , operator , from ) | | ( value < allowed By Partition [ from Partition ] [ from ] [ operator ] ) , EC 53 INSUFFICIENT ALLOWANCE ) ; if ( allowed By Partition [ from Partition ] [ from ] [ operator ] > value ) { allowed By Partition [ from Partition ] [ from ] [ msg . sender ] allowed By Partition [ from Partition ] [ from ] [ operator ] . sub ( value ) ; } else { allowed By Partition [ from Partition ] [ from ] [ operator ] 0 ; } } call Pre Transfer Hooks ( from Partition , operator , from , to , value , data , operator Data ) ; require ( balance Of By Partition [ from ] [ from Partition ] > value , EC 52 INSUFFICIENT BALANCE ) ; bytes32 to Partition Partition Utils . get Destination Partition ( data , from Partition ) ; remove Token From Partition ( from , from Partition , value ) ; add Token To Partition ( to , to Partition , value ) ; call Post Transfer Hooks ( to Partition , operator , from , to , value , data , operator Data ) ; emit Transfer ( from , to , value ) ; emit Transfer By Partition ( from Partition , operator , from , to , value , data , operator Data ) ; if ( to Partition ! from Partition ) { emit Changed Partition ( from Partition , to Partition , value ) ; } return to Partition ; }
function transfer By Default Partition ( address operator , address from , address to , uint256 value , bytes memory data ) internal { transfer By Partition ( default Partition , operator , from , to , value , data , " " ) ; }
function remove Token From Partition ( address from , bytes32 partition , uint256 value ) internal { if ( value 0 ) { return ; } balances [ from ] balances [ from ] . sub ( value ) ; balance Of By Partition [ from ] [ partition ] balance Of By Partition [ from ] [ partition ] . sub ( value ) ; total Supply By Partition [ partition ] total Supply By Partition [ partition ] . sub ( value ) ; if ( total Supply By Partition [ partition ] 0 & & partition ! default Partition ) { remove Partition From Total Partitions ( partition ) ; } if ( balance Of By Partition [ from ] [ partition ] 0 ) { uint256 index index Of Partitions Of [ from ] [ partition ] ; if ( index 0 ) { return ; } bytes32 last Value partitions Of [ from ] [ partitions Of [ from ] . length 1 ] ; adjust for 1 based indexing index Of Partitions Of [ from ] [ last Value ] index ; partitions Of [ from ] . pop ( ) ; index Of Partitions Of [ from ] [ partition ] 0 ; } }
function add Token To Partition ( address to , bytes32 partition , uint256 value ) internal { if ( value 0 ) { return ; } balances [ to ] balances [ to ] . add ( value ) ; if ( index Of Partitions Of [ to ] [ partition ] 0 ) { partitions Of [ to ] . push ( partition ) ; index Of Partitions Of [ to ] [ partition ] partitions Of [ to ] . length ; } balance Of By Partition [ to ] [ partition ] balance Of By Partition [ to ] [ partition ] . add ( value ) ; if ( index Of Total Partitions [ partition ] 0 ) { add Partition To Total Partitions ( partition ) ; } total Supply By Partition [ partition ] total Supply By Partition [ partition ] . add ( value ) ; }
function add Partition To Total Partitions ( bytes32 partition ) internal { total Partitions . push ( partition ) ; index Of Total Partitions [ partition ] total Partitions . length ; }
function remove Partition From Total Partitions ( bytes32 partition ) internal { uint256 index index Of Total Partitions [ partition ] ; if ( index 0 ) { return ; } bytes32 last Value total Partitions [ total Partitions . length 1 ] ; adjust for 1 based indexing index Of Total Partitions [ last Value ] index ; total Partitions . pop ( ) ; index Of Total Partitions [ partition ] 0 ; }
function call Pre Transfer Hooks ( bytes32 from Partition , address operator , address from , address to , uint256 value , bytes memory data , bytes memory operator Data ) internal { address sender Implementation ; sender Implementation interface Addr ( from , AMP TOKENS SENDER ) ; if ( sender Implementation ! address ( 0 ) ) { I Amp Tokens Sender ( sender Implementation ) . tokens To Transfer ( msg . sig , from Partition , operator , from , to , value , data , operator Data ) ; } bytes4 from Partition Prefix Partition Utils . get Partition Prefix ( from Partition ) ; if ( is Partition Strategy [ from Partition Prefix ] ) { address from Partition Validator Implementation ; from Partition Validator Implementation interface Addr ( address ( this ) , Partition Utils . get Partition Strategy Validator I Name ( from Partition Prefix ) ) ; if ( from Partition Validator Implementation ! address ( 0 ) ) { I Amp Partition Strategy Validator ( from Partition Validator Implementation ) . tokens From Partition To Validate ( msg . sig , from Partition , operator , from , to , value , data , operator Data ) ; } } }
function call Post Transfer Hooks ( bytes32 to Partition , address operator , address from , address to , uint256 value , bytes memory data , bytes memory operator Data ) internal { bytes4 to Partition Prefix Partition Utils . get Partition Prefix ( to Partition ) ; if ( is Partition Strategy [ to Partition Prefix ] ) { address partition Manager Implementation ; partition Manager Implementation interface Addr ( address ( this ) , Partition Utils . get Partition Strategy Validator I Name ( to Partition Prefix ) ) ; if ( partition Manager Implementation ! address ( 0 ) ) { I Amp Partition Strategy Validator ( partition Manager Implementation ) . tokens To Partition To Validate ( msg . sig , to Partition , operator , from , to , value , data , operator Data ) ; } } else { require ( to Partition Prefix ZERO PREFIX , EC 5D PARTITION RESERVED ) ; } address recipient Implementation ; recipient Implementation interface Addr ( to , AMP TOKENS RECIPIENT ) ; if ( recipient Implementation ! address ( 0 ) ) { I Amp Tokens Recipient ( recipient Implementation ) . tokens Received ( msg . sig , to Partition , operator , from , to , value , data , operator Data ) ; } }
function approve By Partition ( bytes32 partition , address token Holder , address spender , uint256 amount ) internal { require ( token Holder ! address ( 0 ) , EC 56 INVALID SENDER ) ; require ( spender ! address ( 0 ) , EC 58 INVALID OPERATOR ) ; allowed By Partition [ partition ] [ token Holder ] [ spender ] amount ; emit Approval By Partition ( partition , token Holder , spender , amount ) ; if ( partition default Partition ) { emit Approval ( token Holder , spender , amount ) ; } }
function is Operator ( address operator , address token Holder )
function is Operator For Partition ( bytes32 partition , address operator , address token Holder ) internal view returns ( bool ) { return ( is Operator ( operator , token Holder ) | | authorized Operator By Partition [ token Holder ] [ partition ] [ operator ] | | call Partition Strategy Operator Hook ( partition , operator , token Holder ) ) ; }
function call Partition Strategy Operator Hook ( bytes32 partition , address operator , address token Holder ) internal view returns ( bool ) { bytes4 prefix Partition Utils . get Partition Prefix ( partition ) ; if ( ! is Partition Strategy [ prefix ] ) { return false ; } address strategy Validator Implementation ; strategy Validator Implementation interface Addr ( address ( this ) , Partition Utils . get Partition Strategy Validator I Name ( prefix ) ) ; if ( strategy Validator Implementation ! address ( 0 ) ) { return I Amp Partition Strategy Validator ( strategy Validator Implementation ) . is Operator For Partition Scope ( partition , operator , token Holder ) ; } return false ; }
function mint ( address operator , address to , uint256 value ) internal { require ( to ! address ( 0 ) , EC 57 INVALID RECEIVER ) ; total Supply total Supply . add ( value ) ; add Token To Partition ( to , default Partition , value ) ; call Post Transfer Hooks ( default Partition , operator , address ( 0 ) , to , value , " " , " " ) ; emit Minted ( operator , to , value , " " ) ; emit Transfer ( address ( 0 ) , to , value ) ; emit Transfer By Partition ( bytes32 ( 0 ) , operator , address ( 0 ) , to , value , " " , " " ) ; }
