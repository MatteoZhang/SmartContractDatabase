function get Relay Authority ( ) external view returns ( address ) ;
function hash ( EIP712Approve memory obj ) private view returns ( bytes32 ) { bytes32 digest Domain keccak256 ( abi . encode ( EIP712 DOMAIN TYPEHASH , keccak256 ( bytes ( " XBR Token " ) ) , keccak256 ( bytes ( " 1 " ) ) , FIXME : read chain id at run time address ( this ) ) ) ; bytes32 digest Approve keccak256 ( abi . encode ( EIP712 APPROVE TYPEHASH , obj . sender , obj . relayer , obj . spender , obj . amount , obj . expires , obj . nonce ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , digest Domain , digest Approve ) ) ; return digest ; }
function verify ( address signer , EIP712Approve memory obj , bytes memory signature ) private view returns ( bool ) { bytes32 digest hash ( obj ) ; ( uint8 v , bytes32 r , bytes32 s ) XBR Types . split Signature ( signature ) ; return ecrecover ( digest , v , r , s ) signer ; }
function approve For ( address sender , address relayer , address spender , uint256 amount , uint256 expires , uint256 nonce , bytes memory signature ) public returns ( bool ) { EIP712Approve memory approve EIP712Approve ( sender , relayer , spender , amount , expires , nonce ) ; require ( verify ( sender , approve , signature ) , " INVALID SIGNATURE " ) ; require ( ( relayer address ( 0x0 ) ) | | ( ! XBR Types . is Contract ( relayer ) & & msg . sender relayer ) | | ( XBR Types . is Contract ( relayer ) & & msg . sender IXBR Token Relay Interface ( relayer ) . get Relay Authority ( ) ) , " INVALID RELAYER " ) ; require ( block . number < expires | | expires 0 , " SIGNATURE EXPIRED " ) ; bytes32 digest hash ( approve ) ; require ( burned Signatures [ digest ] 0x0 , " SIGNATURE REUSED " ) ; burned Signatures [ digest ] 0x1 ; approve ( sender , spender , amount ) ; return true ; }
function burn Signature ( address sender , address relayer , address spender , uint256 amount , uint256 expires , uint256 nonce , bytes memory signature ) public returns ( bool success ) { EIP712Approve memory approve EIP712Approve ( sender , relayer , spender , amount , expires , nonce ) ; require ( verify ( sender , approve , signature ) , " INVALID SIGNATURE " ) ; require ( sender msg . sender ) ; bytes32 digest hash ( approve ) ; require ( burned Signatures [ digest ] 0x0 , " SIGNATURE REUSED " ) ; burned Signatures [ digest ] 0x2 ; return true ; }
