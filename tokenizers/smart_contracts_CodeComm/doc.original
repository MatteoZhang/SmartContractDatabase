// Recommend: 86400 86400 86400 3600 50 10 live // Recommend: 240 240 240 120 50 10 test 
// Initialize the auction 
// Place one's bid 
// Increase one's bid 
// Clean up during phase 3 
// Initialize the auction 
// Commit one's bid. This also entails sending an amount of ether at least // equal to, but potentially more than, one's bid; if you send a greater // amount than the difference between the submission and your actual bid // will be refunded to you (even in all-pay auctions). This protects bid // privacy. 
// Reveal one's bid // Only need to keep track of bid values for all-pay auctions
// Clean up during phase 2 // First price auction or all-pay auction: take winner's bid at its own value // Second price auction: take winner's bid at second highest value // First price or second price auction: refund everyone else's bids // All-pay auction: don't refund everyone else's bids
// Enum holding additional data (marked union / sum datatype) 
// using Heap[T] = T[]; ? 
/// @dev the number of elements stored in the queue. 
/// @dev the number of elements this queue can hold /// @invariant capacity() < length() 
/// @dev push a new element to the back of the queue /// @precondition length() < capacity() - 1 
/// @dev remove and return the element at the front of the queue /// @precondition length() > 0 
// Create a Gavmble contract. 
// TODO: allow giving a dead hash. // Provide a chance of `pIn256` in 256 (approx `floor(pIn256/256.0*100)`%) that one later claim from // `msg.caller` which provides the inverse Keccak hash of `key` will result in a transfer of // `web3.toEth(floor(floor(msg.value * 99 / 100) * 256 / pIn256))` back to them. 
// Send `web3.toEth(winningsWithKey(sha3(bet), bet))` to `msg.sender` if and only if they are // `orders[sha3(bet)].owner`. 
// Insert something 
// Computes the sum of all stored data. 
/// Appends `_data` to the end of the list `self`. 
/// Removes the element identified by the iterator /// `_index` from the list `self`. 
/// @return an iterator pointing to the first element whose data /// is `_value` or an invalid iterator otherwise. 
// Iterator interface 
/// @dev Computes the modular exponential (x ** k) % m. 
/// @dev Does a byte-by-byte lexicographical comparison of two strings. /// @return a negative number if `_a` is smaller, zero if they are equal /// and a positive numbe if `_b` is smaller. //@todo unroll the loop into increments of 32 and do full 32 byte comparisons
/// @dev Compares two strings and returns true iff they are equal. 
/// @dev Finds the index of the first occurrence of _needle in _haystack 
//events are returned after functions are successfully called 
/// Function that is called once an auction ends. 
/// Claim that scrypt(data) == hash. With reference to above, /// values[0] = pbkdf2(data) (the "input") and /// pbkdf2(values[2048]) should be equal to hash, values[2048] is called "output". 
/// Challenger queries claimant for the value on a wire `_i`. /// Value 0 is the input, value 1024 is the first input to the second /// half of the computation, value 2048 is the output. 
/// Claimant responds to challenge, committing to a value. 
/// Convicts the claimant to have provided inputs and outputs for a single /// step that do not match the computation of the step. /// q1, q2 and q3 are query indices providing the relevant values. /// q1 is the query index of the first input, q2 the query index of /// the output and q2 is the query index of the auxiliary input only /// used in the second half of the scrypt computation. 
/// Convicts the claimant to have provided an incorrect value for value[0]. 
/// Convicts the claimant to have provided an incorrect value for value[2048]. 
/// Verifies a salsa step in the first half of the scrypt computation. 
/// Verifies a salsa step in the second half of the scrypt computation. 
/// PBKDF2 restricted to c=1, hash = hmacsha256 and dklen being a multiple of 32 not larger than 128 
// EVENTS // this contract only has six types of events: it can accept a confirmation, in which case // we record owner and operation (hash) alongside it. 
// some others are in the case of an owner changing. 
// the last one is emitted if the required signatures change 
// MODIFIERS // simple single-sig function modifier. 
// multi-sig function modifier: the operation must have an intrinsic hash in order // that later attempts can be realised as the same underlying operation and // thus count as confirmations. 
// METHODS // constructor is given number of sigs required to do protected "onlymanyowners" transactions // as well as the selection of addresses capable of confirming them. 
// Revokes a prior confirmation of the given operation // make sure they're an owner
// Replaces an owner `_from` with another `_to`. 
// Gets an owner by 0-indexed position (using numOwners as the count) 
// INTERNAL METHODS // determine what index the present sender is: // make sure they're an owner // if we're not yet working on this operation, switch over and reset the confirmation status. // reset count of confirmations needed. // reset which owners have confirmed (none) - set our bitmap to 0. // determine the bit to set for this owner. // make sure we (the message sender) haven't confirmed this operation previously. // ok - check if count is enough to go ahead. // enough confirmations: reset and run interior. // not enough: record that this owner in particular confirmed.
// MODIFIERS // simple modifier for daily limit. 
// METHODS // constructor - stores initial daily limit and records the present day's index. 
// (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today. 
// resets the amount already spent today. needs many of the owners to confirm. 
// INTERNAL METHODS // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and // returns true. otherwise just returns false. // reset the spend limit if we're on a different day to last time. // check to see if there's enough left - if so, subtract and return true. // overflow protection                    // dailyLimit check
// determines today's index. 
// EVENTS // logged events: // Funds has arrived into the wallet (record how much). 
// Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going). 
// Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going). 
// Confirmation still needed for a transaction. 
// FUNCTIONS // TODO: document 
// METHODS // constructor - just pass on the owner array to the multiowned and // the limit to daylimit 
// kills the contract sending everything to `_to`. 
// gets called when no other function matches // just being sent some cash?
// Outside-visible transact entry point. Executes transaction immediately if below daily spend limit. // If not, goes into multisig process. We provide a hash on return to allow the sender to provide // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value // and _data arguments). They still get the option of using them if they want, anyways. // first, take the opportunity to check that we're under the daily limit. // yes - just execute the call. // determine our operation hash.
// confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order // to determine the body of the transaction from the hash provided. 
// INTERNAL METHODS 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
// Indicates when an address has withdrawn their supply of tokens 
// Indicates when an address has withdrawn their supply of extra wei 
// Logs when owner has pulled eth 
// Generic Notice message that includes and address and number 
// Indicates when an error has occurred in the execution of a function 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/eth at that time, /// 3 is address token purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev function to check if the crowdsale is currently active /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if the crowdsale has ended /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if a purchase is valid /// @param self Stored crowdsale from crowdsale contract /// @return true if the transaction can buy tokens 
/// @dev Function called by purchasers to pull tokens /// @param self Stored crowdsale from crowdsale contract /// @return true if tokens were withdrawn 
/// @dev Function called by purchasers to pull leftover wei from their purchases /// @param self Stored crowdsale from crowdsale contract /// @return true if wei was withdrawn 
/// @dev send ether from the completed crowdsale to the owners wallet address /// @param self Stored crowdsale from crowdsale contract /// @return true if owner withdrew eth 
/// @dev Function to change the price of the token /// @param self Stored crowdsale from crowdsale contract /// @param _tokensPerEth new token price (amount of tokens per ether) /// @return true if the token price changed successfully 
/// @dev function to set tokens for the sale /// @param self Stored Crowdsale from crowdsale contract /// @return true if tokens set successfully 
/// @dev Gets the price and buy cap for individual addresses at the given milestone index /// @param self Stored Crowdsale from crowdsale contract /// @param timestamp Time during sale for which data is requested /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap 
/// @dev Gets the number of tokens sold thus far /// @param self Stored Crowdsale from crowdsale contract /// @return Number of tokens sold 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/ETH at that time, /// 3 is address purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amount of wei that the buyer is sending /// @return true on succesful purchase 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
// Indicates when an address has withdrawn their supply of tokens 
// Indicates when an address has withdrawn their supply of extra wei 
// Logs when owner has pulled eth 
// Generic Notice message that includes and address and number 
// Indicates when an error has occurred in the execution of a function 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/eth at that time, /// 3 is address token purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev function to check if the crowdsale is currently active /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if the crowdsale has ended /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if a purchase is valid /// @param self Stored crowdsale from crowdsale contract /// @return true if the transaction can buy tokens 
/// @dev Function called by purchasers to pull tokens /// @param self Stored crowdsale from crowdsale contract /// @return true if tokens were withdrawn 
/// @dev Function called by purchasers to pull leftover wei from their purchases /// @param self Stored crowdsale from crowdsale contract /// @return true if wei was withdrawn 
/// @dev send ether from the completed crowdsale to the owners wallet address /// @param self Stored crowdsale from crowdsale contract /// @return true if owner withdrew eth 
/// @dev Function to change the price of the token /// @param self Stored crowdsale from crowdsale contract /// @param _tokensPerEth new token price (amount of tokens per ether) /// @return true if the token price changed successfully 
/// @dev function to set tokens for the sale /// @param self Stored Crowdsale from crowdsale contract /// @return true if tokens set successfully 
/// @dev Gets the price and buy cap for individual addresses at the given milestone index /// @param self Stored Crowdsale from crowdsale contract /// @param timestamp Time during sale for which data is requested /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap 
/// @dev Gets the number of tokens sold thus far /// @param self Stored Crowdsale from crowdsale contract /// @return Number of tokens sold 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/ETH at that time, /// 3 is address purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amount of wei that the buyer is sending /// @return true on succesful purchase 
// fallback function can be used to buy tokens 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _capAmountInCents Total to be raised in cents /// @param _startTime Timestamp of sale start time /// @param _endTime Timestamp of sale end time /// @param _tokenPricePoints Array of each price point during sale cents/token /// @param _fallbackExchangeRate Exchange rate of cents/ETH /// @param _changeInterval The number of seconds between each step /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @return true on succesful purchase // if the token price increase interval has passed, update the current day and change the token price //prevents going out of bounds on the tokenPricePoints array uint256 numTokens;  uint256 newBalance;  uint256 weiTokens;  uint256 zeros;  uint256 leftoverWei;  uint256 remainder;  // Find the number of tokens as a function in wei // can't overflow because it is under the cap // calculate the amout of ether in the owners balance self.base.ownerBalance = newBalance;    // can't overflow because it will be under the cap //subtract tokens from owner's share
// Logs when a user is registered in the system before the sale 
// Logs when a user is unregistered from the system before the sale 
// Logs when there is an error with user registration 
// Logs when there is an increase in the contribution cap per address 
// Logs when the address cap is initially calculated 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/ETH at that time, /// 3 is address purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _staticCap Whether or not the address cap is going to be static /// @param _token Token being sold 
/// @dev register user function. can only be called by the owner when a user registers on the web app. /// puts their address in the registered mapping and increments the numRegistered /// @param self Stored crowdsale from crowdsale contract /// @param _registrant address to be registered for the sale 
/// @dev registers multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to register for the sale 
/// @dev Cancels a user's registration status can only be called by the owner when a user cancels their registration. /// sets their address field in the registered mapping to false and decrements the numRegistered /// @param self Stored crowdsale from crowdsale contract 
/// @dev unregisters multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to unregister for the sale 
/// @dev function that calculates address cap from the number of users registered /// @param self Stored crowdsale from crowdsale contract 
/// @dev utility function for the receivePurchase function. returns the lower number /// @param a first argument /// @param b second argument 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @return true on succesful purchase 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
// Indicates when an address has withdrawn their supply of tokens 
// Indicates when an address has withdrawn their supply of extra wei 
// Logs when owner has pulled eth 
// Generic Notice message that includes and address and number 
// Indicates when an error has occurred in the execution of a function 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/eth at that time, /// 3 is address token purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev function to check if the crowdsale is currently active /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if the crowdsale has ended /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if a purchase is valid /// @param self Stored crowdsale from crowdsale contract /// @return true if the transaction can buy tokens 
/// @dev Function called by purchasers to pull tokens /// @param self Stored crowdsale from crowdsale contract /// @return true if tokens were withdrawn 
/// @dev Function called by purchasers to pull leftover wei from their purchases /// @param self Stored crowdsale from crowdsale contract /// @return true if wei was withdrawn 
/// @dev send ether from the completed crowdsale to the owners wallet address /// @param self Stored crowdsale from crowdsale contract /// @return true if owner withdrew eth 
/// @dev Function to change the price of the token /// @param self Stored crowdsale from crowdsale contract /// @param _tokensPerEth new token price (amount of tokens per ether) /// @return true if the token price changed successfully 
/// @dev function to set tokens for the sale /// @param self Stored Crowdsale from crowdsale contract /// @return true if tokens set successfully 
/// @dev Gets the price and buy cap for individual addresses at the given milestone index /// @param self Stored Crowdsale from crowdsale contract /// @param timestamp Time during sale for which data is requested /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap 
/// @dev Gets the number of tokens sold thus far /// @param self Stored Crowdsale from crowdsale contract /// @return Number of tokens sold 
// Logs when a user is registered in the system before the sale 
// Logs when a user is unregistered from the system before the sale 
// Logs when there is an error with user registration 
// Logs when there is an increase in the contribution cap per address 
// Logs when the address cap is initially calculated 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/ETH at that time, /// 3 is address purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _staticCap Whether or not the address cap is going to be static /// @param _token Token being sold 
/// @dev register user function. can only be called by the owner when a user registers on the web app. /// puts their address in the registered mapping and increments the numRegistered /// @param self Stored crowdsale from crowdsale contract /// @param _registrant address to be registered for the sale 
/// @dev registers multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to register for the sale 
/// @dev Cancels a user's registration status can only be called by the owner when a user cancels their registration. /// sets their address field in the registered mapping to false and decrements the numRegistered /// @param self Stored crowdsale from crowdsale contract 
/// @dev unregisters multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to unregister for the sale 
/// @dev function that calculates address cap from the number of users registered /// @param self Stored crowdsale from crowdsale contract 
/// @dev utility function for the receivePurchase function. returns the lower number /// @param a first argument /// @param b second argument 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @return true on succesful purchase 
// fallback function can be used to buy tokens 
// fallback function can be used to buy tokens 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
// Indicates when tokens are bought during the sale 
// Logs when a buyer has exceeded the address cap and tells them to withdraw their leftover wei 
// Logs when a user is registered in the system before the sale 
// Logs when a user is unregistered from the system before the sale 
// Logs when there is an error 
// Logs when there is an increase in the contribution cap per address 
// Logs when the address cap is initially calculated 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _capAmountInCents Total to be raised in cents /// @param _startTime Timestamp of sale start time /// @param _endTime Timestamp of sale end time /// @param _fallbackExchangeRate Exchange rate of cents/ETH /// @param _changeInterval The number of seconds between each step /// @param _percentBurn Percentage of extra tokens to burn /// @param _capPercentMultiplier percent of the address cap that we multiply to increase every time interval /// @param _fallbackAddressCap cap of wei allowed for each address to spend /// @param _token Token being sold 
/// @dev register user function. can only be called by the owner when a user registers on the web app. /// puts their address in the registered mapping and increments the numRegistered /// @param self Stored crowdsale from crowdsale contract /// @param _registrant address to be registered for the sale // if the change interval is 0, then registration is allowed throughout the sale since a cap doesn't need to be calculated
/// @dev registers multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to register for the sale // if the change interval is 0, then registration is allowed throughout the sale since a cap doesn't need to be calculated
/// @dev Cancels a user's registration status can only be called by the owner when a user cancels their registration. /// sets their address field in the registered mapping to false and decrements the numRegistered /// @param self Stored crowdsale from crowdsale contract 
/// @dev unregisters multiple users at the same time /// @param self Stored crowdsale from crowdsale contract /// @param _registrants addresses to unregister for the sale 
/// @dev function that calculates address cap from the number of users registered /// @param self Stored crowdsale from crowdsale contract // can only calculate the address cap during the day before the sale starts. // Also, if the change interval is 0, the address cap should not be calculated because there is a static cap require(!self.base.rateSet);  
/// @dev utility function for the receivePurchase function. returns the lower number /// @param a first argument /// @param b second argument 
/// @dev Called when an address wants to purchase tokens /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @return true on succesful purchase // if the address cap increase interval has passed, update the current day and change the address cap // calculate the number of change intervals that have passed since the last change in cap // multiply by the percentage multiplier for each interval that has passed // fix the decimal point since it was a percentage // set the new change time uint256 numTokens;  uint256 zeros;  uint256 leftoverWei;  uint256 remainder = 0;  uint256 allowedWei;   // Find the number of tokens as a function in wei // can't overflow because it is under the cap // calculate the amout of ether in the owners balance and "deposit" it // can't overflow because it will be under the cap //subtract tokens from owner's share
// Indicates when a bidder submits a bid to the crowdsale 
// Indicates when a bidder manually withdraws their bid from the crowdsale 
// Indicates when a bid is removed by the automated bid removal process 
// Generic Error Msg Event 
// Indicates when the price of the token changes 
// Logs the current bucket that the valuation points to, the total valuation of // the sale, and the amount of ETH committed, including total bids that will eventually get partial purchases 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item arrays such that, in each 3 element /// array index-0 is a timestamp, index-1 is price in tokens/ETH /// index-2 is address purchase cap at that time, 0 if no address cap /// @param _priceBonusPercent the bonus amount for early bidders /// @param _minimumRaise minimim amount that the sale needs to make to be successfull /// @param _endWithdrawalTime timestamp that indicates that manual withdrawals are no longer allowed /// @param _endTime Timestamp of sale end time /// @param _percentBeingSold percentage of total tokens being sold in the sale /// @param _tokenName name of the token being sold. ex: "Jason Network Token" /// @param _tokenSymbol symbol of the token. ex: "JNT" /// @param _tokenDecimals number of decimals in the token /// @param _allowMinting whether or not to allow minting of the token after the sale 
/// @dev calculates the number of digits in a given number /// @param _number the number for which we're caluclating digits /// @return _digits the number of digits in _number 
/// @dev calculates the number of tokens purchased based on the amount of wei ///      spent and the price of tokens /// @param _amount amound of wei that the buyer sent /// @param _price price of tokens in the sale, in tokens/ETH /// @return uint256 numTokens the number of tokens purchased /// @return remainder  any remaining wei leftover from integer division 
/// @dev Called when an address wants to submit a bid to the sale /// @param self Stored crowdsale from crowdsale contract /// @return currentBonus percentage of the bonus that is applied for the purchase // can't underflow becuase endWithdrawalTime > startTime // can't underflow because now > startTime
/// @dev Called when an address wants to submit bid to the sale /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @param _personalCap the total crowdsale valuation (wei) that the bidder is comfortable with /// @param _valuePredict prediction of where the valuation will go in the linked list. saves on searching time /// @return true on succesful bid 
/// @dev Called when an address wants to manually withdraw their bid from the ///      sale. puts their wei in the LeftoverWei mapping /// @param self Stored crowdsale from crowdsale contract /// @return true on succesful // The sender has to have already bid on the sale // cannot withdraw after compulsory withdraw period is over unless the bid's // valuation is below the cutoff // full refund because their bid no longer affects the total sale valuation require(!self.hasManuallyWithdrawn[msg.sender]);   //uint256 t = self.endWithdrawalTime - self.base.startTime; //uint256 s = now - self.base.startTime; //uint256 pa = self.pricePurchasedAt[msg.sender]; //uint256 pu = self.base.tokensPerEth; //uint256 multiplierPercent =  (100*(t - s))/t; //self.pricePurchasedAt = pa-((pa-pu)/3) // Put the sender's contributed wei into the leftoverWei mapping for later withdrawal // subtract the bidder's refund from its total contribution // bidder's withdrawal only affects the pointer if the personal cap is at or // above the current valuation // first we remove the refundWei from the committed value // if we've dropped below the current bucket // and current valuation is above the bucket // if we are still below the current bucket then we need to iterate // if we're going to loop we move to the previous bucket // while we are proposed lower than the previous bucket we add commitments // and iterate to the previous
/// @dev This should be called once the sale is over to commit all bids into ///      the owner's bucket. /// @param self stored crowdsale from crowdsale contract require(!self.isFinalized);  // may need to be computed due to EVM rounding errors // calculate the fraction of each minimal valuation bidders ether and tokens to refund // no computation necessary self.base.ownerBalance = computedValue;  
/// @dev Mints the token being sold by taking the percentage of the token supply ///      being sold in this sale along with the valuation, derives all necessary ///      values and then transfers owner tokens to the owner. /// @param self Stored crowdsale from crowdsale contract // total valuation of all the tokens not including the bonus // total valuation of bonus tokens // total supply of all tokens not including the bonus // total number of bonus tokens // tokens allocated to the owner of the sale // total supply of tokens not including the bonus tokens // deploy new token contract with total number of tokens // if the sale got canceled, then all the tokens go to the owner and bonus tokens are burned // the owner of the crowdsale becomes the new owner of the token contract
/// @dev returns a boolean indicating if the sale is canceled. ///      This can either be if the minimum raise hasn't been met ///      or if it is 30 days after the sale and the owner hasn't finalized the sale. /// @return bool canceled indicating if the sale is canceled or not 
/// @dev If the address' personal cap is below the pointer, refund them all their ETH. ///      if it is above the pointer, calculate tokens purchased and refund leftoever ETH /// @param self Stored crowdsale from crowdsale contract /// @return bool success if the contract runs successfully // if the sale was canceled, everyone gets a full refund // full refund if personal cap is less than total valuation // set hasContributed to 0 to prevent participant from calling this over and over // calculate the portion that this address has to take out of their bid // refund that amount of wei to the address // subtract that amount the address' contribution // calculate the number of tokens that the bidder purchased // add tokens to the bidders purchase.  can't overflow because it will be under the cap // burn any extra bonus tokens // send tokens and leftoverWei to the address calling the function
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
// Indicates when an address has withdrawn their supply of tokens 
// Indicates when an address has withdrawn their supply of extra wei 
// Logs when owner has pulled eth 
// Generic Notice message that includes and address and number 
// Indicates when an error has occurred in the execution of a function 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item sets such that, in each 3 element /// set, 1 is timestamp, 2 is price in tokens/eth at that time, /// 3 is address token purchase cap at that time, 0 if no address cap /// @param _endTime Timestamp of sale end time /// @param _percentBurn Percentage of extra tokens to burn /// @param _token Token being sold 
/// @dev function to check if the crowdsale is currently active /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if the crowdsale has ended /// @param self Stored crowdsale from crowdsale contract /// @return success 
/// @dev function to check if a purchase is valid /// @param self Stored crowdsale from crowdsale contract /// @return true if the transaction can buy tokens 
/// @dev Function called by purchasers to pull tokens /// @param self Stored crowdsale from crowdsale contract /// @return true if tokens were withdrawn 
/// @dev Function called by purchasers to pull leftover wei from their purchases /// @param self Stored crowdsale from crowdsale contract /// @return true if wei was withdrawn 
/// @dev send ether from the completed crowdsale to the owners wallet address /// @param self Stored crowdsale from crowdsale contract /// @return true if owner withdrew eth 
/// @dev Function to change the price of the token /// @param self Stored crowdsale from crowdsale contract /// @param _tokensPerEth new token price (amount of tokens per ether) /// @return true if the token price changed successfully 
/// @dev function to set tokens for the sale /// @param self Stored Crowdsale from crowdsale contract /// @return true if tokens set successfully 
/// @dev Gets the price and buy cap for individual addresses at the given milestone index /// @param self Stored Crowdsale from crowdsale contract /// @param timestamp Time during sale for which data is requested /// @return A 3-element array with 0 the timestamp, 1 the price in cents, 2 the address cap 
/// @dev Gets the number of tokens sold thus far /// @param self Stored Crowdsale from crowdsale contract /// @return Number of tokens sold 
// Indicates when a bidder submits a bid to the crowdsale 
// Indicates when a bidder manually withdraws their bid from the crowdsale 
// Indicates when a bid is removed by the automated bid removal process 
// Generic Error Msg Event 
// Indicates when the price of the token changes 
// Logs the current bucket that the valuation points to, the total valuation of // the sale, and the amount of ETH committed, including total bids that will eventually get partial purchases 
/// @dev Called by a crowdsale contract upon creation. /// @param self Stored crowdsale from crowdsale contract /// @param _owner Address of crowdsale owner /// @param _saleData Array of 3 item arrays such that, in each 3 element /// array index-0 is a timestamp, index-1 is price in tokens/ETH /// index-2 is address purchase cap at that time, 0 if no address cap /// @param _priceBonusPercent the bonus amount for early bidders /// @param _minimumRaise minimim amount that the sale needs to make to be successfull /// @param _endWithdrawalTime timestamp that indicates that manual withdrawals are no longer allowed /// @param _endTime Timestamp of sale end time /// @param _percentBeingSold percentage of total tokens being sold in the sale /// @param _tokenName name of the token being sold. ex: "Jason Network Token" /// @param _tokenSymbol symbol of the token. ex: "JNT" /// @param _tokenDecimals number of decimals in the token /// @param _allowMinting whether or not to allow minting of the token after the sale 
/// @dev calculates the number of digits in a given number /// @param _number the number for which we're caluclating digits /// @return _digits the number of digits in _number 
/// @dev calculates the number of tokens purchased based on the amount of wei ///      spent and the price of tokens /// @param _amount amound of wei that the buyer sent /// @param _price price of tokens in the sale, in tokens/ETH /// @return uint256 numTokens the number of tokens purchased /// @return remainder  any remaining wei leftover from integer division 
/// @dev Called when an address wants to submit a bid to the sale /// @param self Stored crowdsale from crowdsale contract /// @return currentBonus percentage of the bonus that is applied for the purchase // can't underflow becuase endWithdrawalTime > startTime // can't underflow because now > startTime
/// @dev Called when an address wants to submit bid to the sale /// @param self Stored crowdsale from crowdsale contract /// @param _amount amound of wei that the buyer is sending /// @param _personalCap the total crowdsale valuation (wei) that the bidder is comfortable with /// @param _valuePredict prediction of where the valuation will go in the linked list. saves on searching time /// @return true on succesful bid 
/// @dev Called when an address wants to manually withdraw their bid from the ///      sale. puts their wei in the LeftoverWei mapping /// @param self Stored crowdsale from crowdsale contract /// @return true on succesful // The sender has to have already bid on the sale // cannot withdraw after compulsory withdraw period is over unless the bid's // valuation is below the cutoff // full refund because their bid no longer affects the total sale valuation require(!self.hasManuallyWithdrawn[msg.sender]);   //uint256 t = self.endWithdrawalTime - self.base.startTime; //uint256 s = now - self.base.startTime; //uint256 pa = self.pricePurchasedAt[msg.sender]; //uint256 pu = self.base.tokensPerEth; //uint256 multiplierPercent =  (100*(t - s))/t; //self.pricePurchasedAt = pa-((pa-pu)/3) // Put the sender's contributed wei into the leftoverWei mapping for later withdrawal // subtract the bidder's refund from its total contribution // bidder's withdrawal only affects the pointer if the personal cap is at or // above the current valuation // first we remove the refundWei from the committed value // if we've dropped below the current bucket // and current valuation is above the bucket // if we are still below the current bucket then we need to iterate // if we're going to loop we move to the previous bucket // while we are proposed lower than the previous bucket we add commitments // and iterate to the previous
/// @dev This should be called once the sale is over to commit all bids into ///      the owner's bucket. /// @param self stored crowdsale from crowdsale contract require(!self.isFinalized);  // may need to be computed due to EVM rounding errors // calculate the fraction of each minimal valuation bidders ether and tokens to refund // no computation necessary self.base.ownerBalance = computedValue;  
/// @dev Mints the token being sold by taking the percentage of the token supply ///      being sold in this sale along with the valuation, derives all necessary ///      values and then transfers owner tokens to the owner. /// @param self Stored crowdsale from crowdsale contract // total valuation of all the tokens not including the bonus // total valuation of bonus tokens // total supply of all tokens not including the bonus // total number of bonus tokens // tokens allocated to the owner of the sale // total supply of tokens not including the bonus tokens // deploy new token contract with total number of tokens // if the sale got canceled, then all the tokens go to the owner and bonus tokens are burned // the owner of the crowdsale becomes the new owner of the token contract
/// @dev returns a boolean indicating if the sale is canceled. ///      This can either be if the minimum raise hasn't been met ///      or if it is 30 days after the sale and the owner hasn't finalized the sale. /// @return bool canceled indicating if the sale is canceled or not 
/// @dev If the address' personal cap is below the pointer, refund them all their ETH. ///      if it is above the pointer, calculate tokens purchased and refund leftoever ETH /// @param self Stored crowdsale from crowdsale contract /// @return bool success if the contract runs successfully // if the sale was canceled, everyone gets a full refund // full refund if personal cap is less than total valuation // set hasContributed to 0 to prevent participant from calling this over and over // calculate the portion that this address has to take out of their bid // refund that amount of wei to the address // subtract that amount the address' contribution // calculate the number of tokens that the bidder purchased // add tokens to the bidders purchase.  can't overflow because it will be under the cap // burn any extra bonus tokens // send tokens and leftoverWei to the address calling the function
/// @dev returns true if the list exists /// @param self stored linked list from contract 
/// @dev returns true if the node exists /// @param self stored linked list from contract /// @param _node a node to search for 
/// @dev Returns the number of elements in the list /// @param self stored linked list from contract 
/// @dev Returns the links of a node as a tuple /// @param self stored linked list from contract /// @param _node id of the node to get 
/// @dev Returns the link of a node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node id of the node to step from /// @param _direction direction to step in 
/// @dev Can be used before `insert` to build an ordered list /// @param self stored linked list from contract /// @param _node an existing node to search from, e.g. HEAD. /// @param _value value to seek /// @param _direction direction to seek in //  @return next first node beyond '_node' in direction `_direction` 
/// @dev Creates a bidirectional link between two nodes on direction `_direction` /// @param self stored linked list from contract /// @param _node first node for linking /// @param _link  node to link to in the _direction 
/// @dev Insert node `_new` beside existing node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node existing node /// @param _new  new node to insert /// @param _direction direction to insert node in 
/// @dev removes an entry from the linked list /// @param self stored linked list from contract /// @param _node node to remove from the list 
/// @dev pushes an enrty to the head of the linked list /// @param self stored linked list from contract /// @param _node new entry to push to the head /// @param _direction push to the head (NEXT) or tail (PREV) 
/// @dev pops the first entry from the linked list /// @param self stored linked list from contract /// @param _direction pop from the head (NEXT) or the tail (PREV) 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
/// @dev returns true if the list exists /// @param self stored linked list from contract 
/// @dev returns true if the node exists /// @param self stored linked list from contract /// @param _node a node to search for 
/// @dev Returns the number of elements in the list /// @param self stored linked list from contract 
/// @dev Returns the links of a node as a tuple /// @param self stored linked list from contract /// @param _node id of the node to get 
/// @dev Returns the link of a node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node id of the node to step from /// @param _direction direction to step in 
/// @dev Can be used before `insert` to build an ordered list /// @param self stored linked list from contract /// @param _node an existing node to search from, e.g. HEAD. /// @param _value value to seek /// @param _direction direction to seek in //  @return next first node beyond '_node' in direction `_direction` 
/// @dev Creates a bidirectional link between two nodes on direction `_direction` /// @param self stored linked list from contract /// @param _node first node for linking /// @param _link  node to link to in the _direction 
/// @dev Insert node `_new` beside existing node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node existing node /// @param _new  new node to insert /// @param _direction direction to insert node in 
/// @dev removes an entry from the linked list /// @param self stored linked list from contract /// @param _node node to remove from the list 
/// @dev pushes an entry to the head of the linked list /// @param self stored linked list from contract /// @param _node new entry to push to the head /// @param _direction push to the head (NEXT) or tail (PREV) 
/// @dev pops the first entry from the linked list /// @param self stored linked list from contract /// @param _direction pop from the head (NEXT) or the tail (PREV) 
/// @dev returns true if the list exists /// @param self stored linked list from contract 
/// @dev returns true if the node exists /// @param self stored linked list from contract /// @param _node a node to search for 
/// @dev Returns the number of elements in the list /// @param self stored linked list from contract 
/// @dev Returns the links of a node as a tuple /// @param self stored linked list from contract /// @param _node id of the node to get 
/// @dev Returns the link of a node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node id of the node to step from /// @param _direction direction to step in 
/// @dev Can be used before `insert` to build an ordered list /// @param self stored linked list from contract /// @param _node an existing node to search from, e.g. HEAD. /// @param _value value to seek /// @param _direction direction to seek in //  @return next first node beyond '_node' in direction `_direction` 
/// @dev Creates a bidirectional link between two nodes on direction `_direction` /// @param self stored linked list from contract /// @param _node first node for linking /// @param _link  node to link to in the _direction 
/// @dev Insert node `_new` beside existing node `_node` in direction `_direction`. /// @param self stored linked list from contract /// @param _node existing node /// @param _new  new node to insert /// @param _direction direction to insert node in 
/// @dev removes an entry from the linked list /// @param self stored linked list from contract /// @param _node node to remove from the list 
/// @dev pushes an enrty to the head of the linked list /// @param self stored linked list from contract /// @param _node new entry to push to the head /// @param _direction push to the head (NEXT) or tail (PREV) 
/// @dev pops the first entry from the linked list /// @param self stored linked list from contract /// @param _direction pop from the head (NEXT) or the tail (PREV) 
/// @dev checks to see if a node exists 
/// @dev Returns the number of elements in the list 
/// @dev Returns the links of a node as and array /// @param _node id of the node to get 
/// @dev Returns the link of a node `n` in direction `d`. /// @param _node id of the node to step from /// @param _direction direction to step in 
/// @dev Can be used before `insert` to build an ordered list /// @param _node an existing node to search from, e.g. HEAD. /// @param _value value to seek /// @param _direction direction to seek in //  @return next first node beyond '_node' in direction `_direction` 
/// @dev Insert node `_new` beside existing node `_node` in direction `_direction`. /// @param _node existing node /// @param _new  new node to insert /// @param _direction direction to insert node in 
/// @dev removes an entry from the linked list /// @param _node node to remove from the list 
/// @dev pushes an enrty to the head of the linked list /// @param _node new entry to push to the head /// @param _direction push to the head (NEXT) or tail (PREV) 
/// @dev pops the first entry from the linked list /// @param _direction pop from the head (NEXT) or the tail (PREV) 
/* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ 
/* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ 
/* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-termintaed utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ // Allocate space for `self` in memory, copy it there, and point ret at it
/* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ 
/* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ 
/* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ // Starting at ptr-31 means the LSB will be the byte we care about
/* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ 
/* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ // Mask out irrelevant bytes and check again
/* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ 
/* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `rune`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ // Load the first byte of the rune into the LSBs of b // Check for truncated codepoints
/* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ 
/* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ // Load the rune into the MSBs of b // Check for truncated codepoints // Invalid UTF-8 sequence
/* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ 
/* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ 
/* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ 
/* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ 
/* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ 
// Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. 
// Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. 
/* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ 
/* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ 
/* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ // Not found
/* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ 
/* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ // Not found
/* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ 
/* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ 
/* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ 
/* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ 
/* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ 
/* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ 
/* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ 
/* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-termintaed utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ // Allocate space for `self` in memory, copy it there, and point ret at it
/* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ 
/* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ 
/* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ // Starting at ptr-31 means the LSB will be the byte we care about
/* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ 
/* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ // Mask out irrelevant bytes and check again
/* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ 
/* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `rune`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ // Load the first byte of the rune into the LSBs of b // Check for truncated codepoints
/* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ 
/* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ // Load the rune into the MSBs of b // Check for truncated codepoints // Invalid UTF-8 sequence
/* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ 
/* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ 
/* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ 
/* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ 
/* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ 
// Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. 
// Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. 
/* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ 
/* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ 
/* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ // Not found
/* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ 
/* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ // Not found
/* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ 
/* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ 
/* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ 
/* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ 
/* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
//prime the data using the fallback function. 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed 
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
// Generic Error message, error code and string 
// Logs when a user is registered in the system for vesting 
// Logs when a user is unregistered from the system 
// Logs when a user replaces themselves with a different beneficiary 
// Logs when a user withdraws their ETH from vesting 
// Logs when a user withdraws their tokens from the contract 
/// @dev Called by the token vesting contract upon creation. /// @param self Stored token from token contract /// @param _owner the owner of the vesting contract /// @param _isToken indicates if the vesting is for tokens or ETH /// @param _startTime the start time of the vesting (UNIX timestamp) /// @param _endTime the end time of the vesting     (UNIX timestamp) /// @param _numReleases number of times during vesting that the contract releases coins 
/// @dev function owner has to call before the vesting starts to initialize the ETH balance of the contract. /// @param self Stored vesting from vesting contract /// @param _balance the balance that is being vested.  msg.value from the contract call. 
/// @dev function owner has to call before the vesting starts to initialize the token balance of the contract. /// @param self Stored vesting from vesting contract /// @param _balance the balance that is being vested.  owner has to have sent tokens to the contract before calling this function 
/// @dev register user function, can only be called by the owner. registers amount /// of vesting into the address and reduces contractBalance /// @param self Stored vesting from vesting contract /// @param _registrant address to be registered for the vesting /// @param _vestAmount amount of ETH or tokens to vest for address /// @param _bonus amount of bonus tokens or eth if no withdrawal prior to endTime 
/// @dev registers multiple users at the same time. each registrant must be /// receiving the same amount of tokens or ETH /// @param self Stored vesting from vesting contract /// @param _registrants addresses to register for the vesting /// @param _vestAmount amount of ETH or tokens to vest /// @param _bonus amount of ETH or token bonus 
/// @dev Cancels a user's registration status can only be called by the owner /// when a user cancels their registration. sets their address field in the /// holding amount mapping to 0, decrements the numRegistered, and adds amount /// back into contractBalance /// @param self Stored vesting from vesting contract 
/// @dev unregisters multiple users at the same time /// @param self Stored vesting from vesting contract /// @param _registrants addresses to unregister for the vesting 
/// @dev allows a participant to replace themselves in the vesting schedule with a new address /// @param self Stored vesting from vesting contract /// @param _replacementRegistrant new address to replace the caller with 
/// @dev calculates the number of tokens or ETH available for the beneficiary to withdraw /// @param self Stored vesting from vesting contract /// @param _beneficiary the sender, who will be withdrawing their balance // figure out how many intervals have passed since the start // multiply that by the percentage released every interval // calculate the amount released by this time // subtract the amount that has already been withdrawn
/// @dev allows participants to withdraw their vested ETH /// @param self Stored vesting from vesting contract // if there is a bonus and it's before the endTime, cancel the bonus //self.holdingAmount[msg.sender][0] = 0; // add bonus eth back into the contract balance // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer ETH to the sender
/// @dev allows participants to withdraw their vested tokens /// @param self Stored vesting from vesting contract /// @param token the token contract that is being withdrawn // if there is a bonus and it's before the endTime, cancel the bonus and send tokens // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer tokens to the sender
/// @dev allows the owner to send vested ETH to participants /// @param self Stored vesting from vesting contract /// @param _beneficiary registered address to send the ETH to // if there is a bonus and it's before the endTime, cancel the bonus // add bonus eth back into the contract balance // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer ETH to the _beneficiary
/// @dev allows the owner to send vested tokens to participants /// @param self Stored vesting from vesting contract /// @param token the token contract that is being withdrawn /// @param _beneficiary registered address to send the tokens to // if there is a bonus and it's before the endTime, cancel the bonus // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer tokens to the beneficiary
/// @dev Allows the owner to withdraw any ETH left in the contractBalance /// @param self Stored vesting from vesting contract 
/// @dev Allows the owner to withdraw any tokens left in the contractBalance /// @param self Stored vesting from vesting contract 
/// @dev Returns the percentage of the vesting that has been released at the current moment 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
// Generic Error message, error code and string 
// Logs when a user is registered in the system for vesting 
// Logs when a user is unregistered from the system 
// Logs when a user replaces themselves with a different beneficiary 
// Logs when a user withdraws their ETH from vesting 
// Logs when a user withdraws their tokens from the contract 
/// @dev Called by the token vesting contract upon creation. /// @param self Stored token from token contract /// @param _owner the owner of the vesting contract /// @param _isToken indicates if the vesting is for tokens or ETH /// @param _startTime the start time of the vesting (UNIX timestamp) /// @param _endTime the end time of the vesting     (UNIX timestamp) /// @param _numReleases number of times during vesting that the contract releases coins 
/// @dev function owner has to call before the vesting starts to initialize the ETH balance of the contract. /// @param self Stored vesting from vesting contract /// @param _balance the balance that is being vested.  msg.value from the contract call. 
/// @dev function owner has to call before the vesting starts to initialize the token balance of the contract. /// @param self Stored vesting from vesting contract /// @param _balance the balance that is being vested.  owner has to have sent tokens to the contract before calling this function 
/// @dev register user function, can only be called by the owner. registers amount /// of vesting into the address and reduces contractBalance /// @param self Stored vesting from vesting contract /// @param _registrant address to be registered for the vesting /// @param _vestAmount amount of ETH or tokens to vest for address /// @param _bonus amount of bonus tokens or eth if no withdrawal prior to endTime 
/// @dev registers multiple users at the same time. each registrant must be /// receiving the same amount of tokens or ETH /// @param self Stored vesting from vesting contract /// @param _registrants addresses to register for the vesting /// @param _vestAmount amount of ETH or tokens to vest /// @param _bonus amount of ETH or token bonus 
/// @dev Cancels a user's registration status can only be called by the owner /// when a user cancels their registration. sets their address field in the /// holding amount mapping to 0, decrements the numRegistered, and adds amount /// back into contractBalance /// @param self Stored vesting from vesting contract 
/// @dev unregisters multiple users at the same time /// @param self Stored vesting from vesting contract /// @param _registrants addresses to unregister for the vesting 
/// @dev allows a participant to replace themselves in the vesting schedule with a new address /// @param self Stored vesting from vesting contract /// @param _replacementRegistrant new address to replace the caller with 
/// @dev calculates the number of tokens or ETH available for the beneficiary to withdraw /// @param self Stored vesting from vesting contract /// @param _beneficiary the sender, who will be withdrawing their balance // figure out how many intervals have passed since the start // multiply that by the percentage released every interval // calculate the amount released by this time // subtract the amount that has already been withdrawn
/// @dev allows participants to withdraw their vested ETH /// @param self Stored vesting from vesting contract // if there is a bonus and it's before the endTime, cancel the bonus //self.holdingAmount[msg.sender][0] = 0; // add bonus eth back into the contract balance // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer ETH to the sender
/// @dev allows participants to withdraw their vested tokens /// @param self Stored vesting from vesting contract /// @param token the token contract that is being withdrawn // if there is a bonus and it's before the endTime, cancel the bonus and send tokens // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer tokens to the sender
/// @dev allows the owner to send vested ETH to participants /// @param self Stored vesting from vesting contract /// @param _beneficiary registered address to send the ETH to // if there is a bonus and it's before the endTime, cancel the bonus // add bonus eth back into the contract balance // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer ETH to the _beneficiary
/// @dev allows the owner to send vested tokens to participants /// @param self Stored vesting from vesting contract /// @param token the token contract that is being withdrawn /// @param _beneficiary registered address to send the tokens to // if there is a bonus and it's before the endTime, cancel the bonus // if it's past the endTime then send everything left // if we're here then it's before the endTime and no bonus, need to calculate // transfer tokens to the beneficiary
/// @dev Allows the owner to withdraw any ETH left in the contractBalance /// @param self Stored vesting from vesting contract 
/// @dev Allows the owner to withdraw any tokens left in the contractBalance /// @param self Stored vesting from vesting contract 
/// @dev Returns the percentage of the vesting that has been released at the current moment 
// Generic Error message, error code and string 
// Logs when a user is registered in the system for vesting 
// Logs when a user is unregistered from the system 
// Logs when a user replaces themselves with a different beneficiary 
// Logs when a user withdraws their ETH from vesting 
// Generic Error message, error code and string 
// Logs when a user is registered in the system for vesting 
// Logs when a user is unregistered from the system 
// Logs when a user replaces themselves with a different beneficiary 
// Logs when a user withdraws their tokens from the contract 
/// @dev Validates arguments for changeOwner function /// @param _from Index of current owner removing /// @param _to Index of new potential owner, should be 0 /// @return Returns true if check passes, false otherwise 
/// @dev Validates arguments for addOwner function /// @param _index Index of new owner, should be 0 /// @param _length Current length of owner array /// @return Returns true if check passes, false otherwise 
/// @dev Validates arguments for removeOwner function /// @param _index Index of owner removing /// @param _length Current number of owners /// @param _min Minimum owners currently required to meet sig requirements /// @return Returs true if check passes, false otherwise 
/// @dev Validates arguments for changing any of the sig requirement parameters /// @param _newRequired The new sig requirement /// @param _length Current number of owners /// @return Returns true if checks pass, false otherwise 
/// @dev Used later to calculate the number of confirmations needed for tx /// @param _required Number of sigs required /// @param _count Current number of sigs 
/// @dev Changes owner address to a new address /// @param self Wallet in contract storage /// @param _from Current owner address /// @param _to New address /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Adds owner to wallet /// @param self Wallet in contract storage /// @param _newOwner Address for new owner /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Removes owner from wallet /// @param self Wallet in contract storage /// @param _ownerRemoving Address of owner to be removed /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs to change wallet parameters /// @param self Wallet in contract storage /// @param _requiredAdmin The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs for major transactions /// @param self Wallet in contract storage /// @param _requiredMajor The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs for minor transactions /// @param self Wallet in contract storage /// @param _requiredMinor The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes threshold for major transaction day spend per token /// @param self Wallet in contract storage /// @param _token Address of token, ether is 0 /// @param _majorThreshold New threshold /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Get list of wallet owners, will return fixed 50 until fork /// @param self Wallet in contract storage /// @return address[51] Returns entire 51 owner slots 
/// @dev Get index of an owner /// @param self Wallet in contract storage /// @param _owner Address of owner /// @return uint256 Index of the owner 
/// @dev Get max number of wallet owners /// @param self Wallet in contract storage /// @return uint256 Maximum number of owners 
/// @dev Get number of wallet owners /// @param self Wallet in contract storage /// @return uint256 Number of owners 
/// @dev Get sig requirements for administrative changes /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get sig requirements for minor tx spends /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get sig requirements for major tx spends /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get current day spend for token /// @param self Wallet in contract storage /// @param _token Address of token, 0 for ether /// @return uint256[2] 0-index is day timestamp, 1-index is the day spend 
/// @dev Get major tx threshold per token /// @param self Wallet in contract storage /// @param _token Address of token, 0 for ether /// @return uint256 Threshold amount 
/// @dev Get the number of tx's with the same id /// @param self Wallet in contract storage /// @param _id ID of transactions requested /// @return uint256 Number of tx's with same ID 
/// @dev Get list of confirmations for a tx, use getTransactionLength to get latest number /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return uint256[50] Returns list of confirmations, fixed at 50 until fork 
/// @dev Retrieve tx confirmation count /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return uint256 Returns the current number of tx confirmations 
/// @dev Retrieve if transaction was successful /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return bool Returns true if tx successfully executed, false otherwise 
/// @dev Constructor /// @param self The wallet in contract storage /// @param _owners Array of initial owners /// @param _requiredAdmin Set number of sigs for administrative tasks /// @param _requiredMajor Set number of sigs for major tx /// @param _requiredMinor Set number of sigs for minor tx /// @param _majorThreshold Set major tx threshold amount for ether /// @return Will return true when complete 
/// @dev Verifies a confirming owner has not confirmed already /// @param self Contract wallet in storage /// @param _id ID of the tx being checked /// @param _txIndex Index number of this tx /// @return Returns true if check passes, false otherwise 
/// @dev Used later to calculate the number of confirmations needed for tx /// @param _required Number of sigs required /// @param _count Current number of sigs 
/// @dev Used to check if tx is moving tokens and parses amount /// @param _txData Data for proposed tx /// @return bool True if transaction is moving tokens /// @return uint256 Amount of tokens involved, 0 if not spending tx bytes4 tSig = 0xa9059cbb;  bytes4 aSig = 0x095ea7b3;  bytes4 tfSig = 0x23b872dd; 
/// @dev Retrieves sig requirement for spending tx /// @param self Contract wallet in storage /// @param _to Target address of transaction /// @param _value Amount of ether spend /// @param _isTransfer True if transferring other tokens, false otherwise /// @param _amount Amount of tokens being transferred, 0 if not a transfer tx /// @return uint256 The required sigs for tx 
/// @dev Function to create new contract /// @param _txData Transaction data /// @param _value Amount of eth sending to new contract 
/// @dev Create and execute transaction from wallet /// @param self Wallet in contract storage /// @param _to Address of target /// @param _value Amount of ether sending /// @param _txData Data for executing transaction /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Confirms a current pending tx, will execute if final confirmation /// @param self Wallet in contract storage /// @param _id ID of the transaction /// @return Returns true if successful, false otherwise 
/// @dev Revokes a prior confirmation from sender, call with tx ID /// @param self Wallet in contract storage /// @param _id ID of the transaction /// @return Returns true if successful, false otherwise 
/// @dev Sum vector /// @param self Storage array containing uint256 type variables /// @return sum The sum of all elements, does not check for overflow 
/// @dev Returns the max value in an array. /// @param self Storage array containing uint256 type variables /// @return maxValue The highest value in the array 
/// @dev Returns the minimum value in an array. /// @param self Storage array containing uint256 type variables /// @return minValue The highest value in the array 
/// @dev Finds the index of a given value in an array /// @param self Storage array containing uint256 type variables /// @param value The value to search for /// @param isSorted True if the array is sorted, false otherwise /// @return found True if the value was found, false otherwise /// @return index The index of the given value, returns 0 if found is false 
/// @dev Utility function for heapSort /// @param index The index of child node /// @return pI The parent node index 
/// @dev Utility function for heapSort /// @param index The index of parent node /// @return lcI The index of left child 
/// @dev Sorts given array in place /// @param self Storage array containing uint256 type variables 
/// @dev Removes duplicates from a given array. /// @param self Storage array containing uint256 type variables 
/// @dev Multiplies two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The product of a and b, or 0 if there is overflow 
/// @dev Divides two numbers but checks for 0 in the divisor first. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if `b` is 0 /// @return res The quotient of a and b, or 0 if `b` is 0 
/// @dev Adds two numbers and checks for overflow before returning. /// Does not throw. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is overflow /// @return res The sum of a and b, or 0 if there is overflow 
/// @dev Subtracts two numbers and checks for underflow before returning. /// Does not throw but rather logs an Err event if there is underflow. /// @param a First number /// @param b Second number /// @return err False normally, or true if there is underflow /// @return res The difference between a and b, or 0 if there is underflow 
/// @dev Called by the Standard Token upon creation. /// @param self Stored token from token contract /// @param _name Name of the new token /// @param _symbol Symbol of the new token /// @param _decimals Decimal places for the token represented /// @param _initial_supply The initial token supply /// @param _allowMinting True if additional tokens can be created, false otherwise 
/// @dev Transfer tokens from caller's account to another account. /// @param self Stored token from token contract /// @param _to Address to send tokens /// @param _value Number of tokens to send /// @return True if completed //It's not possible to overflow token supply
/// @dev Authorized caller transfers tokens from one account to another /// @param self Stored token from token contract /// @param _from Address to send tokens from /// @param _to Address to send tokens to /// @param _value Number of tokens to send /// @return True if completed 
/// @dev Retrieve token balance for an account /// @param self Stored token from token contract /// @param _owner Address to retrieve balance of /// @return balance The number of tokens in the subject account 
/// @dev Authorize an account to send tokens on caller's behalf /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _value Number of tokens authorized account may send /// @return True if completed // must set to zero before changing approval amount in accordance with spec
/// @dev Remaining tokens third party spender has to send /// @param self Stored token from token contract /// @param _owner Address of token holder /// @param _spender Address of authorized spender /// @return remaining Number of tokens spender has left in owner's account 
/// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it /// @param self Stored token from token contract /// @param _spender Address to authorize /// @param _valueChange Increase or decrease in number of tokens authorized account may send /// @param _increase True if increasing allowance, false if decreasing allowance /// @return True if completed 
/// @dev Change owning address of the token contract, specifically for minting /// @param self Stored token from token contract /// @param _newOwner Address for the new owner /// @return True if completed 
/// @dev Mints additional tokens, new tokens go to owner /// @param self Stored token from token contract /// @param _amount Number of tokens to mint /// @return True if completed 
/// @dev Permanent stops minting /// @param self Stored token from token contract /// @return True if completed 
/// @dev Permanently burn tokens /// @param self Stored token from token contract /// @param _amount Amount of tokens to burn /// @return True if completed 
/// @dev Validates arguments for changeOwner function /// @param _from Index of current owner removing /// @param _to Index of new potential owner, should be 0 /// @return Returns true if check passes, false otherwise 
/// @dev Validates arguments for addOwner function /// @param _index Index of new owner, should be 0 /// @param _length Current length of owner array /// @return Returns true if check passes, false otherwise 
/// @dev Validates arguments for removeOwner function /// @param _index Index of owner removing /// @param _length Current number of owners /// @param _min Minimum owners currently required to meet sig requirements /// @return Returs true if check passes, false otherwise 
/// @dev Validates arguments for changing any of the sig requirement parameters /// @param _newRequired The new sig requirement /// @param _length Current number of owners /// @return Returns true if checks pass, false otherwise 
/// @dev Used later to calculate the number of confirmations needed for tx /// @param _required Number of sigs required /// @param _count Current number of sigs 
/// @dev Changes owner address to a new address /// @param self Wallet in contract storage /// @param _from Current owner address /// @param _to New address /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Adds owner to wallet /// @param self Wallet in contract storage /// @param _newOwner Address for new owner /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Removes owner from wallet /// @param self Wallet in contract storage /// @param _ownerRemoving Address of owner to be removed /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs to change wallet parameters /// @param self Wallet in contract storage /// @param _requiredAdmin The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs for major transactions /// @param self Wallet in contract storage /// @param _requiredMajor The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes required sigs for minor transactions /// @param self Wallet in contract storage /// @param _requiredMinor The new signature requirement /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Changes threshold for major transaction day spend per token /// @param self Wallet in contract storage /// @param _token Address of token, ether is 0 /// @param _majorThreshold New threshold /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Get list of wallet owners, will return fixed 50 until fork /// @param self Wallet in contract storage /// @return address[51] Returns entire 51 owner slots 
/// @dev Get index of an owner /// @param self Wallet in contract storage /// @param _owner Address of owner /// @return uint256 Index of the owner 
/// @dev Get max number of wallet owners /// @param self Wallet in contract storage /// @return uint256 Maximum number of owners 
/// @dev Get number of wallet owners /// @param self Wallet in contract storage /// @return uint256 Number of owners 
/// @dev Get sig requirements for administrative changes /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get sig requirements for minor tx spends /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get sig requirements for major tx spends /// @param self Wallet in contract storage /// @return uint256 Number of sigs required 
/// @dev Get current day spend for token /// @param self Wallet in contract storage /// @param _token Address of token, 0 for ether /// @return uint256[2] 0-index is day timestamp, 1-index is the day spend 
/// @dev Get major tx threshold per token /// @param self Wallet in contract storage /// @param _token Address of token, 0 for ether /// @return uint256 Threshold amount 
/// @dev Get the number of tx's with the same id /// @param self Wallet in contract storage /// @param _id ID of transactions requested /// @return uint256 Number of tx's with same ID 
/// @dev Get list of confirmations for a tx, use getTransactionLength to get latest number /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return uint256[50] Returns list of confirmations, fixed at 50 until fork 
/// @dev Retrieve tx confirmation count /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return uint256 Returns the current number of tx confirmations 
/// @dev Retrieve if transaction was successful /// @param self Wallet in contract storage /// @param _id ID of transaction requested /// @param _txIndex The transaction index number /// @return bool Returns true if tx successfully executed, false otherwise 
/// @dev Constructor /// @param self The wallet in contract storage /// @param _owners Array of initial owners /// @param _requiredAdmin Set number of sigs for administrative tasks /// @param _requiredMajor Set number of sigs for major tx /// @param _requiredMinor Set number of sigs for minor tx /// @param _majorThreshold Set major tx threshold amount for ether /// @return Will return true when complete 
/// @dev Verifies a confirming owner has not confirmed already /// @param self Contract wallet in storage /// @param _id ID of the tx being checked /// @param _txIndex Index number of this tx /// @return Returns true if check passes, false otherwise 
/// @dev Used later to calculate the number of confirmations needed for tx /// @param _required Number of sigs required /// @param _count Current number of sigs 
/// @dev Used to check if tx is moving tokens and parses amount /// @param _txData Data for proposed tx /// @return bool True if transaction is moving tokens /// @return uint256 Amount of tokens involved, 0 if not spending tx bytes4 tSig = 0xa9059cbb;  bytes4 aSig = 0x095ea7b3;  bytes4 tfSig = 0x23b872dd; 
/// @dev Retrieves sig requirement for spending tx /// @param self Contract wallet in storage /// @param _to Target address of transaction /// @param _value Amount of ether spend /// @param _isTransfer True if transferring other tokens, false otherwise /// @param _amount Amount of tokens being transferred, 0 if not a transfer tx /// @return uint256 The required sigs for tx 
/// @dev Function to create new contract /// @param _txData Transaction data /// @param _value Amount of eth sending to new contract 
/// @dev Create and execute transaction from wallet /// @param self Wallet in contract storage /// @param _to Address of target /// @param _value Amount of ether sending /// @param _txData Data for executing transaction /// @param _confirm True if confirming, false if revoking confirmation /// @param _data Message data passed from wallet contract /// @return bool Returns true if successful, false otherwise /// @return bytes32 Returns the tx ID, can be used for confirm/revoke functions 
/// @dev Confirms a current pending tx, will execute if final confirmation /// @param self Wallet in contract storage /// @param _id ID of the transaction /// @return Returns true if successful, false otherwise 
/// @dev Revokes a prior confirmation from sender, call with tx ID /// @param self Wallet in contract storage /// @param _id ID of the transaction /// @return Returns true if successful, false otherwise 
/** * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` * * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite * {RoleAdminChanged} not being emitted signaling this. * * _Available since v3.1._ */ 
/** * @dev Emitted when `account` is granted `role`. * * `sender` is the account that originated the contract call, an admin role * bearer except when using {_setupRole}. */ 
/** * @dev Emitted when `account` is revoked `role`. * * `sender` is the account that originated the contract call: *   - if using `revokeRole`, it is the admin role bearer *   - if using `renounceRole`, it is the role bearer (i.e. `account`) */ 
/** * @dev Modifier that checks that an account has a specific role. Reverts * with a standardized message including the required role. * * The format of the revert reason is given by the following regular expression: * *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/ */ 
/** * @dev See {IERC165-supportsInterface}. */ 
/** * @dev Returns `true` if `account` has been granted `role`. */ 
/** * @dev Revert with a standard message if `account` is missing `role`. * * The format of the revert reason is given by the following regular expression: * *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/ */ 
/** * @dev Returns the admin role that controls `role`. See {grantRole} and * {revokeRole}. * * To change a role's admin, use {_setRoleAdmin}. */ 
/** * @dev Grants `role` to `account`. * * If `account` had not been already granted `role`, emits a {RoleGranted} * event. * * Requirements: * * - the caller must have ``role``'s admin role. */ 
/** * @dev Revokes `role` from `account`. * * If `account` had been granted `role`, emits a {RoleRevoked} event. * * Requirements: * * - the caller must have ``role``'s admin role. */ 
/** * @dev Revokes `role` from the calling account. * * Roles are often managed via {grantRole} and {revokeRole}: this function's * purpose is to provide a mechanism for accounts to lose their privileges * if they are compromised (such as when a trusted device is misplaced). * * If the calling account had been granted `role`, emits a {RoleRevoked} * event. * * Requirements: * * - the caller must be `account`. */ 
/** * @dev Grants `role` to `account`. * * If `account` had not been already granted `role`, emits a {RoleGranted} * event. Note that unlike {grantRole}, this function doesn't perform any * checks on the calling account. * * [WARNING] * ==== * This function should only be called from the constructor when setting * up the initial roles for the system. * * Using this function in any other way is effectively circumventing the admin * system imposed by {AccessControl}. * ==== */ 
/** * @dev Sets `adminRole` as ``role``'s admin role. * * Emits a {RoleAdminChanged} event. */ 
/** * @dev See {IERC165-supportsInterface}. */ 
/** * @dev Returns one of the accounts that have `role`. `index` must be a * value between 0 and {getRoleMemberCount}, non-inclusive. * * Role bearers are not sorted in any particular way, and their ordering may * change at any point. * * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure * you perform all queries on the same block. See the following * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post] * for more information. */ 
/** * @dev Returns the number of accounts that have `role`. Can be used * together with {getRoleMember} to enumerate all bearers of a role. */ 
/** * @dev Overload {grantRole} to track enumerable memberships */ 
/** * @dev Overload {revokeRole} to track enumerable memberships */ 
/** * @dev Overload {renounceRole} to track enumerable memberships */ 
/** * @dev Overload {_setupRole} to track enumerable memberships */ 
/** * @dev Returns the address of the current owner. */ 
/** * @dev Throws if called by any account other than the owner. */ 
/** * @dev Leaves the contract without owner. It will not be possible to call * `onlyOwner` functions anymore. Can only be called by the current owner. * * NOTE: Renouncing ownership will leave the contract without an owner, * thereby removing any functionality that is only available to the owner. */ 
/** * @dev Transfers ownership of the contract to a new account (`newOwner`). * Can only be called by the current owner. */ 
/** * @dev Getter for the total shares held by payees. */ 
/** * @dev Getter for the total amount of Ether already released. */ 
/** * @dev Getter for the amount of shares held by an account. */ 
/** * @dev Getter for the amount of Ether already released to a payee. */ 
/** * @dev Getter for the address of the payee number `index`. */ 
/** * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the * total shares and their previous withdrawals. */ 
/** * @dev Add a new payee to the contract. * @param account The address of the payee to add. * @param shares_ The number of shares owned by the payee. */ 
/** * @dev Emitted when a call is scheduled as part of operation `id`. */ 
/** * @dev Emitted when a call is performed as part of operation `id`. */ 
/** * @dev Emitted when operation `id` is cancelled. */ 
/** * @dev Emitted when the minimum delay for future operations is modified. */ 
/** * @dev Modifier to make a function callable only by a certain role. In * addition to checking the sender's role, `address(0)` 's role is also * considered. Granting a role to `address(0)` is equivalent to enabling * this role for everyone. */ 
/** * @dev Returns whether an id correspond to a registered operation. This * includes both Pending, Ready and Done operations. */ 
/** * @dev Returns whether an operation is pending or not. */ 
/** * @dev Returns whether an operation is ready or not. */ // solhint-disable-next-line not-rely-on-time
/** * @dev Returns whether an operation is done or not. */ 
/** * @dev Returns the timestamp at with an operation becomes ready (0 for * unset operations, 1 for done operations). */ 
/** * @dev Returns the minimum delay for an operation to become valid. * * This value can be changed by executing an operation that calls `updateDelay`. */ 
/** * @dev Returns the identifier of an operation containing a single * transaction. */ 
/** * @dev Returns the identifier of an operation containing a batch of * transactions. */ 
/** * @dev Schedule an operation containing a single transaction. * * Emits a {CallScheduled} event. * * Requirements: * * - the caller must have the 'proposer' role. */ 
/** * @dev Schedule an operation containing a batch of transactions. * * Emits one {CallScheduled} event per transaction in the batch. * * Requirements: * * - the caller must have the 'proposer' role. */ 
/** * @dev Schedule an operation that is to becomes valid after a given delay. */ // solhint-disable-next-line not-rely-on-time
/** * @dev Cancel an operation. * * Requirements: * * - the caller must have the 'proposer' role. */ 
/** * @dev Execute an (ready) operation containing a single transaction. * * Emits a {CallExecuted} event. * * Requirements: * * - the caller must have the 'executor' role. */ 
/** * @dev Execute an (ready) operation containing a batch of transactions. * * Emits one {CallExecuted} event per transaction in the batch. * * Requirements: * * - the caller must have the 'executor' role. */ 
/** * @dev Checks before execution of an operation's calls. */ 
/** * @dev Checks after execution of an operation's calls. */ 
/** * @dev Execute an operation's call. * * Emits a {CallExecuted} event. */ // solhint-disable-next-line avoid-low-level-calls
/** * @dev Changes the minimum timelock duration for future operations. * * Emits a {MinDelayChange} event. * * Requirements: * * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing * an operation where the timelock is the target and the data is the ABI-encoded call to this function. */ 
/** * @dev Should return whether the signature provided is valid for the provided data * @param hash      Hash of the data to be signed * @param signature Signature byte array associated with _data */ 
/** * @dev Receive a flash loan. * @param initiator The initiator of the loan. * @param token The loan currency. * @param amount The amount of tokens lent. * @param fee The additional amount of tokens to repay. * @param data Arbitrary data structure, intended to contain user-defined parameters. * @return The keccak256 hash of "ERC3156FlashBorrower.onFlashLoan" */ 
/** * @dev The amount of currency available to be lended. * @param token The loan currency. * @return The amount of `token` that can be borrowed. */ 
/** * @dev The fee to be charged for a given loan. * @param token The loan currency. * @param amount The amount of tokens lent. * @return The amount of `token` to be charged for the loan, on top of the returned principal. */ 
/** * @dev Initiate a flash loan. * @param receiver The receiver of the tokens in the loan, and the receiver of the callback. * @param token The loan currency. * @param amount The amount of tokens lent. * @param data Arbitrary data structure, intended to contain user-defined parameters. */ 
// Emitted in ERC777Mock. Here for easier decoding 
// test helper function to call asyncTransfer 
// using the do* naming convention to avoid warnings due to clashing opcode names 
/** * @dev Implement supportsInterface(bytes4) using a lookup table. */ 
/** * @dev Private method for registering an interface. */ 
// Not having any checks in this function is dangerous! Do not do this outside tests! 
/** * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`. * * This function uses the create opcode, which should never revert. */ // solhint-disable-next-line no-inline-assembly
/** * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`. * * This function uses the create2 opcode and a `salt` to deterministically deploy * the clone. Using the same `implementation` and `salt` multiple time will revert, since * the clones cannot be deployed twice at the same address. */ // solhint-disable-next-line no-inline-assembly
/** * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}. */ // solhint-disable-next-line no-inline-assembly
/** * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}. */ 
/** * @dev Delegates the current call to `implementation`. * * This function does not return to its internall call site, it will return directly to the external caller. */ // solhint-disable-next-line no-inline-assembly // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. // Call the implementation. // out and outsize are 0 because we don't know the size yet. // Copy the returned data. // delegatecall returns 0 on error.
/** * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function * and {_fallback} should delegate. */ 
/** * @dev Delegates the current call to the address returned by `_implementation()`. * * This function does not return to its internall call site, it will return directly to the external caller. */ 
/** * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback` * call, or as part of the Solidity `fallback` or `receive` functions. * * If overriden should call `super._beforeFallback()`. */ 
/** * @dev Returns the current beacon address. */ 
/** * @dev Returns the current implementation address of the associated beacon. */ 
/** * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}. * * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. * * Requirements: * * - `beacon` must be a contract. * - The implementation returned by `beacon` must be a contract. */ 
/** * @dev Must return an address that can be used as a delegate call target. * * {BeaconProxy} will check that this address is a contract. */ 
/** * @dev Emitted when the implementation returned by the beacon is changed. */ 
/** * @dev Returns the current implementation address. */ 
/** * @dev Upgrades the beacon to a new implementation. * * Emits an {Upgraded} event. * * Requirements: * * - msg.sender must be the owner of the contract. * - `newImplementation` must be a contract. */ 
/** * @dev Sets the implementation contract address for this beacon * * Requirements: * * - `newImplementation` must be a contract. */ 
/** * @dev Returns the current implementation address. */ 
/** * @dev Returns the current implementation address. */ 
/** * @dev Stores a new address in the EIP1967 implementation slot. */ 
/** * @dev Returns the current beacon. */ 
/** * @dev Stores a new beacon in the EIP1967 beacon slot. */ 
/** * @dev Returns the current admin. */ 
/** * @dev Stores a new address in the EIP1967 admin slot. */ 
/** * @dev Emitted when the implementation is upgraded. */ 
/** * @dev Emitted when the beacon is upgraded. */ 
/** * @dev Emitted when the admin account has changed. */ 
/** * @dev Perform implementation upgrade * * Emits an {Upgraded} event. */ 
/** * @dev Perform implementation upgrade with additional setup call. * * Emits an {Upgraded} event. */ 
/** * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call. * * Emits an {Upgraded} event. */ // do inital upgrade // do setup call // check if nested in an upgrade check // trigger upgrade check with flag set to true // check upgrade was effective // reset upgrade // emit event
/** * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that). * * Emits a {BeaconUpgraded} event. */ 
/** * @dev Changes the admin of the proxy. * * Emits an {AdminChanged} event. */ 
/** * @dev Returns the current implementation of `proxy`. * * Requirements: * * - This contract must be the admin of `proxy`. */ // We need to manually run the static call since the getter cannot be flagged as view // bytes4(keccak256("implementation()")) == 0x5c60da1b
/** * @dev Returns the current admin of `proxy`. * * Requirements: * * - This contract must be the admin of `proxy`. */ // We need to manually run the static call since the getter cannot be flagged as view // bytes4(keccak256("admin()")) == 0xf851a440
/** * @dev Changes the admin of `proxy` to `newAdmin`. * * Requirements: * * - This contract must be the current admin of `proxy`. */ 
/** * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}. * * Requirements: * * - This contract must be the admin of `proxy`. */ 
/** * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See * {TransparentUpgradeableProxy-upgradeToAndCall}. * * Requirements: * * - This contract must be the admin of `proxy`. */ 
/** * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin. */ 
/** * @dev Returns the current admin. * * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}. * * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` */ 
/** * @dev Returns the current implementation. * * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}. * * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` */ 
/** * @dev Changes the admin of the proxy. * * Emits an {AdminChanged} event. * * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}. */ 
/** * @dev Upgrade the implementation of the proxy. * * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}. */ 
/** * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the * proxied contract. * * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}. */ 
/** * @dev Returns the current admin. */ 
/** * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}. */ 
/** * @dev Modifier to protect an initializer function from being invoked twice. */ 
/** * @dev Emitted when the pause is triggered by `account`. */ 
/** * @dev Emitted when the pause is lifted by `account`. */ 
/** * @dev Returns true if the contract is paused, and false otherwise. */ 
/** * @dev Modifier to make a function callable only when the contract is not paused. * * Requirements: * * - The contract must not be paused. */ 
/** * @dev Modifier to make a function callable only when the contract is paused. * * Requirements: * * - The contract must be paused. */ 
/** * @dev Triggers stopped state. * * Requirements: * * - The contract must not be paused. */ 
/** * @dev Returns to normal state. * * Requirements: * * - The contract must be paused. */ 
/** * @dev Withdraw accumulated payments, forwarding all gas to the recipient. * * Note that _any_ account can call this function, not just the `payee`. * This means that contracts unaware of the `PullPayment` protocol can still * receive funds this way, by having a separate account call * {withdrawPayments}. * * WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities. * Make sure you trust the recipient, or are either following the * checks-effects-interactions pattern or using {ReentrancyGuard}. * * @param payee Whose payments will be withdrawn. */ 
/** * @dev Returns the payments owed to an address. * @param dest The creditor's address. */ 
/** * @dev Called by the payer to store the sent amount as credit to be pulled. * Funds sent in this way are stored in an intermediate {Escrow} contract, so * there is no danger of them being spent before withdrawal. * * @param dest The destination address of the funds. * @param amount The amount to transfer. */ 
/** * @dev Prevents a contract from calling itself, directly or indirectly. * Calling a `nonReentrant` function from another `nonReentrant` * function is not supported. It is possible to prevent this from happening * by making the `nonReentrant` function external, and make it call a * `private` function that does the actual work. */ // On the first call to nonReentrant, _notEntered will be true // Any calls to nonReentrant after this point will fail // By storing the original value once again, a refund is triggered (see // https://eips.ethereum.org/EIPS/eip-2200)
/** * @dev See {IERC165-supportsInterface}. */ 
/** * @dev See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\{id\}` substring with the * actual token type ID. */ 
/** * @dev See {IERC1155-balanceOf}. * * Requirements: * * - `account` cannot be the zero address. */ 
/** * @dev See {IERC1155-balanceOfBatch}. * * Requirements: * * - `accounts` and `ids` must have the same length. */ 
/** * @dev See {IERC1155-setApprovalForAll}. */ 
/** * @dev See {IERC1155-isApprovedForAll}. */ 
/** * @dev See {IERC1155-safeTransferFrom}. */ 
/** * @dev See {IERC1155-safeBatchTransferFrom}. */ 
/** * @dev Sets a new URI for all token types, by relying on the token type ID * substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * By this mechanism, any occurrence of the `\{id\}` substring in either the * URI or any of the amounts in the JSON file at said URI will be replaced by * clients with the token type ID. * * For example, the `https://token-cdn-domain/\{id\}.json` URI would be * interpreted by clients as * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json` * for token type ID 0x4cce0. * * See {uri}. * * Because these URIs cannot be meaningfully represented by the {URI} event, * this function emits no events. */ 
/** * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`. * * Emits a {TransferSingle} event. * * Requirements: * * - `account` cannot be the zero address. * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the * acceptance magic value. */ 
/** * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}. * * Requirements: * * - `ids` and `amounts` must have the same length. * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the * acceptance magic value. */ 
/** * @dev Destroys `amount` tokens of token type `id` from `account` * * Requirements: * * - `account` cannot be the zero address. * - `account` must have at least `amount` tokens of token type `id`. */ 
/** * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}. * * Requirements: * * - `ids` and `amounts` must have the same length. */ 
/** * @dev Hook that is called before any token transfer. This includes minting * and burning, as well as batched variants. * * The same hook is called on both single and batched variants. For single * transfers, the length of the `id` and `amount` arrays will be 1. * * Calling conditions (for each `id` and `amount` pair): * * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens * of token type `id` will be  transferred to `to`. * - When `from` is zero, `amount` tokens of token type `id` will be minted * for `to`. * - when `to` is zero, `amount` of ``from``'s tokens of token type `id` * will be burned. * - `from` and `to` are never both zero. * - `ids` and `amounts` have the same, non-zero length. * * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. */ 
/** * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`. */ 
/** * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all * transfers. */ 
/** * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to * `approved`. */ 
/** * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI. * * If an {URI} event was emitted for `id`, the standard * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value * returned by {IERC1155MetadataURI-uri}. */ 
/** * @dev Returns the amount of tokens of token type `id` owned by `account`. * * Requirements: * * - `account` cannot be the zero address. */ 
/** * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. * * Requirements: * * - `accounts` and `ids` must have the same length. */ 
/** * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`, * * Emits an {ApprovalForAll} event. * * Requirements: * * - `operator` cannot be the caller. */ 
/** * @dev Returns true if `operator` is approved to transfer ``account``'s tokens. * * See {setApprovalForAll}. */ 
/** * @dev Transfers `amount` tokens of token type `id` from `from` to `to`. * * Emits a {TransferSingle} event. * * Requirements: * * - `to` cannot be the zero address. * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}. * - `from` must have a balance of tokens of type `id` of at least `amount`. * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the * acceptance magic value. */ 
/** * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. * * Emits a {TransferBatch} event. * * Requirements: * * - `ids` and `amounts` must have the same length. * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the * acceptance magic value. */ 
/** @dev Handles the receipt of a single ERC1155 token type. This function is called at the end of a `safeTransferFrom` after the balance has been updated. To accept the transfer, this must return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61, or its own function selector). @param operator The address which initiated the transfer (i.e. msg.sender) @param from The address which previously owned the token @param id The ID of the token being transferred @param value The amount of tokens being transferred @param data Additional data with no specified format @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed */ 
/** @dev Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a `safeBatchTransferFrom` after the balances have been updated. To accept the transfer(s), this must return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81, or its own function selector). @param operator The address which initiated the batch transfer (i.e. msg.sender) @param from The address which previously owned the token @param ids An array containing ids of each token being transferred (order and length must match values array) @param values An array containing amounts of each token being transferred (order and length must match ids array) @param data Additional data with no specified format @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed */ 
/** * @dev See {ERC1155-_beforeTokenTransfer}. * * Requirements: * * - the contract must not be paused. */ 
