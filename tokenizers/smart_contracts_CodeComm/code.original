function initialize(uint256 _hsp, uint256 _hrp, uint256 _bdur, uint256 _dbt, uint256 _mim, uint256 _vssm) returns (bool) { if (initializedTo < 8) { if (owner == 0) owner = msg.sender; hashSubmissionPeriod = _hsp; hashRevealPeriod = _hrp; baseDuration = _bdur; durationBumpTo = _dbt; minIncrementMillis = _mim; valueSubmissionSubsidyMillis = _vssm; for (uint256 i = initializedTo; i < 8 && msg.gas > 1100000; i++) { GasRemaining(msg.gas, i); if (i < 4) { auctions[i] = new OnePhaseAuction(); OnePhaseAuction(auctions[i]).initialize(this, baseDuration, durationBumpTo, minIncrementMillis, i); } else { auctions[i] = new TwoPhaseAuction(); TwoPhaseAuction(auctions[i]).initialize(this, hashSubmissionPeriod, hashRevealPeriod, valueSubmissionSubsidyMillis, i - 3); } } initializedTo = i; if (initializedTo == 8) return true; else return false; } return true; }
function initialize(address _t, uint256 _baseDuration, uint256 _durationBumpTo, uint256 _minIncrementMillis, uint256 _tp) returns (bool) { if (msg.sender != owner) return false; if (phase == 1 || phase == 2) return false; phase = 1; target = adStorer(_t); auctionEnd = block.timestamp + _baseDuration; durationBumpTo = _durationBumpTo; minIncrementMillis = _minIncrementMillis; nextBidIndex = 0; bestBidValue = 0; bestBidIndex = 0; auctionType = _tp; mostRecentAuctionStart = block.number; AuctionInitialized(); return true; }
function bid(string metadata) returns (int256) { if (phase != 1) { msg.sender.send(msg.value); return (-1); } if (phase == 1 && block.timestamp >= auctionEnd) { phase = 2; msg.sender.send(msg.value); return (-1); } if (msg.value * 1000 < bestBidValue * (1000 + minIncrementMillis)) { msg.sender.send(msg.value); return (-1); } if (msg.value > bestBidValue) { bestBidValue = msg.value; bestBidIndex = nextBidIndex; } bids[nextBidIndex].bidValue = msg.value; bids[nextBidIndex].metadata = metadata; bids[nextBidIndex].bidder = msg.sender; BidSubmitted(nextBidIndex, msg.value, metadata, msg.sender); nextBidIndex = nextBidIndex + 1; if (auctionEnd - block.timestamp < durationBumpTo) auctionEnd = block.timestamp + durationBumpTo; if ((auctionType & 2) == 2) totalRevenue += msg.value; return int256(nextBidIndex) - 1; }
function increaseBid(uint256 index) returns (bool) { if ((auctionType & 1) == 0) { msg.sender.send(msg.value); return (false); } if (phase != 1) { msg.sender.send(msg.value); return (false); } if (phase == 1 && block.timestamp >= auctionEnd) { msg.sender.send(msg.value); phase = 2; return (false); } if ((bids[index].bidValue + msg.value) * 1000 < bestBidValue * (1000 + minIncrementMillis)) { msg.sender.send(msg.value); return(false); } if (index >= nextBidIndex) { msg.sender.send(msg.value); return false; } if (bids[index].bidder != msg.sender) { msg.sender.send(msg.value); return false; } bids[index].bidValue += msg.value; if (bids[index].bidValue > bestBidValue) { bestBidValue = bids[index].bidValue; bestBidIndex = index; } if ((auctionType & 2) == 2) totalRevenue += msg.value; BidIncreased(index, msg.value, bids[index].bidValue, bids[index].metadata, bids[index].bidder); if (auctionEnd - block.timestamp < durationBumpTo) auctionEnd = block.timestamp + durationBumpTo; return(true); }
function ping() returns(bool) { if (phase == 1 && block.timestamp >= auctionEnd) phase = 2; if (phase != 2) return(false); uint _nbi = nextBidIndex; while (msg.gas > 100000 && _nbi > 0) { _nbi -= 1; if (_nbi == bestBidIndex) { } else { if ((auctionType & 2) == 0) bids[_nbi].bidder.send(bids[_nbi].bidValue); bids[_nbi].bidValue = 0; } } nextBidIndex = _nbi; if (_nbi == 0) { phase = 0; bool success; if (bestBidValue > 0) { AuctionWinner(bestBidIndex, bestBidValue, bids[bestBidIndex].metadata, bids[bestBidIndex].bidder); success = target.acceptAuctionResult(bids[bestBidIndex].bidder, bestBidValue, bids[bestBidIndex].metadata); } else { success = target.acceptAuctionResult(0, 0, ""); } if ((auctionType & 2) == 2) AuctionFinalized(totalRevenue); else AuctionFinalized(bestBidValue); owner.send(this.balance); if (!success) { while (1 == 1) { _nbi = _nbi; } } return(true); } return(false); }
function initialize(address _t, uint256 _hsp, uint256 _hrp, uint256 _vssm, uint256 _tp) returns (bool) { if (msg.sender != owner) return false; if (phase == 1 || phase == 2) return false; phase = 1; target = adStorer(_t); hashSubmissionEnd = block.timestamp + _hsp; hashRevealEnd = block.timestamp + _hsp + _hrp; valueSubmissionSubsidyMillis = _vssm; nextBidIndex = 0; bestBidValue = 0; secondBestBidValue = 0; totalValueSubmitted = 0; auctionRevenue = 0; auctionType = _tp; mostRecentAuctionStart = block.number; AuctionInitialized(); return true; }
function commitBid(bytes32 bidValueHash, string metadata) returns (int256) { if (phase != 1) { msg.sender.send(msg.value); return (-1); } if (phase == 1 && block.timestamp >= hashSubmissionEnd) { msg.sender.send(msg.value); return (-1); } bids[nextBidIndex].bidValueHash = bidValueHash; bids[nextBidIndex].valueSubmitted = msg.value; bids[nextBidIndex].metadata = metadata; bids[nextBidIndex].bidder = msg.sender; BidCommitted(nextBidIndex, bidValueHash, metadata, msg.sender); nextBidIndex = nextBidIndex + 1; totalValueSubmitted += msg.value; return int256(nextBidIndex) - 1; }
function revealBid(uint256 index, uint256 bidValue, bytes32 nonce) returns (bool) { if (phase == 1 && block.timestamp >= hashRevealEnd) { phase = 2; } if (phase != 1) { return (false); } if (phase == 1 && block.timestamp < hashSubmissionEnd) { return (false); } if (index >= nextBidIndex) return false; if (bidValue > bids[index].valueSubmitted) return false; if (sha3(bidValue, nonce) != bids[index].bidValueHash) return false; if (bidValue > bestBidValue) { secondBestBidValue = bestBidValue; bestBidValue = bidValue; bestBidIndex = index; } else if (bidValue > secondBestBidValue) { secondBestBidValue = bidValue; } if (auctionType == 3 || auctionType == 4) { bids[index].bidValue = bidValue; auctionRevenue += bidValue; } BidRevealed(index, bidValue, bids[index].metadata, bids[index].bidder); return true; }
function ping() returns(bool) { if (phase == 1 && block.timestamp >= hashRevealEnd) phase = 2; if (phase != 2) return(false); uint _nbi = nextBidIndex; uint _ar; if (auctionType == 1) _ar = bestBidValue; else if (auctionType == 2) _ar = secondBestBidValue; else if (auctionType == 3) _ar = auctionRevenue; else if (auctionType == 4) _ar = auctionRevenue + secondBestBidValue - bestBidValue; while (msg.gas > 500000 && _nbi > 0) { _nbi -= 1; uint256 subsidy = bids[_nbi].valueSubmitted * _ar * valueSubmissionSubsidyMillis / totalValueSubmitted / 1000; if (_nbi == bestBidIndex) { if (auctionType == 1 || auctionType == 3) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - bestBidValue + subsidy); else if (auctionType == 2 || auctionType == 4) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - secondBestBidValue + subsidy); } else { if (auctionType == 1 || auctionType == 2) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted + subsidy); else bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - bids[_nbi].bidValue + subsidy); bids[_nbi].bidValueHash = 0; } } nextBidIndex = _nbi; if (_nbi == 0) { phase = 0; bool success; if (bestBidValue > 0) { AuctionWinner(bestBidIndex, bestBidValue, bids[bestBidIndex].metadata, bids[bestBidIndex].bidder); success = target.acceptAuctionResult(bids[bestBidIndex].bidder, bestBidValue, bids[bestBidIndex].metadata); } else { success = target.acceptAuctionResult(0, 0, ""); } AuctionFinalized(_ar); owner.send(this.balance); if (!success) { while (1 == 1) { _nbi = _nbi; } } return(true); } return(false); }
enum Commitment { Hidden(bytes32 hash), Revealed(uint value) }
function insert(Heap[T] storage _heap, T _value)
function length() constant returns (uint) { return back - front; }
function capacity() constant returns (uint) { return q.length - 1; }
function push(uint /*Value*/ data)
function pop() returns (uint /* Value */ r)
function Gavsino() { if (msg.value > 0) m_totalShares = msg.value / 1000000000000000; else m_totalShares = 1; m_shares[msg.sender] = m_totalShares; }
function bet(uint pIn256, hash key) { m_owing += msg.value; m_orders[key].amount = msg.value; m_orders[key].pIn256 = pIn256; m_orders[key].number = block.number; log1(0, key); }
function claim(hash bet) { hash key = sha3(bet); if (m_orders[key].amount > 0) { uint refund = (m_orders[key].amount * 1 / 200); uint w = winningsWithKey(key, bet) + refund; msg.sender.send(w); m_owing -= m_orders[key].amount; delete m_orders[key]; log1(0, key); } }
function insert(uint k, uint v) returns (uint size)
function sum() returns (uint s)
function append(data storage self, bytes32 _data) { var index = uint80(self.items.push(Item({prev: self.last, next: None, data: _data}))); if (self.last == None) { if (self.first != None || self.count != 0) throw; self.first = self.last = index; self.count = 1; } else { self.items[self.last - 1].next = index; self.last = index; self.count ++; } }
function remove(data storage self, uint80 _index) { Item item = self.items[_index - 1]; if (item.prev == None) self.first = item.next; if (item.next == None) self.last = item.prev; if (item.prev != None) self.items[item.prev - 1].next = item.next; if (item.next != None) self.items[item.next - 1].prev = item.prev; delete self.items[_index - 1]; self.count--; }
function find(data storage self, bytes32 _value) returns (uint80) { var it = iterate_start(self); while (iterate_valid(self, it)) { if (iterate_get(self, it) == _value) return it; it = iterate_next(self, it); } return it; }
function iterate_start(data storage self) returns (uint80) { return self.first; }
function modExp(uint x, uint k, uint m) returns (uint r) { r = 1; for (uint s = 1; s <= k; s *= 2) { if (k & s != 0) r = mulmod(r, x, m); x = mulmod(x, x, m); } }
function compare(string _a, string _b) returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; }
function equal(string _a, string _b) returns (bool) { return compare(_a, _b) == 0; }
function indexOf(string _haystack, string _needle) returns (int)
event onNewLoan(address indexed from, uint indexed lid);
function onAuctionEnd(string _name) internal;
function claimComputation(bytes _data, bytes32 _hash) { sessions.push(VerificationSession({ claimant: msg.sender, challenger: address(0), data: _data, hash: _hash, queries: new uint16[](0), values: new uint[4][](0) })); NewClaim(sessions.length - 1); }
function query(uint session, uint16 _i) onlyChallenger(session) { if (_i > 2048) throw; sessions[session].queries.push(_i); NewQuery(session); }
function respond(uint session, uint[4] _value) onlyClaimant(session) { var s = sessions[session]; if (s.values.length >= s.queries.length) throw; s.values.push(_value); NewResponse(session); }
function convict(uint session, uint q1, uint q2, uint q3) onlyChallenger(session) { var s = sessions[session]; var i = s.queries[q1]; if (s.queries[q2] != i + 1) throw; var input = s.values[q1]; var output = s.values[q2]; if (i < 1024) { if (!verifyFirstHalf(input, output)) Convicted(session); } else { var auxIndex = s.queries[q3]; if (auxIndex != (input[2] / 0x100000000000000000000000000000000000000000000000000000000) % 1024) throw; var auxInput = s.values[q3]; if (!verifySecondHalf(input, auxInput, output)) Convicted(session); } }
function convictInitial(uint session, uint q) onlyChallenger(session) { var s = sessions[session]; if (s.queries[q] != 0) throw; var v = s.values[q]; var h = KeyDeriv.pbkdf2(s.data, s.data, 128); if (uint(h[0]) != v[0] || uint(h[1]) != v[1] || uint(h[2]) != v[2] || uint(h[3]) != v[3]) Convicted(session); }
function convictFinal(uint session, uint q) onlyChallenger(session) { var s = sessions[session]; if (s.queries[q] != 2048) throw; var v = s.values[q]; bytes memory val = new bytes(128); for (uint i = 0; i < 128; i ++) val[i] = byte(uint8(v[i / 32] / 2**((32 - (i % 32)) * 8))); var h = KeyDeriv.pbkdf2(val, val, 32); if (h[0] != s.hash) Convicted(session); }
function verifyFirstHalf(uint[4] input, uint[4] output) constant returns (bool) { var (a, b, c, d) = Salsa8.round(input[0], input[1], input[2], input[3]); return (a == output[0] && b == output[1] && c == output[2] && d == output[3]); }
function verifySecondHalf(uint[4] input, uint[4] vinput, uint[4] output) constant returns (bool) { input[0] ^= vinput[0]; input[1] ^= vinput[1]; input[2] ^= vinput[2]; input[3] ^= vinput[3]; return verifyFirstHalf(input, output); }
function pbkdf2(bytes key, bytes salt, uint dklen) constant returns (bytes32[4] r) { var msg = new bytes(salt.length + 4); for (uint i = 0; i < salt.length; i++) msg[i] = salt[i]; for (i = 0; i * 32 < dklen; i++) { msg[msg.length - 1] = bytes1(uint8(i + 1)); r[i] = hmacsha256(key, msg); } }
event Confirmation(address owner, bytes32 operation);
event OwnerChanged(address oldOwner, address newOwner);
event RequirementChanged(uint newRequirement);
modifier onlyowner { require(isOwner(msg.sender)); _; }
modifier onlymanyowners(bytes32 _operation) { require(confirmAndCheck(_operation)); _; }
function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; }
function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } }
function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); }
function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); }
function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } }
modifier limitedDaily(uint _value) { require(underLimit(_value)); _; }
function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); }
function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; }
function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; }
function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; }
function today() private constant returns (uint) { return now / 1 days; }
event Deposit(address _from, uint value);
event SingleTransact(address owner, uint value, address to, bytes data);
event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
function changeOwner(address _from, address _to) external;
function Wallet(address[] _owners, uint _required, uint _daylimit)
function kill(address _to) onlymanyowners(sha3(msg.data)) external { selfdestruct(_to); }
function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); }
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); require(_to.call.value(_value)(_data)); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } }
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { require(m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } }
function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint128[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) sum := add(term,sum) } } }
function getMax(uint128[] storage self) public view returns(uint128 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint128[] storage self) public view returns(uint128 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint128[] storage self, uint128 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint128[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint128 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint128[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint16[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) sum := add(term,sum) } } }
function getMax(uint16[] storage self) public view returns(uint16 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint16[] storage self) public view returns(uint16 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint16[] storage self, uint16 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint16[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint16 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint16[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint32[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) sum := add(term,sum) } } }
function getMax(uint32[] storage self) public view returns(uint32 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint32[] storage self) public view returns(uint32 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint32[] storage self, uint32 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint32[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint32 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint32[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint64[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) sum := add(term,sum) } } }
function getMax(uint64[] storage self) public view returns(uint64 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint64[] storage self) public view returns(uint64 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint64[] storage self, uint64 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint64[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint64 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint64[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint8[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) sum := add(term,sum) } } }
function getMax(uint8[] storage self) public view returns(uint8 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint8[] storage self) public view returns(uint8 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint8[] storage self, uint8 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint8[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint8 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint8[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount)
function () payable public { sendPurchase(); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount) returns (bool) { require(msg.sender != self.base.owner); require(self.base.validPurchase()); require((self.base.ownerBalance + _amount) <= self.base.capAmount); if ((self.changeInterval > 0) && (now >= (self.lastPriceChangeTime + self.changeInterval))) { self.lastPriceChangeTime = self.lastPriceChangeTime + self.changeInterval; uint256 index = (now-self.base.startTime)/self.changeInterval; if (self.tokenPricePoints.length <= index) index = self.tokenPricePoints.length - 1; self.base.changeTokenPrice(self.tokenPricePoints[index]); LogTokenPriceChange(self.base.tokensPerEth,"Token Price has changed!"); } number of tokens that will be purchased bool err; the new balance of the owner of the crowdsale temp calc holder for calculating token wei change for purchaser temp calc holder (err,weiTokens) = _amount.times(self.base.tokensPerEth); require(!err); if(self.base.tokenDecimals <= 18){ zeros = 10**(18-uint256(self.base.tokenDecimals)); numTokens = weiTokens/zeros; leftoverWei = weiTokens % zeros; self.base.leftoverWei[msg.sender] += leftoverWei; } else { zeros = 10**(uint256(self.base.tokenDecimals)-18); numTokens = weiTokens*zeros; } self.base.hasContributed[msg.sender] += _amount - leftoverWei; require(numTokens <= self.base.token.balanceOf(this)); (err,newBalance) = self.base.ownerBalance.plus(_amount-leftoverWei); require(!err);  "deposit" the amount self.base.withdrawTokensMap[msg.sender] += numTokens; (err,remainder) = self.base.withdrawTokensMap[self.base.owner].minus(numTokens); self.base.withdrawTokensMap[self.base.owner] = remainder; LogTokensBought(msg.sender, numTokens); return true; }
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegError(address user, string Msg);
event LogAddressTokenCapChange(uint256 amount, string Msg);
event LogAddressTokenCapCalculated(uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function calculateAddressTokenCap(EvenDistroCrowdsaleStorage storage self)
function getMin(uint256 a, uint256 b) internal pure returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegError(address user, string Msg);
event LogAddressTokenCapChange(uint256 amount, string Msg);
event LogAddressTokenCapCalculated(uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function calculateAddressTokenCap(EvenDistroCrowdsaleStorage storage self)
function getMin(uint256 a, uint256 b) internal pure returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount)
function () payable { sendPurchase(); }
function () payable { sendPurchase(); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
event LogTokensBought(address indexed buyer, uint256 amount);
event LogAddressCapExceeded(address indexed buyer, uint256 amount, string Msg);
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogErrorMsg(string Msg);
event LogAddressCapChange(uint256 amount, string Msg);
event LogAddressCapCalculated(uint256 saleCap, uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant) returns (bool) { require(msg.sender == self.base.owner); if ((self.changeInterval > 0) && (now >= self.base.startTime - 3 days)) { LogErrorMsg("Can only register users earlier than 3 days before the sale!"); return false; } if(self.isRegistered[_registrant]) { LogErrorMsg("Registrant address is already registered for the sale!"); return false; } uint256 result; bool err; self.isRegistered[_registrant] = true; (err,result) = self.numRegistered.plus(1); require(!err); self.numRegistered = result; LogUserRegistered(_registrant); return true; }
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants) returns (bool) { require(msg.sender == self.base.owner); if (self.changeInterval > 0) { require(now < self.base.startTime - 3 days); } bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = registerUser(self,_registrants[i]); } }
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant) returns (bool) { require(msg.sender == self.base.owner); if ((self.changeInterval > 0) && (now >= self.base.startTime - 3 days)) { LogErrorMsg("Can only register and unregister users earlier than 3 days before the sale!"); return false; } if(!self.isRegistered[_registrant]) { LogErrorMsg("Registrant address not registered for the sale!"); return false; } uint256 result; bool err; self.isRegistered[_registrant] = false; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants) returns (bool) { require(msg.sender == self.base.owner); if (self.changeInterval > 0) { require(now < self.base.startTime - 3 days); } bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } }
function calculateAddressCap(EvenDistroCrowdsaleStorage storage self) internal returns (bool) { require(self.numRegistered > 0); if ((now > self.base.startTime) || (now < (self.base.startTime - 3 days)) || (self.changeInterval == 0))  { return false; }  makes sure this can only be called once uint256 result; bool err; (err,result) = self.base.capAmount.dividedBy(self.numRegistered); require(!err); self.addressCap = result; LogAddressCapCalculated(self.base.capAmount,self.numRegistered,result,"Address cap was Calculated!"); }
function getMin(uint256 a, uint256 b) internal constant returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount) returns (bool) { require(msg.sender != self.base.owner); require(self.isRegistered[msg.sender]); require(self.base.validPurchase()); require((self.base.ownerBalance + _amount) <= self.base.capAmount); require((self.base.hasContributed[msg.sender]) < self.addressCap); bool err; uint256 result; if ((self.changeInterval > 0) && (now >= (self.lastCapChangeTime + self.changeInterval))) { uint256 numIntervals = (((now-(now%self.changeInterval))-self.lastCapChangeTime)/self.changeInterval); (err,result) = self.addressCap.times(self.capPercentMultiplier ** (numIntervals)); require(!err); (err,result) = result.dividedBy(100**numIntervals); require(!err); self.addressCap = result; self.lastCapChangeTime = self.lastCapChangeTime + (self.changeInterval*numIntervals); LogAddressCapChange(result, "Address cap has increased!"); } number of tokens that will be purchased for calculating token wei change for purchaser if they went over the address cap temp calc holder for division remainder for leftover wei and then later for tokens remaining for the owner  tells how much more the buyer can contribute up to their cap (err,allowedWei) = self.addressCap.minus(self.base.hasContributed[msg.sender]); require(!err); allowedWei = getMin(_amount,allowedWei); leftoverWei = _amount - allowedWei; (err,result) = allowedWei.times(self.base.tokensPerEth); require(!err); if(self.base.tokenDecimals <= 18){ zeros = 10**(18-uint256(self.base.tokenDecimals)); numTokens = result/zeros; remainder = result % zeros; } else { zeros = 10**(uint256(self.base.tokenDecimals)-18); numTokens = result*zeros; } self.base.leftoverWei[msg.sender] += leftoverWei+remainder; if(((self.base.hasContributed[msg.sender] + _amount)) > self.addressCap) { LogAddressCapExceeded(msg.sender,self.base.leftoverWei[msg.sender],"Cap Per Address has been exceeded! Please withdraw leftover Wei!"); } self.base.hasContributed[msg.sender] += allowedWei - remainder; require(numTokens <= self.base.token.balanceOf(this)); self.base.ownerBalance = self.base.ownerBalance + (allowedWei - remainder); self.base.withdrawTokensMap[msg.sender] += numTokens; (err,remainder) = self.base.withdrawTokensMap[self.base.owner].minus(numTokens); require(!err); self.base.withdrawTokensMap[self.base.owner] = remainder; LogTokensBought(msg.sender, numTokens); return true; }
event LogBidAccepted(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidWithdrawn(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidRemoved(address indexed bidder, uint256 personalValuation);
event LogErrorMsg(uint256 amount, string Msg);
event LogTokenPriceChange(uint256 amount, string Msg);
event BucketAndValuationAndCommitted(uint256 bucket, uint256 valuation, uint256 committed);
function init(InteractiveCrowdsaleStorage storage self,
function numDigits(uint256 _number) public pure returns (uint256) { uint256 _digits = 0; while (_number != 0) { _number /= 10; _digits++; } return _digits; }
function calculateTokenPurchase(uint256 _amount,
function getCurrentBonus(InteractiveCrowdsaleStorage storage self) internal view returns (uint256){ uint256 bonusTime = self.endWithdrawalTime - self.base.startTime; uint256 elapsed = now - self.base.startTime; uint256 percentElapsed = (elapsed * 100)/bonusTime; bool err; uint256 currentBonus; (err,currentBonus) = self.priceBonusPercent.minus(((percentElapsed * self.priceBonusPercent)/100)); require(!err); return currentBonus; }
function submitBid(InteractiveCrowdsaleStorage storage self,
function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(self.personalCaps[msg.sender] > 0); uint256 refundWei; if (now >= self.endWithdrawalTime) { require(self.personalCaps[msg.sender] < self.totalValuation); refundWei = self.base.hasContributed[msg.sender]; } else {  manual withdrawals are only allowed once /*********************************************************************** The following lines were commented out due to stack depth, but they represent the variables and calculations from the paper. The actual code is the same thing spelled out using current variables.  See section 4 of the white paper for formula used ************************************************************************/ uint256 multiplierPercent = (100 * (self.endWithdrawalTime - now)) / (self.endWithdrawalTime - self.base.startTime); refundWei = (multiplierPercent * self.base.hasContributed[msg.sender]) / 100; self.valuationSums[self.personalCaps[msg.sender]] -= refundWei; self.numBidsAtValuation[self.personalCaps[msg.sender]] -= 1; self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender] - ((self.pricePurchasedAt[msg.sender] - self.base.tokensPerEth) / 3); self.hasManuallyWithdrawn[msg.sender] = true; } self.base.leftoverWei[msg.sender] += refundWei; self.base.hasContributed[msg.sender] -= refundWei; uint256 _proposedCommit; uint256 _proposedValue; uint256 _currentBucket; bool loop; bool exists; if(self.personalCaps[msg.sender] >= self.totalValuation){ _proposedCommit = self.valueCommitted - refundWei; if(_proposedCommit <= self.currentBucket){ if(self.totalValuation > self.currentBucket){ _proposedCommit += self.valuationSums[self.currentBucket]; } if(_proposedCommit >= self.currentBucket){ _proposedValue = self.currentBucket; } else { loop = true; } } else { if(self.totalValuation == self.currentBucket){ _proposedValue = self.totalValuation; } else { _proposedValue = _proposedCommit; } } if(loop){ (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV); while(_proposedCommit <= _currentBucket){ _proposedCommit += self.valuationSums[_currentBucket]; if(_proposedCommit >= _currentBucket){ _proposedValue = _currentBucket; } else { (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV); } } if(_proposedValue == 0) { _proposedValue = _proposedCommit; } self.currentBucket = _currentBucket; } self.totalValuation = _proposedValue; self.valueCommitted = _proposedCommit; } LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]); BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted); return true; }
function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now >= self.base.endTime);  can only be called once require(setCanceled(self)); self.isFinalized = true; require(launchToken(self)); uint256 computedValue; if(!self.isCanceled){ if(self.totalValuation == self.currentBucket){ self.q = (100*(self.valueCommitted - self.totalValuation)/(self.valuationSums[self.totalValuation])) + 1; computedValue = self.valueCommitted - self.valuationSums[self.totalValuation]; computedValue += (self.q * self.valuationSums[self.totalValuation])/100; } else { computedValue = self.totalValuation; }  sets ETH raised in the sale to be ready for withdrawal } }
function launchToken(InteractiveCrowdsaleStorage storage self) internal returns (bool) { uint256 _fullValue = (self.totalValuation*100)/uint256(self.percentBeingSold); uint256 _bonusValue = ((self.totalValuation * (100 + self.priceBonusPercent))/100) - self.totalValuation; uint256 _supply = (_fullValue * self.base.tokensPerEth)/1000000000000000000; uint256 _bonusTokens = (_bonusValue * self.base.tokensPerEth)/1000000000000000000; uint256 _ownerTokens = _supply - ((_supply * uint256(self.percentBeingSold))/100); uint256 _totalSupply = _supply + _bonusTokens; self.base.token = new CrowdsaleToken(address(this), self.tokenInfo.name, self.tokenInfo.symbol, self.tokenInfo.decimals, _totalSupply, self.tokenInfo.stillMinting); if(!self.isCanceled){ self.base.token.transfer(self.base.owner, _ownerTokens); } else { self.base.token.transfer(self.base.owner, _supply); self.base.token.burnToken(_bonusTokens); } self.base.token.changeOwner(self.base.owner); self.base.startingTokenBalance = _supply - _ownerTokens; return true; }
function setCanceled(InteractiveCrowdsaleStorage storage self) internal returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.base.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return true; }
function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now > self.base.endTime); require(self.personalCaps[msg.sender] > 0); uint256 numTokens; uint256 remainder; if(!self.isFinalized){ require(setCanceled(self)); require(self.isCanceled); } if (self.isCanceled) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; LogErrorMsg(self.totalValuation, "Sale is canceled, all bids have been refunded!"); return true; } if (self.personalCaps[msg.sender] < self.totalValuation) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; return self.base.withdrawLeftoverWei(); } else if (self.personalCaps[msg.sender] == self.totalValuation) { uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100; self.base.leftoverWei[msg.sender] += refundAmount; self.base.hasContributed[msg.sender] -= refundAmount; } LogErrorMsg(self.base.hasContributed[msg.sender],"contribution"); LogErrorMsg(self.pricePurchasedAt[msg.sender],"price"); LogErrorMsg(self.q,"percentage"); (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], self.pricePurchasedAt[msg.sender]); self.base.withdrawTokensMap[msg.sender] += numTokens; self.valueCommitted = self.valueCommitted - remainder; self.base.leftoverWei[msg.sender] += remainder; uint256 _fullBonus; uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100; (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice); uint256 _leftoverBonus = _fullBonus - numTokens; self.base.token.burnToken(_leftoverBonus); self.base.hasContributed[msg.sender] = 0; self.base.withdrawTokens(); self.base.withdrawLeftoverWei(); }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
event LogBidAccepted(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidWithdrawn(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidRemoved(address indexed bidder, uint256 personalValuation);
event LogErrorMsg(uint256 amount, string Msg);
event LogTokenPriceChange(uint256 amount, string Msg);
event BucketAndValuationAndCommitted(uint256 bucket, uint256 valuation, uint256 committed);
function init(InteractiveCrowdsaleStorage storage self,
function numDigits(uint256 _number) public pure returns (uint256) { uint256 _digits = 0; while (_number != 0) { _number /= 10; _digits++; } return _digits; }
function calculateTokenPurchase(uint256 _amount,
function getCurrentBonus(InteractiveCrowdsaleStorage storage self) internal view returns (uint256){ uint256 bonusTime = self.endWithdrawalTime - self.base.startTime; uint256 elapsed = now - self.base.startTime; uint256 percentElapsed = (elapsed * 100)/bonusTime; bool err; uint256 currentBonus; (err,currentBonus) = self.priceBonusPercent.minus(((percentElapsed * self.priceBonusPercent)/100)); require(!err); return currentBonus; }
function submitBid(InteractiveCrowdsaleStorage storage self,
function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(self.personalCaps[msg.sender] > 0); uint256 refundWei; if (now >= self.endWithdrawalTime) { require(self.personalCaps[msg.sender] < self.totalValuation); refundWei = self.base.hasContributed[msg.sender]; } else {  manual withdrawals are only allowed once /*********************************************************************** The following lines were commented out due to stack depth, but they represent the variables and calculations from the paper. The actual code is the same thing spelled out using current variables.  See section 4 of the white paper for formula used ************************************************************************/ uint256 multiplierPercent = (100 * (self.endWithdrawalTime - now)) / (self.endWithdrawalTime - self.base.startTime); refundWei = (multiplierPercent * self.base.hasContributed[msg.sender]) / 100; self.valuationSums[self.personalCaps[msg.sender]] -= refundWei; self.numBidsAtValuation[self.personalCaps[msg.sender]] -= 1; self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender] - ((self.pricePurchasedAt[msg.sender] - self.base.tokensPerEth) / 3); self.hasManuallyWithdrawn[msg.sender] = true; } self.base.leftoverWei[msg.sender] += refundWei; self.base.hasContributed[msg.sender] -= refundWei; uint256 _proposedCommit; uint256 _proposedValue; uint256 _currentBucket; bool loop; bool exists; if(self.personalCaps[msg.sender] >= self.totalValuation){ _proposedCommit = self.valueCommitted - refundWei; if(_proposedCommit <= self.currentBucket){ if(self.totalValuation > self.currentBucket){ _proposedCommit += self.valuationSums[self.currentBucket]; } if(_proposedCommit >= self.currentBucket){ _proposedValue = self.currentBucket; } else { loop = true; } } else { if(self.totalValuation == self.currentBucket){ _proposedValue = self.totalValuation; } else { _proposedValue = _proposedCommit; } } if(loop){ (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV); while(_proposedCommit <= _currentBucket){ _proposedCommit += self.valuationSums[_currentBucket]; if(_proposedCommit >= _currentBucket){ _proposedValue = _currentBucket; } else { (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV); } } if(_proposedValue == 0) { _proposedValue = _proposedCommit; } self.currentBucket = _currentBucket; } self.totalValuation = _proposedValue; self.valueCommitted = _proposedCommit; } LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]); BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted); return true; }
function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now >= self.base.endTime);  can only be called once require(setCanceled(self)); self.isFinalized = true; require(launchToken(self)); uint256 computedValue; if(!self.isCanceled){ if(self.totalValuation == self.currentBucket){ self.q = (100*(self.valueCommitted - self.totalValuation)/(self.valuationSums[self.totalValuation])) + 1; computedValue = self.valueCommitted - self.valuationSums[self.totalValuation]; computedValue += (self.q * self.valuationSums[self.totalValuation])/100; } else { computedValue = self.totalValuation; }  sets ETH raised in the sale to be ready for withdrawal } }
function launchToken(InteractiveCrowdsaleStorage storage self) internal returns (bool) { uint256 _fullValue = (self.totalValuation*100)/uint256(self.percentBeingSold); uint256 _bonusValue = ((self.totalValuation * (100 + self.priceBonusPercent))/100) - self.totalValuation; uint256 _supply = (_fullValue * self.base.tokensPerEth)/1000000000000000000; uint256 _bonusTokens = (_bonusValue * self.base.tokensPerEth)/1000000000000000000; uint256 _ownerTokens = _supply - ((_supply * uint256(self.percentBeingSold))/100); uint256 _totalSupply = _supply + _bonusTokens; self.base.token = new CrowdsaleToken(address(this), self.tokenInfo.name, self.tokenInfo.symbol, self.tokenInfo.decimals, _totalSupply, self.tokenInfo.stillMinting); if(!self.isCanceled){ self.base.token.transfer(self.base.owner, _ownerTokens); } else { self.base.token.transfer(self.base.owner, _supply); self.base.token.burnToken(_bonusTokens); } self.base.token.changeOwner(self.base.owner); self.base.startingTokenBalance = _supply - _ownerTokens; return true; }
function setCanceled(InteractiveCrowdsaleStorage storage self) internal returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.base.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return true; }
function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now > self.base.endTime); require(self.personalCaps[msg.sender] > 0); uint256 numTokens; uint256 remainder; if(!self.isFinalized){ require(setCanceled(self)); require(self.isCanceled); } if (self.isCanceled) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; LogErrorMsg(self.totalValuation, "Sale is canceled, all bids have been refunded!"); return true; } if (self.personalCaps[msg.sender] < self.totalValuation) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; return self.base.withdrawLeftoverWei(); } else if (self.personalCaps[msg.sender] == self.totalValuation) { uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100; self.base.leftoverWei[msg.sender] += refundAmount; self.base.hasContributed[msg.sender] -= refundAmount; } LogErrorMsg(self.base.hasContributed[msg.sender],"contribution"); LogErrorMsg(self.pricePurchasedAt[msg.sender],"price"); LogErrorMsg(self.q,"percentage"); (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], self.pricePurchasedAt[msg.sender]); self.base.withdrawTokensMap[msg.sender] += numTokens; self.valueCommitted = self.valueCommitted - remainder; self.base.leftoverWei[msg.sender] += remainder; uint256 _fullBonus; uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100; (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice); uint256 _leftoverBonus = _fullBonus - numTokens; self.base.token.burnToken(_leftoverBonus); self.base.hasContributed[msg.sender] = 0; self.base.withdrawTokens(); self.base.withdrawLeftoverWei(); }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function nodeExists(uint256 _node) view public returns (bool) { return list.nodeExists(_node); }
function sizeOf() view public returns (uint256 numElements) { return list.sizeOf(); }
function getNode(uint256 _node)
function getAdjacent(uint256 _node, bool _direction)
function getSortedSpot(uint256 _node, uint256 _value, bool _direction)
function insert(uint256 _node, uint256 _new, bool _direction) public { list.insert(_node,_new,_direction); }
function remove(uint256 _node) public returns (uint256) { return list.remove(_node); }
function push(uint256 _node, bool _direction) public { list.push(_node,_direction); }
function pop(bool _direction) public returns (uint256) { return list.pop(_direction); }
function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); }
function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; }
function toSliceB32(bytes32 self) internal returns (slice ret) { assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); }
function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); }
function toString(slice self) internal view returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; }
function len(slice self) internal view returns (uint) { var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; }
function empty(slice self) internal view returns (bool) { return self._len == 0; }
function compare(slice self, slice other) internal view returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); }
function equals(slice self, slice other) internal view returns (bool) { return compare(self, other) == 0; }
function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; }
function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); }
function ord(slice self) internal view returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; }
function keccak(slice self) internal view returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } }
function startsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; }
function endsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; }
function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; }
function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; }
function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; }
function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); }
function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { self._len = 0; } else { self._len -= token._len + needle._len; } return token; }
function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); }
function count(slice self, slice needle) internal view returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } }
function contains(slice self, slice needle) internal view returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; }
function concat(slice self, slice other) internal view returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; }
function join(slice self, slice[] parts) internal view returns (string) { if (parts.length == 0) return ""; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; }
function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); }
function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; }
function toSliceB32(bytes32 self) internal returns (slice ret) { assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); }
function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); }
function toString(slice self) internal view returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; }
function len(slice self) internal view returns (uint) { var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; }
function empty(slice self) internal view returns (bool) { return self._len == 0; }
function compare(slice self, slice other) internal view returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { uint256 mask = uint256(-1); if(shortest < 32) { mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); } var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); }
function equals(slice self, slice other) internal view returns (bool) { return compare(self, other) == 0; }
function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; }
function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); }
function ord(slice self) internal view returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; }
function keccak(slice self) internal view returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } }
function startsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; }
function endsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; }
function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; }
function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; }
function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; }
function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); }
function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { self._len = 0; } else { self._len -= token._len + needle._len; } return token; }
function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); }
function count(slice self, slice needle) internal view returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } }
function contains(slice self, slice needle) internal view returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; }
function concat(slice self, slice other) internal view returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; }
function join(slice self, slice[] parts) internal view returns (string) { if (parts.length == 0) return ""; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function() public  { data = msg.data; }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool) { bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool) { self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) { return self.allowed[_owner][_spender]; }
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function init(VestingStorage storage self,
function initializeETHBalance(VestingStorage storage self, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(!self.isToken); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function initializeTokenBalance(VestingStorage storage self, CrowdsaleToken token, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(self.isToken); require(token.balanceOf(this) == _balance); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function registerUser(VestingStorage storage self,
function registerUsers(VestingStorage storage self,
function unregisterUser(VestingStorage storage self, address _registrant) public returns (bool) { require((msg.sender == self.owner) || (msg.sender == address(this))); if (now >= self.startTime) { LogErrorMsg(self.startTime, "Can only register and unregister users before the vesting starts!"); return false; } uint256 _totalHolding; uint256 result; bool err; _totalHolding = self.holdingAmount[_registrant][0] + self.holdingAmount[_registrant][1]; if(_totalHolding == 0) { LogErrorMsg(0, "Registrant address not registered for the vesting!"); return false; } self.holdingAmount[_registrant][0] = 0; self.holdingAmount[_registrant][1] = 0; self.contractBalance += _totalHolding; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(VestingStorage storage self, address[] _registrants) public returns (bool) { require(msg.sender == self.owner); bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } return ok; }
function swapRegistration(VestingStorage storage self, address _replacementRegistrant) public returns (bool) { require(_replacementRegistrant != 0); require(self.holdingAmount[_replacementRegistrant][0] == 0); uint256 _vestAmount = self.holdingAmount[msg.sender][0]; uint256 _bonus = self.holdingAmount[msg.sender][1]; uint256 _withdrawnAmount = self.hasWithdrawn[msg.sender]; require(_vestAmount > 0); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; self.hasWithdrawn[msg.sender] = 0; self.holdingAmount[_replacementRegistrant][0] = _vestAmount; self.holdingAmount[_replacementRegistrant][1] = _bonus; self.hasWithdrawn[_replacementRegistrant] = _withdrawnAmount; LogRegistrationReplaced(msg.sender, _replacementRegistrant, self.hasWithdrawn[_replacementRegistrant]); return true; }
function calculateWithdrawal(VestingStorage storage self, address _beneficiary) internal view returns (uint256) { require(_beneficiary != 0); require(self.holdingAmount[_beneficiary][0] > 0); require(self.numRegistered > 0); bool err; uint256 _numIntervals = (now-self.startTime)/self.timeInterval; uint256 _amountReleased = ((_numIntervals*self.percentPerInterval)*self.holdingAmount[_beneficiary][0])/100; (err, _amountReleased) = _amountReleased.minus(self.hasWithdrawn[_beneficiary]); return _amountReleased; }
function withdrawETH(VestingStorage storage self) public returns (bool) { require(now > self.startTime); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; msg.sender.transfer(_withdrawAmount); LogETHWithdrawn(msg.sender,_withdrawAmount); return true; }
function withdrawTokens(VestingStorage storage self,CrowdsaleToken token) public returns (bool) { require(now > self.startTime); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); require(ok); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; ok = token.transfer(msg.sender, _withdrawAmount); require(ok); LogTokensWithdrawn(msg.sender,_withdrawAmount); return true; }
function sendETH(VestingStorage storage self, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[_beneficiary][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; _beneficiary.transfer(_withdrawAmount); LogETHWithdrawn(_beneficiary,_withdrawAmount); return true; }
function sendTokens(VestingStorage storage self,CrowdsaleToken token, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; ok = token.transfer(_beneficiary, _withdrawAmount); require(ok); LogTokensWithdrawn(_beneficiary,_withdrawAmount); return true; }
function ownerWithdrawExtraETH(VestingStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(!self.isToken); uint256 _contractBalance = this.balance; self.contractBalance = 0; self.owner.transfer(_contractBalance); LogETHWithdrawn(self.owner,_contractBalance); return true; }
function ownerWithdrawExtraTokens(VestingStorage storage self, CrowdsaleToken token) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(self.isToken); uint256 _contractBalance = token.balanceOf(this); self.contractBalance = 0; token.transfer(self.owner,_contractBalance); LogTokensWithdrawn(self.owner,_contractBalance); return true; }
function getPercentReleased(VestingStorage storage self) public view returns (uint256) { require(now > self.startTime); return self.percentPerInterval * ((now-self.startTime)/self.timeInterval); }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function init(VestingStorage storage self,
function initializeETHBalance(VestingStorage storage self, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(!self.isToken); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function initializeTokenBalance(VestingStorage storage self, CrowdsaleToken token, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(self.isToken); require(token.balanceOf(this) == _balance); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function registerUser(VestingStorage storage self,
function registerUsers(VestingStorage storage self,
function unregisterUser(VestingStorage storage self, address _registrant) public returns (bool) { require((msg.sender == self.owner) || (msg.sender == address(this))); if (now >= self.startTime) { LogErrorMsg(self.startTime, "Can only register and unregister users before the vesting starts!"); return false; } uint256 _totalHolding; uint256 result; bool err; _totalHolding = self.holdingAmount[_registrant][0] + self.holdingAmount[_registrant][1]; if(_totalHolding == 0) { LogErrorMsg(0, "Registrant address not registered for the vesting!"); return false; } self.holdingAmount[_registrant][0] = 0; self.holdingAmount[_registrant][1] = 0; self.contractBalance += _totalHolding; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(VestingStorage storage self, address[] _registrants) public returns (bool) { require(msg.sender == self.owner); bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } return ok; }
function swapRegistration(VestingStorage storage self, address _replacementRegistrant) public returns (bool) { require(_replacementRegistrant != 0); require(self.holdingAmount[_replacementRegistrant][0] == 0); uint256 _vestAmount = self.holdingAmount[msg.sender][0]; uint256 _bonus = self.holdingAmount[msg.sender][1]; uint256 _withdrawnAmount = self.hasWithdrawn[msg.sender]; require(_vestAmount > 0); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; self.hasWithdrawn[msg.sender] = 0; self.holdingAmount[_replacementRegistrant][0] = _vestAmount; self.holdingAmount[_replacementRegistrant][1] = _bonus; self.hasWithdrawn[_replacementRegistrant] = _withdrawnAmount; LogRegistrationReplaced(msg.sender, _replacementRegistrant, self.hasWithdrawn[_replacementRegistrant]); return true; }
function calculateWithdrawal(VestingStorage storage self, address _beneficiary) internal view returns (uint256) { require(_beneficiary != 0); require(self.holdingAmount[_beneficiary][0] > 0); require(self.numRegistered > 0); bool err; uint256 _numIntervals = (now-self.startTime)/self.timeInterval; uint256 _amountReleased = ((_numIntervals*self.percentPerInterval)*self.holdingAmount[_beneficiary][0])/100000; (err, _amountReleased) = _amountReleased.minus(self.hasWithdrawn[_beneficiary]); return _amountReleased; }
function withdrawETH(VestingStorage storage self) public returns (bool) { require(now > self.startTime); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; msg.sender.transfer(_withdrawAmount); LogETHWithdrawn(msg.sender,_withdrawAmount); return true; }
function withdrawTokens(VestingStorage storage self,CrowdsaleToken token) public returns (bool) { require(now > self.startTime); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); require(ok); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; ok = token.transfer(msg.sender, _withdrawAmount); require(ok); LogTokensWithdrawn(msg.sender,_withdrawAmount); return true; }
function sendETH(VestingStorage storage self, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[_beneficiary][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; _beneficiary.transfer(_withdrawAmount); LogETHWithdrawn(_beneficiary,_withdrawAmount); return true; }
function sendTokens(VestingStorage storage self,CrowdsaleToken token, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; ok = token.transfer(_beneficiary, _withdrawAmount); require(ok); LogTokensWithdrawn(_beneficiary,_withdrawAmount); return true; }
function ownerWithdrawExtraETH(VestingStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(!self.isToken); uint256 _contractBalance = this.balance; self.contractBalance = 0; self.owner.transfer(_contractBalance); LogETHWithdrawn(self.owner,_contractBalance); return true; }
function ownerWithdrawExtraTokens(VestingStorage storage self, CrowdsaleToken token) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(self.isToken); uint256 _contractBalance = token.balanceOf(this); self.contractBalance = 0; token.transfer(self.owner,_contractBalance); LogTokensWithdrawn(self.owner,_contractBalance); return true; }
function getPercentReleased(VestingStorage storage self) public view returns (uint256) { require(now > self.startTime); return (self.percentPerInterval * ((now-self.startTime)/self.timeInterval))/1000; }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function checkChangeOwnerArgs(uint256 _from, uint256 _to)
function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max)
function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min)
function checkRequiredChange(uint256 _newRequired, uint256 _length)
function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) { return _required - _count; }
function changeOwner(WalletMainLib.WalletData storage self,
function addOwner(WalletMainLib.WalletData storage self,
function removeOwner(WalletMainLib.WalletData storage self,
function changeRequiredAdmin(WalletMainLib.WalletData storage self,
function changeRequiredMajor(WalletMainLib.WalletData storage self,
function changeRequiredMinor(WalletMainLib.WalletData storage self,
function changeMajorThreshold(WalletMainLib.WalletData storage self,
function getOwners(WalletMainLib.WalletData storage self) public view returns (address[51]) { address[51] memory o; for(uint256 i = 0; i<self.owners.length; i++){ o[i] = self.owners[i]; } return o; }
function getOwnerIndex(WalletMainLib.WalletData storage self, address _owner) public view returns (uint256) { return self.ownerIndex[_owner]; }
function getMaxOwners(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.maxOwners; }
function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; }
function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; }
function getRequiredMinor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMinor; }
function getRequiredMajor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMajor; }
function getCurrentSpend(WalletMainLib.WalletData storage self, address _token) public view returns (uint256[2]) { uint256[2] memory cs; cs[0] = self.currentSpend[_token][0]; cs[1] = self.currentSpend[_token][1]; return cs; }
function getMajorThreshold(WalletMainLib.WalletData storage self, address _token) public view returns (uint256) { return self.majorThreshold[_token]; }
function getTransactionLength(WalletMainLib.WalletData storage self, bytes32 _id) public view returns (uint256) { return self.transactionInfo[_id].length; }
function getTransactionConfirms(WalletMainLib.WalletData storage self,
function getTransactionConfirmCount(WalletMainLib.WalletData storage self,
function getTransactionSuccess(WalletMainLib.WalletData storage self,
function init(WalletData storage self,
function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)
function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){ return _required - _count; }
function getAmount(bytes _txData) public pure returns (bool,uint256) { bytes32 getSig; bytes4 sig; transfer func signature approve func signature transferFrom func signature bool transfer; bytes32 _amountData; uint256 _amount; assembly { getSig := mload(add(_txData,0x20)) } sig = bytes4(getSig); if(sig ==  tSig || sig == aSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x44)) } _amount = uint256(_amountData); } else if(sig == tfSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x64)) } _amount = uint256(_amountData); } return (transfer,_amount); }
function getRequired(WalletData storage self,
function createContract(bytes _txData, uint256 _value) public { address _newContract; bool allGood; assembly { _newContract := create(_value, add(_txData, 0x20), mload(_txData)) allGood := gt(extcodesize(_newContract),0) } require(allGood); LogContractCreated(_newContract, _value); }
function serveTx(WalletData storage self,
function confirmTx(WalletData storage self, bytes32 _id)
function revokeConfirm(WalletData storage self, bytes32 _id)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function checkChangeOwnerArgs(uint256 _from, uint256 _to)
function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max)
function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min)
function checkRequiredChange(uint256 _newRequired, uint256 _length)
function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) { return _required - _count; }
function changeOwner(WalletMainLib.WalletData storage self,
function addOwner(WalletMainLib.WalletData storage self,
function removeOwner(WalletMainLib.WalletData storage self,
function changeRequiredAdmin(WalletMainLib.WalletData storage self,
function changeRequiredMajor(WalletMainLib.WalletData storage self,
function changeRequiredMinor(WalletMainLib.WalletData storage self,
function changeMajorThreshold(WalletMainLib.WalletData storage self,
function getOwners(WalletMainLib.WalletData storage self) public view returns (address[51]) { address[51] memory o; for(uint256 i = 0; i<self.owners.length; i++){ o[i] = self.owners[i]; } return o; }
function getOwnerIndex(WalletMainLib.WalletData storage self, address _owner) public view returns (uint256) { return self.ownerIndex[_owner]; }
function getMaxOwners(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.maxOwners; }
function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; }
function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; }
function getRequiredMinor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMinor; }
function getRequiredMajor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMajor; }
function getCurrentSpend(WalletMainLib.WalletData storage self, address _token) public view returns (uint256[2]) { uint256[2] memory cs; cs[0] = self.currentSpend[_token][0]; cs[1] = self.currentSpend[_token][1]; return cs; }
function getMajorThreshold(WalletMainLib.WalletData storage self, address _token) public view returns (uint256) { return self.majorThreshold[_token]; }
function getTransactionLength(WalletMainLib.WalletData storage self, bytes32 _id) public view returns (uint256) { return self.transactionInfo[_id].length; }
function getTransactionConfirms(WalletMainLib.WalletData storage self,
function getTransactionConfirmCount(WalletMainLib.WalletData storage self,
function getTransactionSuccess(WalletMainLib.WalletData storage self,
function init(WalletData storage self,
function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)
function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){ return _required - _count; }
function getAmount(bytes _txData) public pure returns (bool,uint256) { bytes32 getSig; bytes4 sig; transfer func signature approve func signature transferFrom func signature bool transfer; bytes32 _amountData; uint256 _amount; assembly { getSig := mload(add(_txData,0x20)) } sig = bytes4(getSig); if(sig ==  tSig || sig == aSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x44)) } _amount = uint256(_amountData); } else if(sig == tfSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x64)) } _amount = uint256(_amountData); } return (transfer,_amount); }
function getRequired(WalletData storage self,
function createContract(bytes _txData, uint256 _value) public { address _newContract; bool allGood; assembly { _newContract := create(_value, add(_txData, 0x20), mload(_txData)) allGood := gt(extcodesize(_newContract),0) } require(allGood); LogContractCreated(_newContract, _value); }
function serveTx(WalletData storage self,
function confirmTx(WalletData storage self, bytes32 _id)
function revokeConfirm(WalletData storage self, bytes32 _id)
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
modifier onlyRole(bytes32 role) { _checkRole(role, _msgSender()); _; }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId); }
function hasRole(bytes32 role, address account) public view override returns (bool) { return _roles[role].members[account]; }
function _checkRole(bytes32 role, address account) internal view { if(!hasRole(role, account)) { revert(string(abi.encodePacked( "AccessControl: account ", Strings.toHexString(uint160(account), 20), " is missing role ", Strings.toHexString(uint256(role), 32) ))); } }
function getRoleAdmin(bytes32 role) public view override returns (bytes32) { return _roles[role].adminRole; }
function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { _grantRole(role, account); }
function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { _revokeRole(role, account); }
function renounceRole(bytes32 role, address account) public virtual override { require(account == _msgSender(), "AccessControl: can only renounce roles for self"); _revokeRole(role, account); }
function _setupRole(bytes32 role, address account) internal virtual { _grantRole(role, account); }
function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { emit RoleAdminChanged(role, getRoleAdmin(role), adminRole); _roles[role].adminRole = adminRole; }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId); }
function getRoleMember(bytes32 role, uint256 index) public view override returns (address) { return _roleMembers[role].at(index); }
function getRoleMemberCount(bytes32 role) public view override returns (uint256) { return _roleMembers[role].length(); }
function grantRole(bytes32 role, address account) public virtual override { super.grantRole(role, account); _roleMembers[role].add(account); }
function revokeRole(bytes32 role, address account) public virtual override { super.revokeRole(role, account); _roleMembers[role].remove(account); }
function renounceRole(bytes32 role, address account) public virtual override { super.renounceRole(role, account); _roleMembers[role].remove(account); }
function _setupRole(bytes32 role, address account) internal virtual override { super._setupRole(role, account); _roleMembers[role].add(account); }
function owner() public view virtual returns (address) { return _owner; }
modifier onlyOwner() { require(owner() == _msgSender(), "Ownable: caller is not the owner"); _; }
function renounceOwnership() public virtual onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), "Ownable: new owner is the zero address"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }
function totalShares() public view returns (uint256) { return _totalShares; }
function totalReleased() public view returns (uint256) { return _totalReleased; }
function shares(address account) public view returns (uint256) { return _shares[account]; }
function released(address account) public view returns (uint256) { return _released[account]; }
function payee(uint256 index) public view returns (address) { return _payees[index]; }
function release(address payable account) public virtual { require(_shares[account] > 0, "PaymentSplitter: account has no shares"); uint256 totalReceived = address(this).balance + _totalReleased; uint256 payment = totalReceived * _shares[account] / _totalShares - _released[account]; require(payment != 0, "PaymentSplitter: account is not due payment"); _released[account] = _released[account] + payment; _totalReleased = _totalReleased + payment; Address.sendValue(account, payment); emit PaymentReleased(account, payment); }
function _addPayee(address account, uint256 shares_) private { require(account != address(0), "PaymentSplitter: account is the zero address"); require(shares_ > 0, "PaymentSplitter: shares are 0"); require(_shares[account] == 0, "PaymentSplitter: account already has shares"); _payees.push(account); _shares[account] = shares_; _totalShares = _totalShares + shares_; emit PayeeAdded(account, shares_); }
event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);
event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);
event Cancelled(bytes32 indexed id);
event MinDelayChange(uint256 oldDuration, uint256 newDuration);
modifier onlyRoleOrOpenRole(bytes32 role) { if (!hasRole(role, address(0))) { _checkRole(role, _msgSender()); } _; }
function isOperation(bytes32 id) public view virtual returns (bool pending) { return getTimestamp(id) > 0; }
function isOperationPending(bytes32 id) public view virtual returns (bool pending) { return getTimestamp(id) > _DONE_TIMESTAMP; }
function isOperationReady(bytes32 id) public view virtual returns (bool ready) { uint256 timestamp = getTimestamp(id); return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp; }
function isOperationDone(bytes32 id) public view virtual returns (bool done) { return getTimestamp(id) == _DONE_TIMESTAMP; }
function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) { return _timestamps[id]; }
function getMinDelay() public view virtual returns (uint256 duration) { return _minDelay; }
function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) { return keccak256(abi.encode(target, value, data, predecessor, salt)); }
function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) { return keccak256(abi.encode(targets, values, datas, predecessor, salt)); }
function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) { bytes32 id = hashOperation(target, value, data, predecessor, salt); _schedule(id, delay); emit CallScheduled(id, 0, target, value, data, predecessor, delay); }
function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) { require(targets.length == values.length, "TimelockController: length mismatch"); require(targets.length == datas.length, "TimelockController: length mismatch"); bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _schedule(id, delay); for (uint256 i = 0; i < targets.length; ++i) { emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } }
function _schedule(bytes32 id, uint256 delay) private { require(!isOperation(id), "TimelockController: operation already scheduled"); require(delay >= getMinDelay(), "TimelockController: insufficient delay"); _timestamps[id] = block.timestamp + delay; }
function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) { require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); delete _timestamps[id]; emit Cancelled(id); }
function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { bytes32 id = hashOperation(target, value, data, predecessor, salt); _beforeCall(predecessor); _call(id, 0, target, value, data); _afterCall(id); }
function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { require(targets.length == values.length, "TimelockController: length mismatch"); require(targets.length == datas.length, "TimelockController: length mismatch"); bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(predecessor); for (uint256 i = 0; i < targets.length; ++i) { _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); }
function _beforeCall(bytes32 predecessor) private view { require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); }
function _afterCall(bytes32 id) private { require(isOperationReady(id), "TimelockController: operation is not ready"); _timestamps[id] = _DONE_TIMESTAMP; }
function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private { (bool success,) = target.call{value: value}(data); require(success, "TimelockController: underlying transaction reverted"); emit CallExecuted(id, index, target, value, data); }
function updateDelay(uint256 newDelay) external virtual { require(msg.sender == address(this), "TimelockController: caller must be timelock"); emit MinDelayChange(_minDelay, newDelay); _minDelay = newDelay; }
function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
function onFlashLoan(
function maxFlashLoan(
function flashFee(
function flashLoan(
event BeforeTokenTransfer();
function callTransfer(address dest, uint256 amount) public { _asyncTransfer(dest, amount); }
function doAdd(uint256 a, uint256 b) public pure returns (uint256) { return SafeMath.add(a, b); }
function supportsInterface(bytes4 interfaceId) public view override returns (bool) { return _supportedInterfaces[interfaceId]; }
function _registerInterface(bytes4 interfaceId) internal { require(interfaceId != 0xffffffff, "ERC165InterfacesSupported: invalid interface id"); _supportedInterfaces[interfaceId] = true; }
function _authorizeUpgrade(address) internal virtual override {}
function clone(address implementation) internal returns (address instance) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create(0, ptr, 0x37) } require(instance != address(0), "ERC1167: create failed"); }
function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create2(0, ptr, 0x37, salt) } require(instance != address(0), "ERC1167: create2 failed"); }
function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000) mstore(add(ptr, 0x38), shl(0x60, deployer)) mstore(add(ptr, 0x4c), salt) mstore(add(ptr, 0x6c), keccak256(ptr, 0x37)) predicted := keccak256(add(ptr, 0x37), 0x55) } }
function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) { return predictDeterministicAddress(implementation, salt, address(this)); }
function _delegate(address implementation) internal virtual { assembly { calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } }
function _implementation() internal view virtual returns (address);
function _fallback() internal virtual { _beforeFallback(); _delegate(_implementation()); }
function _beforeFallback() internal virtual { }
function _beacon() internal view virtual returns (address) { return _getBeacon(); }
function _implementation() internal view virtual override returns (address) { return IBeacon(_getBeacon()).implementation(); }
function _setBeacon(address beacon, bytes memory data) internal virtual { _upgradeBeaconToAndCall(beacon, data, false); }
function implementation() external view returns (address);
event Upgraded(address indexed implementation);
function implementation() public view virtual override returns (address) { return _implementation; }
function upgradeTo(address newImplementation) public virtual onlyOwner { _setImplementation(newImplementation); emit Upgraded(newImplementation); }
function _setImplementation(address newImplementation) private { require(Address.isContract(newImplementation), "UpgradeableBeacon: implementation is not a contract"); _implementation = newImplementation; }
function _implementation() internal view virtual override returns (address impl) { return ERC1967Storage._getImplementation(); }
function _getImplementation() internal view returns (address) { return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value; }
function _setImplementation(address newImplementation) internal { require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract"); StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; }
function _getBeacon() internal view returns (address) { return StorageSlot.getAddressSlot(_BEACON_SLOT).value; }
function _setBeacon(address newBeacon) internal { require( Address.isContract(newBeacon), "ERC1967: new beacon is not a contract" ); require( Address.isContract(IBeacon(newBeacon).implementation()), "ERC1967: beacon implementation is not a contract" ); StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon; }
function _getAdmin() internal view returns (address) { return StorageSlot.getAddressSlot(_ADMIN_SLOT).value; }
function _setAdmin(address newAdmin) internal { require(newAdmin != address(0), "ERC1967: new admin is the zero address"); StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin; }
event Upgraded(address indexed implementation);
event BeaconUpgraded(address indexed beacon);
event AdminChanged(address previousAdmin, address newAdmin);
function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); }
function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); } }
function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal { address oldImplementation = _getImplementation(); _setImplementation(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); } StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) { rollbackTesting.value = true; Address.functionDelegateCall( newImplementation, abi.encodeWithSignature( "upgradeTo(address)", oldImplementation ) ); rollbackTesting.value = false; require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades"); _setImplementation(newImplementation); emit Upgraded(newImplementation); } }
function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal { _setBeacon(newBeacon); emit BeaconUpgraded(newBeacon); if (data.length > 0 || forceCall) { Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data); } }
function _changeAdmin(address newAdmin) internal { emit AdminChanged(_getAdmin(), newAdmin); _setAdmin(newAdmin); }
function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) { (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b"); require(success); return abi.decode(returndata, (address)); }
function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) { (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440"); require(success); return abi.decode(returndata, (address)); }
function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner { proxy.changeAdmin(newAdmin); }
function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner { proxy.upgradeTo(implementation); }
function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner { proxy.upgradeToAndCall{value: msg.value}(implementation, data); }
modifier ifAdmin() { if (msg.sender == _getAdmin()) { _; } else { _fallback(); } }
function admin() external ifAdmin returns (address admin_) { admin_ = _getAdmin(); }
function implementation() external ifAdmin returns (address implementation_) { implementation_ = _implementation(); }
function changeAdmin(address newAdmin) external virtual ifAdmin { _changeAdmin(newAdmin); }
function upgradeTo(address newImplementation) external ifAdmin { _upgradeToAndCall(newImplementation, bytes(""), false); }
function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin { _upgradeToAndCall(newImplementation, data, true); }
function _admin() internal view virtual returns (address) { return _getAdmin(); }
function _beforeFallback() internal virtual override { require(msg.sender != _getAdmin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target"); super._beforeFallback(); }
modifier initializer() { require(_initializing || !_initialized, "Initializable: contract is already initialized"); bool isTopLevelCall = !_initializing; if (isTopLevelCall) { _initializing = true; _initialized = true; } _; if (isTopLevelCall) { _initializing = false; } }
event Paused(address account);
event Unpaused(address account);
function paused() public view virtual returns (bool) { return _paused; }
modifier whenNotPaused() { require(!paused(), "Pausable: paused"); _; }
modifier whenPaused() { require(paused(), "Pausable: not paused"); _; }
function _pause() internal virtual whenNotPaused { _paused = true; emit Paused(_msgSender()); }
function _unpause() internal virtual whenPaused { _paused = false; emit Unpaused(_msgSender()); }
function withdrawPayments(address payable payee) public virtual { _escrow.withdraw(payee); }
function payments(address dest) public view returns (uint256) { return _escrow.depositsOf(dest); }
function _asyncTransfer(address dest, uint256 amount) internal virtual { _escrow.deposit{ value: amount }(dest); }
modifier nonReentrant() { require(_status != _ENTERED, "ReentrancyGuard: reentrant call"); _status = _ENTERED; _; _status = _NOT_ENTERED; }
function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) { return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC1155MetadataURI).interfaceId || super.supportsInterface(interfaceId); }
function uri(uint256) public view virtual override returns (string memory) { return _uri; }
function balanceOf(address account, uint256 id) public view virtual override returns (uint256) { require(account != address(0), "ERC1155: balance query for the zero address"); return _balances[id][account]; }
function balanceOfBatch(
function setApprovalForAll(address operator, bool approved) public virtual override { require(_msgSender() != operator, "ERC1155: setting approval status for self"); _operatorApprovals[_msgSender()][operator] = approved; emit ApprovalForAll(_msgSender(), operator, approved); }
function isApprovedForAll(address account, address operator) public view virtual override returns (bool) { return _operatorApprovals[account][operator]; }
function safeTransferFrom(
function safeBatchTransferFrom(
function _setURI(string memory newuri) internal virtual { _uri = newuri; }
function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual { require(account != address(0), "ERC1155: mint to the zero address"); address operator = _msgSender(); _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data); _balances[id][account] += amount; emit TransferSingle(operator, address(0), account, id, amount); _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data); }
function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual { require(to != address(0), "ERC1155: mint to the zero address"); require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch"); address operator = _msgSender(); _beforeTokenTransfer(operator, address(0), to, ids, amounts, data); for (uint i = 0; i < ids.length; i++) { _balances[ids[i]][to] += amounts[i]; } emit TransferBatch(operator, address(0), to, ids, amounts); _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data); }
function _burn(address account, uint256 id, uint256 amount) internal virtual { require(account != address(0), "ERC1155: burn from the zero address"); address operator = _msgSender(); _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), ""); uint256 accountBalance = _balances[id][account]; require(accountBalance >= amount, "ERC1155: burn amount exceeds balance"); _balances[id][account] = accountBalance - amount; emit TransferSingle(operator, account, address(0), id, amount); }
function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual { require(account != address(0), "ERC1155: burn from the zero address"); require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch"); address operator = _msgSender(); _beforeTokenTransfer(operator, account, address(0), ids, amounts, ""); for (uint i = 0; i < ids.length; i++) { uint256 id = ids[i]; uint256 amount = amounts[i]; uint256 accountBalance = _balances[id][account]; require(accountBalance >= amount, "ERC1155: burn amount exceeds balance"); _balances[id][account] = accountBalance - amount; } emit TransferBatch(operator, account, address(0), ids, amounts); }
function _beforeTokenTransfer(
event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
event ApprovalForAll(address indexed account, address indexed operator, bool approved);
event URI(string value, uint256 indexed id);
