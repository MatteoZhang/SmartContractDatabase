function get Reserve A Token Address ( address reserve ) external view returns ( address ) ;
function sell Bancor Pool (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function operator Action ( address strategy ) public only Defi Operator returns ( uint256 , uint256 ) { require ( is Strategy Registered ( strategy ) , " Strategy is not registered " ) ; process On Hold Deposit ( ) ; address user ; uint256 [ ] memory withdraw Amounts new uint256 [ ] ( registered Vault Tokens . length ) ; uint256 last Processed Request min Processed ( last Processed Requests ) ; uint256 amount To Withdraw ; for ( uint256 i last Processed Request ; i < users Requested . length ; i + + ) { user users Requested [ i ] ; for ( uint256 j 0 ; j < balances Requested [ user ] . length ; j + + ) { amount To Withdraw request To Claim ( user , j ) ; if ( amount To Withdraw > 0 ) { withdraw Amounts [ j ] withdraw Amounts [ j ] . add ( amount To Withdraw ) ; } } } if ( users Requested . length > last Processed Request ) { set Processed ( last Processed Requests , users Requested . length ) ; } uint256 [ ] memory deposit Amounts new uint256 [ ] ( registered Vault Tokens . length ) ; uint256 total Deposit 0 ; uint256 total Withdraw 0 ; for ( uint256 i 0 ; i < registered Vault Tokens . length ; i + + ) { deposit Amounts [ i ] IERC20 ( registered Vault Tokens [ i ] ) . balance Of ( address ( this ) ) . sub ( claimable Tokens [ i ] ) ; deposit Amounts [ i ] handle Remainders ( deposit Amounts [ i ] , i ) ; IERC20 ( registered Vault Tokens [ i ] ) . safe Approve ( address ( strategy ) , deposit Amounts [ i ] ) ; total Deposit total Deposit . add ( Calc Utils . normalize Amount ( registered Vault Tokens [ i ] , deposit Amounts [ i ] ) ) ; total Withdraw total Withdraw . add ( Calc Utils . normalize Amount ( registered Vault Tokens [ i ] , withdraw Amounts [ i ] ) ) ; } if ( total Deposit > 0 ) { I Defi Strategy ( strategy ) . handle Deposit ( registered Vault Tokens , deposit Amounts ) ; emit Deposit By Operator ( total Deposit ) ; } if ( total Withdraw > 0 ) { I Defi Strategy ( strategy ) . withdraw ( address ( this ) , withdraw Amounts ) ; emit Withdraw By Operator ( total Withdraw ) ; for ( uint256 i 0 ; i < claimable Tokens . length ; i + + ) { claimable Tokens [ i ] claimable Tokens [ i ] . add ( withdraw Amounts [ i ] ) ; } } emit Withdraw Requests Resolved ( total Deposit , total Withdraw ) ; return ( total Deposit , total Withdraw ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " add : + " ) ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function disable Circuit (
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function exchange (
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function start Game ( address liquidity Pool , uint seed1 ) external only Owner { require ( game Started false , ' The game has already started ' ) ; require ( liquidity Pool ! address ( 0 ) , ' Need the ETH X20 liquidity pool address ' ) ; chance Rate 100 ; liquidity Pool liquidity Pool ; seed1 seed1 ; seed2 rand Modulus ( uint ( 10000000 ) , seed1 ) ; game Started true ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Size ( Data storage self ) public view returns ( uint256 ) { return self . size ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function create Stake (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function total Supply ( ) external view returns ( uint256 ) ;
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function mod ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b ! 0 , error Message ) ; return a % b ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; before Token Transfer ( address ( 0 ) , to , token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function actual Balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function total Supply ( )
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( )
enum Asset Type { DAI , USDC , ETH , SAI }
function harvest ( ) public restricted override { ( address to , uint256 to Index ) get Most Premium ( ) ; I Curve Mintr ( mintr ) . mint ( gauge ) ; uint256 crv IERC20 ( crv ) . balance Of ( address ( this ) ) ; if ( crv > 0 ) { uint256 keep CRV crv . mul ( keep CRV ) . div ( keep CRV Max ) ; if ( keep CRV > 0 ) { IERC20 ( crv ) . safe Transfer ( treasury , keep CRV ) ; } crv crv . sub ( keep CRV ) ; swap Uniswap ( crv , to , crv ) ; } uint256 to IERC20 ( to ) . balance Of ( address ( this ) ) ; if ( to > 0 ) { IERC20 ( to ) . safe Approve ( curve , 0 ) ; IERC20 ( to ) . safe Approve ( curve , to ) ; uint256 [ 3 ] memory liquidity ; liquidity [ to Index ] to ; I Curve3Pool ( curve ) . add liquidity ( liquidity , 0 ) ; } distribute And Deposit ( ) ; }
function allowance ( address owner , address spender )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function ret Based Black Scholes Estimate (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function confirm Transfer ( ) public { require ( m Admins [ msg . sender ] 1 , " not in admin list or set state " ) ; m Proposal Numb m Proposal Numb + 1 ; m Admins [ msg . sender ] 2 ; }
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function total Supply ( ) external view returns ( uint256 ) ;
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function less Than Or Equal Exp ( Exp memory left , Exp memory right ) pure internal returns ( bool ) { return left . mantissa < right . mantissa ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function stake (
function owner ( ) public view returns ( address ) { return owner ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mint ( address account , uint256 id , uint256 amount , bytes memory data ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , account , as Singleton Array ( id ) , as Singleton Array ( amount ) , data ) ; balances [ id ] [ account ] balances [ id ] [ account ] . add ( amount ) ; emit Transfer Single ( operator , address ( 0 ) , account , id , amount ) ; do Safe Transfer Acceptance Check ( operator , address ( 0 ) , account , id , amount , data ) ; }
function get Last Pay Resolve Deadline Map (
function is Agent (
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
modifier only Owner ( ) { require ( is Owner ( ) ) ; ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function ( ) public payable { revert ( ) ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function revoke ( address keeper ) external { require ( msg . sender governance , " slash : ! gov " ) ; keepers [ keeper ] false ; blacklist [ keeper ] true ; slash ( address ( this ) , keeper , bonds [ keeper ] [ address ( this ) ] ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function require Reserve Not Freezed Internal ( address reserve ) internal view { require ( ! core . get Reserve Is Freezed ( reserve ) , " Action requires an unfreezed reserve " ) ; }
function balance Of ( address owner ) public view returns ( uint256 balance ) ;
function set Storage Cumulative Locked Up Value ( address addr , uint256 value )
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function remove Token From All Tokens Enumeration ( uint256 token Id ) private { uint256 last Token Index all Tokens . length . sub ( 1 ) ; uint256 token Index all Tokens Index [ token Id ] ; uint256 last Token Id all Tokens [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index all Tokens Index [ token Id ] 0 ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer Ownership ( address new Owner ) public only Owner { if ( new Owner ! address ( 0 ) ) { owner new Owner ; } }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Token Config ( uint i ) public view returns ( Token Config memory ) { require ( i < num Tokens , " token config not found " ) ; if ( i 0 ) return Token Config ( { g Token : g Token00 , underlying : underlying00 , symbol Hash : symbol Hash00 , base Unit : base Unit00 , price Source : price Source00 , fixed Price : fixed Price00 , uniswap Market : uniswap Market00 , is Price1From Uniswap : is Price1From Uniswap00 } ) ; if ( i 1 ) return Token Config ( { g Token : g Token01 , underlying : underlying01 , symbol Hash : symbol Hash01 , base Unit : base Unit01 , price Source : price Source01 , fixed Price : fixed Price01 , uniswap Market : uniswap Market01 , is Price1From Uniswap : is Price1From Uniswap01 } ) ; if ( i 2 ) return Token Config ( { g Token : g Token02 , underlying : underlying02 , symbol Hash : symbol Hash02 , base Unit : base Unit02 , price Source : price Source02 , fixed Price : fixed Price02 , uniswap Market : uniswap Market02 , is Price1From Uniswap : is Price1From Uniswap02 } ) ; if ( i 3 ) return Token Config ( { g Token : g Token03 , underlying : underlying03 , symbol Hash : symbol Hash03 , base Unit : base Unit03 , price Source : price Source03 , fixed Price : fixed Price03 , uniswap Market : uniswap Market03 , is Price1From Uniswap : is Price1From Uniswap03 } ) ; if ( i 4 ) return Token Config ( { g Token : g Token04 , underlying : underlying04 , symbol Hash : symbol Hash04 , base Unit : base Unit04 , price Source : price Source04 , fixed Price : fixed Price04 , uniswap Market : uniswap Market04 , is Price1From Uniswap : is Price1From Uniswap04 } ) ; if ( i 5 ) return Token Config ( { g Token : g Token05 , underlying : underlying05 , symbol Hash : symbol Hash05 , base Unit : base Unit05 , price Source : price Source05 , fixed Price : fixed Price05 , uniswap Market : uniswap Market05 , is Price1From Uniswap : is Price1From Uniswap05 } ) ; if ( i 6 ) return Token Config ( { g Token : g Token06 , underlying : underlying06 , symbol Hash : symbol Hash06 , base Unit : base Unit06 , price Source : price Source06 , fixed Price : fixed Price06 , uniswap Market : uniswap Market06 , is Price1From Uniswap : is Price1From Uniswap06 } ) ; if ( i 7 ) return Token Config ( { g Token : g Token07 , underlying : underlying07 , symbol Hash : symbol Hash07 , base Unit : base Unit07 , price Source : price Source07 , fixed Price : fixed Price07 , uniswap Market : uniswap Market07 , is Price1From Uniswap : is Price1From Uniswap07 } ) ; if ( i 8 ) return Token Config ( { g Token : g Token08 , underlying : underlying08 , symbol Hash : symbol Hash08 , base Unit : base Unit08 , price Source : price Source08 , fixed Price : fixed Price08 , uniswap Market : uniswap Market08 , is Price1From Uniswap : is Price1From Uniswap08 } ) ; if ( i 9 ) return Token Config ( { g Token : g Token09 , underlying : underlying09 , symbol Hash : symbol Hash09 , base Unit : base Unit09 , price Source : price Source09 , fixed Price : fixed Price09 , uniswap Market : uniswap Market09 , is Price1From Uniswap : is Price1From Uniswap09 } ) ; if ( i 10 ) return Token Config ( { g Token : g Token10 , underlying : underlying10 , symbol Hash : symbol Hash10 , base Unit : base Unit10 , price Source : price Source10 , fixed Price : fixed Price10 , uniswap Market : uniswap Market10 , is Price1From Uniswap : is Price1From Uniswap10 } ) ; if ( i 11 ) return Token Config ( { g Token : g Token11 , underlying : underlying11 , symbol Hash : symbol Hash11 , base Unit : base Unit11 , price Source : price Source11 , fixed Price : fixed Price11 , uniswap Market : uniswap Market11 , is Price1From Uniswap : is Price1From Uniswap11 } ) ; if ( i 12 ) return Token Config ( { g Token : g Token12 , underlying : underlying12 , symbol Hash : symbol Hash12 , base Unit : base Unit12 , price Source : price Source12 , fixed Price : fixed Price12 , uniswap Market : uniswap Market12 , is Price1From Uniswap : is Price1From Uniswap12 } ) ; if ( i 13 ) return Token Config ( { g Token : g Token13 , underlying : underlying13 , symbol Hash : symbol Hash13 , base Unit : base Unit13 , price Source : price Source13 , fixed Price : fixed Price13 , uniswap Market : uniswap Market13 , is Price1From Uniswap : is Price1From Uniswap13 } ) ; if ( i 14 ) return Token Config ( { g Token : g Token14 , underlying : underlying14 , symbol Hash : symbol Hash14 , base Unit : base Unit14 , price Source : price Source14 , fixed Price : fixed Price14 , uniswap Market : uniswap Market14 , is Price1From Uniswap : is Price1From Uniswap14 } ) ; if ( i 15 ) return Token Config ( { g Token : g Token15 , underlying : underlying15 , symbol Hash : symbol Hash15 , base Unit : base Unit15 , price Source : price Source15 , fixed Price : fixed Price15 , uniswap Market : uniswap Market15 , is Price1From Uniswap : is Price1From Uniswap15 } ) ; if ( i 16 ) return Token Config ( { g Token : g Token16 , underlying : underlying16 , symbol Hash : symbol Hash16 , base Unit : base Unit16 , price Source : price Source16 , fixed Price : fixed Price16 , uniswap Market : uniswap Market16 , is Price1From Uniswap : is Price1From Uniswap16 } ) ; if ( i 17 ) return Token Config ( { g Token : g Token17 , underlying : underlying17 , symbol Hash : symbol Hash17 , base Unit : base Unit17 , price Source : price Source17 , fixed Price : fixed Price17 , uniswap Market : uniswap Market17 , is Price1From Uniswap : is Price1From Uniswap17 } ) ; if ( i 18 ) return Token Config ( { g Token : g Token18 , underlying : underlying18 , symbol Hash : symbol Hash18 , base Unit : base Unit18 , price Source : price Source18 , fixed Price : fixed Price18 , uniswap Market : uniswap Market18 , is Price1From Uniswap : is Price1From Uniswap18 } ) ; if ( i 19 ) return Token Config ( { g Token : g Token19 , underlying : underlying19 , symbol Hash : symbol Hash19 , base Unit : base Unit19 , price Source : price Source19 , fixed Price : fixed Price19 , uniswap Market : uniswap Market19 , is Price1From Uniswap : is Price1From Uniswap19 } ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Level ( address account ) external view returns ( uint256 ) { return NAP Slevel [ account ] ; }
function get Subscribers ( ) public view returns ( Compound Holder [ ] memory ) { return subscribers ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function symbol ( ) external view returns ( string memory ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function set Manager ( string calldata role , address manager ) external only Admin ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
event Approval (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function min Int256 ( ) internal pure returns ( int256 ) { return MIN INT 256 ; }
function delegated Fwd ( address dst , bytes calldata ) internal { require ( is Contract ( dst ) ) ; uint256 fwd Gas Limit FWD GAS LIMIT ; assembly { let result : delegatecall ( sub ( gas , fwd Gas Limit ) , dst , add ( calldata , 0x20 ) , mload ( calldata ) , 0 , 0 ) let size : returndatasize let ptr : mload ( 0x40 ) returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; if ( value Index ! 0 ) { uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee amount In . mul ( 997 ) ; uint numerator amount In With Fee . mul ( reserve Out ) ; uint denominator reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out numerator denominator ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
event Apply Credit ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function buy ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; require ( ex Data . dest Amount ! 0 , " Dest amount must be specified " ) ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } if ( ex Data . price0x > 0 ) { approve0x Proxy ( ex Data . src Addr , ex Data . src Amount ) ; uint eth Amount get Protocol Fee ( ex Data . src Addr , msg . value , ex Data . src Amount ) ; ( success , swaped Tokens , ) take Order ( ex Data , eth Amount , Action Type . BUY ) ; if ( success ) { wrapper ex Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . BUY ) ; wrapper ex Data . wrapper ; } require ( swaped Tokens > ex Data . dest Amount , " Final amount isn ' t correct " ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , get Balance ( ex Data . dest Addr ) ) ; }
event Log User Registered ( address registrant ) ;
function lock For Governance Vote ( address of , uint256 period )
function delegates ( address delegator )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function release Time ( ) public view returns ( uint256 ) { return release Time ; }
function borrowing Reserve Underlying ( ) public view override returns ( uint256 borrowing Reserve Underlying )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function set Implementation ( address implementation , bool allow Resign , bytes memory become Implementation Data ) public ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed approved , uint256 indexed token Id ) ;
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function token URI ( uint256 token Id ) public view override returns ( string memory ) { require ( exists ( token Id ) , " ERC721Metadata : URI query for nonexistent token " ) ; string memory token URI token UR Is [ token Id ] ; if ( bytes ( base URI ) . length 0 ) { return token URI ; } if ( bytes ( token URI ) . length > 0 ) { return string ( abi . encode Packed ( base URI , token URI ) ) ; } return string ( abi . encode Packed ( base URI , token Id . to String ( ) ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function encode ( uint112 x ) internal pure returns ( uq112x112 memory ) { return uq112x112 ( uint224 ( x ) < < RESOLUTION ) ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function update Guardian ( bytes4 ip , address orbs Addr , string calldata name , string calldata website ) external override only Registered Guardian only When Active { update Guardian ( msg . sender , ip , orbs Addr , name , website ) ; }
function delegate By Sig ( address delegatee , uint nonce , uint expiry , uint8 v , bytes32 r , bytes32 s ) public { bytes32 domain Separator keccak256 ( abi . encode ( DOMAIN TYPEHASH , keccak256 ( bytes ( name ) ) , get Chain Id ( ) , address ( this ) ) ) ; bytes32 struct Hash keccak256 ( abi . encode ( DELEGATION TYPEHASH , delegatee , nonce , expiry ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , domain Separator , struct Hash ) ) ; address signatory ecrecover ( digest , v , r , s ) ; require ( signatory ! address ( 0 ) , " Tkn : : delegate By Sig : invalid signature " ) ; require ( nonce nonces [ signatory ] + + , " Tkn : : delegate By Sig : invalid nonce " ) ; require ( now < expiry , " Tkn : : delegate By Sig : signature expired " ) ; return delegate ( signatory , delegatee ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
event Unpaused ( address account ) ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function update Deployer Cut Lockup Duration ( uint256 duration ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; update Deployer Cut Lockup Duration ( duration ) ; emit Update Deployer Cut Lockup Duration Updated ( duration ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( ( a % 2 ) + ( b % 2 ) ) 2 ) ; }
function mint ( address to , uint256 amount )
function change Beneficiary ( address new Beneficiary , address current Beneficiary ) public { require ( has Role ( ADMIN , msg . sender ) ) ; Beneficiaries storage b beneficiary [ current Beneficiary ] ; b . beneficiary new Beneficiary ; emit beneficiary Changed ( current Beneficiary , new Beneficiary , block . number ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function burn ( address account , uint256 value ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; total Supply total Supply . sub ( value ) ; balances [ account ] balances [ account ] . sub ( value ) ; emit Transfer ( account , address ( 0 ) , value ) ; }
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function erc721Wrapper Model ( ) external view returns ( address erc721Wrapper Model Address , uint256 erc721Wrapper Model Version ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function add Controller ( address controller ) external ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function paint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : paint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function get Redeem Premium (
function liquidity Pool Migration Unlock Time ( ) public view override returns ( uint256 migration Unlock Time )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function get Managed Contracts ( ) external view returns ( address [ ] memory ) ;
function get Target Token ( ) external view returns ( address ) ;
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function set Vote Unready Percent Mille Threshold ( uint32 vote Unready Percent Mille Threshold ) external only Functional Manager ;
function name ( ) public view returns ( string memory ) { return name ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mul ( uq112x112 memory self , uint y ) internal pure returns ( uq144x112 memory ) { uint z ; require ( y 0 | | ( z uint ( self . x ) y ) y uint ( self . x ) , " Fixed Point : MULTIPLICATION OVERFLOW " ) ; return uq144x112 ( z ) ; }
function transfer From ( address from , address to , uint256 value ) returns ( bool success ) { }
function transfer ( address to , uint256 amount ) public override returns ( bool ) { uint256 balance balance Of ( msg Sender ( ) ) ; require ( locked Amount [ msg Sender ( ) ] + amount < balance , " transfer : < balance " ) ; update Reward ( msg Sender ( ) ) ; update Reward ( to ) ; transfer ( msg Sender ( ) , to , amount ) ; update Debt ( to ) ; update Debt ( msg Sender ( ) ) ; return true ; }
function withdraw Bootstrap Funds ( address guardian ) external ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function request Flash Loan ( address token , uint256 net Amount , bytes memory context ) internal returns ( bool success )
function burn ( uint256 amount ) public { burn ( msg Sender ( ) , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function approve ( address to , uint256 token Id ) public virtual override { address owner owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg Sender ( ) owner | | is Approved For All ( owner , msg Sender ( ) ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function calc Deposit Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) internal pure returns ( uint256 cost , uint256 fee Shares )
function cap ( ) public view returns ( uint256 ) { return cap ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event New Implementation ( address old Implementation , address new Implementation ) ;
function symbol ( ) public view override returns ( string memory ) { return symbol ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Genesis Ref Time Delay ( ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
modifier only Owner ( ) { require ( msg . sender owner , " only Owner " ) ; ; }
function get Vote Unready Percent Mille Threshold ( ) external view returns ( uint32 ) ;
function remove Party From Contract ( address party Address ) external override { address contract Address msg . sender ; Party storage party party Map [ party Address ] ; uint256 number Of Contracts party . contracts . length ; require ( number Of Contracts ! 0 , " Party has no contracts " ) ; require ( contract Map [ contract Address ] . valid Validity . Valid , " Remove only from valid contract " ) ; require ( is Party Member Of Contract ( party Address , contract Address ) , " Can only remove existing party " ) ; uint256 delete Index party . contract Index [ contract Address ] ; address last Contract Address party . contracts [ number Of Contracts 1 ] ; party . contracts [ delete Index ] last Contract Address ; party . contract Index [ last Contract Address ] delete Index ; party . contracts . pop ( ) ; delete party . contract Index [ contract Address ] ; emit Party Removed ( contract Address , party Address ) ; }
function delete Tokens ( uint256 tokens ) public only Owner { require ( tokens > 0 ) ; require ( balances [ msg . sender ] > tokens ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; total Supply total Supply . sub ( tokens ) ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function call Close And Open (
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function give Permission ( address contract Addr ) public { address curr Authority address ( DS Auth ( address ( this ) ) . authority ( ) ) ; DS Guard guard DS Guard ( curr Authority ) ; if ( curr Authority address ( 0 ) ) { guard DS Guard Factory ( FACTORY ADDRESS ) . new Guard ( ) ; DS Auth ( address ( this ) ) . set Authority ( DS Authority ( address ( guard ) ) ) ; } guard . permit ( contract Addr , address ( this ) , bytes4 ( keccak256 ( " execute ( address , bytes ) " ) ) ) ; }
function is Minter ( address account ) public view non Reentrant View ( ) returns ( bool ) { return holds Role ( uint256 ( Roles . Minter ) , account ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function call ERC165Supports Interface ( address account , bytes4 interface Id )
function total Supply ( ) external view returns ( uint256 ) ;
event Primary Transferred (
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address to , uint256 token Id ) external ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function update Overall States By Intend State (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a 0 ) { return 0 ; } c a b ; assert ( c a b ) ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function total Supply ( uint256 object Id ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
modifier only Governor ( ) { require ( is Governor ( ) , " Caller is not the Governor " ) ; ; }
function calc Underlying Cost From Cost ( uint256 cost , uint256 exchange Rate ) internal pure returns ( uint256 underlying Cost )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function change Init Reward ( uint256 reward ) public only Owner { initreward reward ; Will evaluate if its worth to do . }
function add ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a + b ; require ( ( b > 0 & & c > a ) | | ( b < 0 & & c < a ) , " Signed Safe Math : addition overflow " ) ; return c ; }
function mint ( uint mint Amount ) external returns ( uint ) { ( uint err , ) mint Internal ( mint Amount ) ; return err ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Burn ( address indexed burner , uint256 value ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function fallback ( ) internal { will Fallback ( ) ; delegate ( implementation ( ) ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function balance Of ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function set Approval For All ( address operator , bool approved ) public virtual override { require ( msg Sender ( ) ! operator , " ERC1155 : setting approval status for self " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function dev ( address devaddr ) public { require ( msg . sender devaddr , " dev : wut ? " ) ; devaddr devaddr ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function is Stakeholder ( address address ) public view returns ( bool , uint ) { for ( uint s 0 ; s < stakeholders . length ; s + 1 ) { if ( address stakeholders [ s ] ) return ( true , s ) ; } return ( false , 0 ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function withdraw ( uint amount ) external { require ( msg . sender controller , " ! controller " ) ; uint balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint fee 0 ; if ( withdrawal Fee > 0 ) { fee amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; } address vault Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function set Burn Rate ( uint256 burn Divisor ) public only Admin Or Owner { require ( burn Divisor ! 0 , " Boo : burn Divisor must be bigger than 0 " ) ; burn Divisor burn Divisor ; }
function update Max Children Per Token ( uint256 max Children Per Token ) external { require ( access Controls . has Admin Role ( msg Sender ( ) ) , " Digitalax Garment NFT . update Max Children Per Token : Sender must be admin " ) ; max Children Per Token max Children Per Token ; }
function approve (
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function read Name ( bytes memory self , uint offset ) internal pure returns ( bytes memory ret ) { uint len name Length ( self , offset ) ; return self . substring ( offset , len ) ; }
function mint Tokens ( uint256 amount , address beneficiary , address avatar )
event Approval (
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function mul Scalar Truncate ( Exp memory a , uint scalar ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return ( Math Error . NO ERROR , truncate ( product ) ) ; }
function yearn (
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( uint256 object Id ) external view returns ( uint256 ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function get Loan Maximum LTV ( uint256 loan Id ) external view virtual returns ( uint256 ) ;
event Redeem ( address redeemer , uint redeem Amount , uint redeem Tokens ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function set Approval For All ( address operator , bool approved ) external ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender controller , " ! controller " ) ; require ( reserve ! address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ; }
function yearn ( address strategy , address token , uint parts ) public { uint before IERC20 ( token ) . balance Of ( address ( this ) ) ; I Strategy ( strategy ) . withdraw ( token ) ; uint after IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint amount after . sub ( before ) ; address want I Strategy ( strategy ) . want ( ) ; uint [ ] memory distribution ; uint expected ; before IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( token ) . safe Approve ( onesplit , 0 ) ; IERC20 ( token ) . safe Approve ( onesplit , amount ) ; ( expected , distribution ) One Split Audit ( onesplit ) . get Expected Return ( token , want , amount , parts , 0 ) ; One Split Audit ( onesplit ) . swap ( token , want , amount , expected , distribution , 0 ) ; after IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( after > before ) { amount after . sub ( before ) ; uint reward amount . mul ( split ) . div ( max ) ; earn ( want , amount . sub ( reward ) ) ; IERC20 ( want ) . safe Transfer ( rewards , reward ) ; } } }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function convert Growth Reserve To Underlying ( Self storage self , uint256 input Amount ) internal
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function set Token Offering ( address offering Addr , uint256 amount For Sale ) external only Owner only Token Offering Addr Not Set { require ( ! transfer Enabled ) ; uint256 amount ( amount For Sale 0 ) ? TOKEN OFFERING ALLOWANCE : amount For Sale ; require ( amount < TOKEN OFFERING ALLOWANCE ) ; approve ( offering Addr , amount ) ; token Offering Addr offering Addr ; }
function init ( Self storage self , address reserve Token , address mining Token , address borrow Token , address growth Token ) public
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint amount ) ;
function buy Bancor Pool (
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function Context init ( ) internal initializer { Context init unchained ( ) ; }
function safe Honey Transfer ( uint256 pid , address to , uint256 amount ) internal { uint256 honey Bal honey . balance Of ( address ( this ) ) ; if ( honey Bal 0 ) { return ; } User Info storage user user Info [ pid ] [ to ] ; if ( amount > honey Bal ) { honey . transfer ( to , honey Bal ) ; user . earned user . earned . add ( honey Bal ) ; } else { honey . transfer ( to , amount ) ; user . earned user . earned . add ( amount ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function deposit ( uint256 cost ) public override non Reentrant
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update , bool taxable , uint256 start Block ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Beansprout Per Share : 0 , taxable : taxable } ) ) ; }
function divuu ( uint256 x , uint256 y ) private pure returns ( uint128 ) { require ( y ! 0 ) ; uint256 result ; if ( x < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) result ( x < < 64 ) y ; else { uint256 msb 192 ; uint256 xc x > > 192 ; if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore result ( x < < 255 msb ) ( ( y 1 > > msb 191 ) + 1 ) ; require ( result < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; uint256 hi result ( y > > 128 ) ; uint256 lo result ( y & 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; uint256 xh x > > 192 ; uint256 xl x < < 64 ; if ( xl < lo ) xh 1 ; We rely on overflow behavior here lo hi < < 128 ; if ( xl < lo ) xh 1 ; We rely on overflow behavior here assert ( xh hi > > 128 ) ; result + xl y ; } require ( result < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; return uint128 ( result ) ; }
function get Recovery Vault ( ) public view returns ( address ) { if kernel is not set , it will revert }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mul ( uq112x112 memory self , uint y ) internal pure returns ( uq144x112 memory ) { uint z ; require ( y 0 | | ( z uint ( self . x ) y ) y uint ( self . x ) , " Fixed Point : MULTIPLICATION OVERFLOW " ) ; return uq144x112 ( z ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mul ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { if ( a 0 ) { return 0 ; } uint64 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
event New Admin ( address old Admin , address new Admin ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function mul Exp3 ( Exp memory a , Exp memory b , Exp memory c ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err , Exp memory ab ) mul Exp ( a , b ) ; if ( err ! Math Error . NO ERROR ) { return ( err , ab ) ; } return mul Exp ( ab , c ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function allowance ( address token Owner , address spender ) public override view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
event Transfer ( address indexed from , address indexed to , uint amount ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public { safe Transfer From ( from , to , token Id , " " ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ from ] ) ; require ( value < allowed [ from ] [ msg . sender ] ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; Transfer ( from , to , value ) ; return true ; }
function allowance ( address owner , address spender ) public view returns ( uint256 remaining ) { return allowed [ owner ] [ spender ] ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Address ( Bytes32Set storage set , uint256 index )
function set Max In Progress Proposals ( uint16 new Max In Progress Proposals ) external { require Is Initialized ( ) ; require ( msg . sender address ( this ) , ERROR ONLY GOVERNANCE ) ; require ( new Max In Progress Proposals > 0 , " Governance : Requires non zero new Max In Progress Proposals " ) ; max In Progress Proposals new Max In Progress Proposals ; emit Max In Progress Proposals Updated ( new Max In Progress Proposals ) ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function calculate Rebase Delta ( bool limited )
function unpause ( ) only Owner when Paused public { paused false ; Unpause ( ) ; }
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function approve ( address spender , uint256 value ) public
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function update Remove Delegator Eval Duration ( uint256 duration ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; remove Delegator Eval Duration duration ; emit Remove Delegator Eval Duration Updated ( duration ) ; }
function disable Module ( address module ) external ;
function recover ERC20 ( address token Address , uint256 token Amount ) public only Owner { IERC20 ( token Address ) . transfer ( owner ( ) , token Amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
event Claim Added ( bytes32 indexed claim Id , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mint ( address account , uint256 amount )
function approve ( address spender , uint256 value ) returns ( bool success ) { }
function balance Of ( address account ) external view returns ( uint256 ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function bulk Transfer ( address [ ] calldata receivers , uint256 [ ] calldata amounts ) external { require ( receivers . length amounts . length ) ; for ( uint256 i 0 ; i < receivers . length ; i + + ) { transfer ( msg . sender , receivers [ i ] , amounts [ i ] ) ; } }
function deposit ( uint256 amount ) public { uint256 avail Funds controller . allowable Amount ( address ( this ) ) ; require ( amount < avail Funds , " exceed cont Allowance " ) ; controller . earn ( address ( this ) , amount ) ; uint256 bpt Token Amt musdc Bpt . joinswap Extern Amount In ( address ( want ) , amount , 0 ) ; m Pool . stake ( bpt Token Amt ) ; deposit MTA In Staking ( ) ; }
function rfind Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr )
function transfer ( address from , address to , uint256 token Id ) internal virtual { require ( owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; before Token Transfer ( from , to , token Id ) ; approve ( address ( 0 ) , token Id ) ; holder Tokens [ from ] . remove ( token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( from , to , token Id ) ; }
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else { return bonus End Block . sub ( from ) . add ( to . sub ( bonus End Block ) ) ; } }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function name ( ) public view returns ( string memory ) { return name ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
modifier when Paused ( ) { require ( paused ) ; ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
modifier only Pending Owner ( ) { require ( msg . sender pending Owner , " UNAUTHORIZED " ) ; ; }
function fund (
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { uint old Value allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] 0 ; } else { allowed [ msg . sender ] [ spender ] old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Unpaused ( address account ) ;
function eth Item ERC20Wrapper Model ( ) external view returns ( address eth Item ERC20Wrapper Model Address ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function mul Exp ( uint a , uint b ) pure internal returns ( Math Error , Exp memory ) { return mul Exp ( Exp ( { mantissa : a } ) , Exp ( { mantissa : b } ) ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) return 0 ; uint c a b ; require ( c a b , " multiplication overflow " ) ; return c ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function get Max Collateral ( address c Coll Address , address account ) public returns ( uint ) { ( , uint liquidity In Usd , ) Comptroller Interface ( COMPTROLLER ) . get Account Liquidity ( account ) ; uint users Balance C Token Interface ( c Coll Address ) . balance Of Underlying ( account ) ; address oracle Comptroller Interface ( COMPTROLLER ) . oracle ( ) ; if ( liquidity In Usd 0 ) return users Balance ; C Token Interface ( c Coll Address ) . accrue Interest ( ) ; ( , uint coll Factor Mantissa ) Comptroller Interface ( COMPTROLLER ) . markets ( c Coll Address ) ; Exp memory collateral Factor Exp ( { mantissa : coll Factor Mantissa } ) ; ( , uint tokens To Usd ) div Scalar By Exp Truncate ( liquidity In Usd , collateral Factor ) ; uint usd Price Compound Oracle Interface ( oracle ) . get Underlying Price ( c Coll Address ) ; uint liq In Token wdiv ( tokens To Usd , usd Price ) ; if ( liq In Token > users Balance ) return users Balance ; cut off 1 % due to rounding issues }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function sub ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint128 c a b ; return c ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function total Supply ( ) public constant returns ( uint ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . total Supply ( ) ; } else { return total Supply ; } }
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { uint old Value allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] 0 ; } else { allowed [ msg . sender ] [ spender ] old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { Solidity only automatically asserts when dividing by 0 uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function name ( ) public view returns ( string memory ) { return name ; }
function get Dai Address ( )
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
event Approval ( address indexed owner , address indexed spender , uint amount ) ;
function transfer From (
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function unbind Token ( address token ) external ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div Scalar By Exp Truncate ( uint scalar , Exp memory divisor ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory fraction ) div Scalar By Exp ( scalar , divisor ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return ( Math Error . NO ERROR , truncate ( fraction ) ) ; }
modifier check Contract ( address account ) { if ( ! accept Contract Depositor & & ! whitelisted Contract [ account ] & & ( account ! vault Master . bank ( address ( this ) ) ) ) { require ( ! address ( account ) . is Contract ( ) & & account tx . origin , " contract not support " ) ; } ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function draw ( ) external { require ( msg . sender tx . origin ) ; require ( euler Balances [ msg . sender ] > eulers Fused , " Eulers are not enough . " ) ; euler Balances [ msg . sender ] euler Balances [ msg . sender ] . sub ( eulers Fused ) ; uint256 rwid draw ( ) ; update Enft ( rwid , 1 ) ; add User Enft ( msg . sender , rwid , 1 ) ; emit Reward ( msg . sender , rwid ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Most Premium ( )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function symbol ( ) external view returns ( string memory ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address from , address to , uint256 value ) internal { balance Of [ from ] balance Of [ from ] . sub ( value ) ; balance Of [ to ] balance Of [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function add Reward ( address protocol , address token , uint256 epoch , uint256 amount ) internal { Protocol Rewards storage r rewards [ protocol ] ; Reward Info storage ri r . reward Info [ token ] ; uint256 epochs Length ri . epochs . length ; require ( epochs Length > 0 , " Reward Vesting : protocol or token not registered " ) ; creating a new epoch if ( epoch epochs Length ) { uint256 epoch End ri . epochs [ epochs Length 1 ] . end . add ( default Epoch Length ) ; This generally should not happen , but just in case we generate only one epoch since previous end ri . epochs . push ( Epoch ( { end : epoch End , amount : amount } ) ) ; } else { require ( epochs Length > epoch , " Reward Vesting : epoch is too high " ) ; Epoch storage ep ri . epochs [ epoch ] ; require ( ep . end > block . timestamp , " Reward Vesting : epoch already finished " ) ; ep . amount ep . amount . add ( amount ) ; } emit Epoch Reward Added ( protocol , token , epoch , amount ) ; IERC20 ( token ) . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; }
modifier if Admin ( ) { if ( msg . sender admin ( ) ) { ; } else { fallback ( ) ; } }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function from Bytes ( bytes memory b ) internal pure returns ( buffer memory ) { buffer memory buf ; buf . buf b ; buf . capacity b . length ; return buf ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function get Interest Rate By Dmm Token Id ( uint dmm Token Id ) external view returns ( uint ) ;
function is Reward Allocation Active ( ) external view returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function set Exchange ( Self storage self , address exchange ) public
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function approve ( ) public { wbtc . safe Approve ( address ( pool ) , uint ( 1 ) ) ; wbtc . safe Approve ( address ( settlement Fee Recipient ) , uint ( 1 ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function gavg ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 m int256 ( x ) int256 ( y ) ; require ( m > 0 ) ; require ( m < 0x4000000000000000000000000000000000000000000000000000000000000000 ) ; return int128 ( sqrtu ( uint256 ( m ) , uint256 ( x ) + uint256 ( y ) > > 1 ) ) ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function view Raw Amount ( int128 amount ) public view returns ( uint256 amount ) { uint256 rate cusdc . exchange Rate Stored ( ) ; uint256 supply Rate cusdc . supply Rate Per Block ( ) ; uint256 prev Block cusdc . accrual Block Number ( ) ; rate + rate supply Rate ( block . number prev Block ) 1e18 ; amount ( amount . mulu ( 1e6 ) 1e18 ) rate ; }
function get Committee ( ) external override view returns ( address [ ] memory committee , uint256 [ ] memory weights , address [ ] memory orbs Addrs , bool [ ] memory certification , bytes4 [ ] memory ips ) { I Guardians Registration guardian Registration Contract guardian Registration Contract ; ( committee , weights , certification ) committee Contract . get Committee ( ) ; orbs Addrs guardian Registration Contract . get Guardians Orbs Address ( committee ) ; ips guardian Registration Contract . get Guardian Ips ( committee ) ; }
function set Governance ( address governance ) public { require ( msg . sender governance , " not governance " ) ; governance governance ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function get Max ( uint64 [ ] storage self ) public view returns ( uint64 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 4 ) ) ) remainder : mod ( i , 4 ) for { let j : 0 } lt ( j , mul ( remainder , 2 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x000000000000000000000000000000000000000000000000ffffffffffffffff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Block Number ( ) internal view returns ( uint ) { return block . number ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function set Storage Cumulative Locked Up Value ( address addr , uint256 value )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function to Uint8 ( uint256 value ) internal pure returns ( uint8 ) { require ( value < 2 8 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return uint8 ( value ) ; }
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; before Token Transfer ( address ( 0 ) , to , token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function credit Available ( ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function is Equal ( Unsigned memory a , uint256 b ) internal pure returns ( bool ) { return a . raw Value from Unscaled Uint ( b ) . raw Value ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function reserve Token ( ) external view returns ( address reserve Token ) ;
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint256 c a b ; return c ; }
function owner Withdraw Extra Tokens ( Vesting Storage storage self , Crowdsale Token token ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now > self . end Time ) ; require ( self . is Token ) ; uint256 contract Balance token . balance Of ( this ) ; self . contract Balance 0 ; token . transfer ( self . owner , contract Balance ) ; Log Tokens Withdrawn ( self . owner , contract Balance ) ; return true ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function set Vote Times ( address addr ) external only Owner { vote Times addr ; }
function is Operator ( address operator , address token Holder ) internal view returns ( bool ) { return ( operator token Holder | | authorized Operator [ operator ] [ token Holder ] | | ( is Controllable & & is Controller [ operator ] ) ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
modifier if Admin ( ) { if ( msg . sender get Admin ( ) ) { ; } else { fallback ( ) ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function view Shell ( ) external view returns (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function oracle Symbols ( ) external view returns ( bytes32 [ ] memory ) ;
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function at ( Address Set storage set , uint256 index )
function contains ( Bytes32Set storage set , bytes32 value )
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function increase Approval ( address spender , uint added Value ) public
function unstake ( uint256 amount , uint256 gysr )
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; require ( ! paused ( ) , " ERC20Pausable : token transfer while paused " ) ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
event New Borrow Cap ( address indexed token , uint new Borrow Cap ) ;
function transfer Tokens ( address spender , address src , address dst , uint tokens ) internal returns ( uint ) { Fail if transfer not allowed uint allowed comptroller . transfer Allowed ( address ( this ) , src , dst , tokens ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . COMPTROLLER REJECTION , Failure Info . TRANSFER COMPTROLLER REJECTION , allowed ) ; } Do not allow self transfers if ( src dst ) { return fail ( Error . BAD INPUT , Failure Info . TRANSFER NOT ALLOWED ) ; } Get the allowance , infinite for the account owner uint starting Allowance 0 ; if ( spender src ) { starting Allowance uint ( 1 ) ; } else { starting Allowance transfer Allowances [ src ] [ spender ] ; } Do the calculations , checking for { under , over } flow Math Error math Err ; uint allowance New ; uint src Tokens New ; uint dst Tokens New ; ( math Err , allowance New ) sub U Int ( starting Allowance , tokens ) ; if ( math Err ! Math Error . NO ERROR ) { return fail ( Error . MATH ERROR , Failure Info . TRANSFER NOT ALLOWED ) ; } ( math Err , src Tokens New ) sub U Int ( account Tokens [ src ] , tokens ) ; if ( math Err ! Math Error . NO ERROR ) { return fail ( Error . MATH ERROR , Failure Info . TRANSFER NOT ENOUGH ) ; } ( math Err , dst Tokens New ) add U Int ( account Tokens [ dst ] , tokens ) ; if ( math Err ! Math Error . NO ERROR ) { return fail ( Error . MATH ERROR , Failure Info . TRANSFER TOO MUCH ) ; } account Tokens [ src ] src Tokens New ; account Tokens [ dst ] dst Tokens New ; Eat some of the allowance ( if necessary ) if ( starting Allowance ! uint ( 1 ) ) { transfer Allowances [ src ] [ spender ] allowance New ; } We emit a Transfer event emit Transfer ( src , dst , tokens ) ; comptroller . transfer Verify ( address ( this ) , src , dst , tokens ) ; return uint ( Error . NO ERROR ) ; }
function staking Token ( ) external virtual view returns ( address ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function push Collected Fund Given In ( address token In , uint token Amount In ) internal returns ( uint collected Fee Amount ) { collected Fee Amount 0 ; if ( collected Fee > 0 ) { address collected Token IB Factory ( factory ) . collected Token ( ) ; if ( collected Token ! address ( 0 ) ) { collected Fee Amount bdiv ( bmul ( token Amount In , collected Fee ) , B Const . BONE ) ; push Underlying ( token In , factory , collected Fee Amount ) ; emit LOG COLLECTED FUND ( token In , collected Fee Amount ) ; } } }
function erc1155Wrapper Model ( ) external view returns ( address erc1155Wrapper Model Address , uint256 erc1155Wrapper Model Version ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function is Valid Signature (
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mint ( address to , uint256 amount ) public only Bartender { mint ( to , amount ) ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function balance Of ( address owner ) external view returns ( uint256 balance ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function repay Borrow Allowed (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function is Batch Eligible For Early Bonus ( address staker , uint256 batch Number , uint256 pair Code )
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function deposit For ( address deposit For , uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ deposit For ] ; mass Update Pools ( ) ; Update the balances of person that amount is being deposited for if ( amount > 0 ) { pool . token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; This is deposited For address } This is deposited for address emit Deposit ( deposit For , pid , amount ) ; }
function get Personal Stake For Addresses ( address address ) external view returns ( address [ ] ) { address [ ] memory staked For ; ( , , staked For ) get Personal Stakes ( address ) ; return staked For ; }
function owner Of ( uint256 token Id ) public view returns ( address owner ) ;
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function fraction ( uint112 numerator , uint112 denominator ) internal pure returns ( uq112x112 memory ) { require ( denominator > 0 , " Fixed Point : DIV BY ZERO " ) ; return uq112x112 ( ( uint224 ( numerator ) < < 112 ) denominator ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function delegates ( address delegator )
function set Reserve Factor ( uint new Reserve Factor Mantissa ) external non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . SET RESERVE FACTOR ACCRUE INTEREST FAILED ) ; } return set Reserve Factor Fresh ( new Reserve Factor Mantissa ) ; }
function deposit (
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function mint Fresh ( address minter , uint mint Amount ) internal returns ( uint ) { Fail if mint not allowed uint allowed comptroller . mint Allowed ( address ( this ) , minter , mint Amount ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . COMPTROLLER REJECTION , Failure Info . MINT COMPTROLLER REJECTION , allowed ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return fail ( Error . MARKET NOT FRESH , Failure Info . MINT FRESHNESS CHECK ) ; } Mint Local Vars memory vars ; Fail if check Transfer In fails vars . err check Transfer In ( minter , mint Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . MINT TRANSFER IN NOT POSSIBLE ) ; } We get the current exchange rate and calculate the number of c Tokens to be minted : mint Tokens mint Amount exchange Rate ( vars . math Err , vars . exchange Rate Mantissa ) exchange Rate Stored Internal ( ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT EXCHANGE RATE READ FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . mint Tokens ) div Scalar By Exp Truncate ( mint Amount , Exp ( { mantissa : vars . exchange Rate Mantissa } ) ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT EXCHANGE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We calculate the new total supply of c Tokens and minter token balance , checking for overflow : total Supply New total Supply + mint Tokens account Tokens New account Tokens [ minter ] + mint Tokens ( vars . math Err , vars . total Supply New ) add U Int ( total Supply , vars . mint Tokens ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT NEW TOTAL SUPPLY CALCULATION FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . account Tokens New ) add U Int ( account Tokens [ minter ] , vars . mint Tokens ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT NEW ACCOUNT BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We call do Transfer In for the minter and the mint Amount Note : The c Token must handle variations between ERC 20 and ETH underlying . On success , the c Token holds an additional mint Amount of cash . If do Transfer In fails despite the fact we checked pre conditions , we revert because we can ' t be sure if side effects occurred . vars . err do Transfer In ( minter , mint Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . MINT TRANSFER IN FAILED ) ; } We write previously calculated values into storage total Supply vars . total Supply New ; account Tokens [ minter ] vars . account Tokens New ; We emit a Mint event , and a Transfer event emit Mint ( minter , mint Amount , vars . mint Tokens ) ; emit Transfer ( address ( this ) , minter , vars . mint Tokens ) ; We call the defense hook comptroller . mint Verify ( address ( this ) , minter , mint Amount , vars . mint Tokens ) ; return uint ( Error . NO ERROR ) ; }
function transfer Admin Quickly ( address new Admin ) public only Admin { require ( new Admin ! address ( 0 ) ) ; Transfer Admin Pending ( new Admin ) ; Admin Claimed ( new Admin , admin ) ; admin new Admin ; }
function owner ( ) public view returns ( address ) { return owner ; }
function is Contract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( addr ) } return size > 0 ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function set Halt ( bool halt )
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function get Swap Path Of Btf ( ) public view returns ( address [ ] memory ) { address [ ] memory path ; if ( swap Usdc For Btf ) { path new address [ ] ( 3 ) ; path [ 0 ] weth ; path [ 1 ] usdc ; path [ 2 ] btf ; } else { path new address [ ] ( 2 ) ; path [ 0 ] weth ; path [ 1 ] btf ; } return path ; }
function concat ( slice memory self , slice memory other ) internal pure returns ( string memory ) { string memory ret new string ( self . len + other . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; memcpy ( retptr + self . len , other . ptr , other . len ) ; return ret ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function set Implementation ( address new Implementation ) internal { require ( Open Zeppelin Upgrades Address . is Contract ( new Implementation ) , " Cannot set a proxy implementation to a non contract address " ) ; bytes32 slot IMPLEMENTATION SLOT ; assembly { sstore ( slot , new Implementation ) } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function signer To Validator ( address validator Address )
function sub (
function finish Minting ( ) only Owner public returns ( bool ) { minting Finished true ; Mint Finished ( ) ; return true ; }
function compare ( slice memory self , slice memory other ) internal pure returns ( int ) { uint shortest self . len ; if ( other . len < self . len ) shortest other . len ; uint selfptr self . ptr ; uint otherptr other . ptr ; for ( uint idx 0 ; idx < shortest ; idx + 32 ) { uint a ; uint b ; assembly { a : mload ( selfptr ) b : mload ( otherptr ) } if ( a ! b ) { 0xffff . . . if ( shortest < 32 ) { mask ~ ( 2 ( 8 ( 32 shortest + idx ) ) 1 ) ; } uint256 diff ( a & mask ) ( b & mask ) ; if ( diff ! 0 ) return int ( diff ) ; } selfptr + 32 ; otherptr + 32 ; } return int ( self . len ) int ( other . len ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function get Amount Out ( uint256 amount In , uint256 reserve In , uint256 reserve Out ) internal returns ( uint256 amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee amount In . mul ( 997 ) ; uint numerator amount In With Fee . mul ( reserve Out ) ; uint denominator reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out numerator denominator ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer ( address dst , uint256 amount ) external ;
function check On ERC721Received ( address from , address to , uint256 token Id , bytes memory data ) private returns ( bool )
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function Pending Reward ( address caller ) public view returns ( uint256 pending Reward Weis ) { uint256 total Staking Time now . sub ( users [ caller ] . last Claimed Date ) ; added extra 10 ^ 21 remove extra 10 ^ 21 return reward . add ( users [ caller ] . pending Gains ) ; }
function abs ( int128 x ) internal pure returns ( int128 ) { require ( x ! MIN 64x64 ) ; return x < 0 ? x : x ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public { safe Transfer From ( from , to , token Id , " " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) ) ; return role . bearer [ account ] ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function Transfer Function Types ( uint [ ] memory arr ) internal pure returns ( Transfer Function Type [ ] memory t ) { t new Transfer Function Type [ ] ( arr . length ) ; for ( uint i 0 ; i < t . length ; i + + ) { t [ i ] Transfer Function Type ( arr [ i ] ) ; } }
function get Decrease Stake Lockup Duration ( )
function is Contract ( address addr ) constant internal returns ( bool ) { uint size ; if ( addr 0 ) return false ; assembly { size : extcodesize ( addr ) } return size > 0 ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function write Length ( bytes memory b , uint256 length )
modifier when Not Paused ( ) { require ( ! paused ) ; ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function pause ( ) only Owner when Not Paused returns ( bool ) { paused true ; Pause ( ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function add Liquidity ( I Pool pool , uint256 dai Used , uint256 max FY Dai ) public returns ( uint256 ) { only Known Pool ( pool ) ; IFY Dai fy Dai pool . fy Dai ( ) ; require ( fy Dai . is Mature ( ) ! true , " Yield Proxy : Only before maturity " ) ; require ( dai . transfer From ( msg . sender , address ( this ) , dai Used ) , " Yield Proxy : Transfer Failed " ) ; uint256 dai Reserves dai . balance Of ( address ( pool ) ) ; uint256 fy Dai Reserves fy Dai . balance Of ( address ( pool ) ) ; uint256 dai To Add dai Used . mul ( dai Reserves ) . div ( fy Dai Reserves . add ( dai Reserves ) ) ; uint256 dai To Convert dai Used . sub ( dai To Add ) ; require ( dai To Convert < max FY Dai , " Yield Proxy : max FY Dai exceeded " 1 Dai 1 fy Dai chai . join ( address ( this ) , dai To Convert ) ; uint256 to Borrow chai . dai ( address ( this ) ) ; controller . post ( CHAI , address ( this ) , msg . sender , chai . balance Of ( address ( this ) ) ) ; controller . borrow ( CHAI , fy Dai . maturity ( ) , msg . sender , address ( this ) , to Borrow ) ; return pool . mint ( address ( this ) , msg . sender , dai To Add ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender )
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function symbol ( ) external view returns ( string memory ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function normalize Payback Amount ( address vat , address urn , bytes32 ilk ) internal view returns ( int amount ) { uint dai Vat ( vat ) . dai ( urn ) ; ( , uint rate , , , ) Vat ( vat ) . ilks ( ilk ) ; ( , uint art ) Vat ( vat ) . urns ( ilk , urn ) ; amount to Positive Int ( dai rate ) ; amount uint ( amount ) < art ? amount : to Positive Int ( art ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mint (
function renew Hold ( address token , bytes32 hold Id , uint256 time To Expiration , bytes calldata certificate ) external returns ( bool ) { return renew Hold ( token , hold Id , compute Expiration ( time To Expiration ) , certificate ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Borrows Current ( ) external returns ( uint ) { delegate And Return ( ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function mint ( address account , uint256 amount ) public only Minter returns ( bool ) { mint ( account , amount ) ; return true ; }
function update Locker Settings (
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mint
function initialization Admin ( ) public view returns ( address ) { return initialization Admin ; }
function get Staking Address ( ) external view returns ( address )
function available Funds ( )
function total Supply ( ) public view returns ( uint256 ) { return total Supply At ( block . number ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
event Unpaused ( address account ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function token ( ) public view returns ( IERC20 ) { return token ; }
modifier upkeep ( ) { require ( LK3R . is Locker ( msg . sender ) , " : : is Locker : locker is not registered " ) ; ; LK3R . worked ( msg . sender ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) public pure override returns ( uint256 cost )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function is Greater Than ( Unsigned memory a , Unsigned memory b ) internal pure returns ( bool ) { return a . raw Value > b . raw Value ; }
function perform Strategy Step2 ( bytes calldata dexag Swap Data , address swap Stablecoin ) external only Defi Operator { uint256 crv Amount IERC20 ( crv Token ) . balance Of ( address ( this ) ) ; IERC20 ( crv Token ) . safe Approve ( dexag Approve Handler , crv Amount ) ; ( bool success , bytes memory result ) dexag Proxy . call ( dexag Swap Data ) ; if ( ! success ) assembly { Reverts with same revert reason } uint256 amount IERC20 ( swap Stablecoin ) . balance Of ( address ( this ) ) ; IERC20 ( swap Stablecoin ) . safe Transfer ( vault , amount ) ; }
function last Release Time ( ) public view returns ( uint256 ) { return last Release Time ; }
function name ( ) public view returns ( string memory ) { return name ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function get Admin ( )
function withdraw ( uint256 pid , uint256 amount ) public { withdraw ( pid , amount , msg . sender , msg . sender ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function initialize ( address governance Address ) public initializer
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function initialize ( address sender ) public initializer { owner sender ; emit Ownership Transferred ( address ( 0 ) , owner ) ; }
modifier only Version Manager ( ) { require ( msg . sender address ( version Manager ) , " BF : caller must be Version Manager " ) ; ; }
function gentle Sub ( uint256 a , uint256 b ) private pure returns ( uint256 ) { if ( a < b ) return 0 ; else return a b ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function safe Bento Transfer ( address to , uint256 amount ) internal { uint256 bento Bal bento . balance Of ( address ( this ) ) ; if ( amount > bento Bal ) { bento . transfer ( to , bento Bal ) ; } else { bento . transfer ( to , amount ) ; } }
function decode144 ( uq144x112 memory self ) internal pure returns ( uint144 ) { return uint144 ( self . x > > RESOLUTION ) ; }
function unwrap ( uint256 amount ) internal returns ( bool success )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function freezing Count ( address addr ) public view returns ( uint count ) { uint64 release chains [ to Key ( addr , 0 ) ] ; while ( release ! 0 ) { count + + ; release chains [ to Key ( addr , release ) ] ; } }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function delegates ( address delegator )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Fee ( uint amount , uint gas Cost , address owner ) internal returns ( uint fee Amount ) { uint fee MANUAL SERVICE FEE ; if ( Bot Registry ( BOT REGISTRY ADDRESS ) . bot List ( tx . origin ) ) { fee AUTOMATIC SERVICE FEE ; } if ( Discount ( DISCOUNT ADDRESS ) . is Custom Fee Set ( owner ) ) { fee Discount ( DISCOUNT ADDRESS ) . get Custom Service Fee ( owner ) ; } fee Amount ( fee 0 ) ? 0 : ( amount fee ) ; if ( gas Cost ! 0 ) { uint eth Dai Price get Price ( ETH ILK ) ; gas Cost rmul ( gas Cost , eth Dai Price ) ; fee Amount add ( fee Amount , gas Cost ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } ERC20 ( DAI ADDRESS ) . transfer ( WALLET ID , fee Amount ) ; }
function Forwarder ( ) public { parent Address msg . sender ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg . sender , recipient , amount ) ; return true ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function token By Index ( uint256 index ) public view override returns ( uint256 ) { ( uint256 token Id , ) token Owners . at ( index ) ; return token Id ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
event Productivity Increased ( address indexed user , uint value ) ;
function decrease Approval (
function num Managers ( )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function burn ( uint256 value ) public returns ( bool success ) { Check if the sender has enough Subtract from the sender Updates total Supply emit Burn ( msg . sender , value ) ; return true ; }
function get Settings ( ) external override view returns (
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function get Unlockable Tokens ( address of )
function borrow ( address ctoken , uint256 amount ) internal returns ( bool success )
function set Owner ( address new Owner ) external ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function get ( Uint To Address Map storage map , uint256 key , string memory error Message ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) , error Message ) ) ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function liquidate ( uint256 id ) external ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { uint256 sell Tax Amount ; if ( spender UNI Weth Pool Address ) { sell Tax Amount amount . mul ( max Fee ) . div ( 100 ) ; } approve ( msg Sender ( ) , spender , amount . add ( sell Tax Amount ) ) ; return true ; }
function announce Token Percent Transfer ( Self storage self , address source Token , address target Token , uint256 percent ) public
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function burn Super Admin ( ) public virtual only Super Admin { emit Super Admin Transfered ( super Admin , address ( 0 ) ) ; super Admin address ( 0 ) ; }
function mint ( address to , uint256 amount ) external ;
function withdraw From Deposit Request (
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc WOLF Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe WOLF Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc WOLF Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function borrow Internal ( uint borrow Amount ) internal non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . BORROW ACCRUE INTEREST FAILED ) ; } return borrow Fresh ( msg . sender , borrow Amount ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function tok Usd Price ( string calldata symbol )
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function calc Withdrawal Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) public pure override returns ( uint256 gross Shares , uint256 fee Shares )
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function safe Transfer ( address from , address to , uint256 token Id , bytes memory data ) internal virtual { transfer ( from , to , token Id ) ; require ( check On ERC721Received ( from , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function multi Handler Sweep ( address [ ] memory handlers , IERC20 token Contract ) public { for ( uint i 0 ; i < handlers . length ; i + + ) { require ( handler Map [ handlers [ i ] ] , " Only payment handlers are valid sweep targets . " ) ; Payment Handler ( address ( uint160 ( handlers [ i ] ) ) ) . sweep Tokens ( token Contract ) ; } }
function us mul ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y > > 64 ; return int128 ( result ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function set ( Uint To Address Map storage map , uint256 key , address value ) internal returns ( bool ) { return set ( map . inner , bytes32 ( key ) , bytes32 ( uint256 ( value ) ) ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function mint (
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function owner ( ) public view returns ( address ) { return owner ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function cancel Pool Migration ( Self storage self ) public returns ( address migration Recipient )
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
event New Deviation Threshold (
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function set DIP4Genesis Block ( uint256 block ) external only Owner { Validates the value is not set . require ( get Storage DIP4Genesis Block ( ) 0 , " already set the value " ) ; Sets the value . set Storage DIP4Genesis Block ( block ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function create Liquidation (
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ; }
function sub ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b < a , error Message ) ; uint c a b ; return c ; }
function safe Mint ( address to , uint256 token Id , bytes memory data ) internal virtual { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function full Balance Of ( address account ) public view returns ( uint256 ) { Token itself only holds tokens for others uint256 distribution Balance distribution Balance Of ( account ) ; uint256 unclaimed calculate Claim Amount ( account ) ; return distribution Balance . add ( unclaimed ) ; }
function delegate By Sig (
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } if ( withdrawal Fee > 0 ) { uint256 fee amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( token ) . safe Transfer ( I Controller ( controller ) . com Addr ( ) , fee ) ; amount amount . sub ( fee ) ; } address vault I Controller ( controller ) . vaults ( address ( token ) ) ; require ( vault ! address ( 0 ) , " ! vault " ) ; IERC20 ( token ) . safe Transfer ( vault , amount ) ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public virtual override { safe Transfer From ( from , to , token Id , " " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function Context init ( ) internal initializer { Context init unchained ( ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function total Supply ( ) external view returns ( uint256 ) ;
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) public view returns ( uint remaining ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . allowance ( owner , spender ) ; } else { return super . allowance ( owner , spender ) ; } }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function burn ( address to ) external lock returns ( uint256 amount0 , uint256 amount1 ) { gas savings gas savings gas savings uint256 balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint256 balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; bool fee On mint Fee ( reserve0 , reserve1 ) ; { uint256 liquidity balance Of [ address ( this ) ] ; gas savings , must be defined here since total Supply can update in mint Fee using balances ensures pro rata distribution using balances ensures pro rata distribution require ( amount0 > 0 & & amount1 > 0 , " Sake Swap : INSUFFICIENT LIQUIDITY BURNED " ) ; burn ( address ( this ) , liquidity ) ; } safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; reserve0 and reserve1 are up to date emit Burn ( msg . sender , amount0 , amount1 , to ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Pool Manager Fee ( address pool ) external view returns ( uint256 , uint256 ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function redeem Underlying ( uint redeem Amount ) external returns ( uint ) { return redeem Underlying Internal ( redeem Amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
event Closing Time Change ( uint previous , uint current ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function register Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function migrate Guardians ( address [ ] calldata guardians To Migrate , I Guardians Registration previous Contract ) external only Initialization Admin ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function abs ( int256 a )
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod (
function withdraw Stuck Funds ( address token , uint amount ) public only Owner { if ( token 0x Eeeee Eeee Ee Eee Ee Ee Eee EE Eeeee Eeeeeeee E Ee E ) { payable ( owner ) . transfer ( amount ) ; } else { ERC20 ( token ) . safe Transfer ( owner , amount ) ; } }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; require ( is Contract ( target ) , " Address : call to non contract " ) ; ( bool success , bytes memory returndata ) target . call { value : value } ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( ERC165 , IERC165 ) returns ( bool ) { return interface Id type ( IERC1155Receiver ) . interface Id | | super . supports Interface ( interface Id ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function token ( ) external override view returns ( address ) { return address ( staking Pool . token ( ) ) ; }
function unpause ( ) public only Pauser when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function get Asset Count ( ) public view returns ( uint256 ) { return all Assets . length ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction underflow " ) ; }
function get Mining State ( uint block Num ) public view returns ( uint , uint ) { require ( block Num > mining State Block , " block Num must be > mining State Block " ) ; uint block Number block Num ; if current block . number is bigger than the end of program , only update the state to end Mining Block Num block Number end Mining Block Num ; } uint delta Blocks block Number . sub ( mining State Block ) ; uint mining State Block mining State Block ; uint mining State Index mining State Index ; if ( delta Blocks > 0 & & total Staked > 0 ) { uint tad Accrued delta Blocks . mul ( tad Per Block ) ; multiple ratio to 1e18 to prevent rounding error index is 1e18 precision mining State Block block Number ; } return ( mining State Index , mining State Block ) ; }
function allowance ( address owner , address spender ) external view
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function share Milk ( address taker ) external returns ( uint256 ) ;
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function is Available ( bytes32 subnode ) public view override returns ( bool ) { bytes32 node keccak256 ( abi . encode Packed ( root Node , subnode ) ) ; address current Owner get ENS Registry ( ) . owner ( node ) ; if ( current Owner address ( 0 ) ) { return true ; } return false ; }
function token Percent ( address token ) public view override returns ( uint256 percent )
function get Pending Update Deployer Cut Request ( address service Provider )
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function set Mining Gulp Range ( uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount ) public override only Owner non Reentrant
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function deposit ( uint256 cost ) external ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update , uint256 last Reward Block ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } if ( block . number < start Block ) { if ( last Reward Block 0 ) { last Reward Block start Block ; } else { if ( last Reward Block < start Block ) { last Reward Block start Block ; } } } else { if ( last Reward Block 0 | | last Reward Block < block . number ) { last Reward Block block . number ; } } bool is Started ( last Reward Block < start Block ) | | ( last Reward Block < block . number ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Yax Per Share : 0 , is Started : is Started } ) ) ; if ( is Started ) { total Alloc Point total Alloc Point . add ( alloc Point ) ; } }
function balance Of ( address account ) external view returns ( uint256 ) ;
function get Amount Out (
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external override lock { require ( amount0Out > 0 | | amount1Out > 0 , ' W Swap : INSUFFICIENT OUTPUT AMOUNT ' ) ; gas savings require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' W Swap : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; scope for token { 0 , 1 } , avoids stack too deep errors address token0 token0 ; address token1 token1 ; require ( to ! token0 & & to ! token1 , ' W Swap : INVALID TO ' ) ; optimistically transfer tokens optimistically transfer tokens if ( data . length > 0 ) IWS Callee ( to ) . wb Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' W Swap : INSUFFICIENT INPUT AMOUNT ' ) ; scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors uint balance0Adjusted balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' W Swap : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function withdraw All To Vault ( ) external restricted { Gauge ( gauge ) . withdraw ( Gauge ( gauge ) . balance Of ( address ( this ) ) ) ; mix To WBTC ( uint256 ( ~ 0 ) ) ; uint256 actual Balance IERC20 ( wbtc ) . balance Of ( address ( this ) ) ; if ( actual Balance > 0 ) { IERC20 ( wbtc ) . safe Transfer ( vault , actual Balance ) ; } }
function admin ( ) internal view returns ( address adm ) { bytes32 slot ADMIN SLOT ; assembly { adm : sload ( slot ) } }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function get Total Delegated Stake ( ) external override view returns ( uint256 ) { return total Delegated Stake ; }
function calculate Withdrawable Interest Amount (
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
modifier only Owner ( ) { require ( msg . sender owner ) ; ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function cancel Proposal ( uint256 proposal Id ) external non Reentrant { Proposal storage proposal proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] 0 , " cancelled " ) ; require ( msg . sender proposal . proposer , " ! proposer " ) ; cancelled unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Rebalance Margins ( ) public view override returns ( uint256 liquid Rebalance Margin , uint256 portfolio Rebalance Margin )
function check EIN ( address address ) public returns ( uint ) { Snowflake Interface snowfl Snowflake Interface ( snowflake Address ) ; Identity Registry Interface id Registry Identity Registry Interface ( snowfl . identity Registry Address ( ) ) ; uint Ein id Registry . get EIN ( address ) ; return Ein ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function set Withdrawal Limit Balance (
modifier only Core { require ( core msg . sender , " PR01 " ) ; ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function mod ( uint a , uint b ) internal pure returns ( uint ) { return mod ( a , b , " mod : % " ) ; }
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function cut ( uint256 value ) public view returns ( uint256 ) { uint256 c value . add ( base Percent ) ; uint256 d c . sub ( 1 ) ; uint256 round Value d . div ( base Percent ) . mul ( base Percent ) ; uint256 cut Value round Value . mul ( base Percent ) . div ( 10000 ) ; return cut Value ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function owner Of ( uint256 token Id ) external view returns ( address owner ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From (
function allowance ( Tellor Storage . Tellor Storage Struct storage self , address user , address spender ) public view returns ( uint256 ) { return self . allowed [ user ] [ spender ] ; }
function implementation ( ) public view virtual returns ( address ) ;
function borrowing Reserve Underlying ( ) public view virtual override returns ( uint256 borrowing Reserve Underlying )
event Unpaused ( address account ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Fee ( uint amount , address user , uint gas Cost , address token Addr ) internal returns ( uint fee Amount ) { address price Oracle Address I Lending Pool Addresses Provider ( AAVE LENDING POOL ADDRESSES ) . get Price Oracle ( ) ; uint fee MANUAL SERVICE FEE ; if ( Bot Registry ( BOT REGISTRY ADDRESS ) . bot List ( tx . origin ) ) { fee AUTOMATIC SERVICE FEE ; } if ( Discount ( DISCOUNT ADDR ) . is Custom Fee Set ( user ) ) { fee Discount ( DISCOUNT ADDR ) . get Custom Service Fee ( user ) ; } fee Amount ( fee 0 ) ? 0 : ( amount fee ) ; if ( gas Cost ! 0 ) { uint256 price I Price Oracle Getter Aave ( price Oracle Address ) . get Asset Price ( token Addr ) ; gas Cost wdiv ( gas Cost , price ) ( 10 ( 18 get Decimals ( token Addr ) ) ) ; fee Amount add ( fee Amount , gas Cost ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } if ( token Addr ETH ADDR ) { WALLET ADDR . transfer ( fee Amount ) ; } else { ERC20 ( token Addr ) . safe Transfer ( WALLET ADDR , fee Amount ) ; } }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; 5 % city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function function Call With Value (
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function pendingfuel ( uint256 pid , address user )
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function deposit Underlying ( uint256 underlying Cost ) external ;
function get Effective Stake ( address guardian ) external override view returns ( uint effective Stake ) { return get Guardian Effective Stake ( guardian , settings ) ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function approve ( address spender , uint256 value ) returns ( bool success ) { }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function eth To Weth Addr ( address src ) internal pure returns ( address ) { return src KYBER ETH ADDRESS ? WETH ADDRESS : src ; }
modifier non Reentrant ( ) { guard Counter + 1 ; uint256 local Counter guard Counter ; ; require ( local Counter guard Counter , " Reentrancy Guard : reentrant call " ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) ) ; return role . bearer [ account ] ; }
function name ( ) public view returns ( string memory ) { return name ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function initialize ( address sender ) public initializer { owner sender ; emit Ownership Transferred ( address ( 0 ) , owner ) ; }
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer Whitelist ( address user ) public only Owner returns ( bool ) { trans Whitelist [ user ] true ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function delete Liquidation ( address integration )
function burn ( uint256 value ) public { require ( value < balances [ msg . sender ] ) ; address burner msg . sender ; balances [ burner ] balances [ burner ] . sub ( value ) ; total Supply total Supply . sub ( value ) ; emit Burn ( burner , value ) ; emit Transfer ( burner , address ( 0 ) , value ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function owner ( ) public view returns ( address ) { return owner ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer Ownership ( address new Owner ) public virtual { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
event Reserves Added ( address benefactor , uint add Amount , uint new Total Reserves ) ;
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) public pure override returns ( uint256 cost )
function withdraw ( uint256 amount ) public override { require ( amount > 0 , " Cannot withdraw 0 " ) ; update Reward ( msg . sender ) ; super . withdraw ( amount ) ; if ( boost Level [ msg . sender ] > 0 ) { uint256 prev Balances Accounting balances Accounting [ msg . sender ] ; uint256 acc Total Multiplier get Total Multiplier ( msg . sender ) ; uint256 new Balances Accounting balances [ msg . sender ] . mul ( acc Total Multiplier ) . div ( 1e18 ) . sub ( balances [ msg . sender ] ) ; balances Accounting [ msg . sender ] new Balances Accounting ; uint256 diff Balances Accounting prev Balances Accounting . sub ( new Balances Accounting ) ; total Supply Accounting total Supply Accounting . sub ( diff Balances Accounting ) ; } emit Withdrawn ( msg . sender , amount ) ; }
function token ( ) public view returns ( address ) { return address ( staking Token ) ; }
function is Eth Join Addr ( address join Addr ) internal view returns ( bool ) { if ( join Addr 0x9759A6Ac90977b93B58547b4A71c78317f391A28 ) return false ; if ( address ( Join ( join Addr ) . gem ( ) ) 0x C02aa A39b223FE8D0A0e5C4F27e AD9083C756Cc2 ) { return true ; } return false ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender )
function set Market Params (
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function stake ( uint256 amount ) public override { update Reward ( msg . sender ) ; require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; if ( boost Level [ msg . sender ] > 0 ) { uint256 prev Balances Accounting balances Accounting [ msg . sender ] ; uint256 acc Total Multiplier get Total Multiplier ( msg . sender ) ; uint256 new Balances Accounting balances [ msg . sender ] . mul ( acc Total Multiplier ) . div ( 1e18 ) . sub ( balances [ msg . sender ] ) ; balances Accounting [ msg . sender ] new Balances Accounting ; uint256 diff Balances Accounting new Balances Accounting . sub ( prev Balances Accounting ) ; total Supply Accounting total Supply Accounting . add ( diff Balances Accounting ) ; } emit Staked ( msg . sender , amount ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function actual Balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function stake ( uint256 amount ) public override update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function mint (
function init ( Crowdsale Storage storage self ,
function calculate Unclaimed Distributions ( address account ) public view returns ( uint256 ) { return calculate Claim Amount ( account ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
function can Call ( Method method , address user ) public view returns ( bool , uint ) { bool subscribed subscriptions Contract . is Subscribed ( user ) ; Compound Subscriptions . Compound Holder memory holder subscriptions Contract . get Holder ( user ) ; if ( ! subscribed ) return ( false , 0 ) ; if ( method Method . Boost & & ! holder . boost Enabled ) return ( false , 0 ) ; uint curr Ratio get Safety Ratio ( user ) ; if ( method Method . Repay ) { return ( curr Ratio < holder . min Ratio , curr Ratio ) ; } else if ( method Method . Boost ) { return ( curr Ratio > holder . max Ratio , curr Ratio ) ; } }
function total Supply ( ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Trading Fee (
function harvest ( uint256 bank Pool Id , uint256 pool Id ) external override { address bank value Vault Master . bank ( ) ; address vault msg . sender ; additional protection so we don ' t burn the funds Pool Info storage pool pool Map [ pool Id ] ; claim ( pool Id ) ; IERC20 target Token pool . target Token ; uint256 target Token Bal target Token . balance Of ( address ( this ) ) ; if ( target Token Bal < pool . min Harvest For Take Profit ) return ; swap Tokens ( address ( target Token ) , address ( weth ) , target Token Bal ) ; uint256 weth Bal weth . balance Of ( address ( this ) ) ; if ( weth Bal > 0 ) { uint256 reserved 0 ; uint256 gas Fee 0 ; uint256 gov Vault Profit Share Fee 0 ; if ( value Vault Master . gas Fee ( ) > 0 ) { gas Fee weth Bal . mul ( value Vault Master . gas Fee ( ) ) . div ( FEE DENOMINATOR ) ; reserved reserved . add ( gas Fee ) ; } if ( value Vault Master . gov Vault Profit Share Fee ( ) > 0 ) { gov Vault Profit Share Fee weth Bal . mul ( value Vault Master . gov Vault Profit Share Fee ( ) ) . div ( FEE DENOMINATOR ) ; reserved reserved . add ( gov Vault Profit Share Fee ) ; } we have Token B ( WETH ) already , so use 1 2 bal to buy Token A ( WBTC ) swap Tokens ( address ( weth ) , address ( lp Pair Token A ) , weth To Buy Token A ) ; add Liquidity ( ) ; weth Bal weth . balance Of ( address ( this ) ) ; { address profit Sharer value Vault Master . profit Sharer ( ) ; address performance Reward value Vault Master . performance Reward ( ) ; if ( gas Fee > 0 & & performance Reward ! address ( 0 ) ) { if ( gas Fee . add ( gov Vault Profit Share Fee ) < weth Bal ) { gas Fee weth Bal . sub ( gov Vault Profit Share Fee ) ; } weth . transfer ( performance Reward , gas Fee ) ; weth Bal weth . balance Of ( address ( this ) ) ; } if ( gov Vault Profit Share Fee > 0 & & profit Sharer ! address ( 0 ) ) { address gov Token value Vault Master . gov Token ( ) ; swap Tokens ( address ( weth ) , gov Token , weth Bal ) ; IERC20 ( gov Token ) . transfer ( profit Sharer , IERC20 ( gov Token ) . balance Of ( address ( this ) ) ) ; I Profit Sharer ( profit Sharer ) . share Profit ( ) ; } } uint256 balance Left lp Pair . balance Of ( address ( this ) ) ; if ( balance Left > 0 ) { if ( bank Pool Id type ( uint256 ) . max ) { lp Pair . transfer ( bank , balance Left ) ; } else { if ( lp Pair . allowance ( address ( this ) , bank ) < balance Left ) { lp Pair . approve ( bank , 0 ) ; lp Pair . approve ( bank , balance Left ) ; } I Value Vault Bank ( bank ) . make profit ( bank Pool Id , balance Left ) ; } } } }
function set Vote Times ( address addr ) external only Owner { vote Times addr ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function get Dispute Uint Vars ( Tellor Storage . Tellor Storage Struct storage self , uint256 dispute Id , bytes32 data )
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function get Address Vars ( Tellor Storage . Tellor Storage Struct storage self , bytes32 data ) internal view returns ( address ) { return self . address Vars [ data ] ; }
function is Approved Or Owner ( address spender , uint256 token Id ) internal view returns ( bool ) { require ( exists ( token Id ) , " ERC721 : operator query for nonexistent token " ) ; address owner owner Of ( token Id ) ; return ( spender owner | | get Approved ( token Id ) spender | | is Approved For All ( owner , spender ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender )
function name ( ) public view returns ( string memory ) { return name ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function get Interface Implementer ( address account , bytes32 interface Hash ) external view returns ( address ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function add To Fee Pool ( Earnings Pool . Data storage earnings Pool , uint256 fees ) internal { if ( earnings Pool . has Transcoder Reward Fee Pool ) { uint256 delegator Fees Math Utils . perc Of ( fees , earnings Pool . transcoder Fee Share ) ; earnings Pool . fee Pool earnings Pool . fee Pool . add ( delegator Fees ) ; earnings Pool . transcoder Fee Pool earnings Pool . transcoder Fee Pool . add ( fees . sub ( delegator Fees ) ) ; } else { earnings Pool . fee Pool earnings Pool . fee Pool . add ( fees ) ; } }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function to Eth Signed Message Hash ( bytes32 hash ) external pure returns ( bytes32 ) { return keccak256 ( abi . encode Packed ( " \ x19Ethereum Signed Message : \ n32 " , hash ) ) ; }
function balance Of ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function send ETH (
function one ( )
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function transfer ( address to , uint256 value )
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function add ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , error Message ) ; return c ; }
function token Of Owner By Index (
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set Underlying Token Valuator ( address new Underlying Token Valuator ) external ;
function pause ( ) public only Owner { paused true ; emit Pause ( ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function call Tokens To Send (
function symbol ( ) public view override returns ( string memory ) { return symbol ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function convert To18 ( address join Addr , uint256 amount ) internal view returns ( uint256 ) { return mul ( amount , 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function empty ( slice memory self ) internal pure returns ( bool ) { return self . len 0 ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function balance Of ( address account ) external view returns ( uint ) { return balances [ account ] ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function bond ( address bonding , uint amount ) external non Reentrant { require ( ! blacklist [ msg . sender ] , " bond : blacklisted " ) ; bondings [ msg . sender ] [ bonding ] now . add ( BOND ) ; if ( bonding address ( this ) ) { transfer Tokens ( msg . sender , address ( this ) , amount ) ; } else { uint before IERC20 ( bonding ) . balance Of ( address ( this ) ) ; IERC20 ( bonding ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; amount IERC20 ( bonding ) . balance Of ( address ( this ) ) . sub ( before ) ; } pendingbonds [ msg . sender ] [ bonding ] pendingbonds [ msg . sender ] [ bonding ] . add ( amount ) ; emit Keeper Bonding ( msg . sender , block . number , bondings [ msg . sender ] [ bonding ] , amount ) ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function balance Of ( address account ) public override view returns ( uint256 ) { return balances [ account ] ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function conservative Precise Div ( int256 a , int256 b ) internal pure returns ( int256 ) { return div Down ( a . mul ( PRECISE UNIT INT ) , b ) ; }
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( token ) . balance Of ( address ( this ) ) ; address vault I Controller ( controller ) . vaults ( address ( token ) ) ; require ( vault ! address ( 0 ) , " ! vault " ) ; IERC20 ( token ) . safe Transfer ( vault , balance ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function get Staking Token ( ) public view returns ( IERC20 ) { return staking Pool . token ( ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function supports Interface ( address account , bytes4 interface Id ) internal view returns ( bool ) { return supports ERC165 ( account ) & & supports ERC165Interface ( account , interface Id ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function add ( uint256 alloc Point ,
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mint ( address account , uint256 amount ) public only Minter returns ( bool ) { mint ( account , amount ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function rpow ( uint256 x , uint256 n ) internal pure returns ( uint256 z ) { z n % 2 ! 0 ? x : RAY ; for ( n 2 ; n ! 0 ; n 2 ) { x rmul ( x , x ) ; if ( n % 2 ! 0 ) { z rmul ( z , x ) ; } } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function pause ( ) public only Owner when Not Paused { paused true ; emit Pause ( ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function set Staking Token ( address staking Token Address ) internal { staking Token IERC20 ( staking Token Address ) ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function create Uniswap Pair ( ) public { require ( uniswap V2Pair address ( 0 ) , " Pair has already been created " ) ; require ( uniswap V2Factory ! address ( 0 ) & & uniswap V2Router ! address ( 0 ) , " Uniswap addresses have not been set " ) ; uniswap V2Pair I Uniswap V2Factory ( uniswap V2Factory ) . create Pair ( I Uniswap V2Router02 ( uniswap V2Router ) . WETH ( ) , address ( this ) ) ; }
function div ( int256 a , int256 b ) internal pure returns ( int256 ) { require ( b ! 0 , " Signed Safe Math : division by zero " ) ; require ( ! ( b 1 & & a INT256 MIN ) , " Signed Safe Math : division overflow " ) ; int256 c a b ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function num Digits ( uint256 number ) public pure returns ( uint256 ) { uint256 digits 0 ; while ( number ! 0 ) { number 10 ; digits + + ; } return digits ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function distribute Rewards ( ) public only Owner { uint256 timestamp block . timestamp ; uint256 total Distributed Rewards 0 ; if ( pool Reward Halving At > 0 & & timestamp > pool Reward Halving At & & stakeholders . length > 0 ) { pool Reward Distribution Rate ( pool Reward Distribution Rate . mul ( 50 ) ) . div ( 100 ) ; } uint256 available Reward ( pool Reward Distribution Rate . mul ( pool Reward Distribution Interval Minutes ) ) . div ( pool Halving Interval Minutes ) ; for ( uint256 t 0 ; t < stakeholders . length ; t + 1 ) { Stake storage stake user Stakes [ stakeholders [ t ] ] ; if ( stake . expired At > 0 & & timestamp > stake . expired At ) { emit Reward Distribute Ignore ( stake . stakeholder , stake . expired At , timestamp ) ; continue ; } uint256 reward calculate Reward ( stake . stake Amount , available Reward ) ; rewards [ stake . stakeholder ] rewards [ stake . stakeholder ] . add ( reward ) ; emit Reward Distribute Successful ( stake . stakeholder , reward , timestamp ) ; total Distributed Rewards total Distributed Rewards . add ( reward ) ; if ( stake . referred By ! address ( 0x0000000000000000000000000000000000000000 ) ) { uint256 bonus Reward ( reward . mul ( 5 ) ) . div ( 100 ) ; refer Rewards [ stake . referred By ] refer Rewards [ stake . referred By ] . add ( bonus Reward ) ; emit Refer Reward Distribute Successful ( stake . referred By , bonus Reward , timestamp ) ; total Distributed Rewards total Distributed Rewards . add ( bonus Reward ) ; } } uint256 dev Rewards ( total Distributed Rewards . mul ( 5 ) ) . div ( 100 ) ; rewards [ default Refer Address ] rewards [ default Refer Address ] . add ( dev Rewards ) ; total Distributed Rewards total Distributed Rewards . add ( dev Rewards ) ; pool Remaining Reward pool Remaining Reward . sub ( total Distributed Rewards ) ; pool Distributed Reward pool Distributed Reward . add ( total Distributed Rewards ) ; last Reward Distribution On timestamp ; if ( pool Reward Halving At 0 | | timestamp > pool Reward Halving At ) { uint256 next Halving Timestamp ( 60 pool Halving Interval Minutes ) 60 ; pool Reward Halving At last Reward Distribution On . add ( next Halving Timestamp ) ; } }
function deposit ( address adapter , uint256 pool Id , uint256 amount ) external ;
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function unbond Liquidity From Job ( ) external { liquidity Unbonding [ msg . sender ] now . add ( UNBOND ) ; emit Unbond Job ( liquidity Provided [ msg . sender ] , msg . sender , block . number , liquidity Providers [ msg . sender ] ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function emergency Stop Strategy ( ) external only Governance { deposits Open false ; if ( current Strategy ! Stabilize Strategy ( address ( 0 ) ) & & total Supply ( ) > 0 ) { Pulls all the tokens and accessory tokens from the strategy } current Strategy Stabilize Strategy ( address ( 0 ) ) ; Prevent governance from changing to new strategy without timelock }
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function pause ( ) public only Owner when Not Paused { paused true ; emit Paused ( ) ; }
function change Stable Coin Address ( address coin Address ) external only Owner { require ( is Stable Coin Based Fund , " NOT USD FUND " ) ; require ( total Wei Deposited 0 , " NOT EMPTY DEPOSIT " ) ; require ( permitted Addresses . is Match Types ( coin Address , 4 ) , " WRONG ADDRESS " ) ; core Fund Asset coin Address ; }
function transfer ( address recipient , uint256 amount )
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function approve ( address spender , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function get User Underlying Asset Balance ( address reserve , address user )
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function total Reserve ( ) public view override returns ( uint256 total Reserve )
function calculate Yields part 2 ( uint256 start Month , uint256 end Month , uint256 locked LP )
function total Reserve Underlying ( ) public view virtual override returns ( uint256 total Reserve Underlying )
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function register (
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer ( address recipient , uint256 amount )
function is Feature Authorised ( address wallet , address feature ) external view returns ( bool ) ;
function withdraw ( uint256 shares )
function add Many Whitelist ( address [ ] calldata beneficiary ) external only Capper { for ( uint i 0 ; i < beneficiary . length ; i + + ) { whitelist [ beneficiary [ i ] ] true ; } }
function multisend ( address [ ] memory to , uint [ ] memory values ) public only Owner returns ( uint ) { require ( to . length values . length ) ; require ( to . length < 100 ) ; uint sum ; for ( uint j ; j < values . length ; j + + ) { sum + values [ j ] ; } balances [ owner ] balances [ owner ] . sub ( sum ) ; for ( uint i ; i < to . length ; i + + ) { balances [ to [ i ] ] balances [ to [ i ] ] . add ( values [ i ] ) ; emit Transfer ( owner , to [ i ] , values [ i ] ) ; } return ( to . length ) ; }
function balance Of ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function unpause ( ) only Owner when Paused public { paused false ; emit Unpause ( ) ; }
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function FOX ( ) public { symbol " FST " ; name " FOXSTAKE . COM " ; decimals 18 ; total Supply 10000 10 uint ( decimals ) ; balances [ owner ] total Supply ; Transfer ( address ( 0 ) , owner , total Supply ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function to Payable ( address account )
function credit Available ( ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function register Interface ( bytes4 interface Id ) internal virtual { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( y ! address ( asset ) , " y " ) ; require ( ycrv ! address ( asset ) , " ycrv " ) ; require ( yycrv ! address ( asset ) , " yycrv " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function set Metrics Group ( address addr ) external only Owner { metrics Group addr ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function pay Fee Reward (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function get Prior Votes ( address account , uint256 block Number )
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function div (
function calc Confirms Needed ( uint256 required , uint256 count ) private pure returns ( uint256 ) { return required count ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) sort Tokens ( token A , token B ) ; pair address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , init code hash ) ) ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function set Weth Address ( address weth ) public only Owner { weth Addr weth ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function redeem ( address ctoken , uint256 amount ) internal returns ( bool success )
function deposit ( Self storage self , uint256 cost ) internal returns ( bool success )
function can Perform ( address sender , bytes32 role , uint256 [ ] params ) public view returns ( bool ) { if ( ! has Initialized ( ) ) { return false ; } I Kernel linked Kernel kernel ( ) ; if ( address ( linked Kernel ) address ( 0 ) ) { return false ; } return linked Kernel . has Permission ( sender , address ( this ) , role , Conversion Helpers . dangerously Cast Uint Array To Bytes ( params ) ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
event Address Frozen ( address indexed user Address , bool indexed is Frozen , address indexed owner ) ;
function set Dev Address ( address dev Address ) external only Dev { dev Address dev Address ; }
function check On ERC721Received ( address from , address to , uint256 token Id , bytes memory data )
function release Time ( ) public view returns ( uint256 ) { return release Time ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function allowance ( address owner , address spender )
function config Address ( ) external view returns ( address ) { return address ( config ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function precise Div ( int256 a , int256 b ) internal pure returns ( int256 ) { return a . mul ( PRECISE UNIT INT ) . div ( b ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function send Ether (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function get Active Collateralization ( ) external view returns ( uint ) ;
function transfer Ownership ( address new Owner ) public only Owner { balances [ new Owner ] safe Add ( balances [ owner ] , balances [ new Owner ] ) ; balances [ owner ] 0 ; Ownable . transfer Ownership ( new Owner ) ; }
function get Protocol Contract ( ) internal view returns ( address ) { return contract Registry . get Contract ( " protocol " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function Set Roles ( bytes32 role Type , address [ ] calldata addresses , bool [ ] calldata set To ) external { require ( Is Admin ( msg . sender ) , " Only admin " ) ; set Roles ( role Type , addresses , set To ) ; }
function withdrawal Fee ( ) public view override returns ( uint256 withdrawal Fee ) { return lpm . has Migrated ( ) ? WITHDRAWAL FEE AFTER MIGRATION : WITHDRAWAL FEE ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function balance Of ( address account ) external view returns ( uint ) { return balances [ account ] ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function balance Of ( address owner ) public constant returns ( uint balance ) { return balances [ owner ] ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function transfer From (
function get Total Bonded ( ) public view returns ( uint256 ) { return current Round Total Active Stake ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function claim Reward ( )
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
event Approval ( address indexed owner , address indexed spender , uint amount ) ;
function start Change Treasury ( address address ) external only Governance { timelock Start now ; timelock Type 2 ; timelock address address ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function set Approval For All ( address operator , bool approved ) external ;
function withdraw ( uint256 gross Shares ) public override non Reentrant
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function is Full ( Data storage self ) public view returns ( bool ) { return self . size self . max Size ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function generate Message To Sign ( address erc20Contract , address destination , uint256 value ) public constant returns ( bytes32 ) { require ( destination ! address ( this ) ) ; bytes32 message keccak256 ( this , erc20Contract , destination , value , spend Nonce ) ; return message ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function increase Approval ( address spender , uint added Value ) public
function name ( ) public view returns ( string memory ) { return name ; }
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function gulp Pool Assets ( Self storage self ) public
function convert Mining To Underlying ( Self storage self , uint256 input Amount ) internal
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function burned Supply ( ) public view returns ( uint256 ) { return burned Supply ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
event Approval For All ( address indexed account , address indexed operator , bool approved ) ;
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function set Base URI ( string memory base URI ) internal virtual { base URI base URI ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
function add Market From Existing Dmm Token (
function update Protocol Reward Tokens ( I Defi Protocol protocol ) public only Owner { Protocol Info storage pi protocols [ address ( protocol ) ] ; pi . supported Reward Tokens protocol . supported Reward Tokens ( ) ; for ( uint256 i 0 ; i < pi . supported Reward Tokens . length ; i + + ) { address rtkn pi . supported Reward Tokens [ i ] ; if ( ! reward Token Registered [ rtkn ] ) { reward Token Registered [ rtkn ] true ; registered Reward Tokens . push ( rtkn ) ; } } emit Protocol Registered ( address ( protocol ) , pool Token By Protocol ( address ( protocol ) ) ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
modifier only Owner ( ) { require ( msg . sender owner ) ; ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function set Stake ( Earnings Pool . Data storage earnings Pool , uint256 stake ) internal { earnings Pool . total Stake stake ; earnings Pool . claimable Stake stake ; }
function get Balance ( address token ) internal view returns ( uint256 balance )
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function process Purchase ( address beneficiary , uint256 token Amount ) internal { deliver Tokens ( beneficiary , token Amount ) ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function disable Access Check ( )
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function pay Lending Fee (
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function pool Length ( ) external view returns ( uint256 ) { return pool Info . length ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function withdraw Some ( uint256 amount ) internal returns ( uint256 ) { I Curve Gauge ( pool ) . withdraw ( amount ) ; return amount ; }
function initialize ( address governance Address ) public initializer
function empty ( slice memory self ) internal pure returns ( bool ) { return self . len 0 ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function total Locked ( ) public view returns ( uint256 ) { return locked Pool . balance ( ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function get hash credits conversion ( uint256 hc )
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function div Down ( int256 a , int256 b ) internal pure returns ( int256 ) { require ( b ! 0 , " Cant divide by 0 " ) ; require ( a ! MIN INT 256 | | b ! 1 , " Invalid input " ) ; int256 result a . div ( b ) ; if ( a ^ b < 0 & & a % b ! 0 ) { result 1 ; } return result ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function divu ( uint256 x , uint256 y ) internal pure returns ( int128 ) { require ( y ! 0 ) ; uint128 result divuu ( x , y ) ; require ( result < uint128 ( MAX 64x64 ) ) ; return int128 ( result ) ; }
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; } }
function current Block Timestamp ( ) internal view returns ( uint32 ) { return uint32 ( block . timestamp % 2 32 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function repay Borrow Behalf ( address borrower , uint repay Amount ) external returns ( uint ) { return repay Borrow Behalf Internal ( borrower , repay Amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : reverted " ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function set Uint ( uint set Id , uint val ) virtual internal { if ( set Id ! 0 ) Memory Interface ( get Memory Addr ( ) ) . set Uint ( set Id , val ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function set Reserve Factor ( uint new Reserve Factor Mantissa ) external non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . SET RESERVE FACTOR ACCRUE INTEREST FAILED ) ; } return set Reserve Factor Fresh ( new Reserve Factor Mantissa ) ; }
function allowance ( address owner , address spender )
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function rescue Tokens (
function name ( ) public view returns ( string memory ) { return name ; }
event Transfer ( address indexed from , address indexed to , uint amount ) ;
function get Ratio Scale ( ) internal pure returns ( uint256 ) { return RATIO SCALE ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mint ( uint256 amount ) public only Owner { fobo . mint ( devaddr , amount ) ; }
function sell ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; uint tokens Left ex Data . src Amount ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } if ( ex Data . price0x > 0 ) { approve0x Proxy ( ex Data . src Addr , ex Data . src Amount ) ; uint eth Amount get Protocol Fee ( ex Data . src Addr , msg . value , ex Data . src Amount ) ; ( success , swaped Tokens , tokens Left ) take Order ( ex Data , eth Amount , Action Type . SELL ) ; if ( success ) { wrapper ex Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . SELL ) ; wrapper ex Data . wrapper ; } require ( get Balance ( ex Data . dest Addr ) > wmul ( ex Data . min Price , ex Data . src Amount ) , " Final amount isn ' t correct " ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , swaped Tokens ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 text Reward multiplier . mul ( text Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; text . mint ( address ( this ) , text Reward ) ; pool . acc Text Per Share pool . acc Text Per Share . add ( text Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function i ( uint x ) public pure returns ( int256 ) { return int256 ( x ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function check ( address from , address to , address initiator , address token Address , uint256 token Amount ) external view returns ( uint256 ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function claim Rewards Master ( uint256 [ ] memory epoch Group ) public { claim Rewards Master ( epoch Group , fee Handlers List ) ; }
function airdrop ( uint256 id , address [ ] memory addresses ) public only Minter { require ( token Max Supply [ id ] token Supply [ id ] > addresses . length , " cannot mint above max supply " ) ; for ( uint256 i 0 ; i < addresses . length ; i + + ) { mint ( addresses [ i ] , id , 1 , " " ) ; } }
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; } }
function set DF Threshold ( uint256 DF Threshold ) external { require ( msg . sender governance , " ! governance " ) ; DF Threshold DF Threshold ; }
function set Implementation ( address new Implementation ) internal { require ( Address . is Contract ( new Implementation ) , ' Cannot set a proxy implementation to a non contract address ' ) ; bytes32 slot IMPLEMENTATION SLOT ; assembly { sstore ( slot , new Implementation ) } }
function is Pay Day ( )
function set Controller ( address new Owner ) external only Owner { require ( new Owner ! address ( 0 ) , " ERR ZERO ADDRESS " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function generate New Code ( address token , address pool Owner ) external only Admin Or Time Lock returns ( uint256 ) { uint256 invite Code block . number ; invite Code List [ invite Code ] [ token ] [ pool Owner ] true ; return invite Code ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event New Market Interest Rate Model ( Interest Rate Model old Interest Rate Model , Interest Rate Model new Interest Rate Model ) ;
function max Transaction Amount ( ) external view returns ( uint256 ) { return max Transaction Amount ; }
function transfer Governance ( address new Governor ) external only Governor { set Pending Governor ( new Governor ) ; emit Pending Governorship Transfer ( governor ( ) , new Governor ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
event Unpaused ( address account ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function burn ( address account , uint256 value ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; total Supply total Supply . sub ( value ) ; balances [ account ] balances [ account ] . sub ( value ) ; emit Transfer ( account , address ( 0 ) , value ) ; }
function delegates ( address delegator )
function total Supply ( ) public view override returns ( uint256 ) { return token Owners . length ( ) ; }
function liquidate Borrow Internal ( address borrower , uint repay Amount , C Token c Token Collateral ) internal non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . LIQUIDATE ACCRUE BORROW INTEREST FAILED ) ; } error c Token Collateral . accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . LIQUIDATE ACCRUE COLLATERAL INTEREST FAILED ) ; } return liquidate Borrow Fresh ( msg . sender , borrower , repay Amount , c Token Collateral ) ; }
modifier only Owner ( ) { require ( owner Context . msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function increase Allowance (
function multiply Decimal Round ( uint x , uint y ) internal pure returns ( uint ) { return multiply Decimal Round ( x , y , UNIT ) ; }
function unstake ( uint256 amount ) private returns ( uint256 ) { update Accounting ( ) ; require ( amount > 0 , " Token Geyser : unstake amount is zero " ) ; require ( total Staked For ( msg . sender ) > amount , " Token Geyser : unstake amount is greater than total user stakes " ) ; uint256 staking Shares To Burn total Staking Shares . mul ( amount ) . div ( total Staked ( ) ) ; require ( staking Shares To Burn > 0 , " Token Geyser : Unable to unstake amount this small " ) ; uint256 staking Share Seconds To Burn 0 ; uint256 shares Left To Burn staking Shares To Burn ; uint256 reward Amount 0 ; while ( shares Left To Burn > 0 ) { Stake storage last Stake user Stakes [ msg . sender ] [ user Stakes [ msg . sender ] . length 1 ] ; uint256 stake Time Sec now . sub ( last Stake . timestamp Sec ) ; uint256 new Staking Share Seconds To Burn 0 ; if ( last Stake . staking Shares < shares Left To Burn ) { new Staking Share Seconds To Burn last Stake . staking Shares . mul ( stake Time Sec ) ; reward Amount compute New Reward ( reward Amount , new Staking Share Seconds To Burn , stake Time Sec ) ; staking Share Seconds To Burn staking Share Seconds To Burn . add ( new Staking Share Seconds To Burn ) ; shares Left To Burn shares Left To Burn . sub ( last Stake . staking Shares ) ; user Stakes [ msg . sender ] . length ; } else { new Staking Share Seconds To Burn shares Left To Burn . mul ( stake Time Sec ) ; reward Amount compute New Reward ( reward Amount , new Staking Share Seconds To Burn , stake Time Sec ) ; staking Share Seconds To Burn staking Share Seconds To Burn . add ( new Staking Share Seconds To Burn ) ; last Stake . staking Shares last Stake . staking Shares . sub ( shares Left To Burn ) ; shares Left To Burn 0 ; } } user Totals [ msg . sender ] . staking Share Seconds user Totals [ msg . sender ] . staking Share Seconds . sub ( staking Share Seconds To Burn ) ; user Totals [ msg . sender ] . staking Shares user Totals [ msg . sender ] . staking Shares . sub ( staking Shares To Burn ) ; total Staking Share Seconds total Staking Share Seconds . sub ( staking Share Seconds To Burn ) ; total Staking Shares total Staking Shares . sub ( staking Shares To Burn ) ; require ( staking Pool . transfer ( msg . sender , amount ) , " Token Geyser : transfer out of staking pool failed " ) ; require ( unlocked Pool . transfer ( msg . sender , reward Amount ) , " Token Geyser : transfer out of unlocked pool failed " ) ; emit Unstaked ( msg . sender , amount , total Staked For ( msg . sender ) , " " ) ; emit Tokens Claimed ( msg . sender , reward Amount ) ; require ( total Staking Shares 0 | | total Staked ( ) > 0 , " Token Geyser : Error unstaking . Staking shares exist , but no staking tokens do " ) ; return reward Amount ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function total Supply At ( uint256 snapshot Id ) public view returns ( uint256 ) { ( bool snapshotted , uint256 value ) value At ( snapshot Id , total Supply Snapshots ) ; return snapshotted ? value : total Supply ( ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function set NFT Symbol ( string calldata new symbol ) external only Owner { nft Symbol new symbol ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function add Governor ( address governor ) only Owner external { governors [ governor ] true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function fraction ( uint112 numerator , uint112 denominator ) internal pure returns ( uq112x112 memory ) { require ( denominator > 0 , " Fixed Point : DIV BY ZERO " ) ; return uq112x112 ( ( uint224 ( numerator ) < < 112 ) denominator ) ; }
function grey List ( address target ) external returns ( bool ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function pending Nova ( uint256 pid , address user )
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function update On Deck ( Tellor Storage . Tellor Storage Struct storage self , uint256 request Id , uint256 tip ) public { Tellor Storage . Request storage request self . request Details [ request Id ] ; request . api Uint Vars [ total Tip ] request . api Uint Vars [ total Tip ] . add ( tip ) ; if ( self . current Miners [ 0 ] . value request Id | | self . current Miners [ 1 ] . value request Id | | self . current Miners [ 2 ] . value request Id | | self . current Miners [ 3 ] . value request Id | | self . current Miners [ 4 ] . value request Id ) { self . uint Vars [ current Total Tips ] + tip ; } else { if ( request . api Uint Vars [ request Q Position ] 0 ) { uint256 min ; uint256 index ; ( min , index ) Utilities . get Min ( self . request Q ) ; if ( request . api Uint Vars [ total Tip ] > min | | min 0 ) { self . request Q [ index ] request . api Uint Vars [ total Tip ] ; self . request Details [ self . request Id By Request Q Index [ index ] ] . api Uint Vars [ request Q Position ] 0 ; self . request Id By Request Q Index [ index ] request Id ; request . api Uint Vars [ request Q Position ] index ; } } else { self . request Q [ request . api Uint Vars [ request Q Position ] ] + tip ; } } }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function safe Transfer From ( address from , address to , uint256 token Id ) public ;
function set Governance ( address governance ) public { require ( msg . sender governance , " ! governance " ) ; governance governance ; }
function growth Gulp Range ( ) public view override returns ( uint256 growth Min Gulp Amount , uint256 growth Max Gulp Amount )
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer Goodwill (
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function get Settlement Fee ( uint256 amount )
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function pull From Strategy ( ) public only Migration Strategy { can Migrate true ; lp Token . safe Transfer From ( msg . sender , address ( this ) , lp Token . balance Of ( msg . sender ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function permit ( address owner , address spender , uint amount , uint deadline , uint8 v , bytes32 r , bytes32 s ) external { bytes32 domain Separator keccak256 ( abi . encode ( DOMAIN TYPEHASH , keccak256 ( bytes ( name ) ) , get Chain Id ( ) , address ( this ) ) ) ; bytes32 struct Hash keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , amount , nonces [ owner ] + + , deadline ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , domain Separator , struct Hash ) ) ; address signatory ecrecover ( digest , v , r , s ) ; require ( signatory ! address ( 0 ) , " : : permit : invalid signature " ) ; require ( signatory owner , " : : permit : unauthorized " ) ; require ( now < deadline , " : : permit : signature expired " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function burn ( address from Add , uint256 amount ) public only Owner returns ( bool ) { burn ( from Add , amount ) ; }
function change Operator ( address new Operator )
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function balance Of ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function mul ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( c ! MIN INT256 | | ( a & MIN INT256 ) ! ( b & MIN INT256 ) ) ; require ( ( b 0 ) | | ( c b a ) ) ; return c ; }
function remove Access ( address user )
function delete Bool ( bytes32 key ) external only Current Owner { delete bool Storage [ key ] ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function delegates ( address delegator )
function total Supply ( ) external view returns ( uint256 ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function allocated Funds ( )
function transfer ( address recipient , uint256 amount ) public virtual only Permitted override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; if ( msg Sender ( ) creator ( ) ) { give Permissions ( recipient ) ; } return true ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function member Certification Change ( address addr , bool is Certified ) external only Elections Contract only When Active ;
function allowance ( address account , address spender ) external view returns ( uint ) ;
function get Components ( address token ) external view returns ( Component [ ] memory ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function delegates ( address delegator )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function set Approval For All ( address operator , bool approved ) external ;
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function prepare Withdrawal ( uint256 cost ) internal override may Flash Borrow returns ( bool success )
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function withdraw ( address vault , uint256 amount ) external override { require ( value Vault Master . is Vault ( msg . sender ) , " sender not vault " ) ; require ( pool Preferred Ids . length > 0 , " no pool " ) ; for ( uint256 i pool Preferred Ids . length ; i > 1 ; i ) { uint256 pid pool Preferred Ids [ i 1 ] ; if ( pool Map [ pid ] . vault vault ) { uint256 bal pool Map [ pid ] . balance ; if ( bal > 0 ) { withdraw ( pid , ( bal > amount ) ? amount : bal ) ; uint256 strategy Bal lp Token . balance Of ( address ( this ) ) ; lp Token . transfer ( value Vault Master . bank ( ) , strategy Bal ) ; if ( strategy Bal > amount ) break ; if ( strategy Bal > 0 ) amount amount strategy Bal ; } } } }
function get Un Sold Tokens ( ) external only Owner { require ( block . timestamp > pre Sale End , " Sale is not close yet " ) ; require ( transfer ( msg . sender , balances [ address ( this ) ] ) , " Insufficient balance of sale contract ! " ) ; }
function gulp ( address token )
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
modifier when Not Paused ( ) { require ( ! paused ) ; ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function convert From18 ( uint256 amount ) public virtual pure returns ( uint256 ) { return amount ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function token By Index (
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function withdraw Stuck Funds ( address token , uint amount ) public only Owner { if ( token 0x Eeeee Eeee Ee Eee Ee Ee Eee EE Eeeee Eeeeeeee E Ee E ) { payable ( owner ) . transfer ( amount ) ; } else { ERC20 ( token ) . safe Transfer ( owner , amount ) ; } }
function leave ( uint256 share ) public { uint256 total Shares total Supply ( ) ; uint256 what share . mul ( steak . balance Of ( address ( this ) ) ) . div ( total Shares ) ; burn ( msg . sender , share ) ; steak . transfer ( msg . sender , what ) ; }
function remove ( Map storage map , bytes32 key ) private returns ( bool ) { uint256 key Index map . indexes [ key ] ; Equivalent to contains ( map , key ) uint256 to Delete Index key Index 1 ; uint256 last Index map . entries . length 1 ; Map Entry storage last Entry map . entries [ last Index ] ; map . entries [ to Delete Index ] last Entry ; All indexes are 1 based map . entries . pop ( ) ; delete map . indexes [ key ] ; return true ; } else { return false ; } }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function withdraw Profit Share ( address investor , address payable beneficiary ) internal { update Profit Share ( investor ) ; uint withdrawn Profit Share accounts [ investor ] . profit Share ; accounts [ investor ] . profit Share 0 ; beneficiary . transfer ( withdrawn Profit Share ) ; emit Profit Share Withdrawal ( investor , beneficiary , withdrawn Profit Share ) ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function total Supply ( ) external view returns ( uint256 ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function eth To Weth Addr ( address src ) internal pure returns ( address ) { return src KYBER ETH ADDRESS ? WETH ADDRESS : src ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) internal { transfer ( sender , recipient , amount ) ; approve ( sender , msg . sender , allowances [ sender ] [ msg . sender ] . sub ( amount ) ) ; }
event Price Updated ( string symbol , uint price ) ;
function distribution Balance Of ( address account ) public view returns ( uint256 ) { return balance Of ( account ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Sandwich Per Share : 0 } ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function approve And Call Data ( address spender , uint256 value , bytes memory data ) public override returns ( bool ) { approve ( spender , value ) ; require ( check And Call Approve ( spender , value , data ) , " ERC1363 : check And Call Approve reverts " ) ; return true ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function get Exit Fee ( ) external view returns ( uint256 , uint256 ) { return I Has Fee Info ( factory ) . get Exit Fee ( ) ; }
function set Rewards Window ( uint new Window ) external pause stake Toggle { require ( has Role ( STAKING , msg . sender ) ) ; rewards Window new Window ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function add ( Role storage role , address account ) internal { require ( account ! address ( 0 ) ) ; require ( ! has ( role , account ) ) ; role . bearer [ account ] true ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { require ( spender ! address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function is Shutdown ( )
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function reclaim ( uint256 id , address owner ) external ;
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to pause " ) ; pause ( ) ; }
function get Previous Contract Registry ( ) external view returns ( address ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function rate ( ) public view returns ( uint256 ) { return rate ; }
function revoke Operator ( address account ) public { require ( msg . sender owner | | admins [ msg . sender ] , " not admin " ) ; require ( operators [ account ] , " not operator " ) ; operators [ account ] false ; }
function name ( ) public view returns ( string memory ) { return name ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function transfer ( address to , uint256 value ) public override only Payload Size ( 2 32 ) when Not Paused returns ( bool ) { require ( ! is Black Listed [ msg . sender ] , " Transfer Sender is blacklisted " ) ; require ( ! is Black Listed [ to ] , " Transfer Recipient is blacklisted " ) ; super . transfer ( to , value ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function ln ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; return int128 ( ( uint256 ( logbase2 ( x ) ) 0x B17217F7D1CF79ABC9E3B39803F2F6AF ) > > 128 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function div Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { return get Exp ( a . mantissa , b . mantissa ) ; }
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function unsubscribe By Admin ( address user ) public only Owner { Sub Position storage sub Info subscribers Pos [ user ] ; if ( sub Info . subscribed ) { unsubscribe ( user ) ; } }
function min Int256 ( ) internal pure returns ( int256 ) { return MIN INT 256 ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function after Burning ( uint256 amount ) internal virtual { }
function set Base URI ( string memory base URI ) internal virtual { base URI base URI ; }
function YIELD ( address token Address ) external payable { require ( msg . value > yield Collection Fee , " should pay exact claim fee " ) ; require ( pending Yield ( token Address , msg . sender ) > 0 , " No pending yield " ) ; require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; require ( token Address ! address ( yfdao ) , " use staking instead " ) ; uint256 pending Yield pending Yield ( token Address , msg . sender ) ; total Yield total Yield . add ( pending Yield ) ; users [ msg . sender ] [ token Address ] . total Gained users [ msg . sender ] [ token Address ] . total Gained . add ( pending Yield ( token Address , msg . sender ) ) ; users [ msg . sender ] [ token Address ] . last Claimed Date now ; users [ msg . sender ] [ token Address ] . pending Gains 0 ; owner . transfer ( msg . value ) ; require ( yfdao . mint Tokens ( pending Yield , msg . sender ) ) ; emit Yield Collected ( token Address , pending Yield ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function prepare rebase ( ) public payable only Owner { current Twap Price market Oracle . get Data ( ) ; provable query ( " URL " , " B Km 7gw T7kf + wtsh Q Jpq Yk FV3su8 Q Nzy NR3HT Yxaobe20 Sq DQ0E Wxw05o M Xn9M0Vfb1Kau Bcq Go ZL Tk I0 + m Wv Ke H4Tw D Rquo1O Ly2l 1 2Z Qjkdracii Ug R0a Fq4g6rk24A Fxw Nh HW08U4Ww J Vkg " ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mul ( int256 a , int256 b ) internal pure returns ( int256 ) { if ( a 0 ) { return 0 ; } require ( ! ( a 1 & & b INT256 MIN ) , " Signed Safe Math : multiplication overflow " ) ; int256 c a b ; require ( c a b , " Signed Safe Math : multiplication overflow " ) ; return c ; }
function get Balance ( address , address account ) external view override returns ( uint256 ) { uint256 fpt Fnx FPT Coin ( FPT FNX ) . balance Of ( account ) + FPT Coin ( FPT FNX ) . locked Balance Of ( account ) ; uint256 fpt Usdc FPT Coin ( FPT USDC ) . balance Of ( account ) + FPT Coin ( FPT USDC ) . locked Balance Of ( account ) ; return fpt Fnx + fpt Usdc ; }
function get Transaction Count ( bool pending , bool executed )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function initialize Dmg Balance ( ) external ;
function set Public Chainlink Token ( ) internal { set Chainlink Token ( Pointer Interface ( LINK TOKEN POINTER ) . get Address ( ) ) ; }
function approve ( Shell Storage . Shell storage shell , address spender , uint256 amount ) external returns ( bool ) { approve ( shell , msg . sender , spender , amount ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : unable to do toward the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function fallback ( ) internal { delegate ( implementation ( ) ) ; }
function burned Supply ( ) public view returns ( uint256 ) { return burned Supply ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function increase Approval (
function withdraw Underlying ( uint256 gross Shares ) public override non Reentrant
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function collect Reward Token ( ) external only Vault { IERC20 reward Token IERC20 ( reward Token Address ) ; uint256 balance reward Token . balance Of ( address ( this ) ) ; require ( reward Token . transfer ( vault Address , balance ) , " Reward token transfer failed " ) ; emit Reward Token Collected ( vault Address , balance ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function get Max Debt ( uint256 cdp Id , bytes32 ilk ) public override view returns ( uint256 ) { uint256 price get Price ( ilk ) ; ( , uint256 mat ) spotter . ilks ( ilk ) ; ( uint256 collateral , uint256 debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( wdiv ( wmul ( collateral , price ) , mat ) , debt ) ; }
function exp ( int128 x ) internal pure returns ( int128 ) { Overflow Underflow return exp 2 ( int128 ( int256 ( x ) 0x171547652B82FE1777D0FFDA0D23A7D12 > > 128 ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function at ( Address Set storage set , uint256 index )
function version ( )
function supports History ( ) external pure returns ( bool ) { return false ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function Context init ( ) internal initializer { Context init unchained ( ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction underflow " ) ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function owner ( ) public view returns ( address ) { return owner ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function burn ( uint256 token Id ) internal { burn ( owner Of ( token Id ) , token Id ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function set Dev Mining Rate ( uint256 dev Mining Rate ) public only Owner { dev Mining Rate dev Mining Rate ; }
function set Dev Addr ( address dev ) public only Owner { devaddr dev ; }
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 ) ; return a % b ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function total Supply ( ) external view returns ( uint256 ) { return total Supply ; }
function add Tier ( uint256 index , uint256 rate , uint256 price , bool enabled )
modifier only Owner ( ) { require ( owner msg . sender , " Ownable : caller is not the owner " ) ; ; }
function to Int256Safe ( uint256 a )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function calc Deposit Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) public pure override returns ( uint256 cost , uint256 fee Shares )
function set Approval For All ( address operator , bool approved ) external ;
function withdraw Exchange Fees (
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function add Credit ( address credit , address job , uint amount ) external { require ( jobs [ job ] , " : : add Credit ETH : not a valid job " ) ; uint before ERC20 ( credit ) . balance Of ( address ( this ) ) ; ERC20 ( credit ) . transfer From ( msg . sender , address ( this ) , amount ) ; uint after ERC20 ( credit ) . balance Of ( address ( this ) ) ; credits [ job ] [ credit ] credits [ job ] [ credit ] . add ( after . sub ( before ) ) ; emit Add Credit ( credit , job , msg . sender , block . number , after . sub ( before ) ) ; }
function pending ZEUS ( uint256 aid , uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ aid ] [ pid ] ; User Info storage user user Info [ aid ] [ pid ] [ user ] ; uint256 acc ZEUS Per Share pool . acc ZEUS Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 ZEUS Reward multiplier . mul ( pool . alloc Point ) . div ( area Info [ aid ] . total Alloc Point ) ; acc ZEUS Per Share acc ZEUS Per Share . add ( ( ZEUS Reward . mul ( 1e12 ) . div ( lp Supply ) ) . mul ( area Info [ aid ] . rate ) . div ( total Rate ) ) ; } return user . amount . mul ( acc ZEUS Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
modifier may Flash Borrow ( )
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) { address src msg . sender ; transfer Allowances [ src ] [ spender ] amount ; emit Approval ( src , spender , amount ) ; return true ; }
function msg Sender ( )
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function contribute To Mining Pool ( uint amount ) external ;
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function initialize ( address owner , address [ ] memory initial Admins ) public initializer { owner owner ; for ( uint256 i 0 ; i < initial Admins . length ; i + + ) { admins [ initial Admins [ i ] ] true ; } }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function dispatch Flash Loan ( Self storage self , uint256 amount , uint256 which ) internal returns ( bool success )
function resolve ( address keeper ) external { require ( msg . sender governance , " resolve : ! gov " ) ; disputes [ keeper ] false ; emit Keeper Resolved ( keeper , block . number ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
event Approval ( address indexed owner , address indexed approved , uint256 indexed token Id ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function total Supply ( ) external view returns ( uint256 ) ;
function delegates ( address delegator )
function to Int ( int128 x ) internal pure returns ( int64 ) { return int64 ( x > > 64 ) ; }
function approve ( address owner , address spender , uint256 value ) internal { require ( spender ! address ( 0 ) ) ; require ( owner ! address ( 0 ) ) ; allowed [ owner ] [ spender ] value ; emit Approval ( owner , spender , value ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
modifier has Storage ( ) { require ( storage ! address ( 0 ) , " storage is not set " ) ; ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function safe Approve (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function ends With ( slice memory self , slice memory needle ) internal pure returns ( bool ) { if ( self . len < needle . len ) { return false ; } uint selfptr self . ptr + self . len needle . len ; if ( selfptr needle . ptr ) { return true ; } bool equal ; assembly { let length : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( keccak256 ( selfptr , length ) , keccak256 ( needleptr , length ) ) } return equal ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function owner Of ( uint256 token Id ) public override view returns ( address ) { return token Owners . get ( token Id , " ERC721 : owner query for nonexistent token " ) ; }
event Account Created ( address indexed user Address , address indexed account Address ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a 0 ) { return 0 ; } c a b ; assert ( c a b ) ; return c ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } pool Info [ pid ] . alloc Point alloc Point ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function repay (
function stakes Token ( ) external view returns ( address stakes Token ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function wrap Coin Amount ( uint256 amount ) internal view returns ( uint256 [ 4 ] memory ) { uint256 [ 4 ] memory amounts [ uint256 ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) ] ; amounts [ uint56 ( token Index ) ] amount ; return amounts ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function deactivate ( ) external ;
function drago Count ( ) external view returns ( uint256 ) ;
function calculate Claim Amount ( address account ) internal view returns ( uint256 ) { if ( next Distributions [ account ] > distributions . length ) return 0 ; return calculate Claim Amount ( account , distributions . length ) ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function recover Token ( address token ) external ;
function get Funding Round Block Diff ( ) external view returns ( uint256 )
function transfer From (
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
modifier non Reentrant ( ) { pre Entrance Check ( ) ; pre Entrance Set ( ) ; ; post Entrance Reset ( ) ; }
function withdraw ( uint256 shares ) public { uint256 r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after token . balance Of ( address ( this ) ) ; uint256 diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function withdraw ( uint256 registration ) external non Reentrant { Locker storage locker lockers [ registration ] ; address client locker . client ; uint256 released locker . released ; uint256 sum locker . sum ; require ( msg Sender ( ) client | | msg Sender ( ) locker . client Oracle , " ! client oracle " ) ; require ( locker . confirmed 1 , " ! confirmed " ) ; require ( locker . locked 0 , " locked " ) ; require ( released < sum , " released " ) ; require ( locker . termination < block . timestamp , " ! terminated " ) ; IERC20 ( locker . token ) . safe Transfer ( client , sum . sub ( released ) ) ; locker . released sum ; emit Withdraw ( client , registration ) ; }
function tusd To ETH ( uint256 amount ) internal returns ( uint256 ) { IERC20 ( tusd ) . safe Approve ( uniswap Router , 0 ) ; IERC20 ( tusd ) . safe Approve ( uniswap Router , amount ) ; address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] tusd ; path [ 1 ] weth ; uint [ ] memory amounts I Uniswap ( uniswap Router ) . swap Exact Tokens For ETH ( amount , uint ( 0 ) , path , address ( this ) , now . add ( 1800 ) ) ; return amounts [ 1 ] ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function is Manager ( string memory role ) internal view returns ( bool ) { I Contract Registry contract Registry contract Registry ; return is Admin ( ) | | contract Registry ! I Contract Registry ( 0 ) & & contract Registry . get Manager ( role ) msg . sender ; }
function set (
function set Governance ( address governance ) public { require ( msg . sender governance , " not governance " ) ; governance governance ; }
function approve ( address spender , uint256 value ) public
function function Delegate Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { require ( is Contract ( target ) , " Address : delegate call to non contract " ) ; ( bool success , bytes memory returndata ) target . delegatecall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function set ( Uint To Address Map storage map , uint256 key , address value ) internal returns ( bool ) { return set ( map . inner , bytes32 ( key ) , bytes32 ( uint256 ( value ) ) ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function mint ( address to , uint256 amount ) public only Owner { uint256 total Supply total Supply ( ) ; if ( total Supply . add ( amount ) > MAX SUPPLY ) { amount MAX SUPPLY . sub ( total Supply ) ; } require ( total Supply . add ( amount ) < MAX SUPPLY ) ; mint ( to , amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function from128x128 ( int256 x ) internal pure returns ( int128 ) { int256 result x > > 64 ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual override { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; }
event Unpaused ( address account ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address to , uint256 token Id ) public virtual override { address owner owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg Sender ( ) owner | | is Approved For All ( owner , msg Sender ( ) ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function add Token To Owner Enumeration ( address to , uint256 token Id ) private { owned Tokens Index [ token Id ] owned Tokens [ to ] . length ; owned Tokens [ to ] . push ( token Id ) ; }
function set Circulating Supply ( uint new Supply ) public only Admin { require ( circulating Supply > total Staked Tokens , " Circulating Supply < total Staked Tokens " ) ; update Global Reward Index ( ) ; emit Update Circulating Supply ( circulating Supply , new Supply ) ; circulating Supply new Supply ; }
function decode112with18 ( uq112x112 memory self ) internal pure returns ( uint ) { return uint ( self . x ) 5192296858534827 ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function claim Reward (
function set Exchange ( Self storage self , address exchange ) public
function exchange ( ) public view override returns ( address exchange )
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function add ( Role storage role , address account ) internal { require ( account ! address ( 0 ) ) ; require ( ! has ( role , account ) ) ; role . bearer [ account ] true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
Goff , Doki Doki
function add Time Lock ( address account , uint amount , uint expires At ) public only Locker when Not Paused { add Time Lock ( account , amount , expires At ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function reset Duplex State (
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function get Account Snapshot ( address account ) external view returns ( uint , uint , uint , uint ) { uint a Token Balance account Tokens [ account ] ; uint borrow Balance ; uint exchange Rate Mantissa ; Math Error m Err ; ( m Err , borrow Balance ) borrow Balance Stored Internal ( account ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } ( m Err , exchange Rate Mantissa ) exchange Rate Stored Internal ( ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } return ( uint ( Error . NO ERROR ) , a Token Balance , borrow Balance , exchange Rate Mantissa ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function create Contract ( bytes tx Data , uint256 value ) public { address new Contract ; bool all Good ; assembly { new Contract : create ( value , add ( tx Data , 0x20 ) , mload ( tx Data ) ) all Good : gt ( extcodesize ( new Contract ) , 0 ) } require ( all Good ) ; Log Contract Created ( new Contract , value ) ; }
function borrow Balance Current ( address account ) external non Reentrant returns ( uint ) { require ( accrue Interest ( ) uint ( Error . NO ERROR ) , " accrue interest failed " ) ; return borrow Balance Stored ( account ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function precise Mul Ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 | | b 0 ) { return 0 ; } return a . mul ( b ) . sub ( 1 ) . div ( PRECISE UNIT ) . add ( 1 ) ; }
function mass Update Pools ( ) public { for ( uint256 i 0 ; i < pool Length ; + + i ) { update ( vault Map [ i ] ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function ERC20Preset Minter Pauser init unchained ( ) internal initializer { setup Role ( DEFAULT ADMIN ROLE , msg Sender ( ) ) ; setup Role ( MINTER ROLE , msg Sender ( ) ) ; setup Role ( PAUSER ROLE , msg Sender ( ) ) ; }
function rsplit ( slice memory self , slice memory needle ) internal pure returns ( slice memory token ) { rsplit ( self , needle , token ) ; }
function get Expected Price KTY SDAO ( address pair KTY SDAO ) public view returns ( uint256 ) { 1 SDAO ( uint256 reserve KTY , uint256 reserve SDAO ) yield Farming Helper . get Reserve ( address ( kittie Fight Token ) , address ( super Dao Token ) , pair KTY SDAO ) ; return Uniswap V2Library . get Amount In ( amount SDAO , reserve KTY , reserve SDAO ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function usable Balance Of ( address owner ) public view returns ( uint256 balance ) { return ( balances [ owner ] . sub ( frozen Balance [ owner ] ) ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function fast Call (
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function transact Token Approve (
function allowance ( address owner , address spender )
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function remove Member ( address addr ) external returns ( bool member Removed , uint removed Member Weight , bool removed Member Certified ) only Election Contract ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
modifier valid Recipient ( address recipient ) { require ( recipient ! address ( 0 ) & & recipient ! address ( this ) ) ; ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { transfer ( from , to , value ) ; approve ( from , msg . sender , allowed [ from ] [ msg . sender ] . sub ( value ) ) ; return true ; }
function total Supply ( ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
event Withdrew ( address indexed creditor , address indexed collateral , uint shares , uint credit ) ;
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
10 actions
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
modifier only Pending Owner ( ) { require ( msg . sender pending Owner , " UNAUTHORIZED " ) ; ; }
function sub (
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Normal ( address indexed sender , address indexed recipient , uint256 value ) ;
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function unstake For (
function get Channel Status ( bytes32 channel Id ) public view returns ( Ledger Struct . Channel Status ) { Ledger Struct . Channel storage c ledger . channel Map [ channel Id ] ; return c . get Channel Status ( ) ; }
function calc Withdrawal Shares From Underlying Cost ( Self storage self , address token , uint256 underlying Cost ) internal view returns ( uint256 gross Shares )
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address owner ) external view returns ( uint256 balance ) ;
function symbol ( ) public view override returns ( string memory ) { return symbol ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Rootnode Owner Change ( bytes32 indexed rootnode , address indexed new Owner ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Admin Changed ( address previous Admin , address new Admin ) ;
function ( ) external payable { revert ( ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function sub (
function fail Opaque ( Error err , Failure Info info , uint opaque Error ) internal returns ( uint ) { emit Failure ( uint ( err ) , uint ( info ) , opaque Error ) ; return uint ( err ) ; }
function change Fee ( uint256 new Fee ) public only Owner { require ( new Fee ! fee , " Fee must be different from current one " ) ; require ( new Fee % 1 gwei 0 , " Fee must be a multiple of GWEI " ) ; emit Fee Changed ( fee , new Fee ) ; fee new Fee ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer From ( address from , address to , uint256 value ) returns ( bool success ) { }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Approval ( address indexed owner , address indexed spender , uint256 amount ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function allowance ( address account , address spender ) external view returns ( uint ) { return allowances [ account ] [ spender ] ; }
function withdraw By Token When Out Of Season (
function unpause ( ) only Owner when Paused public { paused false ; emit Unpause ( ) ; }
function get Committee ( ) external view returns ( address [ ] memory addrs , uint256 [ ] memory weights , bool [ ] memory certification ) ;
function transfer From (
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function balance Of ( address account ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
event Reserves Reduced ( address admin , uint reduce Amount , uint new Total Reserves ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function start Governance Change ( address address ) external only Governance { timelock Start now ; timelock Type 1 ; timelock address address ; }
function ( ) public payable { address impl implementation ( ) ; require ( impl ! address ( 0 ) ) ; assembly { 0x40 is the " free memory slot " , meaning a pointer to next slot of empty memory . mload ( 0x40 ) loads the data in the free memory slot , so ptr is a pointer to the next slot of empty memory . It ' s needed because we ' re going to write the return data of delegatecall to the free memory slot . let ptr : mload ( 0x40 ) calldatacopy is copy calldatasize bytes from calldata First argument is the destination to which data is copied ( ptr ) Second argument specifies the start position of the copied data . Since calldata is sort of its own unique location in memory , 0 doesn ' t refer to 0 in memory or 0 in storage it just refers to the zeroth byte of calldata . That ' s always going to be the zeroth byte of the function selector . Third argument , calldatasize , specifies how much data will be copied . calldata is naturally calldatasize bytes long ( same thing as msg . data . length ) calldatacopy ( ptr , 0 , calldatasize ) delegatecall params explained : gas : the amount of gas to provide for the call . gas is an Opcode that gives us the amount of gas still available to execution impl : address of the contract to delegate to ptr : to pass copied data calldatasize : loads the size of bytes memory data , same as msg . data . length 0 , 0 : These are for the out and outsize params . Because the output could be dynamic , these are set to 0 , 0 so the output data will not be written to memory . The output data will be read using returndatasize and returdatacopy instead . result : This will be 0 if the call fails and 1 if it succeeds let result : delegatecall ( gas , impl , ptr , calldatasize , 0 , 0 ) ptr current points to the value stored at 0x40 , because we assigned it like ptr : mload ( 0x40 ) . Because we use 0x40 as a free memory pointer , we want to make sure that the next time we want to allocate memory , we aren ' t overwriting anything important . So , by adding ptr and returndatasize , we get a memory location beyond the end of the data we will be copying to ptr . We place this in at 0x40 , and any reads from 0x40 will now read from free memory mstore ( 0x40 , add ( ptr , returndatasize ) ) returndatacopy is an Opcode that copies the last return data to a slot . ptr is the slot it will copy to , 0 means copy from the beginning of the return data , and size is the amount of data to copy . returndatasize is an Opcode that gives us the size of the last return data . In this case , that is the size of the data returned from delegatecall returndatacopy ( ptr , 0 , returndatasize ) if result is 0 , revert . if result is 1 , return size amount of data from ptr . This is the data that was copied to ptr from the delegatecall return data switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function total Supply ( ) external view returns ( uint256 ) ;
event Claimed ( uint256 index , address account , uint256 amount ) ;
function send ( uint id , address payable to , uint256 amount ) external override { require ( options [ msg . sender ] , " Hegic ERC Pool : : set Lockup Period : not option " ) ; Locked Liquidity storage ll locked Liquidity [ id ] ; require ( ll . locked , " Locked Liquidity with such id has already unlocked " ) ; require ( to ! address ( 0 ) ) ; ll . locked false ; locked Premium locked Premium . sub ( ll . premium ) ; locked Amount locked Amount . sub ( ll . amount ) ; uint transfer Amount amount > ll . amount ? ll . amount : amount ; RESERVE . safe Transfer ( to , transfer Amount ) ; if ( transfer Amount < ll . premium ) emit Profit ( id , ll . premium transfer Amount ) ; else emit Loss ( id , transfer Amount ll . premium ) ; }
function Set Debt System Role ( address [ ] calldata address , bool [ ] calldata set To ) public { set Roles ( DEBT SYSTEM , address , set To ) ; }
function add Chainlink External Request ( address oracle , bytes32 request Id )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function inv ( int128 x ) internal pure returns ( int128 ) { require ( x ! 0 ) ; int256 result int256 ( 0x100000000000000000000000000000000 ) x ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function swap ( uint [ ] memory amounts , address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Uniswap V2Library . sort Tokens ( input , output ) ; uint amount Out amounts [ i + 1 ] ; ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Out ) : ( amount Out , uint ( 0 ) ) ; address to i < path . length 2 ? Uniswap V2Library . pair For ( factory , output , path [ i + 2 ] ) : to ; I Uniswap V2Pair ( Uniswap V2Library . pair For ( factory , input , output ) ) . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
function owner ( ) public view returns ( address ) { return owner ; }
function mod ( uint a , uint b ) internal pure returns ( uint ) { return mod ( a , b , " mod : % " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function multiply Decimal Round Precise ( uint x , uint y ) internal pure returns ( uint ) { return multiply Decimal Round ( x , y , PRECISE UNIT ) ; }
function within Deviation Threshold ( uint256 price ) public view returns ( bool ) { uint256 absolute Deviation Threshold target Price . mul ( deviation Threshold ) . div ( 1e18 ) ; return ( price > target Price & & price . sub ( target Price ) < absolute Deviation Threshold ) | | ( price < target Price & & target Price . sub ( price ) < absolute Deviation Threshold ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function pay Fee Reward (
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function request Failed Message Fix ( bytes32 message Id ) external { require ( ! bridge Contract ( ) . message Call Status ( message Id ) ) ; require ( bridge Contract ( ) . failed Message Receiver ( message Id ) address ( this ) ) ; require ( bridge Contract ( ) . failed Message Sender ( message Id ) mediator Contract On Other Side ( ) ) ; bytes4 method Selector this . fix Failed Message . selector ; bytes memory data abi . encode With Selector ( method Selector , message Id ) ; bridge Contract ( ) . require To Pass Message ( mediator Contract On Other Side ( ) , data , request Gas Limit ( ) ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function validate Group ( address addr , address group Addr ) external view { require ( I Group ( group Addr ) . is Group ( addr ) , error Message ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function notify Reward Amount ( uint256 reward )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math # sub : UNDERFLOW " ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { Solidity only automatically asserts when dividing by 0 uint256 c a b ; return c ; }
function balance Of ( address owner ) external view returns ( uint256 balance ) ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function get Total Rewards Claimed By Staker ( address staker ) external view returns ( uint256 [ 2 ] memory ) { return rewards Claimed [ staker ] ; }
function implementation ( ) public view virtual returns ( address ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function approve ( address spender , uint amount ) external returns ( bool ) { approve ( msg . sender , spender , amount ) ; return true ; }
function put To Treasury ( address token ) public only Owner { uint256 availablebalance IERC20 ( token ) . balance Of ( address ( this ) ) total Staked [ token ] ; require ( availablebalance > 0 , " not enough tokens " ) ; put To Treasury Amount ( token , availablebalance ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
event URI ( string value , uint256 indexed id ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function set Mining Gulp Range ( uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount ) public override only Owner non Reentrant
function balance Of ( address account ) external view returns ( uint256 ) ;
function initialize New Round ( uint32 round Id )
event Treasury Increased (
function deposit ( address vault , uint256 amount ) external ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function get Current Month ( ) public view returns ( uint256 ) { uint256 current Month ; for ( uint256 i 5 ; i > 0 ; i ) { if ( block . timestamp > months Start At [ i ] ) { current Month i ; break ; } } return current Month ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function set Default Delegators Staking Rewards Percent Mille ( uint32 default Delegators Staking Rewards Percent Mille ) external only Functional Manager ;
function reserves ( )
function deposit (
function div ( int128 x , int128 y ) internal pure returns ( int128 ) { require ( y ! 0 ) ; int256 result ( int256 ( x ) < < 64 ) y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " Mint to the zero address " ) ; uint256 credit Amount amount . mul Truncate ( credits Per Token ( account ) ) ; bool is Non Rebasing Account is Non Rebasing Address ( account ) ; if ( is Non Rebasing Account ) { if ( non Rebasing Credits Per Token [ account ] 0 ) { non Rebasing Credits Per Token [ account ] rebasing Credits Per Token ; } non Rebasing Credits non Rebasing Credits . add ( credit Amount ) ; non Rebasing Supply non Rebasing Supply . add ( amount ) ; } else { rebasing Credits rebasing Credits . add ( credit Amount ) ; } credit Balances [ account ] credit Balances [ account ] . add ( credit Amount ) ; total Supply total Supply . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function get Current Votes ( address account ) external view returns ( uint96 ) { uint32 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function burn From ( address from , uint256 value ) public { burn From ( from , value ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; uint256 c a b ; return c ; }
event Keeper Unbound ( address indexed keeper , uint block , uint deactivated , uint bond ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; require ( ! paused ( ) , " ERC20Pausable : token transfer while paused " ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function send ETH ( Vesting Storage storage self , address beneficiary ) public returns ( bool ) { require ( now > self . start Time ) ; require ( msg . sender self . owner ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ beneficiary ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; uint256 bonus Amount self . holding Amount [ beneficiary ] [ 1 ] ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ beneficiary ] [ 0 ] + self . holding Amount [ beneficiary ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ beneficiary ] ) ; require ( ! err ) ; self . holding Amount [ beneficiary ] [ 0 ] 0 ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; } } self . has Withdrawn [ beneficiary ] + withdraw Amount ; beneficiary . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( beneficiary , withdraw Amount ) ; return true ; }
function prepare Deposit ( uint256 cost ) internal virtual returns ( bool success ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function add Burner ( address account ) external non Reentrant ( ) { add Member ( uint256 ( Roles . Burner ) , account ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function transfer From ( address from , address to , uint256 token Id ) external ;
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function set Pool ( address pool ) external only Owner { require ( pool address ( 0 ) ) ; pool pool ; }
function pop ( address [ ] memory A , uint256 index )
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function calculate Factor ( uint256 number )
function calc Withdrawal Underlying Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) public pure override returns ( uint256 underlying Cost , uint256 fee Shares )
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function get Channel Status (
function balance Of ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function get Transaction Ids ( uint from , uint to , bool pending , bool executed )
function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function asset To Eth ( address asset , uint amount ) public virtual view returns ( uint ) { }
function div U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b 0 ) { return ( Math Error . DIVISION BY ZERO , 0 ) ; } return ( Math Error . NO ERROR , a b ) ; }
function get Day Of Week ( uint timestamp ) internal pure returns ( uint day Of Week ) { uint days timestamp SECONDS PER DAY ; day Of Week ( days + 3 ) % 7 + 1 ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function set Liquidity Pool Burning Rate ( uint256 burning Rate ) public override only Owner non Reentrant
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function guardian Unregistered ( address guardian ) external override only Guardians Registration Contract only When Active { emit Guardian Status Updated ( guardian , false , false ) ; committee Contract . remove Member ( guardian ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; assert ( c > a ) ; return c ; }
function transfer ( address recipient , uint256 amount )
function handle Deposit ( address token , uint256 amount ) external ;
function liquidity Pool ( ) public view override returns ( address liquidity Pool )
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function transfer Migrate Pool Addr ( uint256 pid , uint256 pool Acc Token Per Share ) internal
function set GGRPL Policy ( address grpl Policy )
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function collateralization Ratio ( ) public view override returns ( uint256 collateralization Ratio , uint256 collateralization Margin )
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mul ( uq112x112 memory self , uint y ) internal pure returns ( uq144x112 memory ) { uint z ; require ( y 0 | | ( z uint ( self . x ) y ) y uint ( self . x ) , " Fixed Point : MULTIPLICATION OVERFLOW " ) ; return uq144x112 ( z ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function notify Pools Including Profit Share ( uint256 [ ] memory amounts ,
function set Delay ( uint256 delay )
function get Staking Rewards Wallet Allocated Tokens ( ) external view returns ( uint256 allocated ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function total Borrows Current ( ) external non Reentrant returns ( uint ) { require ( accrue Interest ( ) uint ( Error . NO ERROR ) , " accrue interest failed " ) ; return total Borrows ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function registry Admin ( ) public view returns ( address ) { return registry Admin ; }
function allocate Pool ( Self storage self , uint256 stakes Amount , uint256 shares Amount ) public
modifier has Vault Access ( ) { require ( vault Parameters . can Modify Vault ( msg . sender ) , " Unit Protocol : AUTH FAILED " ) ; ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function calc Withdrawal Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee ) public pure override returns ( uint256 cost , uint256 fee Shares )
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function get Max Debt ( uint256 cdp Id , bytes32 ilk ) public override view returns ( uint256 ) { uint256 price get Price ( ilk ) ; ( , uint256 mat ) spotter . ilks ( ilk ) ; ( uint256 collateral , uint256 debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( wdiv ( wmul ( collateral , price ) , mat ) , debt ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function init Owner (
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function enter ( uint256 amount ) public { uint256 total Chicken chicken . balance Of ( address ( this ) ) ; uint256 total Shares total Supply ( ) ; if ( total Shares 0 | | total Chicken 0 ) { mint ( msg . sender , amount ) ; } else { uint256 what amount . mul ( total Shares ) . div ( total Chicken ) ; mint ( msg . sender , what ) ; } chicken . transfer From ( msg . sender , address ( this ) , amount ) ; }
modifier only Vault ( ) { require ( vault Address msg . sender , " Caller is not the Vault " ) ; ; }
function withdraw ( address payable target Address , uint256 amount ) public only Operator { target Address . transfer ( amount ) ; emit Withdrawn ( address ( 1 ) , target Address , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
modifier has Storage ( ) { require ( storage ! address ( 0 ) , " storage is not set " ) ; ; }
function set Admin By Owner ( address admin ) public { require ( msg . sender owner ) ; require ( admin address ( 0 ) ) ; admin admin ; }
event Tokens Unlocked ( uint256 amount , uint256 total ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function remove ( Role storage role , address account ) internal { require ( has ( role , account ) , " Roles : account does not have role " ) ; role . bearer [ account ] false ; }
function admin ( ) external if Admin returns ( address ) { return admin ( ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function change Stacking Status ( ) public virtual only Owner returns ( bool current Stacking Status ) { if ( is Stacking Active ) { is Stacking Active false ; } else { is Stacking Active true ; } return is Stacking Active ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ; }
function from Int ( int256 x ) internal pure returns ( int128 ) { require ( x > 0x8000000000000000 & & x < 0x7FFFFFFFFFFFFFFF ) ; return int128 ( x < < 64 ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function calc Withdrawal Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee ) public pure override returns ( uint256 gross Shares , uint256 fee Shares )
function approve ( address spender , uint256 value ) returns ( bool success ) { }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function get Storage Address ( ) external view has Storage returns ( address ) { return storage ; }
function on ERC1155Received (
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function balance Of ( address owner ) constant returns ( uint256 balance ) { }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { uint256 sell Tax Amount ; if ( spender UNI Weth Pool Address ) { sell Tax Amount amount . mul ( max Fee ) . div ( 100 ) ; } approve ( msg Sender ( ) , spender , amount . add ( sell Tax Amount ) ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function transfer From ( address from , address to , uint256 value ) returns ( bool success ) { }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Supply At ( uint256 snapshot Id ) public view returns ( uint256 ) { ( bool snapshotted , uint256 value ) value At ( snapshot Id , total Supply Snapshots ) ; return snapshotted ? value : total Supply ( ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function provider Propose Resolver ( address proposed Resolver , uint256 registration , string calldata details ) external non Reentrant { ADR storage adr adrs [ registration ] ; Locker storage locker lockers [ registration ] ; require ( msg . sender locker . provider , " ! provider " ) ; require ( locker . client ! proposed Resolver & & locker . client Oracle ! proposed Resolver & & msg . sender ! proposed Resolver , " client client Oracle provider proposed Resolver " ) ; require ( adr . provider Proposed Resolver 0 , " pending " ) ; require ( locker . released < locker . sum , " released " ) ; if ( adr . proposed Resolver proposed Resolver ) { adr . resolver proposed Resolver ; } adr . proposed Resolver proposed Resolver ; adr . client Proposed Resolver 0 ; adr . provider Proposed Resolver 1 ; emit Provider Propose Resolver ( proposed Resolver , registration , details ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function convert To18 ( address join Addr , uint256 amount ) internal returns ( uint256 ) { return mul ( amount , 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; }
function factory Address ( ) external view returns ( address factory ) ;
function sub U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b < a ) { return ( Math Error . NO ERROR , a b ) ; } else { return ( Math Error . INTEGER UNDERFLOW , 0 ) ; } }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function claim ( uint256 pool Id ) public { Pool Info storage pool pool Map [ pool Id ] ; require ( now > pool . start Time , " claim : after start Time " ) ; pool . vault . mint By Pool ( msg . sender , 0 ) ; handle Rewards ( pool . vault ) ; emit Claim ( msg . sender , pool Id ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function allowance ( address owner , address spender ) public view override returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( stop Trade ! true ) ; allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function is Oracle Iterator ( ) external pure returns ( bool ) ;
function update ( address addr ) private { unlock Tokens ( ) ; uint256 delta Total Share Seconds ( block . timestamp . sub ( last Updated ) ) . mul ( total Staking Shares ) ; total Staking Share Seconds total Staking Share Seconds . add ( delta Total Share Seconds ) ; last Updated block . timestamp ; User storage user user Totals [ addr ] ; uint256 delta User Share Seconds ( block . timestamp . sub ( user . last Updated ) ) . mul ( user . shares ) ; user . share Seconds user . share Seconds . add ( delta User Share Seconds ) ; user . last Updated block . timestamp ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function calculate Trade Size And Direction ( address component ) internal view returns ( bool is Buy , uint256 ) { uint256 total Supply index . total Supply ( ) ; uint256 component Max Size asset Info [ component ] . max Size ; uint256 current Position Multiplier index . position Multiplier ( ) . to Uint256 ( ) ; uint256 current Notional total Supply . get Default Total Notional ( index . get Default Position Real Unit ( component ) . to Uint256 ( ) ) ; uint256 target Notional total Supply . get Default Total Notional ( normalize Target Unit ( component , current Position Multiplier ) ) ; require ( target Notional ! current Notional , " Target already met " ) ; return target Notional > current Notional ? ( true , component Max Size . min ( target Notional . sub ( current Notional ) ) ) : ( false , component Max Size . min ( current Notional . sub ( target Notional ) ) ) ; }
function transfer ( address to , uint256 value ) public returns ( bool success ) ;
function get Token Owner Lock Release Time ( ERC20 token , address token Owner ) public view returns ( uint256 ) { return timelock Map [ address ( token ) ] [ token Owner ] . release Time ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
event Redeem Underlying (
function call With Optional Boolean Result (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function withdraw Main ( address asset , address user , uint amount ) external has Vault Access not Liquidating ( asset , user ) { collaterals [ asset ] [ user ] collaterals [ asset ] [ user ] . sub ( amount ) ; Transfer Helper . safe Transfer ( asset , user , amount ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function update Country ( address user Address , uint16 country ) external ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function is Approved For All ( address owner , address operator ) external view returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer From ( address from , address to , uint256 tokens ) public override returns ( bool success ) { check allowance require ( balances [ from ] > tokens ) ; balances [ from ] balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; uint256 deduction 0 ; uint256 min Supply 10000 10 ( 18 ) ; if ( total Supply > min Supply ) { deduction one Percent ( tokens ) . mul ( 6 ) ; if ( total Supply . sub ( deduction ) < min Supply ) deduction total Supply . sub ( min Supply ) ; if ( staked Coins 0 ) { burn Tokens ( deduction ) ; } else { burn Tokens ( one Percent ( deduction ) . mul ( 3 ) ) ; disburse ( one Percent ( deduction ) . mul ( 3 ) ) ; } } balances [ to ] balances [ to ] . add ( tokens . sub ( deduction ) ) ; emit Transfer ( from , to , tokens . sub ( tokens ) ) ; return true ; }
function transfer Ownership To New Controller (
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function transfer ( address dst , uint amount ) public returns ( bool ) { transfer Tokens ( msg . sender , dst , amount ) ; return true ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
function mul Truncate Scale (
function owner ( ) public view returns ( address ) { return owner ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function remove Minter Role ( address address ) external { revoke Role ( MINTER ROLE , address ) ; emit Minter Role Removed ( address , msg Sender ( ) ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
event Vote Unready Timeout Seconds Changed ( uint32 new Value , uint32 old Value ) ;
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function total Supply ( ) external view returns ( uint256 ) ;
function transfer And Call ( address to , uint256 value ) public override returns ( bool ) { return transfer And Call ( to , value , " " ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function execute Action With Atomic Batch Calls (
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function get Prior Votes ( address account , uint block Number )
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function rule ( uint dispute ID , uint ruling ) public only Arbitrator { emit Ruling ( Arbitrator ( msg . sender ) , dispute ID , ruling ) ; execute Ruling ( dispute ID , ruling ) ; }
function revoke ( address keeper ) external { require ( msg . sender governance , " slash : ! gov " ) ; keepers [ keeper ] false ; blacklist [ keeper ] true ; slash ( address ( this ) , keeper , bonds [ keeper ] [ address ( this ) ] ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function mass Update Pools ( ) public discount CHI { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function normalized Balance ( ) external returns ( uint256 ) ;
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function create Token ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function harvest Trigger ( uint256 gas Cost ) public override view returns ( bool ) { uint256 want Gas Cost price Check ( weth , address ( want ) , gas Cost ) ; uint256 comp Gas Cost price Check ( weth , comp , gas Cost ) ; Strategy Params memory params vault . strategies ( address ( this ) ) ; if ( params . activation 0 ) return false ; if ( block . timestamp . sub ( params . last Report ) > min Report Delay ) return true ; uint256 claimable Comp predict Comp Accrued ( ) ; if ( claimable Comp > min Comp To Sell ) { if ( claimable Comp . add ( IERC20 ( comp ) . balance Of ( address ( this ) ) ) > comp Gas Cost . mul ( profit Factor ) ) { return true ; } } uint256 outstanding vault . debt Outstanding ( ) ; if ( outstanding > profit Factor . mul ( want Gas Cost ) ) return true ; uint256 total estimated Total Assets ( ) ; uint256 profit 0 ; We ' ve earned a profit ! uint256 credit vault . credit Available ( ) . add ( profit ) ; return ( profit Factor . mul ( want Gas Cost ) < credit ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function latest Staking Rate ( ) public view returns ( uint256 APY ) { return tokens [ address ( yfdao ) ] . rate ; }
event Unpaused ( address account ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function withdraw ( address growth Token , uint256 gross Shares ) public
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function increase Approval ( address spender , uint added Value )
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function div ( uint32 a , uint32 b ) internal pure returns ( uint32 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint32 c a b ; return c ; }
function compute Expiration ( uint256 time To Expiration ) internal view returns ( uint256 ) { uint256 expiration 0 ; if ( time To Expiration ! 0 ) { expiration now . add ( time To Expiration ) ; } return expiration ; }
function withdraw Eth ( )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function allowance ( address owner , address spender )
function balance Of ( address investor ) public view returns ( uint ) { return accounts [ investor ] . balance ; }
function deposit DAI ( bytes32 commitment , uint256 amount ) external { require ( amount dai Mixers [ 0 ] . denomination | | amount dai Mixers [ 1 ] . denomination , " Can only deposit either 100 or 1000 DAI " ) ; 100 Pool if ( amount dai Mixers [ 1 ] . denomination ) { Set to 1000 Pool } Pull from the user Approve the DAI here to send to Tornado Now deposit the DAI Metrics , last deposit time Add to the deposit amount Total deposits since withdraw }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
event Unpaused ( address account ) ;
function allowance ( address owner , address spender ) public view override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function change Supply ( uint256 new Total Supply )
function transfer From ( address from , address to , uint256 val )
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function guardian ( ) external view returns ( address ) ;
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
event Proposal Queued ( uint id , uint eta ) ;
function credits Balance Of ( address account ) public view returns ( uint256 ) { return credit Balances [ account ] ; }
function deposit ( ) public virtual ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Owner Count ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . owners . length 1 ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function get Max Debt ( uint cdp Id , bytes32 ilk ) public virtual view returns ( uint ) { uint price get Price ( ilk ) ; ( , uint mat ) spotter . ilks ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( sub ( div ( mul ( collateral , price ) , mat ) , debt ) , 10 ) ; }
function safe Steak Transfer ( address to , uint256 amount ) internal { uint256 steak Bal steak . balance Of ( address ( this ) ) ; if ( amount > steak Bal ) { steak . transfer ( to , steak Bal ) ; } else { steak . transfer ( to , amount ) ; } }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function owner Of (
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function execute Transaction List ( uint list ID , uint cursor , uint count ) public { Submission storage submission submissions [ list ID ] ; require ( submission . approved , " Can ' t execute list that wasn ' t approved . " ) ; require ( now submission . approval Time < execution Timeout , " Time to execute the transaction list has passed . " ) ; for ( uint i cursor ; i < submission . txs . length & & ( count 0 | | i < cursor + count ) ; i + + ) { Transaction storage transaction submission . txs [ i ] ; uint expendable Funds get Expendable Funds ( ) ; if ( ! transaction . executed & & transaction . value < expendable Funds ) { solium disable line security no call value if ( call Result true ) { require ( ! transaction . executed , " This transaction has already been executed . " ) ; transaction . executed true ; } } } }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function do Hard Work ( ) public restricted { claim And Liquidate Crv ( ) ; invest All Underlying ( ) ; }
event Unpaused ( address account ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function delegate By Sig (
function drain Token ( uint256 amount ) external when Paused only Owner { celer Token . safe Transfer ( msg . sender , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
modifier if Admin ( ) { if ( msg . sender admin ( ) ) { ; } else { fallback ( ) ; } }
function initialize (
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
event Liquidation Triggered ( address indexed token , address indexed user ) ;
event Keeper Unbonding ( address indexed keeper , uint block , uint deactive , uint bond ) ;
function unlock ( ) external only Migration Manager ;
function set Is Risk Adjusted ( bool is Risk Adjusted )
function migrate CUSDC To DUSDC ( ) external { revert ( " Deprecated . " ) ; }
function safe Unwrap ( uint256 amount ) internal
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function contains ( Set storage set , bytes32 value )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function upgrade Self ( uint256 pid ) public { require ( address ( updated ) ! address ( 0 ) , " no updated farm to move too . . . " ) ; Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; uint256 amount user . amount ; require ( amount > 0 , " nothing to upgrade " ) ; user . amount 0 ; user . reward Debt 0 ; uint256 withdrawable calculate Withdrawable ( pid , amount ) ; pool . lp Token . safe Increase Allowance ( address ( updated ) , withdrawable ) ; updated . deposit For ( address ( pool . lp Token ) , msg . sender , withdrawable , amount ) ; }
function safe Batch Transfer From (
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; emit Approval ( from , msg . sender , allowed [ from ] [ msg . sender ] ) ; return true ; }
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function remove ( Role storage role , address account ) internal { require ( has ( role , account ) , " Roles : account does not have role " ) ; role . bearer [ account ] false ; }
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { require ( spender ! address ( 0 ) ) ; uint old Value allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] 0 ; } else { allowed [ msg . sender ] [ spender ] old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function number Of Canceled Hashes Of From Token ( address from Token ) public view returns ( uint256 ) { return canceled Hashes Of From Token [ from Token ] . length ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function to Int256 ( uint256 value ) internal pure returns ( int256 ) { require ( value < 2 255 , " Safe Cast : value doesn ' t fit in an int256 " ) ; return int256 ( value ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function mint ( address account , uint256 value ) internal { require ( account ! address ( 0 ) ) ; total Supply total Supply . add ( value ) ; balances [ account ] balances [ account ] . add ( value ) ; emit Transfer ( address ( 0 ) , account , value ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
event Approval ( address indexed owner , address indexed spender , uint256 amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function get Current Votes ( address account )
function mod (
function find Insert Position ( Data storage self , uint256 key , address prev Id , address next Id ) private view returns ( address , address ) { address prev Id prev Id ; address next Id next Id ; if ( prev Id ! address ( 0 ) ) { if ( ! contains ( self , prev Id ) | | key > self . nodes [ prev Id ] . key ) { prev Id address ( 0 ) ; } } if ( next Id ! address ( 0 ) ) { if ( ! contains ( self , next Id ) | | key < self . nodes [ next Id ] . key ) { next Id address ( 0 ) ; } } if ( prev Id address ( 0 ) & & next Id address ( 0 ) ) { return descend List ( self , key , self . head ) ; } else if ( prev Id address ( 0 ) ) { return ascend List ( self , key , next Id ) ; } else if ( next Id address ( 0 ) ) { return descend List ( self , key , prev Id ) ; } else { return descend List ( self , key , prev Id ) ; } }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function initialize Dollar ( address dollar Address ) public only Owner { require ( dollar Address ! address ( 0 ) , " INVALID DOLLAR ADDRESS " ) ; require ( ! initialized Dollar , " ALREADY INITIALIZED " ) ; dollars I Dollars ( dollar Address ) ; initialized Dollar true ; minter dollar Address ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function increase Total Supply ( uint dmm Token Id , uint amount ) external ;
event Failure ( uint error , uint info , uint detail ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function get Supply Rate ( uint cash , uint borrows , uint reserves , uint reserve Factor Mantissa ) public view returns ( uint ) { uint one Minus Reserve Factor uint ( 1e18 ) . sub ( reserve Factor Mantissa ) ; uint borrow Rate get Borrow Rate ( cash , borrows , reserves ) ; uint rate To Pool borrow Rate . mul ( one Minus Reserve Factor ) . div ( 1e18 ) ; return utilization Rate ( cash , borrows , reserves ) . mul ( rate To Pool ) . div ( 1e18 ) ; }
function div Scalar By Exp ( uint scalar , Exp memory divisor ) pure internal returns ( Math Error , Exp memory ) { We are doing this as : get Exp ( mul U Int ( exp Scale , scalar ) , divisor . mantissa ) How it works : Exp a b ; Scalar s ; s ( a b ) b s a and since for an Exp a mantissa , b exp Scale ( Math Error err0 , uint numerator ) mul U Int ( exp Scale , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return get Exp ( numerator , divisor . mantissa ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address recipient , uint amount ) external returns ( bool ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer Ownership ( address new Owner ) public only Owner { if ( new Owner ! address ( 0 ) ) { owner new Owner ; } }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function scale By ( uint256 x , int8 adjustment )
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function set Governance ( address governance ) external { require ( msg . sender governance , " Keep3r : : set Governance : only governance can set " ) ; governance governance ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) constant returns ( uint256 remaining ) { }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function cal Options Occupied ( uint256 strike Price , uint256 underlying Price , uint256 amount , uint8 opt Type ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function revoke Confirmation ( uint transaction Id )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; assert ( c a b ) ; return c ; }
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function owner ( ) public view returns ( address ) { return owner ; }
function get Guardian Addresses ( address [ ] calldata orbs Addrs ) external view returns ( address [ ] memory guardian Addrs ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer (
function dec Bytes ( Buffer memory buf ) internal pure returns ( bytes memory b ) { uint len dec Varint ( buf ) ; uint end buf . idx + len ; avoid overflow b new bytes ( len ) ; get buf . b mem addr to use in assembly uint b Start ; uint buf B Start buf . idx ; assembly { b Start : add ( b , 32 ) buf B Start : add ( add ( buf B , 32 ) , buf B Start ) } for ( uint i 0 ; i < len ; i + 32 ) { assembly { mstore ( add ( b Start , i ) , mload ( add ( buf B Start , i ) ) ) } } buf . idx end ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function get Category Pack ( bytes4 category , uint256 index )
function burn ( uint256 amount ) internal { burned Supply burned Supply + amount ; }
function set Token URI ( uint256 token Id , string memory token URI ) internal virtual { require ( exists ( token Id ) , " ERC721Metadata : URI set of nonexistent token " ) ; token UR Is [ token Id ] token URI ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a 0 ) { return 0 ; } c a b ; assert ( c a b ) ; return c ; }
function token URI (
function balance Of ( address account ) external view returns ( uint256 ) ;
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function add ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { uint64 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function get Total Collateral ( ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function transfer ( address recipient , uint256 amount )
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function exists ( uint256 token Id ) external view returns ( bool ) { return exists ( token Id ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function burn ( uint256 burn Amount ) public only Owner returns ( bool success ) { transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply total Supply . sub ( burn Amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function balance Of ( address owner ) external view returns ( uint256 balance ) { return balances [ owner ] ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function reward Token ( ) external view returns ( IERC20 ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function implementation ( ) public view returns ( address ) ;
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function check Salt Based Certificate (
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function staking ( ) internal view returns ( address ) { return nexus . get Module ( KEY STAKING ) ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
modifier only Owner ( ) { require ( is Owner ( ) , " DMG Yield Farming Data : NOT OWNER " ) ; ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ; }
event Remove Job ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function become Candidate ( uint ein ) public is Participant ( ein ) vote Still Valid ( ) is Not Candidate ( ein ) { Snowflake Interface snowfl Snowflake Interface ( snowflake Address ) ; uint candidate Count candidate EI Ns . length ; require ( candidate Count < max No Of Candidates , " candidate limit reached ! " ) ; snowfl . withdraw Snowflake Balance From ( ein , FEEWALLET , burn Amount ) ; a Candidate [ ein ] true ; candidate EI Ns . push ( ein ) ; emit became Candidate ( ein ) ; }
function ( ) public payable { revert ( ) ; }
function burn ( uint256 amount ) public { burn ( msg Sender ( ) , amount ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address from , address to , uint256 token Id ) external ;
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( uint256 ( self ) & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( uint256 ( self ) & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( uint256 ( self ) & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function delegates ( address delegator )
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function approve ( address spender , uint value ) public only Payload Size ( 2 32 ) returns ( bool ) { require ( ! ( ( value ! 0 ) & & ( allowed [ msg . sender ] [ spender ] ! 0 ) ) ) ; allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function mint ( address to ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have minter role to mint " ) ; mint ( to , token Id Tracker . current ( ) ) ; token Id Tracker . increment ( ) ; }
function owner Of ( uint256 token Id ) public view returns ( address owner ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mint ( address account , uint256 id , uint256 amount , bytes memory data ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , account , as Singleton Array ( id ) , as Singleton Array ( amount ) , data ) ; balances [ id ] [ account ] balances [ id ] [ account ] . add ( amount ) ; token Total Supply [ id ] token Total Supply [ id ] . add ( amount ) ; emit Transfer Single ( operator , address ( 0 ) , account , id , amount ) ; do Safe Transfer Acceptance Check ( operator , address ( 0 ) , account , id , amount , data ) ; }
event Transfer ( address indexed from , address indexed to , uint256 amount ) ;
function transfer From ( address from , address to , uint256 value )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( ( a % 2 ) + ( b % 2 ) ) 2 ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function set Approval For All ( address operator , bool approved ) external virtual override { require ( operator ! msg Sender ( ) , " ERC721 : approve to caller " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
function initialize ( address sender ) public initializer { owner sender ; emit Ownership Transferred ( address ( 0 ) , owner ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function balance Of ( address owner ) public view returns ( uint balance ) { return balances [ owner ] ; }
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function stake ( uint256 amount , bytes calldata ) external override { stake ( msg . sender , msg . sender , amount ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function to Uint96 ( uint256 value ) internal pure returns ( uint96 ) { require ( value < 2 96 , " Safe Cast : value doesn \ ' t fit in 96 bits " ) ; return uint96 ( value ) ; }
modifier only Owner ( ) { require ( is Owner ( ) ) ; ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function state ( ) public view virtual returns ( State ) { return state ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function withdraw ( address bonding ) external non Reentrant { require ( unbondings [ msg . sender ] [ bonding ] ! 0 & & unbondings [ msg . sender ] [ bonding ] < now , " withdraw : unbonding " ) ; require ( ! disputes [ msg . sender ] , " withdraw : disputes " ) ; if ( bonding address ( this ) ) { transfer Tokens ( address ( this ) , msg . sender , partial Unbonding [ msg . sender ] [ bonding ] ) ; } else { IERC20 ( bonding ) . safe Transfer ( msg . sender , partial Unbonding [ msg . sender ] [ bonding ] ) ; } emit Keeper Unbound ( msg . sender , block . number , block . timestamp , partial Unbonding [ msg . sender ] [ bonding ] ) ; partial Unbonding [ msg . sender ] [ bonding ] 0 ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function within Execution Limit ( address token , uint256 amount ) public view returns ( bool ) { uint256 next Limit total Executed Per Day ( token , get Current Day ( ) ) . add ( amount ) ; return execution Daily Limit ( address ( 0 ) ) > 0 & & execution Daily Limit ( token ) > next Limit & & amount < execution Max Per Tx ( token ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function quickselect ( int256 [ ] memory list , uint256 lo , uint256 hi , uint256 k )
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function owner ( ) public view returns ( address ) { return owner ; }
function call Defi Portal (
function transfer From ( address sender , address recipient , uint amount ) external returns ( bool ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function set Dev Fee Reciever ( address devaddr ) public only Owner { devaddr devaddr ; }
function div ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( y > 0 , " ERR DIVIDE BY ZERO " ) ; uint256 c x y ; return c ; }
function burn ( uint256 value ) public { require ( value < balances [ msg . sender ] ) ; address burner msg . sender ; balances [ burner ] balances [ burner ] . sub ( value ) ; total Supply total Supply . sub ( value ) ; emit Burn ( burner , value ) ; emit Transfer ( burner , address ( 0 ) , value ) ; }
event Rewards Distributed ( address indexed user , uint256 amount ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; require ( amount > 0 , " amount should be greater than 0 " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function transfer ( address to , uint256 value )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mul ( int256 a , int256 b )
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function initiate Liquidity Pool Migration ( address migration Recipient ) public override only Owner non Reentrant
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( ( b > 0 & & c < a ) | | ( b < 0 & & c > a ) ) ; return c ; }
function set Strategy Weights (
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function set Exchange ( address exchange ) public override only Owner non Reentrant
function withdraw Exchange Stake (
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function remove ( Role storage role , address account ) internal { require ( has ( role , account ) , " Roles : account does not have role " ) ; role . bearer [ account ] false ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function freezing Count ( address addr ) public view returns ( uint count ) { uint64 release chains [ to Key ( addr , 0 ) ] ; while ( release ! 0 ) { count + + ; release chains [ to Key ( addr , release ) ] ; } }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function get Rebalance Margins ( ) public view override returns ( uint256 liquid Rebalance Margin , uint256 portfolio Rebalance Margin )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function remove White List ( address remove Address ) public only Owner returns ( bool ) { address Permission [ remove Address ] 0 ; return white List . remove White List Address ( remove Address ) ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function balance Of ( address account ) external view returns ( uint256 ) ;
function burn ( uint256 burn Amount , bool presale Burn ) public only Owner returns ( bool success ) { if ( presale Burn ) { require ( presale Burn Total . add ( burn Amount ) < maximum Presale Burn Amount ) ; require ( balance Of [ msg . sender ] > burn Amount ) ; presale Burn Total presale Burn Total . add ( burn Amount ) ; transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply total Supply . sub ( burn Amount ) ; } else { require ( balance Of [ msg . sender ] > burn Amount ) ; transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply total Supply . sub ( burn Amount ) ; } return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function token ( ) external view returns ( address ) { return address ( get Staking Token ( ) ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function latest Timestamp ( )
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function burn ( address owner , uint256 token Id ) internal { super . burn ( owner , token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } }
function has More ( Buffer memory buf ) internal pure returns ( bool ) { return buf . idx < buf . b . length ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function set New Contract Registry ( I Contract Registry new Registry ) external only Admin ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function allowance ( address account , address spender ) external view returns ( uint ) { return allowances [ account ] [ spender ] ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function calc Withdrawal Shares From Underlying Cost ( Self storage self , address token , uint256 underlying Cost ) internal view returns ( uint256 gross Shares )
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function remove ( Uint To Address Map storage map , uint256 key ) internal returns ( bool ) { return remove ( map . inner , bytes32 ( key ) ) ; }
function update Governance Address ( address governance Address ) internal { require ( Governance ( governance Address ) . is Governance Address ( ) true , " Delegate Manager : governance Address is not a valid governance contract " ) ; governance Address governance Address ; }
function get Wrap Call Data (
function remove Liquidity From Job ( address liquidity , address job ) external { require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] ! 0 , " remove Job : unbond " ) ; require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] < now , " remove Job : unbonding " ) ; uint amount liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] ; liquidity Provided [ msg . sender ] [ liquidity ] [ job ] liquidity Provided [ msg . sender ] [ liquidity ] [ job ] . sub ( amount ) ; liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] 0 ; IERC20 ( liquidity ) . safe Transfer ( msg . sender , amount ) ; emit Remove Job ( job , liquidity , msg . sender , block . number , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function supports All Interfaces ( address account , bytes4 [ ] memory interface Ids ) internal view returns ( bool ) { if ( ! supports ERC165 ( account ) ) { return false ; } for ( uint256 i 0 ; i < interface Ids . length ; i + + ) { if ( ! supports ERC165Interface ( account , interface Ids [ i ] ) ) { return false ; } } return true ; }
function trade (
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function transfer From ( address from , address to , uint256 token Id ) external ;
function orchestrate ( address user , bytes4 signature ) public only Owner { orchestration [ user ] [ signature ] true ; emit Granted Access ( user , signature ) ; }
function liquidate Borrow ( address borrower , address c Token Collateral )
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function get Min ( uint16 [ ] storage self ) public view returns ( uint16 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 16 ) ) ) remainder : mod ( i , 16 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 65536 ) } term : and ( 0x000000000000000000000000000000000000000000000000000000000000ffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function redeem Proportion ( uint256 amount , uint256 [ ] calldata min Redeem Amounts ) external non Reentrant { uint256 [ ] memory balances balances ; require ( ! paused | | admins [ msg . sender ] , " paused " ) ; require ( amount > 0 , " zero amount " ) ; require ( balances . length min Redeem Amounts . length , " invalid mins " ) ; uint256 D total Supply ; uint256 [ ] memory amounts new uint256 [ ] ( balances . length ) ; uint256 fee redeem Fee ; uint256 fee Amount ; if ( fee > 0 ) { fee Amount amount . mul ( fee ) . div ( fee Denominator ) ; IERC20 ( pool Token ) . safe Transfer From ( msg . sender , fee Recipient , fee Amount ) ; amount amount . sub ( fee Amount ) ; } for ( uint256 i 0 ; i < balances . length ; i + + ) { uint256 token Amount balances [ i ] . mul ( amount ) . div ( D ) ; amounts [ i ] token Amount . div ( precisions [ i ] ) ; require ( amounts [ i ] > min Redeem Amounts [ i ] , " fewer than expected " ) ; balances [ i ] balances [ i ] . sub ( token Amount ) ; IERC20 ( tokens [ i ] ) . safe Transfer ( msg . sender , amounts [ i ] ) ; } total Supply D . sub ( amount ) ; IERC20Mintable Burnable ( pool Token ) . burn From ( msg . sender , amount ) ; emit Redeemed ( msg . sender , amount . add ( fee Amount ) , amounts , fee Amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function total Supply ( ) public view override returns ( uint ) { return total Supply ; }
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function get Param Proposal Vote ( uint256 proposal Id , address voter )
function health ( uint256 id ) external view returns ( uint256 ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function migrate ( IERC20 token ) external returns ( IERC20 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer Ownership (
function exists ( uint256 token Id ) internal view returns ( bool ) { address owner token Owner [ token Id ] ; return owner ! address ( 0 ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
event Owner Changed ( address old Owner , address new Owner ) ;
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function uri ( uint256 id ) external view returns ( string memory ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function to Int16 ( int256 value ) internal pure returns ( int16 ) { require ( value > 2 15 & & value < 2 15 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return int16 ( value ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function rpow ( uint256 x , uint256 n ) internal pure returns ( uint256 z ) { z n % 2 ! 0 ? x : RAY ; for ( n 2 ; n ! 0 ; n 2 ) { x rmul ( x , x ) ; if ( n % 2 ! 0 ) { z rmul ( z , x ) ; } } }
function approve (
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Staked For At (
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function function Delegate Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { require ( is Contract ( target ) , " Address : delegate call to non contract " ) ; ( bool success , bytes memory returndata ) target . delegatecall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function mod (
function mass Update Pools ( ) public { console . log ( " Mass Updating Pools " ) ; uint256 length pool Info . length ; uint all Rewards ; for ( uint256 pid 0 ; pid < length ; + + pid ) { all Rewards all Rewards . add ( update Pool ( pid ) ) ; } pending Rewards pending Rewards . sub ( all Rewards ) ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault Controller ( controller ) . vaults ( address ( this ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function buy ( ) payable public { calculates the amount makes the transfers }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function balance Of ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }
function confirm Unbonded Candidate ( address candidate Addr ) external { Validator Candidate storage candidate candidate Profiles [ candidate Addr ] ; require ( candidate . status D Po S Common . Candidate Status . Unbonding , ' Candidate not unbonding ' ) ; require ( block . number > candidate . unbond Time , ' Unbonding time not reached ' ) ; candidate . status D Po S Common . Candidate Status . Unbonded ; delete candidate . unbond Time ; emit Candidate Unbonded ( candidate Addr ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function deposit ( ) public virtual ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint256 c a b ; return c ; }
function emergency Drain24h After Liquidity Generation Event Is Done ( ) public only Owner { About 24h after liquidity generation happens ( bool success , ) msg . sender . call . value ( address ( this ) . balance ) ( " " ) ; require ( success , " Transfer failed . " ) ; balances [ msg . sender ] balances [ address ( this ) ] ; balances [ address ( this ) ] 0 ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function balance Of Batch ( address [ ] memory owners , uint256 [ ] memory ids )
function withdraw ( uint shares ) public { uint r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after token . balance Of ( address ( this ) ) ; uint diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) external virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function unwrap (
function get Reserve Data ( address reserve )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mod (
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function exists ( uint256 id ) internal view returns ( bool ) { return creators [ id ] ! address ( 0 ) ; }
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function allowance ( address owner , address spender ) external view returns ( uint ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function cancel (
modifier non Reentrant ( ) { require ( reentrancy Lock REENTRANCY GUARD FREE , " non Reentrant " ) ; reentrancy Lock REENTRANCY GUARD LOCKED ; ; reentrancy Lock REENTRANCY GUARD FREE ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function is Set Manager ( I Set Token set Token , address to Check ) internal view returns ( bool ) { return set Token . manager ( ) to Check ; }
function div U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b 0 ) { return ( Math Error . DIVISION BY ZERO , 0 ) ; } return ( Math Error . NO ERROR , a b ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function ( ) public payable { revert ( ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function start Mining ( uint256 token Id , uint256 land Token Id , address resource ) public { I Token Use token Use I Token Use ( registry . address Of ( CONTRACT TOKEN USE ) ) ; token Use . add Activity ( token Id , msg . sender , 0 ) ; require ( msg . sender ERC721 ( registry . address Of ( CONTRACT OBJECT OWNERSHIP ) ) . owner Of ( land Token Id ) , " Must be the owner of the land " ) ; require ( miner2Index [ token Id ] . land Token Id 0 ) ; mine ( land Token Id ) ; uint256 index land2Resource Mine State [ land Token Id ] . miners [ resource ] . length ; land2Resource Mine State [ land Token Id ] . total Miners + 1 ; if ( land2Resource Mine State [ land Token Id ] . max Miners 0 ) { land2Resource Mine State [ land Token Id ] . max Miners 5 ; } require ( land2Resource Mine State [ land Token Id ] . total Miners < land2Resource Mine State [ land Token Id ] . max Miners ) ; address miner I Interstellar Encoder ( registry . address Of ( CONTRACT INTERSTELLAR ENCODER ) ) . get Object Address ( token Id ) ; uint256 strength I Miner Object ( miner ) . strength Of ( token Id , resource , land Token Id ) ; land2Resource Mine State [ land Token Id ] . miners [ resource ] . push ( token Id ) ; land2Resource Mine State [ land Token Id ] . total Miner Strength [ resource ] + strength ; miner2Index [ token Id ] Miner Status ( { land Token Id : land Token Id , resource : resource , index In Resource : uint64 ( index ) } ) ; emit Start Mining ( token Id , land Token Id , resource , strength ) ; }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function token At ( Self storage self , uint256 index ) public view returns ( address token )
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function add Keeper ( address keeper ) public { require ( msg . sender governance | | msg . sender strategist , " ! governance " ) ; keepers [ keeper ] true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function remove Manager ( address manager )
function assign Client Oracle ( address client Oracle , uint256 registration ) external non Reentrant { Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client , " ! client " ) ; require ( locker . locked 0 , " locked " ) ; require ( locker . released < locker . sum , " released " ) ; locker . client Oracle client Oracle ; emit Assign Client Oracle ( client Oracle , registration ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function transfer Ownership ( address new Owner ) public override owner Only { require ( new Owner ! owner , " ERR SAME OWNER " ) ; new Owner new Owner ; }
function get Vote Out Vote ( address voter ) external view returns ( address ) ;
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function approve Charity ( ) public only Overlord { state State . Approved ; emit charity Approved ( now ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function calculate Unclaimed Distributions ( address account ) public view returns ( uint256 ) { return calculate Claim Amount ( account ) ; }
event New Resolver ( bytes32 indexed node , address resolver ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function token By Index ( uint256 index ) external view returns ( uint256 ) ;
function get Flash Loan Liquidity ( address token ) internal view returns ( uint256 liquidity Amount )
function boost (
function burn ( uint256 amount ) public virtual returns ( bool ) { burn ( msg Sender ( ) , amount ) ; return true ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function toggle Contract Active ( ) public only Owner { stopped ! stopped ; }
event Upgraded ( address indexed implementation ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function decrease Allowance ( Shell Storage . Shell storage shell , address spender , uint256 subtracted Value ) external returns ( bool ) { approve ( shell , msg . sender , spender , sub ( shell . allowances [ msg . sender ] [ spender ] , subtracted Value , " Shell allowance decrease underflow " ) ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function find Two Point Five Percent ( uint256 value ) public view returns ( uint256 ) { uint256 round Value value . ceil ( base Percent ) ; uint256 two Point Five Percent round Value . mul ( base Percent ) . div ( 4000 ) ; return two Point Five Percent ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function batch Create Children ( string [ ] calldata uris ) external returns ( uint256 [ ] memory token Ids ) { require ( access Controls . has Smart Contract Role ( msg Sender ( ) ) , " Digitalax Materials . batch Create Children : Sender must be smart contract " ) ; require ( uris . length > 0 , " Digitalax Materials . batch Create Children : No data supplied in array " ) ; uint256 uris Length uris . length ; token Ids new uint256 [ ] ( uris Length ) ; for ( uint256 i 0 ; i < uris Length ; i + + ) { string memory uri uris [ i ] ; require ( bytes ( uri ) . length > 0 , " Digitalax Materials . batch Create Children : URI is a blank string " ) ; token Id Pointer token Id Pointer . add ( 1 ) ; set URI ( token Id Pointer , uri ) ; token Ids [ i ] token Id Pointer ; } emit Children Created ( token Ids ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function add KPR Credit ( address job , uint amount ) external { require ( msg . sender governance , " add KPR Credit : ! gov " ) ; require ( jobs [ job ] , " add KPR Credit : ! job " ) ; credits [ job ] [ address ( this ) ] credits [ job ] [ address ( this ) ] . add ( amount ) ; mint ( address ( this ) , amount ) ; emit Add Credit ( address ( this ) , job , msg . sender , block . number , amount ) ; }
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mod (
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
event Approval For All ( address indexed account , address indexed operator , bool approved ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z y ; uint x y 2 + 1 ; while ( x < z ) { z x ; x ( y x + x ) 2 ; } } else if ( y ! 0 ) { z 1 ; } }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function release ( ) public virtual { require ( block . timestamp > release Time ( ) , " Token Timelock : current time is before release time " ) ; uint256 amount token ( ) . balance Of ( address ( this ) ) ; require ( amount > 0 , " Token Timelock : no tokens to release " ) ; token ( ) . safe Transfer ( beneficiary ( ) , amount ) ; }
function pause ( ) public only Owner when Not Paused { paused true ; emit Paused ( ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function buy Price ( )
function get Token Value ( address token , uint amount ) external view returns ( uint ) ;
function uniswap Sell Tax Fee ( ) external view returns ( uint256 ) { return uniswap Sell Tax Fee ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
event New Pending Admin ( address indexed new Pending Admin ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer ( address to , uint value ) only Payload Size ( 2 32 ) { balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value ) ; }
function allowance ( address owner , address spender )
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function balance Of ( address account ) external view returns ( uint ) { return balances [ account ] ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function remove From In Progress Proposals ( uint256 proposal Id ) internal { uint256 index 0 ; for ( uint256 i 0 ; i < in Progress Proposals . length ; i + + ) { if ( in Progress Proposals [ i ] proposal Id ) { index i ; break ; } } in Progress Proposals [ index ] in Progress Proposals [ in Progress Proposals . length 1 ] ; in Progress Proposals . pop ( ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function total Supply ( ) external view returns ( uint256 ) ;
function Ownable ( ) public { owner msg . sender ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function initialize ( address underlying ,
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function set Bool ( bytes32 key , bool value ) external only Current Owner { bool Storage [ key ] value ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; 5 % city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function transfer From (
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function token ( ) public view returns ( address ) { return address ( staking Token ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function check Triggers ( Strategy memory strategy , bytes [ ] memory trigger Call Data , address subscriptions Addr ) public { for ( uint i 0 ; i < strategy . trigger Ids . length ; + + i ) { Trigger memory trigger Subscriptions ( subscriptions Addr ) . get Trigger ( strategy . trigger Ids [ i ] ) ; address trigger Addr registry . get Addr ( trigger . id ) ; bool is Triggered Trigger Interface ( trigger Addr ) . is Triggered ( trigger Call Data [ i ] , trigger . data ) ; require ( is Triggered , " Trigger not activated " ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function become Implementation ( bytes memory data ) public { data ; if ( false ) { implementation address ( 0 ) ; } require ( msg . sender gov , " only the gov may call become Implementation " ) ; }
function update Reserve State On Repay Internal (
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function get Settlement Fee ( uint amount ) internal pure returns ( uint ) { return amount 100 ; }
function unlock By Bank ( address account , uint256 amount ) public { require ( msg Sender ( ) soda Master . bank ( ) , " not bank " ) ; require ( amount < locked Amount [ account ] , " Vault : unlock too much " ) ; locked Amount [ account ] amount ; }
function name ( ) public view returns ( string memory ) { return name ; }
function cooperative Withdraw (
function balance Of ( address account ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; if ( returndata . length > 0 ) { require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function withdraw Ether ( uint256 amount , address payable send To ) external only Admin { ( bool success , ) send To . call . value ( amount ) ( " " ) ; require ( success ) ; emit Ether Withdraw ( amount , send To ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function withdraw ( uint shares ) public { require ( is Locked ( msg . sender ) false , " locked " ) ; uint r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( this ) , withdraw ) ; uint after token . balance Of ( address ( this ) ) ; uint diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function transfer Ownership ( address new Owner ) external ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Flash Loan Fees In Bips ( ) external pure returns ( uint256 , uint256 ) { return ( FLASHLOAN FEE TOTAL , FLASHLOAN FEE PROTOCOL ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function calc In Given Out (
function add Liquidity (
function get Min ( uint128 [ ] storage self ) public view returns ( uint128 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 2 ) ) ) remainder : mod ( i , 2 ) for { let j : 0 } lt ( j , mul ( remainder , 4 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function balance Of ( address account ) external view returns ( uint256 ) ;
function is Pool Available ( address pool ) public view returns ( bool ) { return pools [ pool ] . rate ! 0 ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; } }
function sell Pool Via Bancor V1 (
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
event Approval (
event Delegations Imported ( address [ ] from , address indexed to ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function skim ( address to ) external lock { gas savings gas savings safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
modifier only Pending Owner ( ) { require ( msg . sender pending Owner ) ; ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function owner ( ) public view returns ( address ) { return owner ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; if ( allowed Contracts [ to ] ) { Receiver receiver Receiver ( to ) ; receiver . token Fallback ( msg . sender , value ) ; } balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function canceled Hashes Of From Token (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function cancel Withdrawal ( ) external non Reentrant ( ) { Position Data storage position Data get Position Data ( msg . sender ) ; require ( position Data . withdrawal Request Pass Timestamp ! 0 , " No pending withdrawal " ) ; emit Request Withdrawal Canceled ( msg . sender , position Data . withdrawal Request Amount . raw Value ) ; reset Withdrawal Request ( position Data ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
event Approval (
function approve ( address spender , uint256 value ) public returns ( bool ) { approve ( msg . sender , spender , value ) ; return true ; }
function fill Fee Buckets ( uint256 amount , uint256 monthly Rate , uint256 from Timestamp ) external ;
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function migrate ( IERC20 token ) external returns ( IERC20 ) ;
function safe Redeem ( address ctoken , uint256 amount ) internal
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function supports Interface ( bytes4 interface Id )
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
enum Math Error { NO ERROR , DIVISION BY ZERO , INTEGER OVERFLOW , INTEGER UNDERFLOW }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address spender , uint amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function process Accumulated Payout ( ) external { address user msg . sender ; uint256 payout accumulated Payouts [ user ] ; require ( payout > 0 , " No payout pending " ) ; uint256 reserve IERC20 ( T3 ADDRESS ) . balance Of ( address ( this ) ) ; require ( reserve > 0 , " Unable to process any more payouts " ) ; if ( reserve > payout ) { delete accumulated Payouts [ user ] ; IERC20 ( T3 ADDRESS ) . safe Transfer ( user , payout ) ; Payout ( user , payout ) ; } else { accumulated Payouts [ user ] payout reserve ; IERC20 ( T3 ADDRESS ) . safe Transfer ( user , reserve ) ; Payout ( user , reserve ) ; } }
function STAKE ( uint256 tokens ) external { require ( IERC20 ( GEX ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from user account " ) ; uint256 staking Fee 0 ; if ( total Stakes > 0 ) staking Fee ( one Percent ( tokens ) . mul ( staking Fee ) ) . div ( 10 ) ; if ( total Stakes > 0 ) add Payout ( staking Fee ) ; uint256 owing pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + owing ; stakers [ msg . sender ] . staked Tokens ( tokens . sub ( staking Fee ) ) . add ( stakers [ msg . sender ] . staked Tokens ) ; stakers [ msg . sender ] . last Dividends owing ; stakers [ msg . sender ] . from Total Dividend total Dividends ; stakers [ msg . sender ] . round round ; total Stakes total Stakes . add ( tokens . sub ( staking Fee ) ) ; emit STAKED ( msg . sender , tokens . sub ( staking Fee ) , staking Fee ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function delegate ( address implementation ) internal { assembly { calldatacopy ( 0 , 0 , calldatasize ) let result : delegatecall ( gas , implementation , 0 , calldatasize , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ) switch result case 0 { revert ( 0 , returndatasize ) } default { return ( 0 , returndatasize ) } } }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function rate ( ) external view returns ( uint ) { return calc Rate ( ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
modifier only Owner ( )
function get Fee ( uint amount , uint gas Cost , address owner ) internal returns ( uint fee Amount ) { uint fee MANUAL SERVICE FEE ; if ( Bot Registry ( BOT REGISTRY ADDRESS ) . bot List ( tx . origin ) ) { fee AUTOMATIC SERVICE FEE ; } if ( Discount ( DISCOUNT ADDRESS ) . is Custom Fee Set ( owner ) ) { fee Discount ( DISCOUNT ADDRESS ) . get Custom Service Fee ( owner ) ; } fee Amount ( fee 0 ) ? 0 : ( amount fee ) ; if ( gas Cost ! 0 ) { uint eth Dai Price get Price ( ETH ILK ) ; gas Cost rmul ( gas Cost , eth Dai Price ) ; fee Amount add ( fee Amount , gas Cost ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } ERC20 ( DAI ADDRESS ) . transfer ( WALLET ID , fee Amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; assert ( c a b ) ; return c ; }
function get Initialization Block ( ) public view returns ( uint256 ) { return INITIALIZATION BLOCK POSITION . get Storage Uint256 ( ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function redeem Presale ( ) non Reentrant public { require ( now > start Date , ' SALE NOT STARTED ' ) ; require ( nonce 2 , ' NONCE ERROR ' ) ; require ( now < end Date , ' END DATE PASSED ' ) ; IERC20 transfer Contract IERC20 ( buoy Presale ) ; uint presale Tokens transfer Contract . balance Of ( msg . sender ) ; require ( presale Tokens > 0 , ' NO PRESALE TOKENS ' ) ; transfer Contract . transfer From ( msg . sender , address ( this ) , presale Tokens ) ; uint tokens 400 ( presale Tokens ) ( 10 18 ) ; uint current Reserve reserves [ msg . sender ] ; uint new Reserve current Reserve . add ( tokens ) ; reserves [ msg . sender ] new Reserve ; total Reserved total Reserved . add ( tokens ) ; }
function pause ( ) public only Owner when Not Paused { pause ( ) ; }
function execute ( address target , bytes memory data ) public virtual payable returns ( bytes32 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg . sender , allowances [ sender ] [ msg . sender ] . sub ( amount ) ) ; return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint256 c a b ; return c ; }
function get Prev ( Data storage self , address id ) public view returns ( address ) { return self . nodes [ id ] . prev Id ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function settle ( address account ) external ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function adjust Leverage ( Self storage self , uint256 room Amount ) internal returns ( bool success )
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allocated Supply ( )
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function remove Service Type ( bytes32 service Type ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; uint256 service Index 0 ; bool found Service false ; for ( uint256 i 0 ; i < valid Service Types . length ; i + + ) { if ( valid Service Types [ i ] service Type ) { service Index i ; found Service true ; break ; } } require ( found Service true , " Service Type Manager : Invalid service type , not found " ) ; uint256 last Index valid Service Types . length 1 ; valid Service Types [ service Index ] valid Service Types [ last Index ] ; valid Service Types . length ; service Type Info [ service Type ] . is Valid false ; emit Service Type Removed ( service Type ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg . sender , allowances [ sender ] [ msg . sender ] . sub ( amount ) ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
modifier onlyowner { require ( is Owner ( msg . sender ) ) ; ; }
function ( ) external payable { if ( msg . value > 0 ) emit Deposit ( msg . sender , msg . value ) ; }
function burn Stakes ( uint256 stakes Amount ) internal virtual
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
event New Price Oracle ( address old Price Oracle , address new Price Oracle ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < 7 days ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > 0 . 1 ether & & msg . value < 60 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < 1 days ) { amount msg . value . mul ( 10 ) ; } else if ( now . sub ( start Date ) > 1 days ) { amount msg . value . mul ( 10 ) ; } require ( amount < Token . balance Of ( address ( this ) ) ) ; total Sold total Sold . add ( amount ) ; collected ETH collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Snapshot ( uint256 id ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function is Min Keeper ( address keeper , uint min Bond , uint earned , uint age ) external returns ( bool ) { gas Used gasleft ( ) ; return keepers [ keeper ] & & bonds [ keeper ] [ address ( this ) ] . add ( votes [ keeper ] ) > min Bond & & work Completed [ keeper ] > earned & & now . sub ( first Seen [ keeper ] ) > age ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function generic Call ( address contract , bytes memory data , uint256 value )
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 dope Reward multiplier . mul ( dope Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; uint256 current Supply dope . total Supply ( ) ; if ( current Supply . add ( dope Reward ) < max Dope Supply ) { dope . mint ( address ( this ) , dope Reward ) ; } pool . acc Dope Per Share pool . acc Dope Per Share . add ( dope Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; if ( block . number > start Block . add ( 100000 ) & & ! is Minting Halved ) { dope Per Block dope Per Block . div ( 2 ) ; is Minting Halved true ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < start Block | | block . number < pool . last Reward Block | | pool . last Reward Block > end Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Pending Blocks ( pool . last Reward Block , block . number ) ; uint256 honey Reward multiplier . mul ( honey Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Honey Per Share pool . acc Honey Per Share . add ( honey Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function set Balance Limits (
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function get Permission Param ( address entity , address app , bytes32 role , uint index )
function token By Index ( uint256 index ) public view override returns ( uint256 ) { ( uint256 token Id , ) token Owners . at ( index ) ; return token Id ; }
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function redeem ( uint redeem Tokens ) external returns ( uint ) { return redeem Internal ( redeem Tokens ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function mint ( address to , uint256 token Id ) internal { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; token Owner [ token Id ] to ; owned Tokens Count [ to ] . increment ( ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function xf Lobby Pending Days ( address member Addr )
event Redeem ( uint amount ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function name ( ) public view returns ( string memory ) { return name ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function initialize ( uint256 hsp , uint256 hrp , uint256 bdur , uint256 dbt , uint256 mim , uint256 vssm ) returns ( bool ) { if ( initialized To < 8 ) { if ( owner 0 ) owner msg . sender ; hash Submission Period hsp ; hash Reveal Period hrp ; base Duration bdur ; duration Bump To dbt ; min Increment Millis mim ; value Submission Subsidy Millis vssm ; for ( uint256 i initialized To ; i < 8 & & msg . gas > 1100000 ; i + + ) { Gas Remaining ( msg . gas , i ) ; if ( i < 4 ) { auctions [ i ] new One Phase Auction ( ) ; One Phase Auction ( auctions [ i ] ) . initialize ( this , base Duration , duration Bump To , min Increment Millis , i ) ; } else { auctions [ i ] new Two Phase Auction ( ) ; Two Phase Auction ( auctions [ i ] ) . initialize ( this , hash Submission Period , hash Reveal Period , value Submission Subsidy Millis , i 3 ) ; } } initialized To i ; if ( initialized To 8 ) return true ; else return false ; } return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function to U Int ( int128 x ) internal pure returns ( uint64 ) { require ( x > 0 ) ; return uint64 ( x > > 64 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function will Fallback ( ) internal virtual { }
function pause ( ) only Owner when Not Paused public { paused true ; emit Pause ( ) ; }
function transfer From (
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function total Supply ( ) public view returns ( uint256 total ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer ( address from , address to , uint256 token Id ) internal virtual { require ( owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; before Token Transfer ( from , to , token Id ) ; approve ( address ( 0 ) , token Id ) ; holder Tokens [ from ] . remove ( token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( from , to , token Id ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function static Call Uint256 ( ) internal view returns ( uint256 value ) { ( bool status , bytes memory result ) core . staticcall ( msg . data ) ; require ( status , string ( result ) ) ; value abi . decode ( result , ( uint256 ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function balance Of ( address account , uint256 id ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount )
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
event Proposal Executed ( uint id ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is In Dispute ( Tellor Storage . Tellor Storage Struct storage self , uint256 request Id , uint256 timestamp ) internal view returns ( bool ) { return self . request Details [ request Id ] . in Dispute [ timestamp ] ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer ( address to , uint256 value ) returns ( bool success ) { }
solhint disable line max line length
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function transfer ( address to , uint256 value ) returns ( bool success ) { }
event Max Committee Size Changed ( uint8 new Value , uint8 old Value ) ;
function underlying Token ( ) external view returns ( address underlying Token ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
event Exchange Stake Deposited ( address exchange Addr , uint amount ) ;
function dynamic Convert Funds ( address exchange , address from , address to , uint256 input Amount , uint256 min Output Amount ) public returns ( uint256 output Amount ) { return Conversions . dynamic Convert Funds ( exchange , from , to , input Amount , min Output Amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function get Transcoder Pool Size ( ) public view returns ( uint256 ) ;
function default Operators ( ) external view returns ( address [ ] memory ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function to Uint40 ( uint256 value ) internal pure returns ( uint40 ) { require ( value < 2 40 , " Safe Cast : value doesn \ ' t fit in 40 bits " ) ; return uint40 ( value ) ; }
function total Reserve ( ) public view virtual override returns ( uint256 total Reserve )
function converter Reserve Weight ( I Converter converter , IERC20Token reserve Token ) private view returns ( uint32 ) { ( , uint32 weight , , , ) converter . connectors ( reserve Token ) ; return weight ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function token To Eth Swap Input ( uint256 tokens sold , uint256 min eth , uint256 deadline ) external returns ( uint256 eth bought ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 YFS Reward multiplier . mul ( YFS Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; YFS . mint ( devaddr , YFS Reward . div ( 10 ) ) ; YFS . mint ( address ( this ) , YFS Reward ) ; pool . acc YFS Per Share pool . acc YFS Per Share . add ( YFS Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function invoke Transfer (
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function update Tellor ( Tellor Storage . Tellor Storage Struct storage self , uint dispute Id ) public { bytes32 hash self . disputes By Id [ dispute Id ] . hash ; uint256 orig ID self . dispute Id By Dispute Hash [ hash ] ; uint256 last ID self . disputes By Id [ orig ID ] . dispute Uint Vars [ keccak256 ( abi . encode ( self . disputes By Id [ orig ID ] . dispute Uint Vars [ keccak256 ( " dispute Rounds " ) ] ) ) ] ; Tellor Storage . Dispute storage disp self . disputes By Id [ last ID ] ; require ( disp . dispute Vote Passed true , " vote needs to pass " ) ; require ( now disp . dispute Uint Vars [ keccak256 ( " tally Date " ) ] > 1 days , " Time for voting for further disputes has not passed " ) ; self . address Vars [ keccak256 ( " tellor Contract " ) ] disp . proposed Fork Address ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Tokens Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Token Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Tokens Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function unlock ( address account ) public only Owner when Not Paused { unlock ( account ) ; }
function total Supply ( ) public view returns ( uint256 ) { return all Tokens . length ; }
function name ( ) public view returns ( string memory ) { return name ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
event Unpaused ( address account ) ;
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function set New Exchange Portal ( address new Exchange Portal Address ) public only Owner { require ( permitted Addresses . is Match Types ( new Exchange Portal Address , 1 ) , " WRONG ADDRESS " ) ; exchange Portal I Exchange Portal ( new Exchange Portal Address ) ; }
function change Rootnode Owner ( address new Owner ) external override only Owner { get ENS Registry ( ) . set Owner ( root Node , new Owner ) ; emit Rootnode Owner Change ( root Node , new Owner ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function unpause ( ) public only Pauser when Paused { paused false ; emit Unpaused ( msg . sender ) ; }
function insert Token ( Self storage self , address token ) public
function pay Trading Fee (
function disable Transfers ( bool disable ) public override owner Only { transfers Enabled ! disable ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function swap (
function delegate ( address implementation ) internal { assembly { calldatacopy ( 0 , 0 , calldatasize ( ) ) let result : delegatecall ( gas ( ) , implementation , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) switch result case 0 { revert ( 0 , returndatasize ( ) ) } default { return ( 0 , returndatasize ( ) ) } } }
function invoke Transfer (
function lockable Token ( uint256 pool Id ) external view override returns ( IERC20 ) { ( IERC20 lp Token , , , ) SAKE MASTER . pool Info ( pool Id ) ; return lp Token ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function get Contract ( bytes32 name ) external view returns ( address contract Addr ) { require Is Initialized ( ) ; return address Storage [ name ] ; }
function token Of Owner By Index ( address owner , uint256 index ) external view returns ( uint256 token Id ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function batch Freeze Partial Tokens ( address [ ] calldata user Addresses , uint256 [ ] calldata amounts ) external ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function client Propose Resolver ( address proposed Resolver , uint256 registration , string calldata details ) external non Reentrant { ADR storage adr adrs [ registration ] ; Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client , " ! client " ) ; require ( adr . client Proposed Resolver 0 , " pending " ) ; require ( locker . released < locker . sum , " released " ) ; if ( adr . proposed Resolver proposed Resolver ) { adr . resolver proposed Resolver ; } else { adr . client Proposed Resolver 0 ; adr . provider Proposed Resolver 0 ; } adr . proposed Resolver proposed Resolver ; adr . client Proposed Resolver 1 ; emit Client Propose Resolver ( proposed Resolver , registration , details ) ; }
function call Function (
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function allowance (
event Trusted Issuer Removed ( I Claim Issuer indexed trusted Issuer ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function upgrade To And Call ( address new Implementation , bytes calldata data ) payable external if Admin { upgrade To ( new Implementation ) ; ( bool success , ) new Implementation . delegatecall ( data ) ; require ( success ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function mint ( address account , uint256 amount ) public only Minter returns ( bool ) { mint ( account , amount ) ; return true ; }
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint256 fee amount . mul ( withdrawal Fee ) . div ( FEE DENOMINATOR ) ; IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . rewards ( ) , fee ) ; address vault I Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function initialize Token Bridge Limits ( address token , uint256 decimals ) internal { uint256 factor ; if ( decimals < 18 ) { factor 10 ( 18 decimals ) ; uint256 min Per Tx min Per Tx ( address ( 0 ) ) . div ( factor ) ; uint256 max Per Tx max Per Tx ( address ( 0 ) ) . div ( factor ) ; uint256 daily Limit daily Limit ( address ( 0 ) ) . div ( factor ) ; uint256 execution Max Per Tx execution Max Per Tx ( address ( 0 ) ) . div ( factor ) ; uint256 execution Daily Limit execution Daily Limit ( address ( 0 ) ) . div ( factor ) ; if ( min Per Tx 0 ) { min Per Tx 1 ; if ( max Per Tx < min Per Tx ) { max Per Tx 100 ; execution Max Per Tx 100 ; if ( daily Limit < max Per Tx | | execution Daily Limit < execution Max Per Tx ) { daily Limit 10000 ; execution Daily Limit 10000 ; } } } set Limits ( token , [ daily Limit , max Per Tx , min Per Tx ] ) ; set Execution Limits ( token , [ execution Daily Limit , execution Max Per Tx ] ) ; } else { factor 10 ( decimals 18 ) ; set Limits ( token , [ daily Limit ( address ( 0 ) ) . mul ( factor ) , max Per Tx ( address ( 0 ) ) . mul ( factor ) , min Per Tx ( address ( 0 ) ) . mul ( factor ) ] ) ; set Execution Limits ( token , [ execution Daily Limit ( address ( 0 ) ) . mul ( factor ) , execution Max Per Tx ( address ( 0 ) ) . mul ( factor ) ] ) ; } }
function withdraw Rewards ( address staked Contract , address token Address , uint amount ) external non Reentrant { IERC20 erc20 IERC20 ( token Address ) ; Reward Pool storage pool reward Pools [ staked Contract ] [ msg . sender ] [ token Address ] ; require ( pool . amount > amount , " Not enough tokens to withdraw " ) ; require ( pool . rate 0 , " Reward rate is not 0 " ) ; pool . amount pool . amount . sub ( amount ) ; erc20 . safe Transfer ( msg . sender , amount ) ; emit Withdrawn ( staked Contract , msg . sender , token Address , amount ) ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function request New Round ( )
event Tokens Purchased ( address indexed purchaser , address indexed beneficiary , uint256 value , uint256 amount ) ;
function mint And Freeze ( address to , uint amount , uint64 until ) public only Owner can Mint returns ( bool ) { total Supply total Supply . add ( amount ) ; bytes32 current Key to Key ( to , until ) ; freezings [ current Key ] freezings [ current Key ] . add ( amount ) ; freezing Balance [ to ] freezing Balance [ to ] . add ( amount ) ; freeze ( to , until ) ; emit Mint ( to , amount ) ; emit Freezed ( to , until , amount ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function select Withdraw Strategy Addr (
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 indexed token Id ) ;
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function stake ( uint256 amount , bytes calldata data ) external { stake For ( msg . sender , msg . sender , amount ) ; }
function mint ( address to , uint256 value ) external virtual returns ( bool ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function withdraw ( uint amount ) external { require ( msg . sender controller , " ! controller " ) ; uint balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } address vault Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function div ( uint a , uint b ) internal pure returns ( uint ) { return div ( a , b , " div : " ) ; }
function burn ( address from , uint256 unit Amount ) only Owner public { require ( unit Amount > 0 & & balance Of [ from ] > unit Amount ) ; balance Of [ from ] balance Of [ from ] . sub ( unit Amount ) ; total Supply total Supply . sub ( unit Amount ) ; emit Burn ( from , unit Amount ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function unpause ( ) public only Owner when Paused { paused false ; emit Unpause ( ) ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
event Unbond Job ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function exchange Rate Stored ( ) public view returns ( uint ) { delegate To View And Return ( ) ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function add ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) + y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function transfer Ownership ( address new Owner ) only Owner public { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( admin , new Owner ) ; admin new Owner ; }
function exchange Rate Stored ( ) public view returns ( uint ) { ( Math Error err , uint result ) exchange Rate Stored Internal ( ) ; require ( err Math Error . NO ERROR , " exchange Rate Stored : exchange Rate Stored Internal failed " ) ; return result ; }
function withdraw Accrued Yield And Add ( uint pid , uint lp Token Amount ) public rem Pos Only unpaused { Liquidity Providers storage p provider [ pid ] [ msg . sender ] ; Pool Info storage pool pool Info [ pid ] ; uint yield calculate User Daily Yield ( pid ) ; require ( remove Position Only false ) ; require ( p . Unlock Height < block . number ) ; if ( lp Token Amount ! 0 ) { if ( p . Days lock Period0 ) { fundamenta . mint To ( msg . sender , yield ) ; pool . Contract Address . safe Transfer From ( msg . sender , address ( this ) , lp Token Amount ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period0 ) ) , lp Token Amount . add ( p . Locked Amount ) , lock Period0 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield0 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; pool . Total LP Tokens Locked pool . Total LP Tokens Locked . add ( lp Token Amount ) ; } else if ( p . Days lock Period1 ) { fundamenta . mint To ( msg . sender , yield ) ; pool . Contract Address . safe Transfer From ( msg . sender , address ( this ) , lp Token Amount ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period1 ) ) , lp Token Amount . add ( p . Locked Amount ) , lock Period1 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield1 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; pool . Total LP Tokens Locked pool . Total LP Tokens Locked . add ( lp Token Amount ) ; } else if ( p . Days lock Period2 ) { fundamenta . mint To ( msg . sender , yield ) ; pool . Contract Address . safe Transfer From ( msg . sender , address ( this ) , lp Token Amount ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period2 ) ) , lp Token Amount . add ( p . Locked Amount ) , lock Period2 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield2 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; pool . Total LP Tokens Locked pool . Total LP Tokens Locked . add ( lp Token Amount ) ; } else revert ( " Liquidity Mining : Incompatible Lock Period " ) ; } else if ( lp Token Amount 0 ) { if ( p . Days lock Period0 ) { fundamenta . mint To ( msg . sender , yield ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period0 ) ) , p . Locked Amount , lock Period0 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield0 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; } else if ( p . Days lock Period1 ) { fundamenta . mint To ( msg . sender , yield ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period1 ) ) , p . Locked Amount , lock Period1 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield1 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; } else if ( p . Days lock Period2 ) { fundamenta . mint To ( msg . sender , yield ) ; provider [ pid ] [ msg . sender ] Liquidity Providers ( msg . sender , block . number . add ( period Calc . mul ( lock Period2 ) ) , p . Locked Amount , lock Period2 , p . User BP . add ( p . User BP > max User BP ? 0 : comp Yield2 ) , p . Total Rewards Paid . add ( yield ) ) ; pool . Total Rewards Paid By Pool pool . Total Rewards Paid By Pool . add ( yield ) ; } else revert ( " Liquidity Mining : Incompatible Lock Period " ) ; } else revert ( " Liquidity Mining : ? " ) ; emit Position Removed ( msg . sender , lp Token Amount , block . number ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z x uint224 ( y ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function burn ( uint256 amount ) public { burn ( msg Sender ( ) , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function allowance ( Tellor Storage . Tellor Storage Struct storage self , address user , address spender ) public view returns ( uint256 ) { return self . allowed [ user ] [ spender ] ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function balance ( address user , uint256 pool ) public view returns ( uint256 ) { for ( uint256 i 0 ; i < users [ pool ] . length ; i + + ) { if ( users [ pool ] [ i ] . addr user ) { return ( users [ pool ] [ i ] . balance ) ; } } return 0 ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { require ( allowances [ msg . sender ] [ spender ] + added Value > allowances [ msg . sender ] [ spender ] ) ; allowances [ msg . sender ] [ spender ] + added Value ; Approval ( msg . sender , spender , allowances [ msg . sender ] [ spender ] ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function batch Burn ( address [ ] calldata user Addresses , uint256 [ ] calldata amounts ) external ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function set Implementation ( address new Implementation ) internal { require ( Open Zeppelin Upgrades Address . is Contract ( new Implementation ) , " Cannot set a proxy implementation to a non contract address " ) ; bytes32 slot IMPLEMENTATION SLOT ; assembly { sstore ( slot , new Implementation ) } }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function add U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { uint c a + b ; if ( c > a ) { return ( Math Error . NO ERROR , c ) ; } else { return ( Math Error . INTEGER OVERFLOW , 0 ) ; } }
function get Next Custom Action ID (
function approve ( address owner , address spender , uint256 value ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] value ; emit Approval ( owner , spender , value ) ; }
function mint ( address account , uint256 amount ) public only Minter returns ( bool ) { mint ( account , amount ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function verify Transfers (
function total Supply ( ) external view returns ( uint256 ) ;
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function fund Tokens ( ) public payable { require ( msg . value > 0 ) ; uint256 tokens msg . value . mul ( exchange Rate ) ; require ( balances [ owner ] . sub ( tokens ) > 0 ) ; balances [ msg . sender ] balances [ msg . sender ] . add ( tokens ) ; balances [ owner ] balances [ owner ] . sub ( tokens ) ; emit Transfer ( msg . sender , owner , tokens ) ; forward Funds ( ) ; }
function ensure Valid Generic Call Target ( address to ) internal view { if ( ! to . is Contract ( ) ) { revert ( revert Reason ( 26 ) ) ; } if ( to address ( this ) ) { revert ( revert Reason ( 27 ) ) ; } if ( to address ( ESCAPE HATCH REGISTRY ) ) { revert ( revert Reason ( 28 ) ) ; } }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function disable Circuit (
function transfer From ( address src , address dst , uint raw Amount ) external returns ( bool ) { address spender msg . sender ; uint96 spender Allowance allowances [ src ] [ spender ] ; uint96 amount safe96 ( raw Amount , " Dena : : approve : amount exceeds 96 bits " ) ; if ( spender ! src & & spender Allowance ! uint96 ( 1 ) ) { uint96 new Allowance sub96 ( spender Allowance , amount , " Dena : : transfer From : transfer amount exceeds spender allowance " ) ; allowances [ src ] [ spender ] new Allowance ; emit Approval ( src , spender , new Allowance ) ; } transfer Tokens ( src , dst , amount ) ; return true ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function transfer ( address recipient , uint256 amount )
event Sell (
function approve ( address spender , uint256 value ) external returns ( bool ) { allowed Fragments [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
event Updated Token Information ( string new Name , string new Symbol , uint8 new Decimals , string new Version , address new Onchain ID ) ;
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
function to Int8 ( int256 value ) internal pure returns ( int8 ) { require ( value > 2 7 & & value < 2 7 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return int8 ( value ) ; }
function pause ( ) internal virtual when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
function reward Token ( ) external view returns ( IERC20 ) ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function intake Numeraire ( int128 amount ) public returns ( uint256 amount ) { uint256 rate cusdt . exchange Rate Current ( ) ; amount ( amount . mulu ( 1e6 ) 1e18 ) rate ; bool transfer Success cusdt . transfer From ( msg . sender , address ( this ) , amount ) ; require ( transfer Success , " Shell c USDT transfer from failed " ) ; uint redeem Success cusdt . redeem ( amount ) ; require ( redeem Success 0 , " Shell c USDT redeem failed " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function get Uniswap Exchange Factory Address ( )
function init ( Interactive Crowdsale Storage storage self ,
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function ln ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; return int128 ( ( uint256 ( logbase2 ( x ) ) 0x B17217F7D1CF79ABC9E3B39803F2F6AF ) > > 128 ) ; }
function pause ( ) only Owner when Not Paused public { paused true ; emit Pause ( ) ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function ( ) external payable { }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { Check allowance allowance [ from ] [ msg . sender ] value ; transfer ( from , to , value ) ; return true ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function abs ( int128 x ) internal pure returns ( int128 ) { require ( x ! MIN 64x64 ) ; return x < 0 ? x : x ; }
function approve ( address to , uint256 token Id ) public virtual override { address owner owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg Sender ( ) owner | | is Approved For All ( owner , msg Sender ( ) ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function can Accept ( uint option UID ) public view returns ( bool ) { Option memory option options [ option UID ] ; return ( ! option . buyer Accepted | | ! option . seller Accepted ) & & ! proposal Expired ( option UID ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function liquidate Borrow ( address borrower , uint repay Amount , C Token Interface c Token Collateral ) external returns ( uint ) { Shh delegate And Return ( ) ; }
function get Recovery Vault ( ) public view returns ( address ) ;
event Approval ( address indexed owner , address indexed spender , uint amount ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function token Of Owner By Index ( address owner , uint256 index ) public view override returns ( uint256 ) { return holder Tokens [ owner ] . at ( index ) ; }
event Now Token Price ( address a , uint256 b , uint256 c ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
event Reserves Added ( address benefactor , uint256 add Amount , uint256 new Total Reserves ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function eth To Weth Addr ( address src ) internal pure returns ( address ) { return src KYBER ETH ADDRESS ? WETH ADDRESS : src ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function salvage ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender governance , " ! governance " ) ; require ( underlying ! address ( asset ) , " underlying " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( treasury , balance ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { approve ( msg . sender , spender , value ) ; return true ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function mint ( address to , uint256 amount ) public only Owner { uint256 total Supply total Supply ( ) ; if ( total Supply . add ( amount ) > MAX SUPPLY ) { amount MAX SUPPLY . sub ( total Supply ) ; } require ( total Supply . add ( amount ) < MAX SUPPLY ) ; mint ( to , amount ) ; }
function get Max Stable Rate Borrow Size Percent ( ) external pure returns ( uint256 ) { return MAX STABLE RATE BORROW SIZE PERCENT ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
modifier only Vault ( ) { require ( vault Address msg . sender , " Caller is not the Vault " ) ; ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
enum Transaction Type
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
function mod (
function cancel Remove Delegator Request ( address service Provider , address delegator ) external { require ( msg . sender service Provider | | msg . sender governance Address , ERROR ONLY SP GOVERNANCE ) ; require ( remove Delegator Requests [ service Provider ] [ delegator ] ! 0 , " Delegate Manager : No pending request " ) ; remove Delegator Requests [ service Provider ] [ delegator ] 0 ; emit Remove Delegator Request Cancelled ( service Provider , delegator ) ; }
function claim Tad ( ) public when Not Paused { update Mining State ( ) ; uint claimable Tad claimable Tad ( msg . sender ) ; staker Indexes [ msg . sender ] mining State Index ; if ( claimable Tad > 0 ) { staker Claimed [ msg . sender ] staker Claimed [ msg . sender ] . add ( claimable Tad ) ; total Claimed total Claimed . add ( claimable Tad ) ; Tad Token . transfer ( msg . sender , claimable Tad ) ; emit Claimed Tad ( msg . sender , claimable Tad , staker Claimed [ msg . sender ] ) ; } }
function unpause ( ) public only Owner { unpause ( ) ; }
function length ( Map storage map ) private view returns ( uint256 ) { return map . entries . length ; }
function approve Minter ( address minter ) public only Owner { if ( ! minters [ minter ] ) { minters [ minter ] true ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function update Access Controls ( Digitalax Access Controls access Controls ) external { require ( access Controls . has Admin Role ( msg Sender ( ) ) , " Digitalax Garment NFT . update Access Controls : Sender must be admin " ) ; access Controls access Controls ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function migrate ( I Uniswap V2Pair uni Pair , uint liquidity , uint pid ) public { address token0 uni Pair . token0 ( ) ; address token1 uni Pair . token1 ( ) ; address sushi Pair I Uniswap V2Factory ( 0x C0A Ee478e3658e2610c5F7A4A2E1777c E9e4f2Ac ) . get Pair ( token0 , token1 ) ; create the pair if it doesn ' t exist yet sushi Pair I Uniswap V2Factory ( 0x C0A Ee478e3658e2610c5F7A4A2E1777c E9e4f2Ac ) . create Pair ( token0 , token1 ) ; } send liquidity to pair Remove liquidity to here ( uint256 reserve0 , uint256 reserve1 , ) I Uniswap V2Pair ( sushi Pair ) . get Reserves ( ) ; uint total Supply I Uniswap V2Pair ( sushi Pair ) . total Supply ( ) ; if ( total Supply 0 ) { safe Transfer ( token0 , sushi Pair , amount0 ) ; safe Transfer ( token1 , sushi Pair , amount1 ) ; Add liquidity Just try to reward SUSHI , if it fails , continue return ; } uint256 liquidity0 amount0 total Supply reserve0 ; uint256 liquidity1 amount1 total Supply reserve1 ; if ( liquidity0 < liquidity1 ) { uint256 adjusted Amount1 amount1 liquidity0 liquidity1 ; safe Transfer ( token0 , sushi Pair , amount0 ) ; safe Transfer ( token1 , sushi Pair , adjusted Amount1 ) ; Add liquidity if ( pid ! 29 ) { IERC20 ( sushi Pair ) . approve ( 0xc2Eda D668740f1a A35E4D8f227f B8E17dc A888Cd , added Liquidity ) ; I Master Chef ( 0xc2Eda D668740f1a A35E4D8f227f B8E17dc A888Cd ) . deposit ( pid , added Liquidity ) ; } if ( amount1 adjusted Amount1 > 0 ) { safe Transfer ( token1 , msg . sender , amount1 adjusted Amount1 ) ; } } else { uint256 adjusted Amount0 amount0 liquidity1 liquidity0 ; safe Transfer ( token0 , sushi Pair , adjusted Amount0 ) ; safe Transfer ( token1 , sushi Pair , amount1 ) ; Add liquidity if ( pid ! 29 ) { IERC20 ( sushi Pair ) . approve ( 0xc2Eda D668740f1a A35E4D8f227f B8E17dc A888Cd , added Liquidity ) ; I Master Chef ( 0xc2Eda D668740f1a A35E4D8f227f B8E17dc A888Cd ) . deposit ( pid , added Liquidity ) ; } if ( amount0 adjusted Amount0 > 0 ) { safe Transfer ( token0 , msg . sender , amount0 adjusted Amount0 ) ; } } Just try to reward SUSHI , if it fails , continue }
function calculate User Global Data ( address user )
function token URI ( uint256 token Id ) public view override returns ( string memory ) { require ( exists ( token Id ) , " ERC721Metadata : URI query for nonexistent token " ) ; string memory token URI token UR Is [ token Id ] ; if ( bytes ( base URI ) . length 0 ) { return token URI ; } if ( bytes ( token URI ) . length > 0 ) { return string ( abi . encode Packed ( base URI , token URI ) ) ; } return string ( abi . encode Packed ( base URI , token Id . to String ( ) ) ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function will Fallback ( ) internal virtual { }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function available Funds ( )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer (
function balance Of ( address account ) external view returns ( uint256 ) ;
function claim Ownership ( )
function approve ( address spender , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub (
function actual Balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) ; }
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function total Supply ( ) public view returns ( uint256 ) { return all Tokens . length ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function max Int256 ( ) internal pure returns ( int256 ) { return MAX INT 256 ; }
function change ENS Resolver ( address ens Resolver ) external only Owner { require ( ens Resolver ! address ( 0 ) , " WF : address cannot be null " ) ; ens Resolver ens Resolver ; emit ENS Resolver Changed ( ens Resolver ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Reward ( ) public update Reward ( msg . sender ) { uint256 reward earned ( msg . sender ) ; if ( reward > 0 ) { rewards [ msg . sender ] 0 ; erc20Token . safe Transfer ( msg . sender , reward ) ; emit Reward Paid ( msg . sender , reward ) ; } }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function approve (
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function safe Transfer From ( address from , address to , uint256 token Id , bytes memory data ) public virtual override { require ( is Approved Or Owner ( msg . sender , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; safe Transfer ( from , to , token Id , data ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function owner ( ) public view returns ( address ) { return owner ; }
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( uint256 ( self ) & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( uint256 ( self ) & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( uint256 ( self ) & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function interests Per Block ( ) external override view returns ( uint ) { return acc Amount Per Share ; }
function harvest Strategy ( address strategy ) external only Authorized { I Lp Pair Strategy ( strategy ) . harvest ( address ( 0 ) ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) ) ; } }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function edit Default Position ( I Set Token set Token , address component , uint256 new Unit ) internal { bool is Position Found has Default Position ( set Token , component ) ; if ( ! is Position Found & & new Unit > 0 ) { if ( ! has External Position ( set Token , component ) ) { set Token . add Component ( component ) ; } } else if ( is Position Found & & new Unit 0 ) { if ( ! has External Position ( set Token , component ) ) { set Token . remove Component ( component ) ; } } set Token . edit Default Position Unit ( component , new Unit . to Int256 ( ) ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; When minting tokens require ( total Supply ( ) . add ( amount ) < cap , " ERC20Capped : cap exceeded " ) ; } }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | allowed [ msg . sender ] [ spender ] 0 ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function user Input Collateral ( address user , address collateral ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function user Balance Changed ( address account ) internal { }
function pending Reward ( uint256 pool Id ) public override view returns ( uint256 ) { do not support other pool types return I Staking Rewards ( pool Map [ pool Id ] . target Pool ) . earned ( address ( this ) ) ; }
function name ( ) external view returns ( string memory ) { return name ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function adjust Reserve ( Self storage self , uint256 room Amount ) public returns ( bool success )
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
function latest Timestamp ( )
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function accrue Interest ( ) public virtual returns ( uint ) ;
event Keeper Slashed ( address indexed keeper , address indexed slasher , uint block , uint slash ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function unstake ( ) external { withdraw ( balance Of ( msg . sender ) ) ; get Reward ( ) ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function calc Network Value Dune Analytics ( uint256 mock Input )
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function approve ( address spender , uint256 value ) returns ( bool success ) { }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function accrue Interest ( ) public virtual returns ( uint ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Titan Swap V1Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mul Scalar Truncate ( Exp memory a , uint scalar ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return ( Math Error . NO ERROR , truncate ( product ) ) ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function transfer ( address to , uint256 value ) public virtual override ( ERC20 ) can Transfer ( msg Sender ( ) ) returns ( bool ) { return super . transfer ( to , value ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function get Guardian Delegators Staking Rewards Percent Mille ( address guardian ) external view returns ( uint256 delegator Rewards Ratio Percent Mille ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function owner ( ) public view returns ( address ) { return owner ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Unpaused ( address account ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z y ; uint x y 2 + 1 ; while ( x < z ) { z x ; x ( y x + x ) 2 ; } } else if ( y ! 0 ) { z 1 ; } }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function decode144 ( uq144x112 memory self ) internal pure returns ( uint144 ) { return uint144 ( self . x > > RESOLUTION ) ; }
function set Market Factory ( address addr ) external only Owner { market Factory addr ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function fallback ( ) internal { will Fallback ( ) ; delegate ( implementation ( ) ) ; }
modifier when Paused ( ) { require ( paused ) ; ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function hatching ALPA Cost ( uint256 matron Id , uint256 sire Id )
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function calc Deposit Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) internal pure returns ( uint256 net Shares , uint256 fee Shares )
modifier valid Recipient ( address to ) { require ( to ! address ( 0x0 ) ) ; require ( to ! address ( this ) ) ; ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function revoke Liquidity ( address liquidity ) external { require ( msg . sender governance , " revoke Liquidity : ! gov " ) ; liquidity Accepted [ liquidity ] false ; }
function ( ) public payable { require ( current Stage Stages . ico Start ) ; require ( msg . value > 0 ) ; require ( remaining Tokens > 0 ) ; Calculate tokens to sell uint256 tokens wei Amount . mul ( base Price ) . div ( 1 ether ) ; uint256 return Wei 0 ; if ( tokens Sold . add ( tokens ) > cap ) { uint256 new Tokens cap . sub ( tokens Sold ) ; uint256 new Wei new Tokens . div ( base Price ) . mul ( 1 ether ) ; return Wei wei Amount . sub ( new Wei ) ; wei Amount new Wei ; tokens new Tokens ; } Increment raised amount remaining Tokens cap . sub ( tokens Sold ) ; if ( return Wei > 0 ) { msg . sender . transfer ( return Wei ) ; emit Transfer ( address ( this ) , msg . sender , return Wei ) ; } balances [ msg . sender ] balances [ msg . sender ] . add ( tokens ) ; emit Transfer ( address ( this ) , msg . sender , tokens ) ; total Supply total Supply . add ( tokens ) ; Send money to owner }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function delegates ( address delegator )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function get Delegator Staking Rewards ( address delegator , uint256 delegator Stake , Guardian Staking Rewards memory guardian Staking Rewards ) private view returns ( Delegator Staking Rewards memory delegator Staking Rewards , uint256 delegator Rewards Added , uint256 delegator Rewards Per Token Delta ) { delegator Staking Rewards delegators Staking Rewards [ delegator ] ; delegator Rewards Per Token Delta uint256 ( guardian Staking Rewards . delegator Rewards Per Token ) . sub ( delegator Staking Rewards . last Delegator Rewards Per Token ) ; delegator Rewards Added delegator Rewards Per Token Delta . mul ( delegator Stake ) . div ( TOKEN BASE ) ; delegator Staking Rewards . balance delegator Staking Rewards . balance . add ( delegator Rewards Added ) ; delegator Staking Rewards . last Delegator Rewards Per Token guardian Staking Rewards . delegator Rewards Per Token ; }
function mod (
function owner ( ) public view returns ( address ) { return owner ; }
function supply Rate Per Block ( ) external view returns ( uint ) { bytes memory data delegate To View Implementation ( abi . encode With Signature ( " supply Rate Per Block ( ) " ) ) ; return abi . decode ( data , ( uint ) ) ; }
function div Down ( int256 a , int256 b ) internal pure returns ( int256 ) { require ( b ! 0 , " Cant divide by 0 " ) ; require ( a ! MIN INT 256 | | b ! 1 , " Invalid input " ) ; int256 result a . div ( b ) ; if ( a ^ b < 0 & & a % b ! 0 ) { result 1 ; } return result ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function stake ( uint256 amount , bytes calldata ) external override { stake ( msg . sender , msg . sender , amount ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function set (
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function Multi Sig Wallet ( address [ ] owners , uint required )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function set Mining Gulp Range ( Self storage self , uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount ) public
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function fund ( uint256 amount , uint256 duration ) public override { fund ( amount , duration , block . timestamp ) ; }
function set Metrics Group ( address addr ) external only Owner { metrics Group addr ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function cancel Liquidity Pool Migration ( ) public override only Owner non Reentrant
function add Block L Ist ( address ads ) external only Owner { require ( ads ! owner ) ; blocklist [ ads ] 1 ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function set Uniswap Router ( address uniswap Router ) public only Owner { uniswap Router uniswap Router ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function wrap Coin Amount ( uint256 amount ) internal view returns ( uint256 [ 2 ] memory ) { uint256 [ 2 ] memory amounts [ uint256 ( 0 ) , uint256 ( 0 ) ] ; amounts [ uint56 ( token Index ) ] amount ; return amounts ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function get All Unclaimed Rewards Data Member (
function transfer ( address to , uint256 val )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function assimilator (
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function balance Of ( address account ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function length ( Map storage map ) private view returns ( uint256 ) { return map . entries . length ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function transfer ( address to , uint256 value ) public returns ( bool success ) ;
function run ( uint256 amount , bytes32 account id ) external { xrt . burn From ( msg Sender ( ) , amount ) ; emit Migration ( msg Sender ( ) , amount , account id ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function add Transaction ( address destination , uint value , bytes data )
function set Btf ( address btf ) public { require ( msg . sender governance , " ! governance " ) ; btf btf ; }
function approve ( address spender , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg . sender , allowances [ account ] [ msg . sender ] . sub ( amount ) ) ; }
function get Prior Votes ( address account , uint block Number )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function set Daily Reward ( uint256 daily Reward ) public only Owner { daily Reward daily Reward ; }
function exit ( ) external { get Reward ( ) ; withdraw ( balance Of ( msg . sender ) ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function confirm New Monitor ( ) public only Allowed { require ( ( change Requested Timestamp + CHANGE PERIOD ) < now ) ; require ( change Requested Timestamp ! 0 ) ; require ( new Monitor ! address ( 0 ) ) ; monitor new Monitor ; new Monitor address ( 0 ) ; change Requested Timestamp 0 ; emit Monitor Change Finished ( monitor ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function remove ( Role storage role , address account ) internal { require ( account ! address ( 0 ) ) ; require ( has ( role , account ) ) ; role . bearer [ account ] false ; }
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function total Supply ( ) external view returns ( uint256 ) ;
function growth Gulp Range ( ) public view override returns ( uint256 growth Min Gulp Amount , uint256 growth Max Gulp Amount )
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mul ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { if ( a 0 ) { return 0 ; } uint64 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function add ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { uint128 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set Withdrawal Limit Balance (
function total Supply ( ) external view returns ( uint256 ) ;
function symbol ( ) public pure returns ( string ) { return " STSS " ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mod ( uint a , uint b ) internal pure returns ( uint ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function process Join (
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function earned ( address account ) public view returns ( uint256 ) { uint256 block Time block . timestamp ; return points [ account ] . add ( block Time . sub ( last Update Time [ account ] ) . mul ( 1e18 ) . div ( 5760 ) . mul ( balance Of ( account ) . div ( 1e18 ) ) ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function borrowing Reserve Underlying ( ) public view override returns ( uint256 borrowing Reserve Underlying )
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < 7 days ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > 0 . 1 ether & & msg . value < 1 . 5 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < 1 days ) { amount msg . value . mul ( 666666 ) ; } else if ( now . sub ( start Date ) > 1 days ) { amount msg . value . mul ( 666666 ) ; } require ( amount < Token . balance Of ( address ( this ) ) ) ; total Sold total Sold . add ( amount ) ; collected ETH collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function logbase10 ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; return int128 ( ( uint256 ( logbase2 ( x ) ) 0x4d104d427de7fce20a6e420e02236748 ) > > 128 ) ; }
function slash ( address bonded , address keeper , uint amount ) public non Reentrant { require ( msg . sender governance , " slash : ! gov " ) ; if ( bonded address ( this ) ) { transfer Tokens ( address ( this ) , governance , amount ) ; } else { IERC20 ( bonded ) . safe Transfer ( governance , amount ) ; } unbond ( bonded , keeper , amount ) ; disputes [ keeper ] false ; emit Keeper Slashed ( keeper , msg . sender , block . number , amount ) ; }
function pair For Old Router ( address token A , address token B ) internal view returns ( address pair ) { ( address token0 , address token1 ) Uniswap V2Library . sort Tokens ( token A , token B ) ; pair address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , old Router . factory ( ) , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , init code hash ) ) ) ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function get Block Info ( uint block Idx )
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function liquidity Pool Migration Unlock Time ( ) public view override returns ( uint256 migration Unlock Time )
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function withdraw Eth ( address payable user , uint amount ) external has Vault Access not Liquidating ( weth , user ) { collaterals [ weth ] [ user ] collaterals [ weth ] [ user ] . sub ( amount ) ; IWETH ( weth ) . withdraw ( amount ) ; Transfer Helper . safe Transfer ETH ( user , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function function Call (
modifier only Safe ( ) { require ( msg . sender owner [ 0 ] | | msg . sender owner [ 1 ] | | msg . sender owner [ 2 ] ) ; ; }
function deposit Underlying ( uint256 underlying Cost ) external ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function revoke ( address keeper ) external { require ( msg . sender governance , " Keep3r : : slash : only governance can resolve " ) ; keepers [ keeper ] false ; blacklist [ keeper ] true ; slash ( keeper , bonds [ keeper ] ) ; }
function mul Truncate Ceil ( uint256 x , uint256 y )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function burn ( uint256 amount ) public only Minter { burn ( msg . sender , amount ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Keeper Unbonding ( address indexed keeper , uint block , uint deactive , uint bond ) ;
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Contract Registry Address Updated ( address addr ) ;
function dev ( address devaddr ) public { require ( msg . sender devaddr , " dev : wut ? " ) ; devaddr devaddr ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function set Cumulative Price ( address property , uint256 value ) internal { eternal Storage ( ) . set Uint ( get Cumulative Price Key ( property ) , value ) ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function transfer ( address recipient , uint256 amount )
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function accept Governance ( ) external { require ( msg . sender pending Governance , " Keep3r : : accept Governance : only pending Governance can accept " ) ; governance pending Governance ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function cancel Ownership Transfer ( ) public only Owner { delete new Potential Owner ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function issue ( uint amount ) public only Owner { require ( total Supply + amount > total Supply ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] + amount ; total Supply + amount ; Issue ( amount ) ; }
function receive In Token ( uint256 in Amount )
function is Min Keeper ( address keeper , uint min Bond , uint earned , uint age ) external returns ( bool ) { gas Used gasleft ( ) ; return keepers [ keeper ] & & bonds [ keeper ] [ address ( this ) ] . add ( votes [ keeper ] ) > min Bond & & work Completed [ keeper ] > earned & & now . sub ( first Seen [ keeper ] ) > age ; }
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function delegates ( address delegator )
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function avg ( int256 a , int256 b )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function burn From ( address from , uint256 value ) public returns ( bool success ) { Check if the targeted balance is enough Check allowance Subtract from the targeted balance Subtract from the sender ' s allowance Update total Supply emit Burn ( from , value ) ; return true ; }
function migrate Stake For ( address target , uint256 amount New Share ) internal { total Supply total Supply . add ( amount New Share ) ; balances [ target ] balances [ target ] . add ( amount New Share ) ; }
function total Supply At ( uint256 block Number ) public view returns ( uint256 ) { if ( ( total Supply History . length 0 ) | | ( total Supply History [ 0 ] . from Block > block Number ) ) { return 0 ; } else { return get Value At ( total Supply History , block Number ) ; } }
function on ERC1155Received (
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function get Max Age Deposit Until Withdrawable ( )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function token URI ( uint256 token Id ) external view returns ( string memory ) ;
function fraction ( uint216 numerator , uint216 denominator ) internal pure returns ( uint256 ) { return div ( uint256 ( numerator ) REAL ONE , uint256 ( denominator ) REAL ONE ) ; }
function pay Borrowing Fee (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function function Call With Value (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Keepers ( ) external view returns ( address [ ] memory ) { return keeper List ; }
function get Prior Votes ( address account , uint block Number )
function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { return allowed [ owner ] [ spender ] ; }
function fast Call (
function total Supply ( ) external view returns ( uint256 ) ;
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function safe Zcdw Transfer ( address to , uint256 amount ) internal { uint256 zcdw Bal zcdw . balance Of ( address ( this ) ) ; if ( amount > zcdw Bal ) { zcdw . transfer ( to , zcdw Bal ) ; } else { zcdw . transfer ( to , amount ) ; } }
function approve And Call ( address spender , uint amount , bytes memory data ) pause Check public returns ( bool ) { uint length256 ; if ( data . length > 0 ) { length256 data . length 32 ; if ( 32 length256 < data . length ) length256 + + ; } require ( msg . data . length ( ( ( 4 + length256 ) 32 ) + 4 ) , " Input length error " ) ; require ( amount < balances [ msg . sender ] , " Insufficient balance " ) ; if ( amount > 0 ) require ( allowed [ msg . sender ] [ spender ] 0 , " Zero allowance first " ) ; allowed [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , amount , address ( this ) , data ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mint (
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
event Confirmation ( address indexed sender , uint indexed transaction Id ) ;
event Unpaused ( address account ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function token Of Owner By Index ( address owner , uint256 index ) external view returns ( uint256 token Id ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function batch Transfer Out (
function token At ( Self storage self , uint256 index ) public view returns ( address token )
function calculate Health Factor From Balances Internal (
function create Pool ( address token0 , uint256 amount0 , address token1 , uint256 amount1 ) internal returns ( address pool )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) ) ; return role . bearer [ account ] ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function owner ( ) public view returns ( address ) { return owner ; }
function calculate Deposit To Shares ( uint256 amount ) internal view returns ( uint256 ) { uint256 fund Manager Cut ; uint256 fund Value ; if ( total Shares 0 ) return INITIAL SHARES ; ( fund Manager Cut , fund Value , ) calculate Fund Manager Cut ( ) ; uint256 fund Value Before Deposit fund Value . sub ( fund Manager Cut ) ; if ( fund Value Before Deposit 0 ) return 0 ; return amount . mul ( total Shares ) . div ( fund Value Before Deposit ) ; }
function leave ( ) public { require ( unstaked At ! 0 | | staked At 0 , " NOT UNSTAKED YET " ) ; uint256 total TRB IERC20 ( tellor Address ) . balance Of ( address ( this ) ) ; uint256 total Shares total Supply ( ) ; uint256 their Shares balance Of ( msg . sender ) ; uint256 their TRB total TRB . mul ( their Shares ) . div ( total Shares ) ; burn ( msg . sender , their Shares ) ; require ( IERC20 ( tellor Address ) . transfer ( msg . sender , their TRB ) ) ; }
event Approval For All ( address indexed account , address indexed operator , bool approved ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function slash ( address keeper , uint amount ) public { require ( msg . sender governance , " Keep3r : : slash : only governance can resolve " ) ; transfer Tokens ( address ( this ) , governance , amount ) ; move Delegates ( delegates [ msg . sender ] , address ( 0 ) , amount ) ; bonds [ keeper ] bonds [ keeper ] . sub ( amount ) ; disputes [ keeper ] false ; emit Keeper Slashed ( keeper , msg . sender , block . number , amount ) ; }
function Log ( address contract , address caller , string memory log Name , bytes memory data )
function expected APY ( uint256 pool Id , uint256 lp Pair Usdc Price ) external view returns ( uint256 ) ;
function remove Authorized Address ( address target )
function transfer ( address from , address to , uint256 token Id ) private { require ( owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; approve ( address ( 0 ) , token Id ) ; holder Tokens [ from ] . remove ( token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( from , to , token Id ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function get Contributions ( address holder ) view public returns ( uint256 ) { return contributions [ holder ] ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function safe Noodle Transfer ( address to , uint256 amount ) internal { uint256 noodle Bal noodle . balance Of ( address ( this ) ) ; if ( amount > noodle Bal ) { noodle . transfer ( to , noodle Bal ) ; } else { noodle . transfer ( to , amount ) ; } }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function contains ( address [ ] memory A , address a ) internal pure returns ( bool ) { ( , bool is In ) index Of ( A , a ) ; return is In ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function become Implementation ( bytes memory data ) public ;
function validate Illegal Address ( address addr ) external pure { require ( addr ! address ( 0 ) , error Message ) ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function initialize (
function get Vote Out Percent Mille Threshold ( ) external view returns ( uint32 ) ;
function approve ( address spender , uint256 amount ) public virtual only Creator override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer From (
function on ERC721Received ( address operator , address from , uint256 token Id , bytes calldata data ) external returns ( bytes4 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function set Staking Address ( address staking Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; staking Address staking Address ; emit Staking Address Updated ( staking Address ) ; }
function eth To Weth Addr ( address src ) internal pure returns ( address ) { return src KYBER ETH ADDRESS ? WETH ADDRESS : src ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function encode144 ( uint144 x ) internal pure returns ( uq144x112 memory ) { return uq144x112 ( uint256 ( x ) < < RESOLUTION ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function locked Lp Amount ( ) public view returns ( uint256 ) { if ( uniswap V2Pair address ( 0 ) ) { return 0 ; } return IERC20 ( uniswap V2Pair ) . balance Of ( address ( 0 ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function add ( Role storage role , address account ) internal { require ( account ! address ( 0 ) ) ; require ( ! has ( role , account ) ) ; role . bearer [ account ] true ; }
function get Max Debt ( uint cdp Id , bytes32 ilk ) public virtual view returns ( uint ) { uint price get Price ( ilk ) ; ( , uint mat ) spotter . ilks ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( sub ( div ( mul ( collateral , price ) , mat ) , debt ) , 10 ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function withdraw Stake ( uint256 unbonding Lock Id )
function set Guardian Certification ( address guardian , bool is Certified ) external Owner only ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function decrease Allowance (
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function admin ( ) external if Admin returns ( address ) { return admin ( ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function full Balance Of ( address account ) public view returns ( uint256 ) { Token itself only holds tokens for others uint256 distribution Balance distribution Balance Of ( account ) ; uint256 unclaimed calculate Claim Amount ( account ) ; return distribution Balance . add ( unclaimed ) ; }
function get Loan Minimum LTV ( uint256 loan Id ) external view override returns ( uint256 ) { if ( loan Id < LOAN ID START & & ! loan Info Fixed [ loan Id ] . filled By Old ) { return old Calculator . get Loan Minimum LTV ( loan Id ) ; } return loan Info Fixed [ loan Id ] . minimum LTV ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function allowance ( address account , address spender ) external view returns ( uint ) { return allowances [ account ] [ spender ] ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function name ( uint256 object Id )
function has Attribute ( address who , bytes32 attribute ) public view returns ( bool ) { return attributes [ who ] [ attribute ] . value ! 0 ; }
function self Destruct Market ( I Market market , address payable refund Address )
function deposit Fee ( ) public view override returns ( uint256 deposit Fee ) { return lpm . has Migrated ( ) ? DEPOSIT FEE AFTER MIGRATION : DEPOSIT FEE ; }
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
event New Max Slippage Factor (
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mint ( address to , uint256 amount ) only Owner can Mint public returns ( bool ) { total Supply total Supply . add ( amount ) ; balances [ to ] balances [ to ] . add ( amount ) ; emit Mint ( to , amount ) ; emit Transfer ( address ( 0 ) , to , amount ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint value ) ;
event Apply Credit ( address indexed job , address indexed provider , uint block , uint credit ) ;
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function safe Borrow ( address ctoken , uint256 amount ) internal
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function get Interface Implementer ( address account , bytes32 interface Hash ) external view returns ( address ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function stake Count ( address staker Addr )
function to Uint8 ( uint256 value ) internal pure returns ( uint8 ) { require ( value < 2 8 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return uint8 ( value ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function calc Deposit Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) external pure returns ( uint256 net Shares , uint256 fee Shares ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { Solidity only automatically asserts when dividing by 0 uint256 c a b ; return c ; }
function set Min Collateralization ( uint new Min Collateralization ) external ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Default Delegators Staking Rewards Percent Mille ( ) external view returns ( uint32 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function set Burn Rate Per Thousandth ( uint32 value ) external only Owner { burn Rate Per Transfer Thousandth value ; validate Contract Parameters ( ) ; emit Burn Rate Changed ( value ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee amount In . mul ( 997 ) ; uint numerator amount In With Fee . mul ( reserve Out ) ; uint denominator reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out numerator denominator ; }
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function redeem ( uint amount ) public only Owner { require ( total Supply > amount ) ; require ( balances [ owner ] > amount ) ; total Supply amount ; balances [ owner ] amount ; Redeem ( amount ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
event Submit Job (
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function get Time Lock ( address account , uint8 index ) public view returns ( uint , uint ) { require ( time Locks [ account ] . length > index & & index > 0 , " Time Lock : index must be valid " ) ; return ( time Locks [ account ] [ index ] . amount , time Locks [ account ] [ index ] . expires At ) ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function calc Deposit Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) public pure override returns ( uint256 net Shares , uint256 fee Shares )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function approve (
function set Whitelist Only ( bool only Whitelist ) external only Owner { only Whitelist only Whitelist ; }
function total Balance ( ) public override view returns ( uint256 balance ) { return address ( this ) . balance . sub ( locked Premium ) ; }
function safe Mint ( address to , uint256 token Id ) internal { safe Mint ( to , token Id , " " ) ; }
function is Approved For All ( address owner , address operator ) public view override returns ( bool ) { return operator Approvals [ owner ] [ operator ] ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function calculate Unclaimed Distributions ( address account ) public view returns ( uint256 ) { return calculate Claim Amount ( account ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function transfer ( address to , uint256 value )
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function transfer ( address to , uint256 value ) public returns ( bool ) { if ( contracts [ to ] ) { approve And Call ( to , value , new bytes ( 0 ) ) ; } else { super . transfer ( to , value ) ; } return true ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function lock Minting ( ) internal { require ( ! get Is Mint Locked ( ) , " RIO Token : mint is locked " ) ; is Mint Locked true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function withdraw Tokens ( uint256 id ) public { require ( block . timestamp > locked Token [ id ] . unlock Time , ' Tokens are locked ' ) ; require ( msg . sender locked Token [ id ] . withdrawal Address , ' Can withdraw by withdrawal Address only ' ) ; require ( ! locked Token [ id ] . withdrawn , ' Tokens already withdrawn ' ) ; require ( Token ( locked Token [ id ] . token Address ) . transfer ( msg . sender , locked Token [ id ] . token Amount ) , ' Transfer of tokens failed ' ) ; locked Token [ id ] . withdrawn true ; wallet Token Balance [ locked Token [ id ] . token Address ] [ msg . sender ] wallet Token Balance [ locked Token [ id ] . token Address ] [ msg . sender ] . sub ( locked Token [ id ] . token Amount ) ; uint256 i ; uint256 j ; for ( j 0 ; j < deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] . length ; j + + ) { if ( deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] [ j ] id ) { for ( i j ; i < deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] . length 1 ; i + + ) { deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] [ i ] deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] [ i + 1 ] ; } deposits By Withdrawal Address [ locked Token [ id ] . withdrawal Address ] . length ; break ; } } emit Log Withdrawal ( msg . sender , locked Token [ id ] . token Amount ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function new Stake ( Tellor Storage . Tellor Storage Struct storage self , address staker ) internal { require ( Tellor Transfer . balance Of ( self , staker ) > self . uint Vars [ keccak256 ( " stake Amount " ) ] , " Balance is lower than stake amount " ) ; require ( self . staker Details [ staker ] . current Status 0 | | self . staker Details [ staker ] . current Status 2 , " Miner is in the wrong state " ) ; self . uint Vars [ keccak256 ( " staker Count " ) ] + 1 ; self . staker Details [ staker ] Tellor Storage . Stake Info ( { this resets their stake start date to today start Date : now ( now % 86400 ) } ) ; emit New Stake ( staker ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Underlying Token ( address ctoken ) internal view returns ( address token )
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function calc Deposit Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) internal pure returns ( uint256 cost , uint256 fee Shares )
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function set Liquidity Bonding Delay ( uint new Liq Bond ) external only Governance { LIQUIDITYBOND new Liq Bond ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function get Vote Out Percent Mille Threshold ( ) external view returns ( uint32 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function is Agent (
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function import Members ( I Committee previous Committee Contract ) external override only Initialization Admin { ( address [ ] memory addrs , uint256 [ ] memory weights , bool [ ] memory certification ) previous Committee Contract . get Committee ( ) ; for ( uint i 0 ; i < addrs . length ; i + + ) { add Member ( addrs [ i ] , weights [ i ] , certification [ i ] , false ) ; } }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function length ( Address To Uint Map storage map ) internal view returns ( uint256 ) { return length ( map . inner ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function withdraw From Approved Withdrawals (
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function claim Comp ( address holder ) external ;
event Stake Good Accounting (
function safe Mint ( address to , uint256 token Id , bytes memory data ) internal virtual { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function to Int64 ( int256 value ) internal pure returns ( int64 ) { require ( value > 2 63 & & value < 2 63 , " Safe Cast : value doesn \ ' t fit in 64 bits " ) ; return int64 ( value ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function get Current Votes ( address account ) external view returns ( uint96 ) { uint32 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
modifier only Owner ( ) { require ( is Owner ( ) ) ; ; }
event Approval ( address indexed owner , address indexed spender , uint value ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function get ( Uint To Address Map storage map , uint256 key , string memory error Message ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) , error Message ) ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function delegates ( address delegator )
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function transfer From And Call ( address from , address to , uint256 value , bytes calldata data ) external returns ( bool ) ;
function release Once ( ) public { bytes32 head Key to Key ( msg . sender , 0 ) ; uint64 head chains [ head Key ] ; require ( head ! 0 ) ; require ( uint64 ( block . timestamp ) > head ) ; bytes32 current Key to Key ( msg . sender , head ) ; uint64 next chains [ current Key ] ; uint amount freezings [ current Key ] ; delete freezings [ current Key ] ; balances [ msg . sender ] balances [ msg . sender ] . add ( amount ) ; freezing Balance [ msg . sender ] freezing Balance [ msg . sender ] . sub ( amount ) ; if ( next 0 ) { delete chains [ head Key ] ; } else { chains [ head Key ] next ; delete chains [ current Key ] ; } emit Released ( msg . sender , amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function div ( uint a , uint b ) internal pure returns ( uint ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function burn ( uint256 token Id ) internal virtual { address owner owner Of ( token Id ) ; before Token Transfer ( owner , address ( 0 ) , token Id ) ; approve ( address ( 0 ) , token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } holder Tokens [ owner ] . remove ( token Id ) ; token Owners . remove ( token Id ) ; emit Transfer ( owner , address ( 0 ) , token Id ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function un Blacklist ( address account ) public only Blacklister { blacklisted [ account ] false ; emit Un Blacklisted ( account ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function transfer From ( Tellor Storage . Tellor Storage Struct storage self , address from , address to , uint256 amount )
function set Collateralization Ratio ( uint256 collateralization Ratio , uint256 collateralization Margin ) public override only Owner non Reentrant
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function remove Relay By Owner ( address relay ) external ;
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
event Created ( uint id , address indexed owner , address indexed token , uint amount , uint strike , uint created , uint expire ) ;
function add (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
enum Exchange Type { , OASIS , KYBER , UNISWAP , ZEROX }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function eth Usd Price ( ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
event Reserves Reduced ( address admin , uint reduce Amount , uint new Total Reserves ) ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { Check allowance allowance [ from ] [ msg . sender ] allowance [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return true ; }
function get Round Data ( uint80 round Id )
modifier only Pending Owner ( ) { assert ( msg . sender ! address ( 0 ) ) ; require ( msg . sender pending Owner ) ; ; }
function generate Tokens ( address owner , uint amount ) only Controller public returns ( bool ) { uint cur Total Supply total Supply ( ) ; Check for overflow uint previous Balance To balance Of ( owner ) ; Check for overflow update Value At Now ( total Supply History , cur Total Supply + amount ) ; update Value At Now ( balances [ owner ] , previous Balance To + amount ) ; Transfer ( 0 , owner , amount ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function is Liquidatable Position (
event Time Period Changed ( uint256 indexed previous Time Period , uint256 indexed new Time Period ) ;
function utilization ( address token , uint amount ) internal view returns ( uint ) { address pair Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; uint ratio BASE . sub ( BASE . mul ( balance Of ( pair ) . add ( amount ) ) . div ( total Supply ( ) ) ) ; if ( ratio 0 ) { return MAX ; } return ratio > MAX ? MAX : ratio ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function is Pool Supported ( I Converter Anchor pool Anchor ) public view returns ( bool ) { I Converter Registry converter Registry I Converter Registry ( address Of ( CONVERTER REGISTRY ) ) ; require ( converter Registry . is Anchor ( address ( pool Anchor ) ) , " ERR INVALID ANCHOR " ) ; I Converter converter I Converter ( payable ( pool Anchor . owner ( ) ) ) ; if ( converter . connector Token Count ( ) ! 2 ) { return false ; } IERC20Token reserve0Token converter . connector Tokens ( 0 ) ; IERC20Token reserve1Token converter . connector Tokens ( 1 ) ; if ( reserve0Token ! network Token & & reserve1Token ! network Token ) { return false ; } if ( converter Reserve Weight ( converter , reserve0Token ) ! PPM RESOLUTION 2 | | converter Reserve Weight ( converter , reserve1Token ) ! PPM RESOLUTION 2 ) { return false ; } return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function start Presale2 ( ) public only Owner { require ( current Stage ! Stages . presale2End ) ; current Stage Stages . presale2Start ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function deposit ( Self storage self , uint256 cost ) internal returns ( bool success )
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( from ! address ( 0 ) ) ; require ( to ! address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ from ] > tokens ) ; require ( allowed [ from ] [ msg . sender ] > tokens ) ; balances [ from ] balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function renounce Ownership ( ) public only Owner { emit Ownership Renounced ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function deposit ( address adapter , uint256 pool Id , uint256 amount ) external ;
function rfind ( slice memory self , slice memory needle ) internal pure returns ( slice memory ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; return self ; }
function balance Of ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Reward Paid ( address account , uint256 reward ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function mint ( address to , uint256 fy Dai Amount ) internal override { super . mint ( to , fy Dai Amount ) ; 2 112 }
function total Supply ( ) constant returns ( uint256 supply ) { }
event Ownership Transferred ( address previous Owner , address new Owner ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function find Upper Bound ( uint256 [ ] storage array , uint256 element ) internal view returns ( uint256 ) { if ( array . length 0 ) { return 0 ; } uint256 low 0 ; uint256 high array . length ; while ( low < high ) { uint256 mid Math . average ( low , high ) ; if ( array [ mid ] > element ) { high mid ; } else { low mid + 1 ; } } if ( low > 0 & & array [ low 1 ] element ) { return low 1 ; } else { return low ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function total Reserve ( ) public view override returns ( uint256 total Reserve )
function desired Liquidity ( ) external view returns ( uint256 ) ;
event Approval (
function set Contract Registry ( I Contract Registry new Registry ) external only Admin ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault I Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Sake Swap Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Sake Swap Library : ZERO ADDRESS ' ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function base URI ( ) public view returns ( string memory ) { return base URI ; }
event Mint Finished ( ) ;
function name ( ) external view returns ( string memory ) { return name ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function add Admin Role ( address address ) external { grant Role ( DEFAULT ADMIN ROLE , address ) ; emit Admin Role Granted ( address , msg Sender ( ) ) ; }
function reduce Reserves ( uint reduce Amount ) external non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . REDUCE RESERVES ACCRUE INTEREST FAILED ) ; } return reduce Reserves Fresh ( reduce Amount ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function Set Roles ( bytes32 role Type , address [ ] calldata addresses , bool [ ] calldata set To ) external { require ( Is Admin ( msg . sender ) , " Only admin " ) ; set Roles ( role Type , addresses , set To ) ; }
function transfer From (
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function is Dharma Smart Wallet (
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function div (
function debt Outstanding ( ) external view returns ( uint256 ) ;
event Fee Collected ( address indexed fee Recipient , uint256 fee Amount ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function reward Pool Share ( Earnings Pool . Data storage earnings Pool , uint256 stake , bool is Transcoder ) internal view returns ( uint256 ) { uint256 delegator Rewards 0 ; uint256 transcoder Rewards 0 ; if ( earnings Pool . has Transcoder Reward Fee Pool ) { ( delegator Rewards , transcoder Rewards ) reward Pool Share With Transcoder Reward Fee Pool ( earnings Pool , stake , is Transcoder ) ; } else { ( delegator Rewards , transcoder Rewards ) reward Pool Share No Transcoder Reward Fee Pool ( earnings Pool , stake , is Transcoder ) ; } return delegator Rewards . add ( transcoder Rewards ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function set Admin By Admin ( address admin ) public { require ( msg . sender admin ) ; admin admin ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function to Payable ( address account )
function total Supply ( ) external view returns ( uint256 ) ;
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function set Service Provider Factory Address ( address service Provider Factory Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; service Provider Factory Address service Provider Factory Address ; emit Service Provider Factory Address Updated ( service Provider Factory Address ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function rpow ( uint256 x , uint256 n ) internal pure returns ( uint256 z ) { z n % 2 ! 0 ? x : RAY ; for ( n 2 ; n ! 0 ; n 2 ) { x rmul ( x , x ) ; if ( n % 2 ! 0 ) { z rmul ( z , x ) ; } } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function complete Pool Migration ( Self storage self ) public returns ( address migration Recipient , uint256 stakes Amount , uint256 shares Amount )
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function is Trusted Issuer ( address issuer ) external view returns ( bool ) ;
event Keeper Unbound ( address indexed keeper , uint block , uint deactivated , uint bond ) ;
function epoch ( ) public view returns ( uint256 ) { return state . epoch . current ; }
function allowance ( address owner , address spender ) external view returns ( uint256 remaining ) ;
function add Governor ( address governor ) only Owner external { governors [ governor ] true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function is Zero Exp ( Exp memory value ) pure internal returns ( bool ) { return value . mantissa 0 ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < 30 seconds ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > 0 . 00493 ether & & msg . value < 0 . 00494 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < 1 days ) { amount msg . value . mul ( 202839757 ) . div ( 1000000 ) ; } else if ( now . sub ( start Date ) > 1 days ) { amount msg . value . mul ( 202839757 ) . div ( 1000000 ) ; } require ( amount < Token . balance Of ( address ( this ) ) ) ; total Sold total Sold . add ( amount ) ; collected ETH collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mint ( address to ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " Non Fungible Token : must have minter role to mint " ) ; mint ( to , token Id Tracker . current ( ) ) ; token Id Tracker . increment ( ) ; }
function set Conversion Path ( address from , address to , address [ ] memory uniswap Route )
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function proportional Deposit (
function pop ( address [ ] memory A , uint256 index )
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
modifier when Paused ( ) { require ( paused ) ; ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function approve ( IERC20 token ) external override only Owner { token . approve ( soda Master . pool ( ) , type ( uint256 ) . max ) ; }
function assign Client Oracle ( address client Oracle , uint256 registration ) external non Reentrant { Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client , " ! client " ) ; require ( locker . locked 0 , " locked " ) ; require ( locker . released < locker . sum , " released " ) ; locker . client Oracle client Oracle ; emit Assign Client Oracle ( client Oracle , registration ) ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function transfer From And Call Data ( address from , address to , uint256 value , bytes memory data ) public override returns ( bool ) { transfer From ( from , to , value ) ; require ( check And Call Transfer ( from , to , value , data ) , " ERC1363 : check And Call Transfer reverts " ) ; return true ; }
enum Delegator Status { Pending , Bonded , Unbonded }
function calc Deposit Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) internal pure returns ( uint256 net Shares , uint256 fee Shares )
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
event New Pending Admin ( address indexed new Pending Admin ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function deactivate ( ) external ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function prepare Withdrawal ( uint256 cost ) internal virtual returns ( bool success ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function get Collateral Addr ( address join Addr ) internal view returns ( address ) { return address ( Join ( join Addr ) . gem ( ) ) ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
event Admin Changed ( address previous Admin , address new Admin ) ;
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
event URI ( string value , uint256 indexed id ) ;
event Reserves Reduced ( address admin , uint reduce Amount , uint new Total Reserves ) ;
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function ( ) public payable { revert ( ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address to , uint256 amount ) external returns ( bool ) { return tellor . transfer ( to , amount ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function pair For (
function create ( uint mint Amount , address lp Token , uint lp Token Amount , uint pool ) public only Owner { require ( total Supply ( ) 0 , " Token has already been created " ) ; I Token ( lp Token ) . transfer From ( msg . sender , address ( this ) , lp Token Amount ) ; I Token ( lp Token ) . approve ( MASTER CHEF , lp Token Amount ) ; I Master Chef ( MASTER CHEF ) . deposit ( pool , lp Token Amount ) ; mint ( address ( this ) , mint Amount ) ; sushi Pool Number pool ; lp Uni Token I Token ( lp Token ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function safe Snp Transfer ( address to , uint256 amount ) internal { uint256 snp Bal snptoken . balance Of ( address ( this ) ) ; if ( amount > snp Bal ) { snptoken . transfer ( to , snp Bal ) ; } else { snptoken . transfer ( to , amount ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function latest Timestamp ( )
function remove Address ( Bytes32Set storage set , address addrvalue )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Unpaused ( address account ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function exp ( int128 x ) internal pure returns ( int128 ) { Overflow Underflow return exp 2 ( int128 ( int256 ( x ) 0x171547652B82FE1777D0FFDA0D23A7D12 > > 128 ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function reward Token ( Victim victim ) external view returns ( IERC20 ) { ( bool success , bytes memory result ) address ( victim ) . staticcall ( abi . encode With Signature ( " reward Token ( ) " ) ) ; require ( success , " reward Token ( ) staticcall failed . " ) ; return abi . decode ( result , ( IERC20 ) ) ; }
function resolve ( bytes32 virt Addr ) external view returns ( address ) { require ( virt To Real Map [ virt Addr ] ! address ( 0 ) , ' Nonexistent virtual address ' ) ; return virt To Real Map [ virt Addr ] ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function balance Of ( address owner ) public view returns ( uint balance ) { return balances [ owner ] ; }
function repay Borrow Fresh ( address payer , address borrower , uint repay Amount ) internal returns ( uint , uint ) { Fail if repay Borrow not allowed uint allowed comptroller . repay Borrow Allowed ( address ( this ) , payer , borrower , repay Amount ) ; if ( allowed ! 0 ) { return ( fail Opaque ( Error . COMPTROLLER REJECTION , Failure Info . REPAY BORROW COMPTROLLER REJECTION , allowed ) , 0 ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return ( fail ( Error . MARKET NOT FRESH , Failure Info . REPAY BORROW FRESHNESS CHECK ) , 0 ) ; } Repay Borrow Local Vars memory vars ; We remember the original borrower Index for verification purposes vars . borrower Index account Borrows [ borrower ] . interest Index ; We fetch the amount the borrower owes , with accumulated interest ( vars . math Err , vars . account Borrows ) borrow Balance Stored Internal ( borrower ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return ( fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW ACCUMULATED BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) , 0 ) ; } If repay Amount 1 , repay Amount account Borrows if ( repay Amount uint ( 1 ) ) { vars . repay Amount vars . account Borrows ; } else { vars . repay Amount repay Amount ; } We call do Transfer In for the payer and the repay Amount Note : The c Token must handle variations between ERC 20 and ETH underlying . On success , the c Token holds an additional repay Amount of cash . do Transfer In reverts if anything goes wrong , since we can ' t be sure if side effects occurred . it returns the amount actually transferred , in case of a fee . vars . actual Repay Amount do Transfer In ( payer , vars . repay Amount ) ; We calculate the new borrower and total borrow balances , failing on underflow : account Borrows New account Borrows actual Repay Amount total Borrows New total Borrows actual Repay Amount ( vars . math Err , vars . account Borrows New ) sub U Int ( vars . account Borrows , vars . actual Repay Amount ) ; require ( vars . math Err Math Error . NO ERROR , " REPAY BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED " ) ; ( vars . math Err , vars . total Borrows New ) sub U Int ( total Borrows , vars . actual Repay Amount ) ; require ( vars . math Err Math Error . NO ERROR , " REPAY BORROW NEW TOTAL BALANCE CALCULATION FAILED " ) ; We write the previously calculated values into storage account Borrows [ borrower ] . principal vars . account Borrows New ; account Borrows [ borrower ] . interest Index borrow Index ; total Borrows vars . total Borrows New ; We emit a Repay Borrow event emit Repay Borrow ( payer , borrower , vars . actual Repay Amount , vars . account Borrows New , vars . total Borrows New ) ; We call the defense hook comptroller . repay Borrow Verify ( address ( this ) , payer , borrower , vars . actual Repay Amount , vars . borrower Index ) ; return ( uint ( Error . NO ERROR ) , vars . actual Repay Amount ) ; }
event Recovered ( address token , uint256 amount ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller | | msg . sender governance | | msg . sender strategist , " ! authorized " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( want ) . safe Transfer ( address ( vault ) , balance ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function update ( ) external override non Reentrant { update ( msg . sender ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function bridge Transfer From (
function borrowing Reserve Underlying ( ) public view override returns ( uint256 borrowing Reserve Underlying )
function transfer (
function owner ( ) public view returns ( address ) { return owner ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function create Smart Fund Light (
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function assign Proxy Operators (
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function initialize ( address pool , address [ ] memory tokens ) public initializer { Module . initialize ( pool ) ; Defi Operator Role . initialize ( msg Sender ( ) ) ; registered Vault Tokens new address [ ] ( tokens . length ) ; claimable Tokens new uint256 [ ] ( tokens . length ) ; last Processed Requests new uint256 [ ] ( tokens . length ) ; last Processed Deposits new uint256 [ ] ( tokens . length ) ; remainders new uint256 [ ] ( tokens . length ) ; for ( uint256 i 0 ; i < tokens . length ; i + + ) { registered Vault Tokens [ i ] tokens [ i ] ; } available Enabled false ; }
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function transcoder ( uint256 reward Cut , uint256 fee Share ) external { transcoder With Hint ( reward Cut , fee Share , address ( 0 ) , address ( 0 ) ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function total Supply ( ) public override view returns ( uint256 ) { return total Supply ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function name ( ) public view returns ( string memory ) { return name ; }
function before Token Transfer (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function add Then Sub U Int ( uint a , uint b , uint c ) internal pure returns ( Math Error , uint ) { ( Math Error err0 , uint sum ) add U Int ( a , b ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , 0 ) ; } return sub U Int ( sum , c ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function total Supply ( ) external view returns ( uint256 ) ;
function deposit To Token Pool ( address pool Address , uint256 amount ) external only Whitelisted returns ( bool ) { return I Token Pool ( pool Address ) . deposit Asset Token ( amount ) ; }
function has Migrated ( Self storage self ) public view returns ( bool has Migrated )
function get D ( uint256 [ ] memory balances , uint256 A ) internal pure returns ( uint256 ) { uint256 sum 0 ; uint256 i 0 ; uint256 Ann A ; for ( i 0 ; i < balances . length ; i + + ) { sum sum . add ( balances [ i ] ) ; Ann Ann . mul ( balances . length ) ; } if ( sum 0 ) return 0 ; uint256 prev D 0 ; uint256 D sum ; for ( i 0 ; i < 255 ; i + + ) { uint256 p D D ; for ( uint256 j 0 ; j < balances . length ; j + + ) { p D p D . mul ( D ) . div ( balances [ j ] . mul ( balances . length ) ) ; } prev D D ; D Ann . mul ( sum ) . add ( p D . mul ( balances . length ) ) . mul ( D ) . div ( Ann . sub ( 1 ) . mul ( D ) . add ( balances . length . add ( 1 ) . mul ( p D ) ) ) ; if ( D > prev D ) { if ( D prev D < 1 ) break ; } else { if ( prev D D < 1 ) break ; } } return D ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) public virtual only Creator override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function cancel Withdrawal ( ) external non Reentrant ( ) { Position Data storage position Data get Position Data ( msg . sender ) ; require ( position Data . withdrawal Request Pass Timestamp ! 0 , " No pending withdrawal " ) ; emit Request Withdrawal Canceled ( msg . sender , position Data . withdrawal Request Amount . raw Value ) ; reset Withdrawal Request ( position Data ) ; }
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function claim Ownership ( Tellor Storage . Tellor Storage Struct storage self ) public { require ( msg . sender self . address Vars [ pending owner ] , " Sender is not pending owner " ) ; emit Ownership Transferred ( self . address Vars [ owner ] , self . address Vars [ pending owner ] ) ; self . address Vars [ owner ] self . address Vars [ pending owner ] ; }
function set Owner By Admin ( address owner ) public { require ( msg . sender admin ) ; owner owner ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function get Prior Votes ( address account , uint block Number )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer Ownership ( address new Owner ) internal virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
modifier only Owner ( ) { require ( msg . sender owner ) ; ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function truncate ( Exp memory exp ) pure internal returns ( uint ) { return exp . mantissa exp Scale ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function check Remaining Amount ( ) public view not Expired ( ) returns ( uint ) { uint Amount charity Goal . sub ( current Balance ) ; return ( Amount ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function tokens Received (
function shutdown ( address exit Owner )
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function enable Access Check ( )
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function redeem Ether In C Tokens ( uint256 amount C Tokens ) internal non Reentrant { redeem In C Tokens ( amount C Tokens ) ; WETH9 weth WETH9 ( address ( weth ) ) ; weth . deposit . value ( address ( this ) . balance ) ( ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function finish Minting ( ) only Owner can Mint public returns ( bool ) { minting Finished true ; emit Mint Finished ( ) ; return true ; }
function granularity By Partition ( address token , bytes32 partition ) external view returns ( uint256 ) { return granularity By Partition [ token ] [ partition ] ; }
function approve ( address spender , uint256 value ) external returns ( bool success ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function sub ( uint32 a , uint32 b ) internal pure returns ( uint32 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint32 c a b ; return c ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function recover ERC20 ( address token Address , uint256 token Amount ) public only Owner { IERC20 ( token Address ) . transfer ( owner ( ) , token Amount ) ; }
function revoke Vesting ( address holder , uint256 vesting Id )
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
event Transfer Batch ( address indexed operator , address indexed from , address indexed to , uint256 [ ] ids , uint256 [ ] values ) ;
event Genesis Purchased (
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
event Requirement Changed ( uint new Requirement ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function clearing Price ( ) public view returns ( uint256 ) { if ( token Price ( ) > price Function ( ) ) { return token Price ( ) ; } return price Function ( ) ; }
function harvest ( ) public { require ( msg . sender tx . origin | | msg . sender governance | | msg . sender strategist , " No harvest from contract " ) ; d Rewards ( pool ) . get Reward ( ) ; uint256 df IERC20 ( df ) . balance Of ( address ( this ) ) ; if ( df < DF Threshold ) return ; if ( df > 0 ) { swap ( df , want , df ) ; } uint256 want IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( want > 0 ) { IERC20 ( want ) . safe Transfer ( I Sashimi Plate Controller ( controller ) . treasury ( ) , want . mul ( performance Fee ) . div ( performance Max ) ) ; deposit ( ) ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function revoked ( ) public view returns ( bool ) { return revoked ; }
function full Balance Of ( address account ) public view returns ( uint256 ) { Token itself only holds tokens for others uint256 distribution Balance distribution Balance Of ( account ) ; uint256 unclaimed calculate Claim Amount ( account ) ; return distribution Balance . add ( unclaimed ) ; }
modifier only Delegate From ( ) virtual { require ( msg . sender DELEGATE FROM ) ; ; }
function get Remove Delegator Eval Duration ( )
function remove Bytes32 ( Bytes32Set storage set , bytes32 value )
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function get Answer ( uint256 round Id )
function validate3Addresses (
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function migrator ( ) external view returns ( address ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function pair For ( address factory , address token A , address token B ) internal pure returns ( address ) { ( address token0 , address token1 ) sort Tokens ( token A , token B ) ; return ( address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , init code hash ) ) ) ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function deprecate ( address upgraded Address ) public only Owner { deprecated true ; upgraded Address upgraded Address ; Deprecate ( upgraded Address ) ; }
function mint ( address account , uint256 amount ) only Owner public { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; balances [ Owner ] balances [ Owner ] . add ( amount ) ; emit Approval ( address ( 0 ) , Owner , amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function set Admin By Owner ( address admin ) public { require ( msg . sender owner ) ; require ( admin address ( 0 ) ) ; admin admin ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function execute Transaction ( address target , uint value , string memory signature , bytes memory data ) public returns ( bytes memory ) { require ( msg . sender timelock , " ! timelock " ) ; bytes memory call Data ; if ( bytes ( signature ) . length 0 ) { call Data data ; } else { call Data abi . encode Packed ( bytes4 ( keccak256 ( bytes ( signature ) ) ) , data ) ; } ( bool success , bytes memory return Data ) target . call { value : value } ( call Data ) ; require ( success , string ( abi . encode Packed ( get Name ( ) , " : : execute Transaction : Transaction execution reverted . " ) ) ) ; emit Execute Transaction ( target , value , signature , data ) ; return return Data ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { return to . sub ( from ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function delegates ( address delegator )
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function owner ( ) public view returns ( address ) { return owner ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function push Collected Fund Given In ( address token In , uint token Amount In ) internal returns ( uint collected Fee Amount ) { collected Fee Amount 0 ; if ( collected Fee > 0 ) { address collected Token IB Factory ( factory ) . collected Token ( ) ; if ( collected Token ! address ( 0 ) ) { collected Fee Amount bdiv ( bmul ( token Amount In , collected Fee ) , B Const . BONE ) ; push Underlying ( token In , factory , collected Fee Amount ) ; emit LOG COLLECTED FUND ( token In , collected Fee Amount ) ; } } }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
modifier only EOA ( ) { require ( msg . sender tx . origin , " Not EOA " ) ; ; }
function total Supply ( ) external view returns ( uint256 ) ;
function update Global Yield Per Token (
function bind Method ( bytes4 method , address module ) external ;
function callon ERC1155Received ( address from , address to , uint256 id , uint256 amount , bytes memory data )
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function function Static Call ( address target , bytes memory data , string memory error Message ) internal view returns ( bytes memory ) { require ( is Contract ( target ) , " Address : static call to non contract " ) ; ( bool success , bytes memory returndata ) target . staticcall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function adjust Leverage ( Self storage self , uint256 room Amount ) internal returns ( bool success )
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function admin ( ) external if Admin returns ( address ) { return admin ( ) ; }
function get Approved ( uint256 token Id ) external view returns ( address operator ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Transfer Single ( address indexed operator , address indexed from , address indexed to , uint256 id , uint256 amount ) ;
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( value < balances [ msg . sender ] ) ; require ( to ! address ( 0 ) ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function pause ( ) internal virtual when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
function from Int ( int256 x ) internal pure returns ( int128 ) { require ( x > 0x8000000000000000 & & x < 0x7FFFFFFFFFFFFFFF ) ; return int128 ( x < < 64 ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function balance Of ( address account ) public override view returns ( uint256 ) { return balances [ account ] ; }
function update Available Funds ( )
function transfer ( address to , uint256 value ) public returns ( bool success ) { transfer ( msg . sender , to , value ) ; return true ; }
function get Prior Votes ( address account , uint block Number )
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function is Operator ( address user Address ) public view returns ( bool ) { return user Address owner | | admins [ user Address ] | | operators [ user Address ] ; }
function token Address ( ) external view returns ( address token ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function get Total Locked Delegation For Service Provider ( address sp )
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function mul Exp ( uint a , uint b ) pure internal returns ( Math Error , Exp memory ) { return mul Exp ( Exp ( { mantissa : a } ) , Exp ( { mantissa : b } ) ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
modifier only EOA ( ) { require ( msg . sender tx . origin , " not eoa " ) ; ; }
function ERC20Preset Minter Pauser init unchained ( ) internal initializer { setup Role ( DEFAULT ADMIN ROLE , msg Sender ( ) ) ; setup Role ( MINTER ROLE , msg Sender ( ) ) ; setup Role ( PAUSER ROLE , msg Sender ( ) ) ; }
function implements ERC165Interface No Cache ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function exists ( uint256 token Id ) internal view returns ( bool ) { return token Owners . contains ( token Id ) ; }
function update Prevent Flag ( uint256 flag , uint256 to Prevent ) external only Owner returns ( bool ) { if ( to Prevent 0 ) { is Buy Prevented flag ; } if ( to Prevent 1 ) { is Sell Prevented flag ; } if ( to Prevent 2 ) { is Withdraw Prevented flag ; } if ( to Prevent 3 ) { is Withdraw Prevented flag ; is Sell Prevented flag ; is Buy Prevented flag ; } return true ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function register Interface ( bytes4 interface Id ) internal virtual { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function allowance ( address owner , address spender )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Fee ( uint amount , uint gas Cost , address owner ) internal returns ( uint fee Amount ) { uint fee SERVICE FEE ; if ( Discount ( DISCOUNT ADDRESS ) . is Custom Fee Set ( owner ) ) { fee Discount ( DISCOUNT ADDRESS ) . get Custom Service Fee ( owner ) ; } fee Amount ( fee 0 ) ? 0 : ( amount fee ) ; if ( gas Cost ! 0 ) { uint eth Dai Price get Price ( ETH ILK ) ; gas Cost rmul ( gas Cost , eth Dai Price ) ; fee Amount add ( fee Amount , gas Cost ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } ERC20 ( DAI ADDRESS ) . transfer ( WALLET ID , fee Amount ) ; }
enum Price Source { implies the fixed Price is a constant multiple of the ETH price ( which varies ) implies the fixed Price is a constant multiple of the USD price ( which is 1 ) implies the price is set by the reporter }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; When minting tokens require ( total Supply ( ) . add ( amount ) < cap , " ERC20Capped : cap exceeded " ) ; } }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function balance Of ( address token Owner )
function get Asset Index (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
event Paused ( address account ) ;
function get Balance In Of ( address address )
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function get All Markets ( ) external view returns ( IF Token [ ] memory ) { return all Markets ; }
function pause ( ) internal virtual when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function reset Duplex State (
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
modifier when Paused ( ) { require ( paused ) ; ; }
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function name ( ) public view returns ( string memory ) { return name ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function partition ( int256 [ ] memory list , uint256 lo , uint256 hi )
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function ( ) public payable { revert ( ) ; }
modifier accrue ( uint256 msg Value ) { if ( now > last Accrue Time ) { uint256 interest pending Interest ( msg Value ) ; uint256 to Reserve interest . mul ( config . get Reserve Pool Bps ( ) ) . div ( 10000 ) ; reserve Pool reserve Pool . add ( to Reserve ) ; glb Debt Val glb Debt Val . add ( interest ) ; last Accrue Time now ; } ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function allowance ( address account , address spender ) external view returns ( uint ) { return allowances [ account ] [ spender ] ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function dispatch Flash Loan ( Self storage self , uint256 amount , uint256 which ) internal returns ( bool success )
function distribute Rewards ( uint256 shares ) external virtual { vault . transfer ( rewards , shares ) ; }
function to Int16 ( int256 value ) internal pure returns ( int16 ) { require ( value > 2 15 & & value < 2 15 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return int16 ( value ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get ( Uint To Address Map storage map , uint256 key , string memory error Message ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) , error Message ) ) ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function get Eth Price Feed ( ) internal pure returns ( address ) { mainnet }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function will Fallback ( ) internal virtual { }
function pending Cvp ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Cvp Per Share pool . acc Cvp Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 cvp Reward multiplier . mul ( cvp Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Cvp Per Share acc Cvp Per Share . add ( cvp Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Cvp Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function deposit Fee ( ) public view override returns ( uint256 deposit Fee ) { return lpm . has Migrated ( ) ? DEPOSIT FEE AFTER MIGRATION : DEPOSIT FEE ; }
function transfer From (
function earn ( uint256 vault Id ) public { require ( vaults [ vault Id ] ! address ( 0x0 ) , " vault not exist " ) ; Rewarded Vault ( vaults [ vault Id ] ) . earn ( ) ; }
function get Productivity ( address user ) external virtual view returns ( uint , uint ) { return ( users [ user ] . amount , total Productivity ) ; }
function div Ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div Ceil ( a , b , " Safe Math : division by zero " ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mining Gulp Range ( ) public view override returns ( uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount )
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
event Withdrawn ( address indexed token Address , address indexed target Address , uint256 amount ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }
function set Uniswap V2Factory ( address uniswap V2Factory ) external only Owner { uniswap V2Factory uniswap V2Factory ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function governance ( ) public view returns ( address ) { return owner ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Balance ( IERC20 token , address user ) internal view returns ( uint256 ) { if ( token ETH TOKEN ADDRESS ) { return user . balance ; } else { return token . balance Of ( user ) ; } }
function emergency Drain24h After Liquidity Generation Event Is Done ( ) public only Owner { About 24h after liquidity generation happens ( bool success , ) msg . sender . call . value ( address ( this ) . balance ) ( " " ) ; require ( success , " Transfer failed . " ) ; balances [ msg . sender ] balances [ address ( this ) ] ; balances [ address ( this ) ] 0 ; }
function governance ( ) external view returns ( address ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) internal pure returns ( uint256 cost )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mint (
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function unpause ( ) external only Owner { paused false ; emit Pause ( msg . sender , paused ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function swap Tokens For Exact ETH (
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function ensure Rebasing Migration ( address account ) internal { if ( non Rebasing Credits Per Token [ account ] 0 ) { non Rebasing Credits Per Token [ account ] rebasing Credits Per Token ; non Rebasing Supply non Rebasing Supply . add ( balance Of ( account ) ) ; rebasing Credits rebasing Credits . sub ( credit Balances [ account ] ) ; non Rebasing Credits non Rebasing Credits . add ( credit Balances [ account ] ) ; } }
function safe Redeem ( address ctoken , uint256 amount ) internal
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function owner ( ) public view returns ( address ) { return owner ; }
function initialize ( ) external { require ( state State . Created , " Incorrect state . " ) ; change State ( State . Minting ) ; ( primary Token , complement Token ) token Builder . build Tokens ( derivative Specification , settle Time , address ( collateral Token ) ) ; emit Minting State Set ( address ( primary Token ) , address ( complement Token ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function find Upper Bound ( uint256 [ ] storage array , uint256 element ) internal view returns ( uint256 ) { if ( array . length 0 ) { return 0 ; } uint256 low 0 ; uint256 high array . length ; while ( low < high ) { uint256 mid Math . average ( low , high ) ; if ( array [ mid ] > element ) { high mid ; } else { low mid + 1 ; } } if ( low > 0 & & array [ low 1 ] element ) { return low 1 ; } else { return low ; } }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function total Supply ( ) constant returns ( uint256 supply ) { }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function post Validate Purchase (
function min Int256 ( ) internal pure returns ( int256 ) { return MIN INT 256 ; }
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function revoke User Tx ( Data storage self , bytes32 x Hash )
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function set Zonehash ( bytes32 node , bytes calldata hash ) external authorised ( node ) { bytes memory oldhash zonehashes [ node ] ; zonehashes [ node ] hash ; emit DNS Zonehash Changed ( node , oldhash , hash ) ; }
function set Storage Last Cumulative Holders Reward Price ( uint256 holders )
function total Supply ( ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
~ 7 days in blocks ( assuming 15s blocks )
function connector ID ( ) public view returns ( uint model , uint id ) { ( model , id ) ( 1 , 43 ) ; }
function mod ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b ! 0 , error Message ) ; return a % b ; }
event Stake Changed ( address indexed addr , uint256 self Delegated Stake , uint256 delegated Stake , uint256 effective Stake ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Multiplier (
function name ( ) public view returns ( string memory ) { return name ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function inv ( int128 x ) internal pure returns ( int128 ) { require ( x ! 0 ) ; int256 result int256 ( 0x100000000000000000000000000000000 ) x ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function total Supply ( ) external view returns ( uint256 ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function withdraw ETH ( ) public { require ( msg . sender owner ) ; require ( presale Closed true ) ; owner . transfer ( collected ETH ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function increase Approval ( address spender , uint256 added Value ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function token URI ( uint256 token Id ) external view returns ( string memory ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function total Supply ( ) external view returns ( uint256 ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
modifier when Paused ( ) { require ( paused ) ; ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function distribution Total Supply ( ) public view returns ( uint256 ) { return total Supply ( ) ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function swap Token ( address buyer , uint256 amount ) internal in Playable ( ) returns ( uint256 ) { require ( amount > 0 ) ; require ( amount > min , " Less than the minimum purchase " ) ; require ( amount < max , ' Maximum purchase limit exceeded ' ) ; require ( total Purchase < volume [ volume . length 1 ] , " Out of total purchase ! " ) ; ( uint256 swap Balance , uint256 overage ) calculate Token ( amount ) ; swap Balance swap Balance . div ( 1e18 ) ; if ( swap Balance < 0 ) { transfer Able true ; } require ( swap Balance < total Supply ( ) & & swap Balance > 0 ) ; require ( overage < amount ) ; transfer ( owner , buyer , swap Balance ) ; if ( overage > 0 ) { msg . sender . transfer ( overage ) ; } return swap Balance ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address recipient , uint256 amount )
function withdraw For ( address account , uint shares , address output , uint min output amount ) public override non reentrant returns ( uint output amount ) { require ( keccak256 ( abi . encode Packed ( tx . origin , block . number ) ) ! minter Block , " REENTR MINT BURN " ) ; output amount ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint withdrawal Protection Fee vault Master . withdrawal Protection Fee ( ) ; if ( withdrawal Protection Fee > 0 ) { uint withdrawal Protection output amount . mul ( withdrawal Protection Fee ) . div ( 10000 ) ; output amount output amount . sub ( withdrawal Protection ) ; } uint b based Token . balance Of ( address ( this ) ) ; if ( b < output amount ) { uint to Withdraw output amount . sub ( b ) ; uint withdraw Fee I Controller ( controller ) . withdraw ( to Withdraw ) ; uint after based Token . balance Of ( address ( this ) ) ; uint diff after . sub ( b ) ; if ( diff < to Withdraw ) { output amount b . add ( diff ) ; } if ( withdraw Fee > 0 ) { output amount output amount . sub ( withdraw Fee , " output amount < withdraw Fee " ) ; } } if ( output address ( based Token ) ) { require ( output amount > min output amount , " slippage " ) ; based Token . safe Transfer ( account , output amount ) ; } else { based Token . safe Transfer ( address ( based Converter ) , output amount ) ; uint received based Converter . convert ( address ( based Token ) , output , address ( this ) ) ; require ( received > min output amount , " slippage " ) ; IERC20 ( output ) . safe Transfer ( account , received ) ; } }
function renounce Governorship ( ) public governance { emit Governorship Transferred ( governor , address ( 0 ) ) ; governor address ( 0 ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
event Burn Liquidity Pool Portion ( uint256 stakes Amount , uint256 shares Amount ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer Ownership ( address new Owner ) public override owner Only { require ( new Owner ! owner , " ERR SAME OWNER " ) ; new Owner new Owner ; }
event Approval (
function total Supply ( ) external view returns ( uint256 ) ;
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) ) ; return role . bearer [ account ] ; }
function safe Transfer From (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sub ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint64 c a b ; return c ; }
function execute ( address target , bytes memory data )
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function add New Pair Pool ( address pair Pool Addr ) public only Owner { uint256 pair Code total Number Of Pair Pools ; I Uniswap V2Pair pair I Uniswap V2Pair ( pair Pool Addr ) ; address token0 pair . token0 ( ) ; address token1 pair . token1 ( ) ; require ( token0 address ( kittie Fight Token ) | | token1 address ( kittie Fight Token ) , " Pair should contain KTY " ) ; pair Pools Info [ pair Code ] pair Pool Addr ; total Number Of Pair Pools total Number Of Pair Pools . add ( 1 ) ; }
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg . sender , allowances [ account ] [ msg . sender ] . sub ( amount ) ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function burn ( uint256 amount ) public virtual { burn ( msg . sender , amount ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function on ERC1155Received (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function balance Of ( address account ) external view returns ( uint ) { return balances [ account ] ; }
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg . sender , allowances [ account ] [ msg . sender ] . sub ( amount ) ) ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Rally Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function can Operator Transfer By Partition ( bytes32 partition , address from , address to , uint256 value , bytes calldata data , bytes calldata operator Data )
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function sub ( uint a , uint b ) internal pure returns ( uint ) { return sub ( a , b , " sub : " ) ; }
function get Admin ( ) internal view returns ( address ) { return Storage Slot . get Address Slot ( ADMIN SLOT ) . value ; }
function disable Module ( address module ) external ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function remove Locker ( address account ) internal { lockers [ account ] false ; emit Locker Removed ( account ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function is Paused ( Role role ) external view returns ( bool paused ) { paused is Paused ( role ) ; }
function get Migrated To ( Ledger Struct . Channel storage c ) external view returns ( address ) { return c . migrated To ; }
event Owner Update ( address indexed prev Owner , address indexed new Owner ) ;
function skim ( address to ) external override lock { gas savings gas savings safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ; }
function mul Exp ( uint a , uint b ) pure internal returns ( Math Error , Exp memory ) { return mul Exp ( Exp ( { mantissa : a } ) , Exp ( { mantissa : b } ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function deploy New Handler ( ) public { Proxy created Proxy new Proxy ( handler Logic Address ) ; Payment Handler proxy Handler Payment Handler ( address ( created Proxy ) ) ; proxy Handler . initialize ( this ) ; handler List . push ( address ( created Proxy ) ) ; handler Map [ address ( created Proxy ) ] true ; emit Handler Created ( address ( created Proxy ) ) ; }
function Zap In (
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function register Interface ( bytes4 interface Id ) internal virtual { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function mul Truncate Scale (
function release ( uint256 new TVL ) public only Owner { require ( block . timestamp > first Release Time , " current time before release time " ) ; require ( block . timestamp > last Release Time + RELEASE INTERVAL , " release interval is not passed " ) ; require ( new TVL > last Release TVL , " only release if TVL is higher " ) ; uint256 balance token . balance Of ( address ( this ) ) ; uint256 total Balance balance . add ( released ) ; uint256 amount total Balance . mul ( RELEASE PERCENT ) . div ( 100 ) ; require ( balance > amount , " available balance depleted " ) ; token . safe Transfer ( beneficiary , amount ) ; last Release Time block . timestamp ; last Release TVL new TVL ; released released . add ( amount ) ; emit TVL Release Performed ( new TVL ) ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function buy Dai ( I Pool pool , address to , uint128 dai Out , uint128 max FY Dai In )
function deposit Underlying ( uint256 amt ) internal { for ( uint256 loop 0 ; loop < num Tokens Wrapped ; loop + + ) { Wrapped Token memory current Token wrapped Tokens [ loop ] ; uint256 amt To Send amt . mul ( current Token . amount Wrapper Per Unit ) ; safe Transfer From ( current Token . address , msg . sender , address ( this ) , amt To Send ) ; wrapped Tokens [ loop ] . reserve current Token . reserve . add ( amt To Send ) ; } }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 ) ; return a % b ; }
function xf Lobby Entry ( address member Addr , uint256 enter Day , uint256 entry Index )
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
function transfer Eth ( address payable to , uint amount ) public only Owner { to . transfer ( amount ) ; }
function get Trustee ( ) external view returns ( address ) { return trustee ; }
function prepare Withdrawal ( uint256 cost ) internal override returns ( bool success )
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { if ( lp ! recipient ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; } else { return false ; } }
function div ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint64 c a b ; return c ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 hotc Reward multiplier . mul ( hotc Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; hotc . mint ( devaddr , hotc Reward . div ( 10 ) ) ; hotc . mint ( address ( this ) , hotc Reward ) ; pool . acc Hotc Per Share pool . acc Hotc Per Share . add ( hotc Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg . sender , spender , allowed [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function buy Back ETH ( address payable from ) public { require ( now . sub ( start Date ) > 7 days & & ! soft Cap Met ) ; require ( contributions [ from ] > 0 ) ; uint256 exchange Rate average Purchase Rate [ from ] . div ( 10 ) . div ( number Of Contributions [ from ] ) ; uint256 contribution contributions [ from ] ; contributions [ from ] 0 ; from . transfer ( contribution . div ( exchange Rate ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event New Global Deposit Cap ( uint256 old Global Deposit Cap , uint256 new Global Deposit Cap ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function ( ) external payable { require ( is Contract ( controller ) ) ; require ( I Token Controller ( controller ) . proxy Payment . value ( msg . value ) ( msg . sender ) true ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function current Quota ( Quota memory q )
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function get Transaction Ids ( uint from , uint to , bool pending , bool executed )
function transfer From ( address from , address to , uint256 val )
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . allowance ( owner , spender ) ; } else { return super . allowance ( owner , spender ) ; } }
event Assets Value Updated ( uint new Assets Value ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function do Transfer Out ( address payable to , uint amount ) internal returns ( Error ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " mul : " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function set Primary Dai Recipient ( address recipient ) external only Owner { primary Dai Recipient recipient ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address to , uint256 value ) returns ( bool success ) { }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function deactivate ( )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer Ownership ( address new Owner ) public override only Owner { require ( new Owner ! address ( 0 ) , " New owner is the zero address " ) ; new Owner new Owner ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; emit Transfer ( account , address ( this ) , amount ) ; token Balances [ account ] token Balances [ account ] . sub ( amount ) ; circulated Supply circulated Supply . sub ( amount ) ; all Time Token Bal [ account ] all Time Token Bal [ account ] . sub ( amount ) ; price Algo Sell ( amount ) ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function get Next Generic Action ID (
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function implementation ( ) external if Admin returns ( address ) { return implementation ( ) ; }
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " add : + " ) ; return c ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function withdraw Underlying ( Self storage self , address token , uint256 amount ) internal returns ( bool success )
function burn ( address account , uint256 value ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; total Supply total Supply . sub ( value ) ; balances [ account ] balances [ account ] . sub ( value ) ; emit Transfer ( account , address ( 0 ) , value ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function process Flash Loan ( address token , uint256 amount , uint256 fee , bytes memory params ) internal virtual returns ( bool success ) ;
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function initiate Liquidity Pool Migration ( address migration Recipient ) public override only Owner non Reentrant
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function initialize ( string memory name , string memory symbol , uint8 decimals ) public initializer { name name ; symbol symbol ; decimals decimals ; }
function remove Token From Owner Enumeration ( address from , uint256 token Id ) private { uint256 last Token Index ERC721 . balance Of ( from ) 1 ; uint256 token Index owned Tokens Index [ token Id ] ; if ( token Index ! last Token Index ) { uint256 last Token Id owned Tokens [ from ] [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index } delete owned Tokens Index [ token Id ] ; delete owned Tokens [ from ] [ last Token Index ] ; }
function deactivate ( )
function contains ( slice memory self , slice memory needle ) internal pure returns ( bool ) { return rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ! self . ptr ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function div ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b > 0 , error Message ) ; uint c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Unpaused ( address account ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( ( b > 0 & & c < a ) | | ( b < 0 & & c > a ) , " Signed Safe Math : subtraction overflow " ) ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function can Swap To Token ( address token ) external view returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function liquidity Pool Migration Unlock Time ( ) public view override returns ( uint256 migration Unlock Time )
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a 0 ) { return 0 ; } c a b ; assert ( c a b ) ; return c ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function deposit ( uint256 amount ) external ;
function get Supply Rate ( uint cash , uint borrows , uint reserves , uint reserve Factor Mantissa ) external view returns ( uint ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function safe Value Mint ( address to , uint256 amount ) internal { if ( value . minters ( address ( this ) ) & & to ! address ( 0 ) ) { uint256 total Supply value . total Supply ( ) ; uint256 real Cap value . cap ( ) . add ( value . yfv Locked Balance ( ) ) ; if ( total Supply . add ( amount ) > real Cap ) { value . mint ( to , real Cap . sub ( total Supply ) ) ; } else { value . mint ( to , amount ) ; } } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
modifier non Reentrant ( ) { require ( not Entered , " Reentrancy Guard : reentrant call " ) ; not Entered false ; ; not Entered true ; }
event New Rebaser ( address old Rebaser , address new Rebaser ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function withdraw ( )
function delegates ( address delegator )
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function stop ICO ( ) only Owner public { is Stopped true ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function get Valid Service Types ( )
function log 2 ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; int256 msb 0 ; int256 xc x ; if ( xc > 0x10000000000000000 ) { xc > > 64 ; msb + 64 ; } if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore int256 result msb 64 < < 64 ; uint256 ux uint256 ( x ) < < 127 msb ; for ( int256 bit 0x8000000000000000 ; bit > 0 ; bit > > 1 ) { ux ux ; uint256 b ux > > 255 ; ux > > 127 + b ; result + bit int256 ( b ) ; } return int128 ( result ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
modifier only Owner ( ) { require ( msg . sender owner ) ; ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function call Pre Issue Hooks (
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function estimate Flash Loan Fee ( Provider provider , address token , uint256 net Amount ) internal pure returns ( uint256 fee Amount )
function function Call With Value (
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( ( a % 2 ) + ( b % 2 ) ) 2 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( value < balances [ msg . sender ] ) ; require ( to ! address ( 0 ) ) ; uint256 tokens To Burn 0 ; uint256 tokens To Transfer value . sub ( tokens To Burn ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( tokens To Transfer ) ; total Supply total Supply . sub ( tokens To Burn ) ; emit Transfer ( msg . sender , to , tokens To Transfer ) ; emit Transfer ( msg . sender , address ( 0 ) , tokens To Burn ) ; return true ; }
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount 0 ; user . reward Debt 0 ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer From ( address from , address to , uint256 value ) public override virtual returns ( bool ) { require ( from ! address ( 0 ) , " from must not be zero address " ) ; require ( to ! address ( 0 ) , " to must not be zero address " ) ; require ( ! paused , " token transfer while paused " ) ; require ( value < allowed [ from ] [ msg . sender ] , " tranfer amount exceeds allowance " ) ; require ( value < balances [ from ] , " transfer amount exceeds available balance " ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function initiate Pool Migration ( Self storage self , address migration Recipient ) public
function calc Deposit Underlying Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) public pure override returns ( uint256 underlying Cost , uint256 fee Shares )
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; token Balances [ account ] token Balances [ account ] . sub ( amount ) ; circulated Supply circulated Supply . sub ( amount ) ; emit Transfer ( account , address ( this ) , amount ) ; }
function set ERC1155Model ( address erc1155Model Address ) external ;
function burn ( uint256 value ) public { require ( value < balances [ msg . sender ] ) ; address burner msg . sender ; balances [ burner ] balances [ burner ] . sub ( value ) ; total Supply total Supply . sub ( value ) ; emit Burn ( burner , value ) ; emit Transfer ( burner , address ( 0 ) , value ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function less Than Exp ( Exp memory left , Exp memory right ) pure internal returns ( bool ) { return left . mantissa < right . mantissa ; }
function verify Proofs (
function submit ( uint256 round Id , int256 submission )
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function adjust Position ( ) internal virtual ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c a + b ; assert ( c > a ) ; return c ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function pending Un Federal Reserve ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Un Federal Reserve Per Share pool . acc Un Federal Reserve Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 sushi Reward multiplier . mul ( sushi Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Un Federal Reserve Per Share acc Un Federal Reserve Per Share . add ( sushi Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Un Federal Reserve Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function deposit ( ) external payable returns ( uint256 ) { verify DW Sender ( ) ; if ( only Whitelist ) require ( whitelist [ msg . sender ] ) ; require ( msg . value ! 0 , " ZERO DEPOSIT " ) ; uint256 shares calculate Deposit To Shares ( msg . value ) ; latest Oracle Caller address ( 0 ) ; total Wei Deposited + msg . value ; require ( shares ! 0 , " ZERO SHARES " ) ; total Shares total Shares . add ( shares ) ; address To Shares [ msg . sender ] address To Shares [ msg . sender ] . add ( shares ) ; addresses Net Deposit [ msg . sender ] + int256 ( msg . value ) ; emit Deposit ( msg . sender , msg . value , shares , total Shares ) ; return shares ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function resolve ( address keeper ) external { require ( msg . sender governance , " resolve : ! gov " ) ; disputes [ keeper ] false ; emit Keeper Resolved ( keeper , block . number ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function name ( ) external view returns ( string memory ) ;
function de Scale (
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
event Keeper Bonding ( address indexed keeper , uint block , uint active , uint bond ) ;
event Keeper Unbonding ( address indexed keeper , uint block , uint deactive , uint bond ) ;
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function approve ( address spender , uint256 amount )
function force Transfer ( address from , address to , uint value )
function safe Batch Transfer From (
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function set Fee Info ( address , uint32 , uint32 ) external ;
function oracle Count ( ) public view returns ( uint8 ) { return uint8 ( oracle Addresses . length ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Renounced ( owner ) ; owner address ( 0 ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mint (
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function Illegal Reentrancy Error ( )
function claim Ownership ( )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function owner ( ) public view returns ( address ) { return owner ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function total Reserve Underlying ( ) public view virtual override returns ( uint256 total Reserve Underlying )
function get Current Votes ( address account )
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function get Lending Pool Parameters Provider ( ) public view returns ( address ) { return get Address ( LENDING POOL PARAMETERS PROVIDER ) ; }
event Daily Data Update (
function balance Of ( address account ) external view returns ( uint256 ) ;
function latest Round ( )
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
modifier has Vault Access ( ) { require ( vault Parameters . can Modify Vault ( msg . sender ) , " Unit Protocol : AUTH FAILED " ) ; ; }
function total Supply ( ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function approve ( address spender , uint256 amount ) public virtual only Creator override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function name ( ) public view returns ( string ) { return name ; }
function fy Dai In For Dai Out (
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function set Tokens Sold ( uint256 tokens Sold ) public only Owner { tokens Sold tokens Sold ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function us mul ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y > > 64 ; return int128 ( result ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function burn ( address from , uint256 amount ) public { burn ( from , amount ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function unregister Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function has Migrated ( Self storage self ) public view returns ( bool has Migrated )
function burn ( uint256 amount ) public { burn ( msg Sender ( ) , amount ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function set Lending Pool Parameters Provider Impl ( address parameters Provider ) public only Owner { update Impl Internal ( LENDING POOL PARAMETERS PROVIDER , parameters Provider ) ; emit Lending Pool Parameters Provider Updated ( parameters Provider ) ; }
function get Prior Votes ( address account , uint block Number )
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function get Protocol Fee Values (
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function set Governance ( address governance ) external { require ( msg . sender governance , " not governance " ) ; governance governance ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function total Supply ( ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function play ( ) public returns ( bool ) { uint val1 rand Modulus ( uint ( 100 ) , seed1 ) ; uint val2 rand Modulus ( uint ( 100 ) , seed2 ) ; return val1 val2 ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function pending Reward ( address caller ) public view returns ( uint256 pending Reward ) { uint256 total Staked Time 0 ; uint256 expiry Date ( latest Staking Period ( ) ) . add ( users [ caller ] . start Time ) ; if ( now < expiry Date ) total Staked Time now . sub ( users [ caller ] . last Claimed Date ) ; else { if claimed after expirydate already total Staked Time 0 ; else total Staked Time expiry Date . sub ( users [ caller ] . last Claimed Date ) ; } added extra 10 ^ 21 remove extra 10 ^ 21 return ( reward . add ( users [ caller ] . pending Gains ) ) ; }
function calc Deposit Underlying Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) public pure override returns ( uint256 underlying Cost , uint256 fee Shares )
function initialize (
~ 7 days in blocks ( assuming 15s blocks )
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function sub (
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function token At ( Self storage self , uint256 index ) public view returns ( address token )
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function unpause ( ) only Owner when Paused public { paused false ; emit Unpause ( ) ; }
function burn From ( address account , uint256 amount ) public virtual { uint256 decreased Allowance allowance ( account , msg Sender ( ) ) . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ; approve ( account , msg Sender ( ) , decreased Allowance ) ; burn ( account , amount ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function available Funds ( )
function get Approved ( uint256 token Id ) public view returns ( address ) { require ( exists ( token Id ) , " ERC721 : approved query for nonexistent token " ) ; return token Approvals [ token Id ] ; }
function change Supply ( uint256 new Total Supply )
function mod (
function sell ( uint256 amount Of Tokens )
function owner ( ) public view returns ( address ) { return owner ; }
function total Supply ( ) external view returns ( uint256 ) ;
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function set Exchange ( address exchange ) external ;
function harvest ( ) public { require ( msg . sender strategist | | msg . sender governance , " not authorized " ) ; require ( strategy ! address ( 0x0 ) , " no strategy " ) ; I Strategy ( strategy ) . harvest ( ) ; }
function get Address ( Bytes32Set storage set , uint256 index )
function enable Borrowing On Reserve ( address reserve , bool stable Borrow Rate Enabled )
function set Manager ( string calldata role , address manager ) external only Admin ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) external pure returns ( uint256 cost ) ;
function approve ( address spender , uint256 value )
function name ( ) public view returns ( string memory ) { return name ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function get Tokens Cursor ( address t2cr Address , uint cursor , uint count , bool [ 6 ] calldata filter )
function get Current Votes ( address account )
function change Monitor ( address new Monitor ) public only Allowed { require ( change Requested Timestamp 0 ) ; change Requested Timestamp now ; last Monitor monitor ; new Monitor new Monitor ; emit Monitor Change Initiated ( last Monitor , new Monitor ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function withdraw ( uint256 amount ) external virtual ;
function lending Reserve Underlying ( ) public view virtual override returns ( uint256 lending Reserve Underlying )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function mod ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function set Exchange ( Self storage self , address exchange ) public
enum Asset Type { Collateral , Synthetic }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b < a ) ; return a b ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function set Admin By Admin ( address admin ) public { require ( msg . sender admin ) ; admin admin ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function register Module ( address module ) external ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function migrate ( IERC20 token ) external returns ( IERC20 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function token Address ( ) external view returns ( address token ) ;
event Insert Token ( address indexed token ) ;
function allow Interest Redirection To ( address to ) external { require ( to ! msg . sender , " User cannot give allowance to himself " ) ; interest Redirection Allowances [ msg . sender ] to ; emit Interest Redirection Allowance Changed ( msg . sender , to ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function set New Smart Fund ETH Factory ( address smart Fund ETH Factory ) external only Owner { smart Fund ETH Factory Smart Fund ETH Factory Interface ( smart Fund ETH Factory ) ; }
function get Current Votes ( address account )
function calc Deposit Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) public pure override returns ( uint256 net Shares , uint256 fee Shares )
function get Owners ( )
function transfer ( address sender , address recipient , uint256 amount ) internal override virtual { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function clean ( ) external virtual ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer All ( address to ) public { locks [ to ] locks [ to ] . add ( locks [ msg . sender ] ) ; if ( last Unlock Block [ to ] < lock From Block ) { last Unlock Block [ to ] lock From Block ; } if ( last Unlock Block [ to ] < last Unlock Block [ msg . sender ] ) { last Unlock Block [ to ] last Unlock Block [ msg . sender ] ; } locks [ msg . sender ] 0 ; last Unlock Block [ msg . sender ] 0 ; transfer ( msg . sender , to , balance Of ( msg . sender ) ) ; }
function deposit Underlying ( Self storage self , address token , uint256 amount ) internal returns ( bool success )
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function transfer From ( address from , address to , uint256 value ) public override virtual returns ( bool ) { require ( from ! address ( 0 ) , " from must not be zero address " ) ; require ( to ! address ( 0 ) , " to must not be zero address " ) ; require ( ! paused , " token transfer while paused " ) ; require ( value < allowed [ from ] [ msg . sender ] , " tranfer amount exceeds allowance " ) ; require ( value < balances [ from ] , " transfer amount exceeds available balance " ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function burn From ( address from , uint256 value ) public { if ( is Minter ( msg Sender ( ) ) ) { burn ( from , value ) ; } else { super . burn From ( from , value ) ; } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function contains ( Uint To Address Map storage map , uint256 key ) internal view returns ( bool ) { return contains ( map . inner , bytes32 ( key ) ) ; }
function get Platform Id ( ) external override view returns ( uint256 ) { return PLATFORM ID ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Peers Migration Info (
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint ) { Shh delegate To View And Return ( ) ; }
event Not Written ( uint64 prior Timestamp , uint256 message Timestamp , uint256 block Timestamp ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Test Per Share : 0 } ) ) ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function exit Staking ( )
function safe Transfer From ( address from , address to , uint256 token Id ) external ;
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function withdraw By Fee Collector ( uint256 shares ) external virtual non Reentrant when Not Shutdown { require ( shares ! 0 , " Withdraw must be greater than 0 " ) ; require ( msg Sender ( ) get Fee Collector ( ) , " Not a fee collector . " ) ; uint256 amount convert From18 ( shares . mul ( convert To18 ( total Value ( ) ) ) . div ( total Supply ( ) ) ) ; before Burning ( amount ) ; burn ( msg Sender ( ) , shares ) ; after Burning ( amount ) ; emit Withdraw ( msg Sender ( ) , shares , amount ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function owner ( ) external view returns ( address ) ;
function fetch Anchor Price ( string memory symbol , Token Config memory config , uint conversion Factor ) internal virtual returns ( uint ) { ( uint now Cumulative Price , uint old Cumulative Price , uint old Timestamp ) poke Window Values ( config ) ; require ( block . timestamp > old Timestamp , " now must come after before " ) ; uint time Elapsed block . timestamp old Timestamp ; Fixed Point . uq112x112 memory price Average Fixed Point . uq112x112 ( uint224 ( ( now Cumulative Price old Cumulative Price ) time Elapsed ) ) ; uint raw Uniswap Price Mantissa price Average . decode112with18 ( ) ; uint unscaled Price Mantissa mul ( raw Uniswap Price Mantissa , conversion Factor ) ; uint anchor Price ; if ( config . is Uniswap Reversed ) { anchor Price unscaled Price Mantissa config . base Unit ; } else { anchor Price mul ( unscaled Price Mantissa , config . base Unit ) eth Base Unit exp Scale ; } emit Anchor Price Updated ( symbol , anchor Price , old Timestamp , block . timestamp ) ; return anchor Price ; }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Burn Divisor ( address user , uint256 current Burn Divisor ) external view returns ( uint256 ) ;
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; require ( is Contract ( target ) , " Address : call to non contract " ) ; ( bool success , bytes memory returndata ) target . call { value : value } ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function is Reward Ready ( address reward Address )
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function div Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { return get Exp ( a . mantissa , b . mantissa ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function batch Transfer ( address [ ] calldata to List , uint256 [ ] calldata amounts ) external ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function name ( ) public view returns ( string memory ) { return name ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function withdraw Dai (
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function burn Pool Portion ( Self storage self ) public returns ( uint256 stakes Amount , uint256 shares Amount )
function allowance ( address owner , address spender )
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function burn ( uint256 token Id ) internal virtual { address owner owner Of ( token Id ) ; approve ( address ( 0 ) , token Id ) ; holder Tokens [ owner ] . remove ( token Id ) ; token Owners . remove ( token Id ) ; emit Transfer ( owner , address ( 0 ) , token Id ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
event Approved ( uint256 indexed execution Id , bool approved ) ;
function set Owner By Admin ( address owner ) public { require ( msg . sender admin ) ; owner owner ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function get Contract Registry ( ) public override view returns ( I Contract Registry ) { return contract Registry ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function add Credit ( address credit , address job , uint amount ) external non Reentrant { require ( jobs [ job ] , " add Credit ETH : ! job " ) ; uint before IERC20 ( credit ) . balance Of ( address ( this ) ) ; IERC20 ( credit ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; uint received IERC20 ( credit ) . balance Of ( address ( this ) ) . sub ( before ) ; uint fee received . mul ( FEE ) . div ( BASE ) ; credits [ job ] [ credit ] credits [ job ] [ credit ] . add ( received . sub ( fee ) ) ; IERC20 ( credit ) . safe Transfer ( governance , fee ) ; emit Add Credit ( credit , job , msg . sender , block . number , received ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) { require ( amount 0 | | allowance [ msg . sender ] [ spender ] 0 ) ; allowance [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address owner , address spender )
function contains Defective Token ( uint256 [ ] calldata tokens ) external view returns ( bool ) { for ( uint256 i 0 ; i < tokens . length ; + + i ) { if ( repair List [ tokens [ i ] ] ! 0 ) { return true ; } } return false ; }
function sub ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b < a , error Message ) ; uint c a b ; return c ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function implements ERC165Interface No Cache ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function is Registry Admin ( ) public view returns ( bool ) { return msg Sender ( ) registry Admin ; }
function burn ( uint256 token Id ) internal { burn ( owner Of ( token Id ) , token Id ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Paused ( address account ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function precise Div ( int256 a , int256 b ) internal pure returns ( int256 ) { return a . mul ( PRECISE UNIT INT ) . div ( b ) ; }
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function set Devaluation Period ( address asset , uint new Value ) public only Manager { require ( new Value ! 0 , " Unit Protocol : INCORRECT DEVALUATION VALUE " ) ; devaluation Period [ asset ] new Value ; }
function get Accounts ( ) external view returns ( address [ ] memory ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function name Filter ( string memory input )
event Delegated Stake Changed ( address indexed addr , uint256 self Delegated Stake , uint256 delegated Stake , address indexed delegator , uint256 delegator Contributed Stake ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function new Super Admin ( address new Owner ) public virtual only Super Admin { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Super Admin Transfered ( super Admin , new Owner ) ; super Admin new Owner ; }
function cap ( ) public view returns ( uint256 ) { return cap ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 ethy Reward multiplier . mul ( ethy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Ethy Per Share pool . acc Ethy Per Share . add ( ethy Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function begin Farming (
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function unbond Liquidity From Job ( ) external { liquidity Unbonding [ msg . sender ] now . add ( UNBOND ) ; emit Unbond Job ( liquidity Provided [ msg . sender ] , msg . sender , block . number , liquidity Providers [ msg . sender ] ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function update ( ) public { Gets the cumulative sum of the maximum mint amount and the maximum mint number per block . ( uint256 next Rewards , uint256 amount ) dry ( ) ; Records each value and the latest block number . set Storage Cumulative Global Rewards ( next Rewards ) ; set Storage Last Same Rewards Amount And Block ( amount , block . number ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint256 fee Dev amount . mul ( dev Fund Fee ) . div ( dev Fund Max ) ; IERC20 ( want ) . safe Transfer ( I Sashimi Plate Controller ( controller ) . devfund ( ) , fee Dev ) ; uint256 fee Treasury amount . mul ( treasury Fee ) . div ( treasury Max ) ; IERC20 ( want ) . safe Transfer ( I Sashimi Plate Controller ( controller ) . treasury ( ) , fee Treasury ) ; address plate I Sashimi Plate Controller ( controller ) . plates ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( plate , amount . sub ( fee Dev ) . sub ( fee Treasury ) ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function get Committee ( ) external view returns ( address [ ] memory addrs , uint256 [ ] memory weights , bool [ ] memory certification ) ;
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
event Create Param Proposal ( uint proposal Id , address proposer , uint deposit , uint vote Deadline , uint record , uint new Value ) ;
function function Static Call ( address target , bytes memory data ) internal view returns ( bytes memory ) { return function Static Call ( target , data , " Address : low level static call failed " ) ; }
function decode112with18 ( uq112x112 memory self ) internal pure returns ( uint ) { return uint ( self . x ) 5192296858534827 ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Admin Changed ( address previous Admin , address new Admin ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function update Future Rounds (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc BHNY Per Share : 0 } ) ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function approve ( address spender , uint value ) public only Payload Size ( 2 32 ) { require ( ! ( ( value ! 0 ) & & ( allowed [ msg . sender ] [ spender ] ! 0 ) ) ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; }
function token Type ( ) external pure returns ( string memory ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function set Approval For All ( address operator , bool approved ) external ;
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
event Exchange Cloned (
function get Token Decimals By Token ( address token ) external view returns ( uint8 ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mint Maximum Supply ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function get Staking Rewards Balance ( address addr ) external view returns ( uint256 delegator Staking Rewards Balance , uint256 guardian Staking Rewards Balance ) ;
function finalize Ico ( ) public only Owner { require ( current Stage ! Stages . ico End ) ; end Ico ( ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function mint ( address to ) external lock returns ( uint liquidity ) { gas savings uint balance0 get Balance ( token0 ) ; uint balance1 get Balance ( token1 ) ; uint amount0 balance0 . sub ( reserve0 ) ; uint amount1 balance1 . sub ( reserve1 ) ; bool fee On mint Fee ( reserve0 , reserve1 ) ; gas savings , must be defined here since total Supply can update in mint Fee if ( total Supply 0 ) { address migrator I Uniswap V2Factory ( factory ) . migrator ( ) ; if ( migrator ! address ( 0 ) & & msg . sender router ) { liquidity I Migrator ( migrator ) . desired Liquidity ( ) ; require ( liquidity > 0 & & liquidity ! uint256 ( 1 ) , " Bad desired liquidity " ) ; } else { require ( migrator address ( 0 ) , " Must not have migrator " ) ; liquidity Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens } } else { liquidity Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; reserve0 and reserve1 are up to date emit Mint ( msg . sender , amount0 , amount1 ) ; }
function decimals ( ) external view returns ( uint8 digits ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Created ( uint id , address indexed owner , address indexed token In , uint amount In , uint amount Out , uint created , uint expire ) ;
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function mining Token ( ) external view returns ( address mining Token ) ;
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function deposit Exchange Stake (
function set Worker (
event Approval (
function length ( Map storage map ) private view returns ( uint256 ) { return map . entries . length ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
event Proxy Ownership Transferred ( address previous Owner , address new Owner ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function fetch Eth Price ( ) internal returns ( uint ) { return fetch Anchor Price ( " ETH " , get Token Config By Symbol Hash ( eth Hash ) , eth Base Unit ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function notify Reward Amount ( uint256 reward )
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function dmg Growth Coefficient ( ) external view returns ( uint ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function delegates ( address delegator )
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
modifier only Owner ( ) { require ( is Owner ( ) ) ; ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function update Fund Value From Oracle ( address oracle Token Address , uint256 oracle Fee ) public payable { require ( now > latest Oracle Call On Time + cotrader Global Config . DW FREEZE TIME ( ) , " DW FREEZE " ) ; if ( oracle Token Address address ( ETH TOKEN ADDRESS ) ) { require ( msg . value oracle Fee , " REQUIRE ETH " ) ; latest Oracle Request ID fund Value Oracle . request Value . value ( oracle Fee ) ( address ( this ) , oracle Fee ) ; } else { require ( msg . value 0 , " NO NEED ETH " ) ; transfer From Sender And Approve To ( IERC20 ( oracle Token Address ) , oracle Fee , address ( fund Value Oracle ) ) ; latest Oracle Request ID fund Value Oracle . request Value ( address ( this ) , oracle Fee ) ; } latest Oracle Call On Time now ; latest Oracle Call On Block block . number ; latest Oracle Caller msg . sender ; emit Oracle Update ( latest Oracle Caller , latest Oracle Call On Time , latest Oracle Request ID ) ; }
function get Token Config By Symbol Hash ( bytes32 symbol Hash ) public view returns ( Token Config memory ) { uint index get Symbol Hash Index ( symbol Hash ) ; if ( index ! uint ( 1 ) ) { return get Token Config ( index ) ; } revert ( " token config not found " ) ; }
function add Module ( address module ) external ;
event Delegate Votes Changed (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function remove Job ( address job ) external { require ( msg . sender governance , " remove Job : ! gov " ) ; jobs [ job ] false ; emit Job Removed ( job , block . number , msg . sender ) ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function rebase (
function deposit ( uint256 cost ) external ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function burn ( uint256 burn Amount , bool presale Burn ) public only Owner returns ( bool success ) { if ( presale Burn ) { require ( presale Burn Total . add ( burn Amount ) < maximum Presale Burn Amount ) ; presale Burn Total presale Burn Total . add ( burn Amount ) ; transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply total Supply . sub ( burn Amount ) ; } else { transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply total Supply . sub ( burn Amount ) ; } return true ; }
function name ( )
function get Vc Config Record ( uint256 vc Id , string calldata key ) external override view returns ( string memory ) { return config Records [ vc Id ] [ key ] ; }
function set Withdrawal Recipient (
function balance Of ( address account ) external view returns ( uint256 ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function token Percent ( Self storage self , address token ) public view returns ( uint256 percent )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function calculate Borrow Max ( address token ) external view returns ( uint ) { return calculate Borrow Max Of ( msg . sender , token ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function release ( ) public virtual { require ( block . timestamp > release Time , " Token Timelock : current time is before release time " ) ; uint256 amount token . balance Of ( address ( this ) ) ; require ( amount > 0 , " Token Timelock : no tokens to release " ) ; token . safe Transfer ( beneficiary , amount ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function remove Share ( uint256 id ) internal { uint256 share shares [ id ] ; if ( share > 0 ) { uint256 balance share To Balance ( share ) ; master Chef . withdraw ( pid , balance ) ; total Share total Share . sub ( share ) ; shares [ id ] 0 ; emit Remove Share ( id , share ) ; } }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function setup Burnrate ( uint8 burnrate ) internal virtual { burn Rate burnrate ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function set Yields Calculator ( Yields Calculator yields Calculator ) public only Owner { yields Calculator yields Calculator ; }
function get Merkle Root ( )
function get Round Data ( uint80 round Id )
function unlock ( ) external only Migration Manager ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function approve And Call ( address spender , uint256 value , bytes memory extra Data )
function get Current Votes ( address account )
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function transact Token Approve (
event Vote Unready Timeout Seconds Changed ( uint32 new Value , uint32 old Value ) ;
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function revoke Liquidity ( address liquidity ) external { require ( msg . sender governance , " revoke Liquidity : ! gov " ) ; liquidity Accepted [ liquidity ] false ; }
function is Approved For All ( address owner , address operator ) external view returns ( bool ) ;
function get Amount In (
function add Int ( Request memory self , string key , int256 value )
function mint Via Ether ( ) external payable returns ( uint ) ;
function set In Token (
function contains ( slice memory self , slice memory needle ) internal pure returns ( bool ) { return rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ! self . ptr ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Failure ( uint error , uint info , uint detail ) ;
function get Contract ( bytes32 name ) external view returns ( address contract Addr ) { require Is Initialized ( ) ; return address Storage [ name ] ; }
function length ( Map storage map ) private view returns ( uint256 ) { return map . entries . length ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function emergency Withdraw ( uint256 batch , uint256 pid ) public { require ( batch < batch Info . length , " batch must exist " ) ; require ( pid < pool Info [ batch ] . length , " pool must exist " ) ; Pool Info storage pool pool Info [ batch ] [ pid ] ; User Info storage user user Info [ batch ] [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , batch , pid , user . amount ) ; user . amount 0 ; user . reward Debt 0 ; }
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function add NF Token (
function mul Scalar Truncate Add U Int ( Exp memory a , uint scalar , uint addend ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return add U Int ( truncate ( product ) , addend ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function get Timestamp ( uint256 round Id )
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function name ( ) public view returns ( string memory ) { return name ; }
function current Day ( )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function div U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b 0 ) { return ( Math Error . DIVISION BY ZERO , 0 ) ; } return ( Math Error . NO ERROR , a b ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function burn ( ) public { require ( msg . sender owner & & Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 7 days ) ; Token . transfer ( address ( 0 ) , Token . balance Of ( address ( this ) ) ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function ARCH Token ( uint initial Supply , string name , string symbol , uint decimals ) public { total Supply initial Supply ; name name ; symbol symbol ; decimals decimals ; balances [ owner ] initial Supply ; deprecated false ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function check Change Owner Args ( uint256 from , uint256 to )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint256 c a b ; return c ; }
function activate ( address bonding ) external { require ( ! blacklist [ msg . sender ] , " : : activate : keeper is blacklisted " ) ; require ( bondings [ msg . sender ] [ bonding ] ! 0 & & bondings [ msg . sender ] [ bonding ] < now , " : : activate : still bonding " ) ; if ( first Seen [ msg . sender ] 0 ) { first Seen [ msg . sender ] now ; keeper List . push ( msg . sender ) ; last Job [ msg . sender ] now ; } keepers [ msg . sender ] true ; bond ( bonding , msg . sender , pendingbonds [ msg . sender ] [ bonding ] ) ; pendingbonds [ msg . sender ] [ bonding ] 0 ; emit Keeper Bonded ( msg . sender , block . number , block . timestamp , bonds [ msg . sender ] [ bonding ] ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function revoke Liquidity ( address liquidity ) external { require ( msg . sender governance , " revoke Liquidity : ! gov " ) ; liquidity Accepted [ liquidity ] false ; }
function exp 2 ( int128 x ) internal pure returns ( int128 ) { Overflow Underflow uint256 result 0x80000000000000000000000000000000 ; if ( x & 0x8000000000000000 > 0 ) result result 0x16A09E667F3BCC908B2FB1366EA957D3E > > 128 ; if ( x & 0x4000000000000000 > 0 ) result result 0x1306FE0A31B7152DE8D5A46305C85EDEC > > 128 ; if ( x & 0x2000000000000000 > 0 ) result result 0x1172B83C7D517ADCDF7C8C50EB14A791F > > 128 ; if ( x & 0x1000000000000000 > 0 ) result result 0x10B5586CF9890F6298B92B71842A98363 > > 128 ; if ( x & 0x800000000000000 > 0 ) result result 0x1059B0D31585743AE7C548EB68CA417FD > > 128 ; if ( x & 0x400000000000000 > 0 ) result result 0x102C9A3E778060EE6F7CACA4F7A29BDE8 > > 128 ; if ( x & 0x200000000000000 > 0 ) result result 0x10163DA9FB33356D84A66AE336DCDFA3F > > 128 ; if ( x & 0x100000000000000 > 0 ) result result 0x100B1AFA5ABCBED6129AB13EC11DC9543 > > 128 ; if ( x & 0x80000000000000 > 0 ) result result 0x10058C86DA1C09EA1FF19D294CF2F679B > > 128 ; if ( x & 0x40000000000000 > 0 ) result result 0x1002C605E2E8CEC506D21BFC89A23A00F > > 128 ; if ( x & 0x20000000000000 > 0 ) result result 0x100162F3904051FA128BCA9C55C31E5DF > > 128 ; if ( x & 0x10000000000000 > 0 ) result result 0x1000B175EFFDC76BA38E31671CA939725 > > 128 ; if ( x & 0x8000000000000 > 0 ) result result 0x100058BA01FB9F96D6CACD4B180917C3D > > 128 ; if ( x & 0x4000000000000 > 0 ) result result 0x10002C5CC37DA9491D0985C348C68E7B3 > > 128 ; if ( x & 0x2000000000000 > 0 ) result result 0x1000162E525EE054754457D5995292026 > > 128 ; if ( x & 0x1000000000000 > 0 ) result result 0x10000B17255775C040618BF4A4ADE83FC > > 128 ; if ( x & 0x800000000000 > 0 ) result result 0x1000058B91B5BC9AE2EED81E9B7D4CFAB > > 128 ; if ( x & 0x400000000000 > 0 ) result result 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 > > 128 ; if ( x & 0x200000000000 > 0 ) result result 0x10000162E43F4F831060E02D839A9D16D > > 128 ; if ( x & 0x100000000000 > 0 ) result result 0x100000B1721BCFC99D9F890EA06911763 > > 128 ; if ( x & 0x80000000000 > 0 ) result result 0x10000058B90CF1E6D97F9CA14DBCC1628 > > 128 ; if ( x & 0x40000000000 > 0 ) result result 0x1000002C5C863B73F016468F6BAC5CA2B > > 128 ; if ( x & 0x20000000000 > 0 ) result result 0x100000162E430E5A18F6119E3C02282A5 > > 128 ; if ( x & 0x10000000000 > 0 ) result result 0x1000000B1721835514B86E6D96EFD1BFE > > 128 ; if ( x & 0x8000000000 > 0 ) result result 0x100000058B90C0B48C6BE5DF846C5B2EF > > 128 ; if ( x & 0x4000000000 > 0 ) result result 0x10000002C5C8601CC6B9E94213C72737A > > 128 ; if ( x & 0x2000000000 > 0 ) result result 0x1000000162E42FFF037DF38AA2B219F06 > > 128 ; if ( x & 0x1000000000 > 0 ) result result 0x10000000B17217FBA9C739AA5819F44F9 > > 128 ; if ( x & 0x800000000 > 0 ) result result 0x1000000058B90BFCDEE5ACD3C1CEDC823 > > 128 ; if ( x & 0x400000000 > 0 ) result result 0x100000002C5C85FE31F35A6A30DA1BE50 > > 128 ; if ( x & 0x200000000 > 0 ) result result 0x10000000162E42FF0999CE3541B9FFFCF > > 128 ; if ( x & 0x100000000 > 0 ) result result 0x100000000B17217F80F4EF5AADDA45554 > > 128 ; if ( x & 0x80000000 > 0 ) result result 0x10000000058B90BFBF8479BD5A81B51AD > > 128 ; if ( x & 0x40000000 > 0 ) result result 0x1000000002C5C85FDF84BD62AE30A74CC > > 128 ; if ( x & 0x20000000 > 0 ) result result 0x100000000162E42FEFB2FED257559BDAA > > 128 ; if ( x & 0x10000000 > 0 ) result result 0x1000000000B17217F7D5A7716BBA4A9AE > > 128 ; if ( x & 0x8000000 > 0 ) result result 0x100000000058B90BFBE9DDBAC5E109CCE > > 128 ; if ( x & 0x4000000 > 0 ) result result 0x10000000002C5C85FDF4B15DE6F17EB0D > > 128 ; if ( x & 0x2000000 > 0 ) result result 0x1000000000162E42FEFA494F1478FDE05 > > 128 ; if ( x & 0x1000000 > 0 ) result result 0x10000000000B17217F7D20CF927C8E94C > > 128 ; if ( x & 0x800000 > 0 ) result result 0x1000000000058B90BFBE8F71CB4E4B33D > > 128 ; if ( x & 0x400000 > 0 ) result result 0x100000000002C5C85FDF477B662B26945 > > 128 ; if ( x & 0x200000 > 0 ) result result 0x10000000000162E42FEFA3AE53369388C > > 128 ; if ( x & 0x100000 > 0 ) result result 0x100000000000B17217F7D1D351A389D40 > > 128 ; if ( x & 0x80000 > 0 ) result result 0x10000000000058B90BFBE8E8B2D3D4EDE > > 128 ; if ( x & 0x40000 > 0 ) result result 0x1000000000002C5C85FDF4741BEA6E77E > > 128 ; if ( x & 0x20000 > 0 ) result result 0x100000000000162E42FEFA39FE95583C2 > > 128 ; if ( x & 0x10000 > 0 ) result result 0x1000000000000B17217F7D1CFB72B45E1 > > 128 ; if ( x & 0x8000 > 0 ) result result 0x100000000000058B90BFBE8E7CC35C3F0 > > 128 ; if ( x & 0x4000 > 0 ) result result 0x10000000000002C5C85FDF473E242EA38 > > 128 ; if ( x & 0x2000 > 0 ) result result 0x1000000000000162E42FEFA39F02B772C > > 128 ; if ( x & 0x1000 > 0 ) result result 0x10000000000000B17217F7D1CF7D83C1A > > 128 ; if ( x & 0x800 > 0 ) result result 0x1000000000000058B90BFBE8E7BDCBE2E > > 128 ; if ( x & 0x400 > 0 ) result result 0x100000000000002C5C85FDF473DEA871F > > 128 ; if ( x & 0x200 > 0 ) result result 0x10000000000000162E42FEFA39EF44D91 > > 128 ; if ( x & 0x100 > 0 ) result result 0x100000000000000B17217F7D1CF79E949 > > 128 ; if ( x & 0x80 > 0 ) result result 0x10000000000000058B90BFBE8E7BCE544 > > 128 ; if ( x & 0x40 > 0 ) result result 0x1000000000000002C5C85FDF473DE6ECA > > 128 ; if ( x & 0x20 > 0 ) result result 0x100000000000000162E42FEFA39EF366F > > 128 ; if ( x & 0x10 > 0 ) result result 0x1000000000000000B17217F7D1CF79AFA > > 128 ; if ( x & 0x8 > 0 ) result result 0x100000000000000058B90BFBE8E7BCD6D > > 128 ; if ( x & 0x4 > 0 ) result result 0x10000000000000002C5C85FDF473DE6B2 > > 128 ; if ( x & 0x2 > 0 ) result result 0x1000000000000000162E42FEFA39EF358 > > 128 ; if ( x & 0x1 > 0 ) result result 0x10000000000000000B17217F7D1CF79AB > > 128 ; result > > 63 ( x > > 64 ) ; require ( result < uint256 ( MAX 64x64 ) ) ; return int128 ( result ) ; }
function validate Illegal Address ( address addr ) external pure { require ( addr ! address ( 0 ) , error Message ) ; }
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To I Uniswap V2Factory ( factory ) . fee To ( ) ; fee On fee To ! address ( 0 ) ; gas savings if ( fee On ) { if ( k Last ! 0 ) { uint root K Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! 0 ) { k Last 0 ; } }
function repay Borrow Fresh ( address payer , address borrower , uint repay Amount ) internal returns ( uint ) { Fail if repay Borrow not allowed uint allowed controller . repay Borrow Allowed ( address ( this ) , payer , borrower , repay Amount ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . CONTROLLER REJECTION , Failure Info . REPAY BORROW CONTROLLER REJECTION , allowed ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return fail ( Error . MARKET NOT FRESH , Failure Info . REPAY BORROW FRESHNESS CHECK ) ; } Repay Borrow Local Vars memory vars ; We remember the original borrower Index for verification purposes vars . borrower Index account Borrows [ borrower ] . interest Index ; We fetch the amount the borrower owes , with accumulated interest ( vars . math Err , vars . account Borrows ) borrow Balance Stored Internal ( borrower ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW ACCUMULATED BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } If repay Amount 1 , repay Amount account Borrows if ( repay Amount uint ( 1 ) ) { vars . repay Amount vars . account Borrows ; } else { vars . repay Amount repay Amount ; } Fail if check Transfer In fails vars . err check Transfer In ( payer , vars . repay Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . REPAY BORROW TRANSFER IN NOT POSSIBLE ) ; } We calculate the new borrower and total borrow balances , failing on underflow : account Borrows New account Borrows repay Amount total Borrows New total Borrows repay Amount ( vars . math Err , vars . account Borrows New ) sub U Int ( vars . account Borrows , vars . repay Amount ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . total Borrows New ) sub U Int ( total Borrows , vars . repay Amount ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW NEW TOTAL BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We call do Transfer In for the payer and the repay Amount Note : The a Token must handle variations between ERC 20 and ETH underlying . On success , the a Token holds an additional repay Amount of cash . If do Transfer In fails despite the fact we checked pre conditions , we revert because we can ' t be sure if side effects occurred . vars . err do Transfer In ( payer , vars . repay Amount ) ; require ( vars . err Error . NO ERROR , " repay borrow transfer in failed " ) ; We write the previously calculated values into storage account Borrows [ borrower ] . principal vars . account Borrows New ; account Borrows [ borrower ] . interest Index borrow Index ; total Borrows vars . total Borrows New ; We emit a Repay Borrow event emit Repay Borrow ( payer , borrower , vars . repay Amount , vars . account Borrows New , vars . total Borrows New ) ; We call the defense hook controller . repay Borrow Verify ( address ( this ) , payer , borrower , vars . repay Amount , vars . borrower Index ) ; return uint ( Error . NO ERROR ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
event Transfer ( address indexed from , address indexed to , uint amount ) ;
function set Admin ( address account , bool allowed ) external { require ( msg . sender governance , " not governance " ) ; require ( account ! address ( 0x0 ) , " account not set " ) ; admins [ account ] allowed ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 value ) returns ( bool success ) { }
function withdraw ( address protocol , address token , uint256 dn Amount , uint256 max N Amount )
function safe Transfer From (
function add Managed Contract ( address addr ) private { managed Contract Addresses . push ( addr ) ; }
function is Valid Signature (
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function is Initialized ( ) internal view returns ( bool ) { return is Initialized ; }
event Keeper Dispute ( address indexed keeper , uint block ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function get ( Address To Uint Map storage map , address key ) internal view returns ( uint256 ) { return uint256 ( get ( map . inner , bytes32 ( uint256 ( key ) ) ) ) ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function is Token Agent ( address agent Address ) external view returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function release Time ( ) public view returns ( uint256 ) { return release Time ; }
function pool Quota ( uint256 pool Id ) external override view returns ( uint256 ) { return pool Map [ pool Id ] . pool Quota ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function pool Address ( uint256 pool Id ) external view returns ( address ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address to , uint256 token Id ) external ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function get Batch Number And Pair Code ( address staker , uint256 deposit Number )
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function release Vested Tokens For ( address owner ) public { Token Vesting ( vesting Of [ owner ] ) . release ( this ) ; }
function lock ( ) external only Migration Manager ;
function to Int256 ( uint256 value ) internal pure returns ( int256 ) { require ( value < 2 255 , " Safe Cast : value doesn ' t fit in an int256 " ) ; return int256 ( value ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function mulu ( int128 x , uint256 y ) internal pure returns ( uint256 ) { if ( y 0 ) return 0 ; require ( x > 0 ) ; uint256 lo ( uint256 ( x ) ( y & 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ) > > 64 ; uint256 hi uint256 ( x ) ( y > > 128 ) ; require ( hi < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; hi < < 64 ; require ( hi < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF lo ) ; return hi + lo ; }
function allowance ( address owner , address spender )
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function deposit ( uint256 amount ) public { require ( is Active , ' vault is not active ' ) ; require ( strategy ! address ( 0 ) , ' strategy is not yet set ' ) ; uint256 pool balance ( ) ; uint256 before token . balance Of ( address ( this ) ) ; token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; uint256 after token . balance Of ( address ( this ) ) ; Additional check for deflationary tokens deposits [ msg . sender ] deposits [ msg . sender ] . add ( amount ) ; total Deposited total Deposited . add ( amount ) ; uint256 shares 0 ; if ( total Supply ( ) 0 ) { if ( tiers [ msg . sender ] > 0 ) { uint256 user Multiplier tiers [ msg . sender ] . add ( tier Base ) ; shares amount . mul ( user Multiplier ) . div ( tier Base ) ; } else { shares amount ; } } else { if ( tiers [ msg . sender ] > 0 ) { uint256 user Multiplier tiers [ msg . sender ] . add ( tier Base ) ; shares ( amount . mul ( user Multiplier ) . div ( tier Base ) . mul ( total Supply ( ) ) ) . div ( pool ) ; } else { shares ( amount . mul ( total Supply ( ) ) ) . div ( pool ) ; } } mint ( msg . sender , shares ) ; deposit Blocks [ msg . sender ] block . number ; emit Deposit ( msg . sender , amount ) ; emit Shares Issued ( msg . sender , shares ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
event Burn ( address indexed burner , uint256 amount ) ;
function burn ( uint256 amount , bytes calldata data ) external ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function add ( uint32 a , uint32 b ) internal pure returns ( uint32 ) { uint32 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function reset Points ( address address ) external only Owner { staked Tokens [ address ] . points 0 ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function init ( Self storage self , address reserve Token , address mining Token , address borrow Token , address growth Token ) public
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function owner ( ) public view returns ( address ) { return owner ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer ( address recipient , uint256 amount )
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function accept Rewards Balance Migration ( address [ ] calldata addrs , uint256 [ ] calldata migrated Guardian Staking Rewards , uint256 [ ] calldata migrated Delegator Staking Rewards , uint256 total Amount ) external ;
function has Game Started ( ) public view returns ( bool ) { return game Started ; }
function set Approval For All ( address operator , bool approved ) external ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Delegated ( address indexed from , address indexed to ) ;
function get Undelegate Lockup Duration ( )
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function fail ( Error err , Failure Info info ) internal returns ( uint ) { emit Failure ( uint ( err ) , uint ( info ) , 0 ) ; return uint ( err ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer From ( address src , address dst , uint256 amount ) external returns ( bool success ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function vest Cmd3Month1Percent Int ( address beneficiary , uint256 tokens Amount Int ) external only Owner { vest Tokens From Now Int ( beneficiary , tokens Amount Int , lock90Days , 0 , unlock100Days ) ; }
function stake ( uint256 amount ) external ;
function get Distribution Token ( ) public view returns ( IERC20 ) { assert ( unlocked Pool . token ( ) locked Pool . token ( ) ) ; return unlocked Pool . token ( ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Delegate Changed (
function balance Of (
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function withdraw Exchange Stake (
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Approval (
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function set (
function change Required Minor ( Wallet Main Lib . Wallet Data storage self ,
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
event New Treasury ( address old Treasury , address new Treasury ) ;
function on ERC1155Received (
function daylimit ( uint limit ) { m daily Limit limit ; m last Day today ( ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function paused ( ) public view returns ( bool ) { return paused ; }
function name ( ) public view returns ( string memory ) { return name ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function allowance (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function withdraw ( ) external { require ( unbondings [ msg . sender ] ! 0 , " Keep3r : : withdraw : unbond first " ) ; require ( unbondings [ msg . sender ] < now , " Keep3r : : withdraw : still unbonding " ) ; require ( ! disputes [ msg . sender ] , " Keep3r : : withdraw : pending disputes " ) ; transfer Tokens ( address ( this ) , msg . sender , partial Unbonding [ msg . sender ] ) ; emit Keeper Unbound ( msg . sender , block . number , block . timestamp , partial Unbonding [ msg . sender ] ) ; partial Unbonding [ msg . sender ] 0 ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function balance Of ( address holder ) external view returns ( uint256 ) ;
function remove Subscriber ( address addr ) external only Functional Manager ;
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Name Hash ( string memory name ) internal pure returns ( bytes32 ) { return keccak256 ( bytes ( name ) ) ; }
event Transfer ( bytes32 indexed node , address owner ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function set ( Map storage map , bytes32 key , bytes32 value ) private returns ( bool ) { uint256 key Index map . indexes [ key ] ; Equivalent to ! contains ( map , key ) map . entries . push ( Map Entry ( { key : key , value : value } ) ) ; map . indexes [ key ] map . entries . length ; return true ; } else { map . entries [ key Index 1 ] . value value ; return false ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller | | msg . sender governance , " Golff : ! governance " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function add Owner ( Wallet Main Lib . Wallet Data storage self ,
event New TTL ( bytes32 indexed node , uint64 ttl ) ;
function greater Than Exp ( Exp memory left , Exp memory right ) pure internal returns ( bool ) { return left . mantissa > right . mantissa ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function actual Balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function lockable Token ( uint256 pool Id ) external view returns ( IERC20 ) ;
function quit (
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
function set Enable Claim Block ( uint256 enable Claim Block ) public only Owner { enable Claim Block enable Claim Block ; }
function sub (
enum Fund Type { ETH , USD , COT }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b < a ) ; return a b ; }
function ( ) external payable { }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function send ( address recipient , uint256 amount , bytes calldata data ) external ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function total Staked For At (
event Keeper Resolved ( address indexed keeper , uint block ) ;
function set Growth Gulp Range ( uint256 growth Min Gulp Amount , uint256 growth Max Gulp Amount ) public override only Owner non Reentrant
function is Approved (
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function balance Of At ( address owner , uint block Number ) public constant returns ( uint ) { if ( ( balances [ owner ] . length 0 ) | | ( balances [ owner ] [ 0 ] . from Block > block Number ) ) { if ( address ( parent Token ) ! 0 ) { return parent Token . balance Of At ( owner , min ( block Number , parent Snap Shot Block ) ) ; } else { return 0 ; } } else { return get Value At ( balances [ owner ] , block Number ) ; } }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function name ( ) public view returns ( string memory ) { return name ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function erc20Wrapper Model ( ) external view returns ( address erc20Wrapper Model Address , uint256 erc20Wrapper Model Version ) ;
function can Call ( Method method , address user ) public view returns ( bool , uint ) { bool subscribed subscriptions Contract . is Subscribed ( user ) ; Compound Subscriptions . Compound Holder memory holder subscriptions Contract . get Holder ( user ) ; if ( ! subscribed ) return ( false , 0 ) ; if ( method Method . Boost & & ! holder . boost Enabled ) return ( false , 0 ) ; uint curr Ratio get Safety Ratio ( user ) ; if ( method Method . Repay ) { return ( curr Ratio < holder . min Ratio , curr Ratio ) ; } else if ( method Method . Boost ) { return ( curr Ratio > holder . max Ratio , curr Ratio ) ; } }
function guardian Execute Transaction (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function unpause ( ) public only Owner { unpause ( ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function initialize (
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function set Pending Gov ( address pending Gov ) external only Gov { address old Pending Gov pending Gov ; pending Gov pending Gov ; emit New Pending Gov ( old Pending Gov , pending Gov ) ; }
function super Register ( address useraddress , address referrer Address , uint usercountry , uint pack , uint rbal , uint gbv , uint [ 7 ] user Earnings , uint [ 2 ] last Buy , uint ltime ) external only Owner { require ( ! is User Exists ( useraddress ) & & is User Exists ( referrer Address ) , " user exists " ) ; require ( check Country ( usercountry ) , " country must be from 0 to 200 " ) ; require ( is Address ( useraddress ) , " cannot be a contract " ) ; total Country Gpv [ usercountry ] + Packs [ pack ] 1000000 ; total Gpv + Packs [ pack ] 1000000 ; user Exist [ useraddress ] true ; User memory user User ( { userid : + + lastuid , teamaddress : referrer Address , countrycode : usercountry , isbonus : true , familyaddress : get Family From Referral ( referrer Address ) , pbalance : 0 , rbalance : rbal , rank : pack , g Height : users [ referrer Address ] . g Height + 1 , status : Status . ACTIVE , gpv : gbv , is Kyc : false , last Buy : [ uint ( last Buy [ 0 ] ) , last Buy [ 1 ] ] , traininglevel : 0 , earnings : [ uint ( user Earnings [ 0 ] ) , user Earnings [ 1 ] , user Earnings [ 2 ] , user Earnings [ 3 ] , user Earnings [ 4 ] , user Earnings [ 5 ] , user Earnings [ 6 ] ] } ) ; users [ useraddress ] user ; useridmap [ lastuid ] useraddress ; if ( last Buy [ 1 ] 0 ) { users [ useraddress ] . status Status . CREATED ; users [ useraddress ] . isbonus false ; } is Country Eli [ useraddress ] false ; globalpool [ useraddress ] false ; millpool [ useraddress ] false ; orgpool [ useraddress ] false ; users [ useraddress ] . trainingpackage [ pack ] . package pack ; users [ useraddress ] . traininglevel 0 ; users [ useraddress ] . trainingpackage [ pack ] . purchased true ; user Lock Time [ useraddress ] ltime ; user Packages [ useraddress ] . push ( pack ) ; countrypool [ usercountry ] . push ( useraddress ) ; user Downlink [ referrer Address ] . push ( useraddress ) ; Emitter emit Registration ( useraddress , users [ useraddress ] . countrycode , users [ useraddress ] . g Height , users [ useraddress ] . teamaddress ) ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function update Swift Resolver Status ( string calldata details , bool registered ) external non Reentrant { require ( IERC20 ( swift Resolver Token ) . balance Of ( msg . sender ) > swift Resolver Token Balance , " ! swift Resolver Token Balance " ) ; swift Resolver Registrations [ msg . sender ] registered ; emit Update Swift Resolver Status ( msg . sender , details , registered ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
function admin ( ) internal view returns ( address adm ) { bytes32 slot ADMIN SLOT ; assembly { adm : sload ( slot ) } }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function adjust Reserve ( Self storage self , uint256 room Amount ) public returns ( bool success )
function is Contract (
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function owner ( ) public view returns ( address ) { return owner ; }
function mul Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint double Scaled Product ) mul U Int ( a . mantissa , b . mantissa ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } ( Math Error err1 , uint double Scaled Product With Half Scale ) add U Int ( half Exp Scale , double Scaled Product ) ; if ( err1 ! Math Error . NO ERROR ) { return ( err1 , Exp ( { mantissa : 0 } ) ) ; } ( Math Error err2 , uint product ) div U Int ( double Scaled Product With Half Scale , exp Scale ) ; assert ( err2 Math Error . NO ERROR ) ; return ( Math Error . NO ERROR , Exp ( { mantissa : product } ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function burn For ( address stake Account , uint256 amount ) internal { require ( amount > 0 , ERROR AMOUNT ZERO ) ; modify Stake Balance ( stake Account , amount , false ) ; modify Total Staked ( amount , false ) ; ERC20Burnable ( address ( staking Token ) ) . burn ( amount ) ; No event emitted since token . burn ( ) call already emits a Transfer event }
event Staking ( address indexed who , uint256 value , uint256 staketime ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function set Collateralization Ratio ( Self storage self , uint256 collateralization Ratio , uint256 collateralization Margin ) public
function total Staked ( ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function normalized Balance ( ) external returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value )
function enabled Modules ( ) external view returns ( address [ ] memory modules ) ;
function calculate Fee ( uint256 amount , uint16 basis Points )
function owner ( ) public view returns ( address ) { return owner ; }
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function proposed Latest Round Data ( )
function owner ( ) public view returns ( address ) { return owner ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; When minting tokens require ( total Supply ( ) . add ( amount ) < cap , " ERC20Capped : cap exceeded " ) ; } }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function TX DATA AVAILABILITY SIZE ( ) internal pure returns ( uint32 ) { return 68 ; }
function set ( Map storage map , bytes32 key , bytes32 value ) private returns ( bool ) { uint256 key Index map . indexes [ key ] ; Equivalent to ! contains ( map , key ) map . entries . push ( Map Entry ( { key : key , value : value } ) ) ; map . indexes [ key ] map . entries . length ; return true ; } else { map . entries [ key Index 1 ] . value value ; return false ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function withdrawal Allowed ( address ) public view override returns ( bool ) { return state ( ) State . Refunding ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function set Allocator ( address addr ) external only Owner { allocator addr ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Approval ( address indexed owner , address indexed spender , uint amount ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
function stake Remove ( Stake Store [ ] storage stake List Ref , uint256 stake Index )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function disable Initial Stage ( ) public
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function total Supply At ( uint256 snapshot Id ) public view returns ( uint256 ) { ( bool snapshotted , uint256 value ) value At ( snapshot Id , total Supply Snapshots ) ; return snapshotted ? value : total Supply ( ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function to128x128 ( int128 x ) internal pure returns ( int256 ) { return int256 ( x ) < < 64 ; }
function total Supply ( ) external view returns ( uint256 ) ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function withdraw Contributions ( address to ) public only Charity Owner { Snowflake Interface snowfl Snowflake Interface ( snowflake Address ) ; Hydro Interface hydro Hydro Interface ( snowfl . hydro Token Address ( ) ) ; withdraw Hydro Balance To ( to , hydro . balance Of ( address ( this ) ) ) ; current Balance current Balance . sub ( hydro . balance Of ( address ( this ) ) ) ; emit creator Paid ( to ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function set Storage Pending Interest Withdrawal (
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " add : + " ) ; return c ; }
event Deprecate ( address new Address ) ;
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function validate Asset Registration (
function withdraw ( uint256 shares ) public { uint256 r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after token . balance Of ( address ( this ) ) ; uint256 diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function get Answer ( uint256 round Id )
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function div U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b 0 ) { return ( Math Error . DIVISION BY ZERO , 0 ) ; } return ( Math Error . NO ERROR , a b ) ; }
function claim Token Reserve ( address parter , uint256 lock Id , uint8 batch ) public returns ( bool ) { require ( batch 0 | | batch 1 ) ; require ( allocations [ parter ] [ lock Id ] [ batch ] ! 0 & & time Locks [ parter ] [ lock Id ] [ batch ] ! 0 ) ; require ( block . timestamp > time Locks [ parter ] [ lock Id ] [ batch ] ) ; uint256 amount allocations [ parter ] [ lock Id ] [ batch ] ; require ( token . transfer ( msg . sender , amount ) ) ; allocations [ parter ] [ lock Id ] [ batch ] 0 ; time Locks [ parter ] [ lock Id ] [ batch ] 0 ; Distributed ( lock Id , batch , amount ) ; return true ; }
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " add : + " ) ; return c ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function allowance ( address owner , address spender ) public view returns ( uint256 remaining ) { return allowed [ owner ] [ spender ] ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0x0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer (
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function init ( Self storage self , address reserve Token , address underlying Token , address mining Token ) public
function sqrt ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; return int128 ( sqrtu ( uint256 ( x ) < < 64 ) ) ; }
function liquidate Borrow ( address borrower , uint repay Amount , A Token a Token Collateral ) external returns ( uint ) { return liquidate Borrow Internal ( borrower , repay Amount , a Token Collateral ) ; }
function before Token Transfer (
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function get Total Locked Delegation For Service Provider ( address sp )
function call Any (
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function update Available Funds ( )
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function update User Event Permission ( address address To Update , bool flag , uint256 event Id ) external only Owner returns ( bool ) { if ( event Id 0 ) { is User Buy Disallowed [ address To Update ] flag ; } if ( event Id 1 ) { is User Sell Disallowed [ address To Update ] flag ; } if ( event Id 2 ) { is User Withdraw Disallowed [ address To Update ] flag ; } if ( event Id 3 ) { is User Sell Disallowed [ address To Update ] flag ; is User Buy Disallowed [ address To Update ] flag ; is User Withdraw Disallowed [ address To Update ] flag ; } return true ; }
function get Random Burned Amount ( uint256 amount ) private returns ( uint256 ) { uint256 burnrate rand Modulus ( uint ( 90 ) , seed2 ) ; return amount . div ( burnrate . add ( 10 ) ) ; }
function burn ( uint256 amount ) public override virtual { super . burn ( amount ) ; move Delegates ( delegates [ msg Sender ( ) ] , address ( 0 ) , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function set Max Delegators Staking Rewards Percent Mille ( uint32 max Delegators Staking Rewards Percent Mille ) public override only Functional Manager { require ( max Delegators Staking Rewards Percent Mille < PERCENT MILLIE BASE , " max Delegators Staking Rewards Percent Mille must not be larger than 100000 " ) ; settings . max Delegators Staking Rewards Percent Mille max Delegators Staking Rewards Percent Mille ; emit Max Delegators Staking Rewards Changed ( max Delegators Staking Rewards Percent Mille ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function deposit ( uint amount ) public returns ( bool ) { deposit ( ) ; IERC20 ( RESERVE ) . transfer From ( msg . sender , address ( this ) , amount ) ; uint shares 0 ; if ( reserves ( ) 0 ) { shares amount ; } else { shares amount . mul ( total Supply ) . div ( reserves ( ) ) ; } mint ( msg . sender , shares ) ; emit Deposited ( msg . sender , shares , amount ) ; return true ; }
function total Supply ( ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function grey List ( address target ) external view returns ( bool ) ;
function burn ( uint256 token Id ) external { require ( minters [ msg . sender ] , " minter invalid " ) ; require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " caller is not owner nor approved " ) ; burn ( token Id ) ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( value < balances [ msg . sender ] ) ; require ( to ! address ( 0 ) ) ; uint256 tokens To Burn 0 ; uint256 tokens To Transfer value . sub ( tokens To Burn ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( tokens To Transfer ) ; total Supply total Supply . sub ( tokens To Burn ) ; emit Transfer ( msg . sender , to , tokens To Transfer ) ; emit Transfer ( msg . sender , address ( 0 ) , tokens To Burn ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function change Governor ( address new Governor ) internal { require ( new Governor ! address ( 0 ) , " New Governor is address ( 0 ) " ) ; emit Governorship Transferred ( governor ( ) , new Governor ) ; set Governor ( new Governor ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function approve ( address spender , uint256 value ) internal returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function to Payable ( address account )
function name ( ) public view returns ( string memory ) { return name ; }
4 % of WSE
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function worked ( address keeper ) external { work Receipt ( keeper , KPRH . get Quote Limit ( gas Used . sub ( gasleft ( ) ) ) ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint64 c a b ; return c ; }
function process Flash Loan ( address token , uint256 amount , uint256 fee , bytes memory params ) internal virtual returns ( bool success ) ;
function last Time Reward Applicable ( ) external view returns ( uint256 ) ;
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event Buy Option ( address indexed from , address indexed settlement , uint256 option Price , uint256 settlement Amount , uint256 option Amount ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set Burn Rate ( uint256 rate ) public only Owner { burn Rate rate ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function safe Recycle Transfer ( address to , uint256 amount ) internal { uint256 Recycle Bal recycle . balance Of ( address ( this ) ) ; if ( amount > Recycle Bal ) { recycle . transfer Without Fee ( to , Recycle Bal ) ; } else { recycle . transfer Without Fee ( to , amount ) ; } }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transact (
function liquidate ( uint256 id ) external only Operator non Reentrant { remove Share ( id ) ; lp Token . transfer ( address ( liq Strat ) , lp Token . balance Of ( address ( this ) ) ) ; liq Strat . execute ( address ( 0 ) , 0 , abi . encode ( f Token , 0 ) ) ; uint256 wad address ( this ) . balance ; Safe Token . safe Transfer ETH ( msg . sender , wad ) ; emit Liquidate ( id , wad ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function set Token Price ( uint256 new Price ) external only Owner { token Price new Price ; }
function owner ( ) public view returns ( address ) { return owner ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function set Reserve ( uint256 reserved Percent ) public only Owner { reserved Percent reserved Percent ; update Holy Per Block ( ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function total Staked For ( address addr ) public view returns ( uint256 ) { return total Staking Shares > 0 ? total Staked ( ) . mul ( user Totals [ addr ] . staking Shares ) . div ( total Staking Shares ) : 0 ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function name ( ) public view returns ( string memory ) { return name ; }
function update Pool ( uint256 pid ) public pool Exist ( pid ) { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zoo Reward multiplier . mul ( zoo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; zoo . mint ( address ( this ) , zoo Reward ) ; pool . acc Zoo Per Share pool . acc Zoo Per Share . add ( zoo Reward . mul ( factor ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function total Supply ( ) external view returns ( uint256 ) ;
function has Module ( address module ) external view returns ( bool ) ;
function create Pool ( address token0 , uint256 amount0 , address token1 , uint256 amount1 ) internal returns ( address pool )
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function before Token Transfer ( address from , address to , uint amount ) internal virtual { }
function set Reward Token ( address reward Token ) public { require ( msg . sender governance , " not governance " ) ; require ( reward Token ! address ( 0x0 ) , " reward token not set " ) ; reward Token reward Token ; }
function whitelist Addresses ( address [ ] memory addresses , bool [ ] memory is Staking ) public only Owner { require ( status Contract Status . INIT ) ; for ( uint256 i 0 ; i < addresses . length ; i + + ) { if ( ! whitelist [ addresses [ i ] ] . is Whitelisted ) { whitelist Count whitelist Count . add ( 1 ) ; } whitelist [ addresses [ i ] ] . is Whitelisted true ; whitelist [ addresses [ i ] ] . is Staking is Staking [ i ] ; emit Whitelist ( addresses [ i ] , is Staking [ i ] ) ; } }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function supports Interface ( bytes4 interface Id ) public view virtual override ( Access Control Enumerable , ERC1155 ) returns ( bool ) { return super . supports Interface ( interface Id ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function on ERC721Received ( address operator , address from , uint256 token Id , bytes calldata data )
event charity Disabled ( uint time Disabled ) ;
function before Token Transfer (
event Upgraded ( address indexed implementation ) ;
function notify Secondary Tokens ( uint256 number ) external { IERC20 ( ausc ) . safe Transfer From ( msg . sender , address ( this ) , number ) ; if ( last Mint . add ( 1 days ) < block . timestamp & & last Mint ! 0 ) { uint256 daily Mint 1000 1e18 ; IERC20Mintable ( share Token ) . mint ( pool , daily Mint ) ; Auric Rewards ( pool ) . notify Reward Amount ( daily Mint ) ; last Mint block . timestamp ; } }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function total Supply ( ) public view returns ( uint ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . total Supply ( ) ; } else { return total Supply ; } }
function total Reserve ( Self storage self ) public view returns ( uint256 total Reserve )
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c a b ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer From ( address sender , address recipient , uint256 amount ) govern ( sender ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; emit Approval ( sender , recipient , amount ) ; return true ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( ( a % 2 ) + ( b % 2 ) ) 2 ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function balance Of ( address owner ) public view returns ( uint256 ) { require ( owner ! address ( 0 ) , " ERC721 : balance query for the zero address " ) ; return owned Tokens Count [ owner ] . current ( ) ; }
modifier current Round Initialized ( ) { require ( rounds Manager ( ) . current Round Initialized ( ) , " current round is not initialized " ) ; ; }
modifier only Profit Depositor ( ) { require ( msg . sender profit Depositor , " Restricted to profit depositor " ) ; ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
event Minter Changed ( address minter , address new Minter ) ;
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function set Price Per Alpaca ( uint256 price ) public only Owner { price Per Alpaca price ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function to Int128 ( int256 value ) internal pure returns ( int128 ) { require ( value > 2 127 & & value < 2 127 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return int128 ( value ) ; }
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
function join ( slice memory self , slice [ ] memory parts ) internal pure returns ( string memory ) { if ( parts . length 0 ) return " " ; uint length self . len ( parts . length 1 ) ; for ( uint i 0 ; i < parts . length ; i + + ) length + parts [ i ] . len ; string memory ret new string ( length ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } for ( uint i 0 ; i < parts . length ; i + + ) { memcpy ( retptr , parts [ i ] . ptr , parts [ i ] . len ) ; retptr + parts [ i ] . len ; if ( i < parts . length 1 ) { memcpy ( retptr , self . ptr , self . len ) ; retptr + self . len ; } } return ret ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function total Supply ( ) external view returns ( uint256 ) ;
function set Oracle Payment (
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function is Token Supported ( address token )
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function approve ( address to , uint256 token Id ) external ;
function delete Address ( bytes32 key )
function char ( uint8 b ) pure private returns ( byte c ) { if ( b < 10 ) { return byte ( b + 0x30 ) ; } else { return byte ( b + 0x37 ) ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function get Staking Token ( ) public view returns ( IERC20 ) { return staking Pool . token ( ) ; }
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function safe Transfer From ( address from , address to , uint256 token Id ) external ;
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( uint256 ( self ) & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( uint256 ( self ) & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( uint256 ( self ) & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function mint ( address to ) external lock returns ( uint liquidity ) { gas savings uint balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 balance0 . sub ( reserve0 ) ; uint amount1 balance1 . sub ( reserve1 ) ; bool fee On mint Fee ( reserve0 , reserve1 ) ; gas savings , must be defined here since total Supply can update in mint Fee if ( total Supply 0 ) { liquidity Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens } else { liquidity Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Litchiswap : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; reserve0 and reserve1 are up to date emit Mint ( msg . sender , amount0 , amount1 ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; if ( returndata . length > 0 ) { require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function burn From ( address account , uint256 amount ) public virtual { uint256 decreased Allowance allowance ( account , msg Sender ( ) ) . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ; approve ( account , msg Sender ( ) , decreased Allowance ) ; burn ( account , amount ) ; }
function asset To Usd ( address asset , uint amount ) public virtual view returns ( uint ) ;
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function ERC20 init ( string memory name , string memory symbol ) internal initializer { Context init unchained ( ) ; ERC20 init unchained ( name , symbol ) ; }
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( uint256 ( self ) & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( uint256 ( self ) & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( uint256 ( self ) & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function balance Of ( address account ) public view override returns ( uint ) { return balances [ account ] ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function transfer ( address dst , uint amount ) public returns ( bool ) { transfer Tokens ( msg . sender , dst , amount ) ; return true ; }
function get ( Uint To Address Map storage map , uint256 key ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) ) ) ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function get Generic Action ID (
function get Max Debt ( uint cdp Id , bytes32 ilk ) public virtual view returns ( uint ) { uint price get Price ( ilk ) ; ( , uint mat ) spotter . ilks ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( sub ( div ( mul ( collateral , price ) , mat ) , debt ) , 10 ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function safe Transfer From ( address from , address to , uint256 token Id , bytes memory data ) public virtual override { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; safe Transfer ( from , to , token Id , data ) ; }
function encode ( uint112 x ) internal pure returns ( uq112x112 memory ) { return uq112x112 ( uint224 ( x ) < < RESOLUTION ) ; }
function scale Integer ( uint256 x )
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function token At ( uint256 index ) public view override returns ( address token )
function increase Allowance ( address spender , uint256 added Value )
function global Constraints Count ( address avatar )
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ISA " ) ; require ( recipient ! address ( 0 ) , " IRA " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " TIF " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function div Scalar ( Exp memory a , uint scalar ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint descaled Mantissa ) div U Int ( a . mantissa , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return ( Math Error . NO ERROR , Exp ( { mantissa : descaled Mantissa } ) ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function add KPR Credit ( address job , uint amount ) external { require ( msg . sender governance , " add KPR Credit : ! gov " ) ; require ( jobs [ job ] , " add KPR Credit : ! job " ) ; credits [ job ] [ address ( this ) ] credits [ job ] [ address ( this ) ] . add ( amount ) ; mint ( address ( this ) , amount ) ; emit Add Credit ( address ( this ) , job , msg . sender , block . number , amount ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function div Scalar ( Exp memory a , uint scalar ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint descaled Mantissa ) div U Int ( a . mantissa , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return ( Math Error . NO ERROR , Exp ( { mantissa : descaled Mantissa } ) ) ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function start Sale ( ) public { require ( msg . sender owner & & start Date 0 ) ; start Date now ; }
function finalize ( ) public only Owner { require ( ! finalized , " Finalizable Crowdsale : already finalized " ) ; require ( has Closed ( ) , " Finalizable Crowdsale : not closed " ) ; finalized true ; finalization ( ) ; emit Crowdsale Finalized ( ) ; }
function is Farm Active ( ) external view returns ( bool ) ;
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function legacy Withdrawable Interest Amount (
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount 0 ; user . reward Debt [ pool . debt Index Key ] 0 ; }
function add Reward ( address protocol , address token , uint256 epoch , uint256 amount ) internal { Protocol Rewards storage r rewards [ protocol ] ; Reward Info storage ri r . reward Info [ token ] ; uint256 epochs Length ri . epochs . length ; require ( epochs Length > 0 , " Reward Vesting : protocol or token not registered " ) ; creating a new epoch if ( epoch epochs Length ) { uint256 epoch End ri . epochs [ epochs Length 1 ] . end . add ( default Epoch Length ) ; This generally should not happen , but just in case we generate only one epoch since previous end ri . epochs . push ( Epoch ( { end : epoch End , amount : amount } ) ) ; } else { require ( epochs Length > epoch , " Reward Vesting : epoch is too high " ) ; Epoch storage ep ri . epochs [ epoch ] ; require ( ep . end > block . timestamp , " Reward Vesting : epoch already finished " ) ; ep . amount ep . amount . add ( amount ) ; } emit Epoch Reward Added ( protocol , token , epoch , amount ) ; IERC20 ( token ) . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function initialize ( address governor ) virtual public initializer { governor governor ; emit Governorship Transferred ( address ( 0 ) , governor ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function remove Liquidity From Job ( address liquidity , address job ) external { require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] ! 0 , " remove Job : unbond " ) ; require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] < now , " remove Job : unbonding " ) ; uint256 amount liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] ; liquidity Provided [ msg . sender ] [ liquidity ] [ job ] liquidity Provided [ msg . sender ] [ liquidity ] [ job ] . sub ( amount ) ; liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] 0 ; IERC20 ( liquidity ) . safe Transfer ( msg . sender , amount ) ; emit Remove Job ( job , liquidity , msg . sender , block . number , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function buy ( address referred By ) public payable returns ( uint256 )
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function update Lock Name (
function delete Uint ( bytes32 key ) external only Current Owner { delete u Int Storage [ key ] ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function total Supply ( )
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function freeze To ( address to , uint amount ) public only Owner { require ( to ! address ( 0 ) , " freezing a zero address " ) ; require ( amount < balances [ msg . sender ] , " amount exceeds balance " ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( amount ) ; balances [ to ] balances [ to ] . add ( amount ) ; frozen Balance [ to ] frozen Balance [ to ] . add ( amount ) ; emit Transfer ( msg . sender , to , amount ) ; emit Tokens Frozen ( to , amount ) ; }
function function Delegate Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { require ( is Contract ( target ) , " Address : delegate call to non contract " ) ; ( bool success , bytes memory returndata ) target . delegatecall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function swap Uniswap (
function assert In Catastrophic Failure ( )
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function last Release TVL ( ) public view returns ( uint256 ) { return last Release TVL ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function remove ( Role storage role , address account ) internal { require ( has ( role , account ) , " Roles : account does not have role " ) ; role . bearer [ account ] false ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function to128x128 ( int128 x ) internal pure returns ( int256 ) { return int256 ( x ) < < 64 ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function div ( uq112x112 memory self , uint112 x ) internal pure returns ( uq112x112 memory ) { require ( x ! 0 , ' Fixed Point : DIV BY ZERO ' ) ; return uq112x112 ( self . x uint224 ( x ) ) ; }
function validate Token Info ( Pb Entity . Token Info memory token )
function is Governance Address ( ) external pure returns ( bool ) { return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
event Circuit Registered (
event Tier Deleted ( uint256 index ) ;
modifier only Minter ( ) { require ( minter msg Sender ( ) , " Mintable : caller is not the minter " ) ; ; }
function check Balance ( address asset )
function connector ID ( ) public pure returns ( uint type , uint id ) { ( type , id ) ( 1 , 50 ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function supply Rate Per Block ( ) external view returns ( uint ) { We calculate the supply rate : underlying total Supply  exchange Rate borrows Per total Borrows  underlying supply Rate borrow Rate  ( 1 reserve Factor )  borrows Per uint exchange Rate Mantissa exchange Rate Stored ( ) ; ( uint e0 , uint borrow Rate Mantissa ) interest Rate Model . get Borrow Rate ( get Cash Prior ( ) , total Borrows , total Reserves ) ; semi opaque ( Math Error e1 , Exp memory underlying ) mul Scalar ( Exp ( { mantissa : exchange Rate Mantissa } ) , total Supply ) ; require ( e1 Math Error . NO ERROR , " supply Rate Per Block : calculating underlying failed " ) ; ( Math Error e2 , Exp memory borrows Per ) div Scalar By Exp ( total Borrows , underlying ) ; require ( e2 Math Error . NO ERROR , " supply Rate Per Block : calculating borrows Per failed " ) ; ( Math Error e3 , Exp memory one Minus Reserve Factor ) sub Exp ( Exp ( { mantissa : mantissa One } ) , Exp ( { mantissa : reserve Factor Mantissa } ) ) ; require ( e3 Math Error . NO ERROR , " supply Rate Per Block : calculating one Minus Reserve Factor failed " ) ; ( Math Error e4 , Exp memory supply Rate ) mul Exp3 ( Exp ( { mantissa : borrow Rate Mantissa } ) , one Minus Reserve Factor , borrows Per ) ; require ( e4 Math Error . NO ERROR , " supply Rate Per Block : calculating supply Rate failed " ) ; return supply Rate . mantissa ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function withdraw All ( ) public virtual { withdraw ( balance Of ( msg . sender ) ) ; }
function approve ( address owner , address spender , uint256 value ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] value ; emit Approval ( owner , spender , value ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function append ( uint256 alloc Point , IERC20 lp Token , bool with Update ) external only Owner pool Not Exist ( lp Token ) { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Zoo Per Share : 0 } ) ) ; }
function freeze To ( address to , uint amount , uint64 until ) public { require ( to ! address ( 0 ) ) ; require ( amount < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( amount ) ; bytes32 current Key to Key ( to , until ) ; freezings [ current Key ] freezings [ current Key ] . add ( amount ) ; freezing Balance [ to ] freezing Balance [ to ] . add ( amount ) ; freeze ( to , until ) ; emit Transfer ( msg . sender , to , amount ) ; emit Freezed ( to , until , amount ) ; }
function pending BTF ( uint256 pid , address user ) external view returns ( uint256 ) { return earned ( pid , user ) ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function delegate ( address implementation ) internal { assembly { calldatacopy ( 0 , 0 , calldatasize ( ) ) let result : delegatecall ( gas ( ) , implementation , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) switch result case 0 { revert ( 0 , returndatasize ( ) ) } default { return ( 0 , returndatasize ( ) ) } } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mod (
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function bond ( address bonding , uint amount ) external non Reentrant { require ( ! blacklist [ msg . sender ] , " bond : blacklisted " ) ; bondings [ msg . sender ] [ bonding ] now . add ( BOND ) ; if ( bonding address ( this ) ) { transfer Tokens ( msg . sender , address ( this ) , amount ) ; } else { uint before IERC20 ( bonding ) . balance Of ( address ( this ) ) ; IERC20 ( bonding ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; amount IERC20 ( bonding ) . balance Of ( address ( this ) ) . sub ( before ) ; } pendingbonds [ msg . sender ] [ bonding ] pendingbonds [ msg . sender ] [ bonding ] . add ( amount ) ; emit Keeper Bonding ( msg . sender , block . number , bondings [ msg . sender ] [ bonding ] , amount ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; uint256 gon Amount amount . mul ( gon Per Unit ) ; gon Balances [ account ] gon Balances [ account ] . sub ( gon Amount , " ERC20 : burn amount exceeds balance " ) ; total Gon Supply total Gon Supply . sub ( gon Amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
event Global Proxy Set ( address indexed proxy , bool is Trusted ) ;
function owner Of ( uint256 token Id ) external view returns ( address owner ) ;
event Unpaused ( address account ) ;
function mint ( address to , uint256 amount ) public only Owner { uint256 total Supply total Supply ( ) ; if ( total Supply . add ( amount ) > MAX SUPPLY ) { amount MAX SUPPLY . sub ( total Supply ) ; } require ( total Supply . add ( amount ) < MAX SUPPLY ) ; mint ( to , amount ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function set Delegate Manager Address ( address address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; delegate Manager Address address ; emit Delegate Manager Address Updated ( address ) ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender )
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; }
function name ( ) public view returns ( string memory ) { return name ; }
function init ( uint256 dai In )
function cap ( ) public view returns ( uint256 ) { return cap ; }
function extend Subscription ( uint256 vc Id , uint256 amount , string calldata tier , uint256 rate , address payer ) external ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function get Borrow Rate ( uint cash , uint borrows , uint reserves ) external view returns ( uint , uint ) ;
function remove Liquidity (
function balance Of ( address account ) external view returns ( uint256 ) ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function is Approved Or Owner ( address spender , uint256 token Id ) internal view returns ( bool ) { require ( exists ( token Id ) , " ERC721 : operator query for nonexistent token " ) ; address owner owner Of ( token Id ) ; return ( spender owner | | get Approved ( token Id ) spender | | is Approved For All ( owner , spender ) ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; before Token Transfer ( address ( 0 ) , to , token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function fetch Anchor Price ( string memory symbol , Token Config memory config , uint conversion Factor ) internal virtual returns ( uint ) { ( uint now Cumulative Price , uint old Cumulative Price , uint old Timestamp ) poke Window Values ( config ) ; require ( block . timestamp > old Timestamp , " now must come after before " ) ; uint time Elapsed block . timestamp old Timestamp ; Fixed Point . uq112x112 memory price Average Fixed Point . uq112x112 ( uint224 ( ( now Cumulative Price old Cumulative Price ) time Elapsed ) ) ; uint raw Uniswap Price Mantissa price Average . decode112with18 ( ) ; uint unscaled Price Mantissa mul ( raw Uniswap Price Mantissa , conversion Factor ) ; uint anchor Price ; if ( config . is Uniswap Reversed ) { anchor Price unscaled Price Mantissa config . base Unit ; } else { anchor Price mul ( unscaled Price Mantissa , config . base Unit ) eth Base Unit exp Scale ; } emit Anchor Price Updated ( symbol , anchor Price , old Timestamp , block . timestamp ) ; return anchor Price ; }
function owner ( ) public view returns ( address ) { return owner ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b < a ) ; return a b ; }
function get Delegator Stake For Service Provider ( address delegator , address service Provider )
function interface Hash ( string calldata interface Name ) external pure returns ( bytes32 ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function sell ( uint256 amount Of Tokens )
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee amount In . mul ( 997 ) ; uint numerator amount In With Fee . mul ( reserve Out ) ; uint denominator reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out numerator denominator ; }
function fill Fee Buckets ( uint256 amount , uint256 monthly Rate , uint256 from Timestamp ) external override only When Active { uint256 bucket bucket Time ( from Timestamp ) ; require ( bucket > bucket Time ( block . timestamp ) , " Fee Wallet : : cannot fill bucket from the past " ) ; uint256 amount amount ; uint256 bucket Amount Math . min ( amount , monthly Rate . mul ( BUCKET TIME PERIOD . sub ( from Timestamp % BUCKET TIME PERIOD ) ) . div ( BUCKET TIME PERIOD ) ) ; fill Fee Bucket ( bucket , bucket Amount ) ; amount amount . sub ( bucket Amount ) ; while ( amount > 0 ) { bucket bucket . add ( BUCKET TIME PERIOD ) ; bucket Amount Math . min ( monthly Rate , amount ) ; fill Fee Bucket ( bucket , bucket Amount ) ; amount amount . sub ( bucket Amount ) ; } require ( token . transfer From ( msg . sender , address ( this ) , amount ) , " failed to transfer fees into fee wallet " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function reset Approve ( address token , address spender ) external only Owner { IERC20 ( token ) . approve ( spender , 0 ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function change Token Price ( Crowdsale Storage storage self ,
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg . sender , allowances [ account ] [ msg . sender ] . sub ( amount ) ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function multiply Decimal Round (
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
event Upgraded ( address indexed implementation ) ;
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function deposit ( uint256 pid , uint256 amount ) external only Address pool Exist ( pid ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Zoo Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; } user . reward Debt user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function change Owner ( Token Storage storage self , address new Owner ) returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function my Pool Information ( )
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal override virtual { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; }
function bond ( uint amount ) external { require ( pendingbonds [ msg . sender ] 0 , " Keep3r : : bond : current pending bond " ) ; require ( ! blacklist [ msg . sender ] , " Keep3r : : bond : keeper is blacklisted " ) ; bondings [ msg . sender ] now . add ( BOND ) ; pendingbonds [ msg . sender ] amount ; transfer Tokens ( msg . sender , address ( this ) , amount ) ; emit Keeper Bonding ( msg . sender , block . number , bondings [ msg . sender ] , amount ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function burn ( address from , uint256 amount ) public { burn ( from , amount ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; if ( sender ! owner ( ) & & recipient ! owner ( ) & & ( sender UNI Weth Pool Address | | recipient UNI Weth Pool Address ) ) { require ( swap Enable Flag , ' You can not swap until swap enalbed ' ) ; require ( amount < max Transaction Amount , " ERC20 : transfer amount exceeds limit " ) ; } if ( max Fee > 0 ) require ( store Address ! address ( 0 ) , " ERC20 : store address is not set yet . " ) ; before Token Transfer ( sender , recipient , amount ) ; uint256 tax Amount ; uint256 transf Amount ; if ( recipient UNI Weth Pool Address ) { tax Amount amount . mul ( max Fee ) . div ( 100 ) ; transf Amount amount ; } else { tax Amount amount . mul ( tax Fee ) . div ( 100 ) ; transf Amount amount . sub ( tax Amount ) ; } balances [ sender ] balances [ sender ] . sub ( transf Amount . add ( tax Amount ) , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( transf Amount ) ; emit Transfer ( sender , recipient , transf Amount ) ; if ( tax Amount > 0 ) { balances [ store Address ] balances [ store Address ] . add ( tax Amount ) ; emit Transfer ( sender , store Address , tax Amount ) ; } }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function inner Mint ( address owner , uint amount ) internal { total Supply total Supply . add ( amount ) ; balances [ owner ] balances [ owner ] . add ( amount ) ; emit Transfer ( address ( 0 ) , owner , amount ) ; }
function set Annual Staking Rewards Rate ( uint32 annual Rate In Percent Mille , uint96 annual Cap ) external only Functional Manager ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function add Reserves ( uint add Amount ) external returns ( uint ) { bytes memory data delegate To Implementation ( abi . encode With Signature ( " add Reserves ( uint256 ) " , add Amount ) ) ; return abi . decode ( data , ( uint ) ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function ERC20 init ( string memory name , string memory symbol ) internal initializer { Context init unchained ( ) ; ERC20 init unchained ( name , symbol ) ; }
function token By Index ( uint256 index ) external view returns ( uint256 ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function burn From ( address from , uint256 value ) public { if ( is Minter ( msg Sender ( ) ) ) { burn ( from , value ) ; } else { super . burn From ( from , value ) ; } }
function transfer ( address to , uint256 value )
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
event Minter Changed ( address minter , address new Minter ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
event Transaction Failed (
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount 0 ; user . reward Debt 0 ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; } }
function salvage ( address token Address , uint256 amount ) public { require ( msg . sender strategist | | msg . sender governance , " not authorized " ) ; require ( token Address ! ac Btc , " cannot salvage " ) ; require ( amount > 0 , " zero amount " ) ; IERC20 ( token Address ) . safe Transfer ( governance , amount ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function balance Of ( address own )
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function get Service Endpoint Info ( bytes32 service Type , uint256 service Id )
function withdrawall ( )
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function change Admin ( address new Admin ) external if Admin { require ( new Admin ! address ( 0 ) , " Cannot change the admin of a proxy to the zero address " ) ; emit Admin Changed ( admin ( ) , new Admin ) ; set Admin ( new Admin ) ; }
function withdraw Protocol Fees (
function mod ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b ! 0 , error Message ) ; return a % b ; }
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function total Supply ( ) public view returns ( uint256 ) { return all Tokens . length ; }
function get Guardian Delegators Staking Rewards Percent Mille ( address guardian ) external view returns ( uint256 delegator Rewards Ratio Percent Mille ) ;
function to Eth Signed Message Hash ( bytes32 hash ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encode Packed ( " \ x19Ethereum Signed Message : \ n32 " , hash ) ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Yfin Per Share : 0 } ) ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function get Manager ( address account ) external view returns ( address ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function total Supply ( ) external view returns ( uint256 ) ;
function get Max5 ( uint256 [ 51 ] memory data ) internal pure returns ( uint256 [ 5 ] memory max , uint256 [ 5 ] memory max Index ) { uint256 min5 data [ 1 ] ; uint256 min I 0 ; for ( uint256 j 0 ; j < 5 ; j + + ) { max [ 0 ] data [ 1 ] max Index [ 0 ] 1 if ( max [ j ] < min5 ) { min5 max [ j ] ; min I j ; } } for ( uint256 i 6 ; i < data . length ; i + + ) { if ( data [ i ] > min5 ) { max [ min I ] data [ i ] ; max Index [ min I ] i ; min5 data [ i ] ; for ( uint256 j 0 ; j < 5 ; j + + ) { if ( max [ j ] < min5 ) { min5 max [ j ] ; min I j ; } } } } }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function set Approval For All ( address operator , bool approved ) public virtual override { require ( operator ! msg Sender ( ) , " ERC721 : approve to caller " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function withdraw Stuck Funds ( address token , uint amount ) public only Owner { if ( token 0x Eeeee Eeee Ee Eee Ee Ee Eee EE Eeeee Eeeeeeee E Ee E ) { payable ( owner ) . transfer ( amount ) ; } else { ERC20 ( token ) . safe Transfer ( owner , amount ) ; } }
function transfer From ( address from , address to , uint value ) public only Payload Size ( 3 32 ) { var allowance allowed [ from ] [ msg . sender ] ; uint fee ( value . mul ( basis Points Rate ) ) . div ( 10000 ) ; if ( fee > maximum Fee ) { fee maximum Fee ; } if ( allowance < MAX UINT ) { allowed [ from ] [ msg . sender ] allowance . sub ( value ) ; } uint send Amount value . sub ( fee ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( send Amount ) ; if ( fee > 0 ) { balances [ owner ] balances [ owner ] . add ( fee ) ; Transfer ( from , owner , fee ) ; } Transfer ( from , to , send Amount ) ; }
function global Info ( )
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; assert ( c > a ) ; return c ; }
function is Market Enabled By Dmm Token Address ( address dmm Token ) external view returns ( bool ) ;
function unpause ( ) public only Owner { unpause ( ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function unlock Tokens ( ) private { uint256 tokens To Unlock 0 ; uint256 locked Tokens total Locked ( ) ; if ( total Locked Shares 0 ) { tokens To Unlock locked Tokens ; } else { uint256 shares To Unlock 0 ; for ( uint256 i 0 ; i < fundings . length ; i + + ) { uint256 shares unlockable ( i ) ; Funding storage funding fundings [ i ] ; if ( shares > 0 ) { funding . unlocked funding . unlocked . add ( shares ) ; funding . last Updated block . timestamp ; shares To Unlock shares To Unlock . add ( shares ) ; } } tokens To Unlock shares To Unlock . mul ( locked Tokens ) . div ( total Locked Shares ) ; total Locked Shares total Locked Shares . sub ( shares To Unlock ) ; } if ( tokens To Unlock > 0 ) { locked Pool . transfer ( address ( unlocked Pool ) , tokens To Unlock ) ; emit Rewards Unlocked ( tokens To Unlock , total Unlocked ( ) ) ; } }
function on ERC1155Batch Received (
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function payback ( address token , uint amt , uint get Id , uint set Id ) external payable { uint amt get Uint ( get Id , amt ) ; address Cr Token Insta Cream Mapping ( get Mapping Addr ( ) ) . Cr Token Mapping ( token ) ; Cr Token Interface Cr Token Contract Cr Token Interface ( Cr Token ) ; amt amt uint ( 1 ) ? Cr Token Contract . borrow Balance Current ( address ( this ) ) : amt ; if ( token get Address ETH ( ) ) { require ( address ( this ) . balance > amt , " not enough eth " ) ; Cr ETH Interface ( Cr Token ) . repay Borrow . value ( amt ) ( ) ; } else { Token Interface token Contract Token Interface ( token ) ; require ( token Contract . balance Of ( address ( this ) ) > amt , " not enough token " ) ; token Contract . approve ( Cr Token , amt ) ; require ( Cr Token Contract . repay Borrow ( amt ) 0 , " repay failed . " ) ; } set Uint ( set Id , amt ) ; emit Log Payback ( token , Cr Token , amt , get Id , set Id ) ; bytes32 event Code keccak256 ( " Log Payback ( address , address , uint256 , uint256 , uint256 ) " ) ; bytes memory event Param abi . encode ( token , Cr Token , amt , get Id , set Id ) ; ( uint type , uint id ) connector ID ( ) ; Event Interface ( get Event Addr ( ) ) . emit Event ( type , id , event Code , event Param ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function append Int ( buffer memory buf , uint data , uint len ) internal pure returns ( buffer memory buffer ) { if ( len + buf . buf . length > buf . capacity ) { resize ( buf , max ( buf . capacity , len ) 2 ) ; } uint mask 256 len 1 ; assembly { Memory address of the buffer data Length of existing buffer data Address buffer address + buffer length + sizeof ( buffer length ) + len mstore ( dest , or ( and ( mload ( dest ) , not ( mask ) ) , data ) ) Update buffer length } return buf ; }
function transfer From ( Loihi Storage . Shell storage shell , address sender , address recipient , uint256 amount ) external returns ( bool ) { transfer ( shell , msg . sender , recipient , amount ) ; approve ( shell , sender , msg . sender , sub ( shell . allowances [ sender ] [ msg . sender ] , amount , " Shell insufficient allowance " ) ) ; return true ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function get Vote Info By Proposal And Voter ( uint256 proposal Id , address voter )
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function proxy Delegate Id ( address proxy ) override public view returns ( uint256 ) { return proxy Delegate Ids [ proxy ] ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function set Withdraw Storage ( address addr ) external only Owner { withdraw Storage addr ; }
function set Policy Group ( address addr ) external only Owner { policy Group addr ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function pool Address ( Victim victim , uint256 pool Id ) external view returns ( address ) { ( bool success , bytes memory result ) address ( victim ) . staticcall ( abi . encode With Signature ( " pool Address ( uint256 ) " , pool Id ) ) ; require ( success , " pool Address ( uint256 pool Id ) staticcall failed . " ) ; return abi . decode ( result , ( address ) ) ; }
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
function div ( uint32 a , uint32 b ) internal pure returns ( uint32 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint32 c a b ; return c ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function mint And Freeze ( address to , uint amount , uint64 until ) public only Owner can Mint returns ( bool ) { total Supply total Supply . add ( amount ) ; bytes32 current Key to Key ( to , until ) ; freezings [ current Key ] freezings [ current Key ] . add ( amount ) ; freezing Balance [ to ] freezing Balance [ to ] . add ( amount ) ; freeze ( to , until ) ; emit Mint ( to , amount ) ; emit Freezed ( to , until , amount ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function transfer Ownership ( address new Owner ) public override only Hidden Owner when Not Paused { super . transfer Ownership ( new Owner ) ; }
function total Supply ( ) public override view returns ( uint256 ) { return total Supply ; }
function add Subscriber ( address addr ) external only Functional Manager ;
function kill ( ) public only Owner { selfdestruct ( payable ( owner ) ) ; }
function assert Sender Is Staking Proxy ( )
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function get Epoch D Fee Data Id ( uint256 epoch , uint256 from )
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function update Issuer Claim Topics ( I Claim Issuer trusted Issuer , uint [ ] calldata claim Topics ) external ;
function liquidity Pool Migration Recipient ( ) public view override returns ( address migration Recipient )
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function enter ( uint256 amount ) public { require ( IERC20 ( tellor Address ) . transfer From ( msg . sender , address ( this ) , amount ) ) ; mint ( msg . sender , amount ) ; require ( total Supply ( ) < stake Amount , " CAN NOT ACCEPT MORE THAN STAKE AMOUNT " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function ( ) external payable { fallback ( ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function share Pool Rewards ( Pool Info storage info ) private { share Pool Rewards ( info , 0 , true ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
event Paused ( address account ) ;
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function mul Scalar Truncate Add U Int ( Exp memory a , uint scalar , uint addend ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return add U Int ( truncate ( product ) , addend ) ; }
function transfer Ownership ( address new Owner ) public only Owner { if ( new Owner ! address ( 0 ) ) { owner new Owner ; } }
function salvage ( address recipient , address token , uint256 amount ) external ;
function check Transfer In ( address from , uint amount ) internal view returns ( Error ) ;
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
event New Incentivizer ( address old Incentivizer , address new Incentivizer ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
event Transfer Single ( address indexed operator , address indexed from , address indexed to , uint256 id , uint256 value ) ;
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
event Transfer ( address indexed from , address indexed to , uint256 amount ) ;
function price ( string memory symbol ) external view returns ( uint ) { Token Config memory config get Token Config By Symbol ( symbol ) ; return price Internal ( config ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function is Token Supported ( address token )
function decimals ( ) public pure returns ( uint8 ) { return 18 ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function balance Of ( address account ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function before Token Transfer ( address from , address to , uint256 token Id ) internal virtual { }
function allowance ( address owner , address spender )
function deposit ( uint256 amount ) external ;
function total Supply ( ) external view returns ( uint256 ) ;
function name ( ) public view returns ( string memory ) { return name ; }
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function find ( slice memory self , slice memory needle ) internal pure returns ( slice memory ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; self . ptr ptr ; return self ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function spawn ( address asset , address user , uint oracle Type ) external has Vault Access not Liquidating ( asset , user ) { oracle Type [ asset ] [ user ] oracle Type ; delete liquidation Block [ asset ] [ user ] ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function payback Flash Loan ( address token , uint256 gross Amount ) internal
function calc In Given Out (
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function balance ( IERC20 token ) public view returns ( uint ) { address token address ( token ) ; uint balance IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( curve [ token ] ) { balance balance . mul ( Curve ( token ) . get virtual price ( ) ) . div ( 1e18 ) ; } else if ( yearn [ token ] ) { balance balance . mul ( Yearn ( token ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; } return normalize1e18 ( token , balance ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function burn ( uint256 token Id ) internal virtual { address owner owner Of ( token Id ) ; before Token Transfer ( owner , address ( 0 ) , token Id ) ; approve ( address ( 0 ) , token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } holder Tokens [ owner ] . remove ( token Id ) ; token Owners . remove ( token Id ) ; emit Transfer ( owner , address ( 0 ) , token Id ) ; }
function get Level ( address account ) external view returns ( uint256 ) { return NAP Slevel [ account ] ; }
function token ( ) public view returns ( IERC20 ) { return token ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function validate3Addresses (
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function sub ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b < a , error Message ) ; uint c a b ; return c ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function mod (
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function ceil Div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { Solidity automatically throws for div by 0 but require to emit reason return ( a % b ! 0 ) ? ( a b + 1 ) : ( a b ) ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ; }
function set Property Factory ( address addr ) external only Owner { property Factory addr ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
