function borrow With Erc20 (
function view Proportional Withdraw (
modifier can Transfer (
function get Max Borrow ( address c Borrow Address , address account ) public returns ( uint ) { ( , uint liquidity In Eth , ) Comptroller Interface ( COMPTROLLER ) . get Account Liquidity ( account ) ; address oracle Comptroller Interface ( COMPTROLLER ) . oracle ( ) ; C Token Interface ( c Borrow Address ) . accrue Interest ( ) ; if ( c Borrow Address CETH ADDRESS ) return sub ( liquidity In Eth , ( liquidity In Eth 100 ) ) ; uint eth Price Compound Oracle Interface ( oracle ) . get Underlying Price ( c Borrow Address ) ; uint liquidity In Token wdiv ( liquidity In Eth , eth Price ) ; cut off 1 % due to rounding issues }
function ( ) public payable { emit Funded ( address ( this ) . balance ) ; }
function set Voting Period ( uint256 voting Period ) external { require Is Initialized ( ) ; require ( msg . sender address ( this ) , ERROR ONLY GOVERNANCE ) ; require ( voting Period > 0 , ERROR INVALID VOTING PERIOD ) ; voting Period voting Period ; emit Voting Period Updated ( voting Period ) ; }
function get Confirmations ( uint256 transaction Id )
function concat ( slice self , slice other ) internal view returns ( string ) { var ret new string ( self . len + other . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; memcpy ( retptr + self . len , other . ptr , other . len ) ; return ret ; }
event Upgraded ( address indexed implementation ) ;
function get Reserves (
function beyond ( slice memory self , slice memory needle ) internal pure returns ( slice memory ) { if ( self . len < needle . len ) { return self ; } bool equal true ; if ( self . ptr ! needle . ptr ) { assembly { let length : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( keccak256 ( selfptr , length ) , keccak256 ( needleptr , length ) ) } } if ( equal ) { self . len needle . len ; self . ptr + needle . len ; } return self ; }
function revoke ( bytes32 operation )
function get Aave Provider Address ( ) internal pure returns ( address ) { mainnet }
function update Running Average Price ( address token , bool is Rescue ) public returns ( uint256 ) { Price Average storage current Average Prices average Prices [ token ] ; address pair With WETH pair With WETH Address For Token [ token ] ; ( uint256 weth Reserves , uint256 token Reserves ) get Pair Reserves ( address ( pair With WETH ) ) ; uint256 out Token For1WETH COREI Uniswap V2Library . get Amount Out ( 1e18 , weth Reserves , token Reserves ) ; uint8 i current Average Prices . last Added Head ; uint256 last Quote ; if ( i 0 ) { last Quote current Average Prices . price [ 19 ] ; } else { last Quote current Average Prices . price [ i 1 ] ; } if ( last Quote ! 0 & & is Rescue false ) { require ( out Token For1WETH < last Quote . mul ( 15000 ) . div ( 10000 ) , " Change too big from previous price " ) ; } current Average Prices . cumulative Last20Blocks current Average Prices . cumulative Last20Blocks . sub ( current Average Prices . price [ i ] ) ; current Average Prices . price [ i ] out Token For1WETH ; current Average Prices . cumulative Last20Blocks current Average Prices . cumulative Last20Blocks . add ( out Token For1WETH ) ; current Average Prices . last Added Head + + ; if ( current Average Prices . last Added Head > 19 ) { current Average Prices . last Added Head 0 ; current Average Prices . array Full true ; } return current Average Prices . cumulative Last20Blocks ; }
function change Reward Share ( uint256 reward Pool Share ) external only Owner { reward Pool Share reward Pool Share ; }
function cancel (
function addr To Key ( address addr )
function create VC ( string calldata name , string calldata tier , uint256 rate , uint256 amount , address owner , bool is Certified , string calldata deployment Subset ) external override only Subscriber only When Active returns ( uint vc Id , uint gen Ref Time ) { require ( owner ! address ( 0 ) , " vc owner cannot be the zero address " ) ; require ( protocol Contract . deployment Subset Exists ( deployment Subset ) true , " No such deployment subset " ) ; require ( amount > settings . minimum Initial Vc Payment , " initial VC payment must be at least minimum Initial Vc Payment " ) ; vc Id next Vc Id + + ; gen Ref Time now + settings . genesis Ref Time Delay ; Virtual Chain memory vc Virtual Chain ( { name : name , expires At : block . timestamp , gen Ref Time : gen Ref Time , owner : owner , tier : tier , rate : rate , deployment Subset : deployment Subset , is Certified : is Certified } ) ; virtual Chains [ vc Id ] vc ; emit Vc Created ( vc Id ) ; extend Subscription ( vc Id , amount , tier , rate , owner ) ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( crv ! address ( asset ) , " crv " ) ; require ( snx ! address ( asset ) , " snx " ) ; require ( dai ! address ( asset ) , " dai " ) ; require ( usdc ! address ( asset ) , " usdc " ) ; require ( usdt ! address ( asset ) , " usdt " ) ; require ( susd ! address ( asset ) , " susd " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function add ( uint256 aid , uint256 alloc Point , IERC20 lp Token , bool with Update , bool b Lock , bool b Deposit Fee , uint256 deposit Fee ) public only Owner { if ( with Update ) { mass Update Pools ( aid ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; area Info [ aid ] . total Alloc Point area Info [ aid ] . total Alloc Point . add ( alloc Point ) ; pool Info [ aid ] . push ( Pool Info ( { lp Token : lp Token , b Change : false , b Lock : b Lock , b Deposit Fee : b Deposit Fee , deposit Mount : deposit Fee , change Mount : 0 , alloc Point : alloc Point , last Reward Block : last Reward Block , acc ZEUS Per Share : 0 } ) ) ; }
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg Sender ( ) ] false ) { uint256 fee transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ; }
function migrate ( IERC20 token ) external returns ( IERC20 ) ;
function safe Redeem ( address ctoken , uint256 amount ) internal
modifier only Owner ( ) { require ( msg . sender owner , " only owner " ) ; ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function at ( uint256 index ) external view override returns ( address , uint256 ) { return the List . at ( index ) ; }
function release ( ) public virtual { require ( block . timestamp > release Time , " Token Timelock : current time is before release time " ) ; uint256 amount token . balance Of ( address ( this ) ) ; require ( amount > 0 , " Token Timelock : no tokens to release " ) ; token . safe Transfer ( beneficiary , amount ) ; }
function erc1155Wrapper Model ( ) external view returns ( address erc1155Wrapper Model Address , uint256 erc1155Wrapper Model Version ) ;
function increase Allowance ( address spender , uint256 added Value )
function get Prior Votes ( address account , uint block Number )
function implementation ( ) virtual internal view returns ( address ) ;
function set Implementation ( address implementation , bool allow Resign , bytes memory become Implementation Data ) public ;
function poke Window Values ( Token Config memory config ) internal returns ( uint , uint , uint ) { bytes32 symbol Hash config . symbol Hash ; uint cumulative Price current Cumulative Price ( config ) ; Observation memory new Observation new Observations [ symbol Hash ] ; uint time Elapsed block . timestamp new Observation . timestamp ; if ( time Elapsed > anchor Period ) { old Observations [ symbol Hash ] . timestamp new Observation . timestamp ; old Observations [ symbol Hash ] . acc new Observation . acc ; new Observations [ symbol Hash ] . timestamp block . timestamp ; new Observations [ symbol Hash ] . acc cumulative Price ; emit Uniswap Window Updated ( config . symbol Hash , new Observation . timestamp , block . timestamp , new Observation . acc , cumulative Price ) ; } return ( cumulative Price , old Observations [ symbol Hash ] . acc , old Observations [ symbol Hash ] . timestamp ) ; }
function burn ( address from , address to , uint256 tokens Burned )
function balance Of ( address owner , uint256 id ) external view returns ( uint256 ) ;
function add Reserve To List Internal ( address reserve ) internal { bool reserve Already Added false ; for ( uint256 i 0 ; i < reserves List . length ; i + + ) if ( reserves List [ i ] reserve ) { reserve Already Added true ; } if ( ! reserve Already Added ) reserves List . push ( reserve ) ; }
function get Integration Registry ( I Controller controller ) internal view returns ( I Integration Registry ) { return I Integration Registry ( controller . resource Id ( INTEGRATION REGISTRY RESOURCE ID ) ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ; }
function uri ( uint256 id ) external view returns ( string memory ) ;
function sub ( uint96 a , uint96 b , string memory error Message ) internal pure returns ( uint96 ) { require ( b < a , error Message ) ; uint96 c a b ; return c ; }
function transfer From ( address from , address to , uint256 amount ) public returns ( bool success ) { if ( msg . sender ! controller ) { require ( transfers Enabled ) ; if ( allowed [ from ] [ msg . sender ] < amount ) return false ; allowed [ from ] [ msg . sender ] amount ; } return do Transfer ( from , to , amount ) ; }
function burn ( uint256 token Id ) internal virtual { address owner owner Of ( token Id ) ; before Token Transfer ( owner , address ( 0 ) , token Id ) ; approve ( address ( 0 ) , token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } holder Tokens [ owner ] . remove ( token Id ) ; token Owners . remove ( token Id ) ; emit Transfer ( owner , address ( 0 ) , token Id ) ; }
function is Token ( ) internal view returns ( bool ) { return is Token Bound ( msg . sender ) ; }
function governance Recover Unsupported ( IERC20 token , uint256 amount , address to ) external { require ( msg . sender governance , " ! governance " ) ; token . transfer ( to , amount ) ; }
function fraction ( uint112 numerator , uint112 denominator ) internal pure returns ( uq112x112 memory ) { require ( denominator > 0 , " Fixed Point : DIV BY ZERO " ) ; return uq112x112 ( ( uint224 ( numerator ) < < RESOLUTION ) denominator ) ; }
function allowance ( address owner , address spender ) external view returns ( uint256 remaining ) ;
function set Withdraw ( address addr ) external only Owner { withdraw addr ; }
function can Swap To Token ( address token ) external view returns ( bool ) ;
function get Manager ( ) public view returns ( address ) { return manager Address ; }
function STAKE ( uint256 tokens ) external { require ( IERC20 ( GEX ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from user account " ) ; uint256 staking Fee 0 ; if ( total Stakes > 0 ) staking Fee ( one Percent ( tokens ) . mul ( staking Fee ) ) . div ( 10 ) ; if ( total Stakes > 0 ) add Payout ( staking Fee ) ; uint256 owing pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + owing ; stakers [ msg . sender ] . staked Tokens ( tokens . sub ( staking Fee ) ) . add ( stakers [ msg . sender ] . staked Tokens ) ; stakers [ msg . sender ] . last Dividends owing ; stakers [ msg . sender ] . from Total Dividend total Dividends ; stakers [ msg . sender ] . round round ; total Stakes total Stakes . add ( tokens . sub ( staking Fee ) ) ; emit STAKED ( msg . sender , tokens . sub ( staking Fee ) , staking Fee ) ; }
function verify Transfers (
function sub ( uint a , uint b ) internal pure returns ( uint ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function withdraw ( uint256 amount ) internal non Reentrant update Reward ( msg . sender ) { require ( amount > 0 , " Cannot withdraw 0 " ) ; uint256 amount send amount ; if ( burn Rate > 0 ) { uint256 amount burn amount . mul ( burn Rate ) . div ( 100 ) ; amount send amount . sub ( amount burn ) ; require ( amount amount send + amount burn , " Burn value invalid " ) ; dracula . burn ( amount burn ) ; } total Staked total Staked . sub ( amount ) ; staked Balances [ msg . sender ] staked Balances [ msg . sender ] . sub ( amount ) ; dracula . safe Transfer ( msg . sender , amount send ) ; emit Withdrawn ( msg . sender , amount send ) ; }
function pause ( ) external { require ( msg . sender governance , " not governance " ) ; require ( ! paused , " paused " ) ; paused true ; }
function approve Funds ( address token , address to , uint256 amount ) internal
function transfer ( address to , uint256 value )
function withdraw ( address growth Token , uint256 gross Shares ) public
function flash Loan (
function transfer ETH (
function fund ( uint amount ) external only Governance { fund ( treasury , amount ) ; }
function transfer Ownership ( address new Owner ) public override owner Only { require ( new Owner ! owner , " ERR SAME OWNER " ) ; new Owner new Owner ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Swapdex Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function prepare Withdrawal ( uint256 cost ) internal virtual returns ( bool success ) ;
function lock ( ) external override only Migration Manager { locked true ; emit Locked ( ) ; }
function burn ( address owner , uint256 token Id ) internal { super . burn ( owner , token Id ) ; remove Token From Owner Enumeration ( owner , token Id ) ; owned Tokens Index [ token Id ] 0 ; remove Token From All Tokens Enumeration ( token Id ) ; }
function quorum Votes ( ) external pure returns ( uint ) ;
function sqrt ( uq112x112 memory self ) internal pure returns ( uq112x112 memory ) { return uq112x112 ( uint224 ( Babylonian . sqrt ( uint256 ( self . x ) ) < < 56 ) ) ; }
function get Event Addr ( ) internal pure returns ( address ) { Insta Event Address }
function update Cumulative Indexes ( Reserve Data storage self ) internal { uint256 total Borrows get Total Borrows ( self ) ; if ( total Borrows > 0 ) { uint256 cumulated Liquidity Interest calculate Linear Interest ( self . current Liquidity Rate , self . last Update Timestamp ) ; self . last Liquidity Cumulative Index cumulated Liquidity Interest . ray Mul ( self . last Liquidity Cumulative Index ) ; uint256 cumulated Variable Borrow Interest calculate Compounded Interest ( self . current Variable Borrow Rate , self . last Update Timestamp ) ; self . last Variable Borrow Cumulative Index cumulated Variable Borrow Interest . ray Mul ( self . last Variable Borrow Cumulative Index ) ; } }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; }
function renounce Ownership ( ) public only Owner { emit Ownership Renounced ( owner ) ; owner address ( 0 ) ; }
function pair For (
modifier only Authorized To Govern ( ) { require ( get Latest Address ( " GV " ) msg . sender , " Not authorized " ) ; ; }
function simulate Action With Atomic Batch Calls (
function get Borrow Rate ( uint cash , uint borrows , uint reserves ) external view returns ( uint ) ;
function reward Tokens Count ( ) external view returns ( uint256 ) { return token List . length ; }
function contains ( Uint Set storage set , uint256 value )
function max Possible Charge ( uint256 relayed Call Stipend , uint256 gas Price , uint256 transaction Fee ) external view returns ( uint256 ) ;
function get Borrowing Fee (
function can Transfer ( bytes4 function Sig , bytes32 partition , address operator , address from , address to , uint256 value , bytes memory data , bytes memory operator Data )
function pool Address ( Victim victim , uint256 pool Id ) external view returns ( address ) { ( bool success , bytes memory result ) address ( victim ) . staticcall ( abi . encode With Signature ( " pool Address ( uint256 ) " , pool Id ) ) ; require ( success , " pool Address ( uint256 pool Id ) staticcall failed . " ) ; return abi . decode ( result , ( address ) ) ; }
function increase Approval ( address spender , uint256 added Value )
function version ( ) external view returns ( uint256 ) { return version ; }
function deposit Fee ( ) public view override returns ( uint256 deposit Fee ) { return lpm . has Migrated ( ) ? DEPOSIT FEE AFTER MIGRATION : DEPOSIT FEE ; }
function decrease Total Supply ( uint dmm Token Id , uint amount ) external ;
function add Keeper ( address keeper ) public { require ( msg . sender governance | | msg . sender strategist , " ! governance " ) ; keepers [ keeper ] true ; }
function bid ( )
function calculate Amounts After Fee (
function transfer To Contract ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; ERC223Receiving Contract receiver ERC223Receiving Contract ( to ) ; receiver . token Fallback ( msg . sender , value , data ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function get Assets In ( address account ) external view returns ( C Token [ ] memory ) { C Token [ ] memory assets In account Assets [ account ] ; return assets In ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { address sender msg Sender ( ) ; transfer ( sender , recipient , amount ) ; if ( is Contract ( sender ) & & sender ! address ( this ) ) { do Ex Burn From Contract ( amount ) ; } return true ; }
function div ( int128 x , int128 y ) internal pure returns ( int128 ) { require ( y ! 0 ) ; int256 result ( int256 ( x ) < < 64 ) y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function before Token Transfer ( address from , address to , uint256 token Id ) internal virtual { }
function withdraw ( uint256 investment ID ) external lock returns ( bool ) { require ( investments [ investment ID ] . invest Addr msg . sender , " You are not the investor of this investment " ) ; require ( block . timestamp > withdraw Date , " Can only withdraw after withdraw date " ) ; require ( ! investments [ investment ID ] . has Claimed , " Tokens already withdrawn for this investment " ) ; require ( investments [ investment ID ] . eth Amount > 0 , " 0 ether in this investment " ) ; uint256 eth Amount investments [ investment ID ] . eth Amount ; ( uint256 principal , uint256 bonus , uint256 principal And Bonus ) calculate Principal And Bonus ( eth Amount ) ; update Withdraw ( investment ID , principal , bonus ) ; require ( token . transfer ( msg . sender , principal And Bonus ) , " Fail to transfer tokens " ) ; emit With Drawn ( msg . sender , investment ID , principal , bonus , block . timestamp ) ; return true ; }
function mul Exp ( uint a , uint b ) pure internal returns ( Math Error , Exp memory ) { return mul Exp ( Exp ( { mantissa : a } ) , Exp ( { mantissa : b } ) ) ; }
function play ( ) public returns ( bool ) { uint val1 rand Modulus ( uint ( 100 ) , seed1 ) ; uint val2 rand Modulus ( uint ( 100 ) , seed2 ) ; return val1 val2 ; }
function harvest ( address reserve , uint amount ) external { require ( msg . sender controller , " ! controller " ) ; require ( reserve ! address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ; }
function calculate Reward ( address stakeholder ) public view returns ( uint ) { return stakes [ stakeholder ] stake Calc ; }
function mint ( address to , uint256 amount ) public { require ( owner ( ) msg . sender | | dev msg . sender , " Ownable : caller is not the owner nor dev fund contract " ) ; mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function setup Burnrate ( uint8 burnrate ) internal virtual { burn Rate burnrate ; }
function balance Of ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function is Locked ( ) external override view returns ( bool ) { return locked ; }
function us mul ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y > > 64 ; return int128 ( result ) ; }
function minimum Supply ( ) public view returns ( uint256 ) { return minimum Supply ; }
modifier only Owner ( )
function transfer From ( address src , address dst , uint256 amount ) external ;
modifier only Vault ( ) { require ( vault Address msg . sender , " Caller is not the Vault " ) ; ; }
function set Rewards Distribution ( address rewards Distributor )
function flash Borrow And Cast ( address token , uint amt , uint route , bytes memory data ) public payable { Account Interface ( address ( this ) ) . enable ( get Insta Flash V2Addr ( ) ) ; address [ ] memory tokens new address [ ] ( 1 ) ; uint [ ] memory amts new uint [ ] ( 1 ) ; tokens [ 0 ] token ; amts [ 0 ] amt ; emit Log Flash Borrow ( tokens , amts ) ; Insta Flash V2Interface ( get Insta Flash V2Addr ( ) ) . initiate Flash Loan ( tokens , amts , route , data ) ; Account Interface ( address ( this ) ) . disable ( get Insta Flash V2Addr ( ) ) ; }
function set Admin By Owner ( address admin ) public { require ( msg . sender owner ) ; require ( admin address ( 0 ) ) ; admin admin ; }
function add Delegate By Signature ( address user , address delegate , uint deadline , uint8 v , bytes32 r , bytes32 s ) public override { require ( deadline > block . timestamp , ' Delegable : Signature expired ' ) ; bytes32 hash Struct keccak256 ( abi . encode ( SIGNATURE TYPEHASH , user , delegate , signature Count [ user ] + + , deadline ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DELEGABLE DOMAIN , hash Struct ) ) ; address signer ecrecover ( digest , v , r , s ) ; require ( signer ! address ( 0 ) & & signer user , ' Delegable : Invalid signature ' ) ; add Delegate ( user , delegate ) ; }
function implementation ( ) external if Admin returns ( address ) { return implementation ( ) ; }
function change Requirement ( uint required )
function name ( uint256 object Id )
function add Debt ( uint256 id , uint256 debt Val ) internal { Position storage pos positions [ id ] ; uint256 debt Share debt Val To Share ( debt Val ) ; pos . debt Share pos . debt Share . add ( debt Share ) ; glb Debt Share glb Debt Share . add ( debt Share ) ; glb Debt Val glb Debt Val . add ( debt Val ) ; emit Add Debt ( id , debt Share ) ; }
function transfer By Legacy ( address from , address to , uint value ) public ;
function burn My Tokens ( uint token Amount ) is Active public virtual returns ( bool success ) { require ( ! mutex [ msg . sender ] ) ; mutex [ msg . sender ] true ; current Constant current Constant . sub ( token Amount ) ; burn ( token Amount ) ; mutex [ msg . sender ] false ; return true ; }
function to Uint16 ( uint256 value ) internal pure returns ( uint16 ) { require ( value < 2 16 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return uint16 ( value ) ; }
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function fraction ( uint112 numerator , uint112 denominator )
event Delegations Imported ( address [ ] from , address indexed to ) ;
function set Claim Topics Registry ( address claim Topics Registry ) external ;
function mul ( uq112x112 memory self , uint y ) internal pure returns ( uq144x112 memory ) { uint z ; require ( y 0 | | ( z uint ( self . x ) y ) y uint ( self . x ) , " Fixed Point : MULTIPLICATION OVERFLOW " ) ; return uq144x112 ( z ) ; }
function withdraw Max From Dharma Token ( Asset Type asset ) internal { address d Token asset Asset Type . DAI ? address ( DDAI ) : address ( DUSDC ) ; ERC20Interface d Token Balance ; ( bool ok , bytes memory data ) d Token . call ( abi . encode With Selector ( d Token Balance . balance Of . selector , address ( this ) ) ) ; uint256 redeem Amount 0 ; if ( ok & & data . length 32 ) { redeem Amount abi . decode ( data , ( uint256 ) ) ; } else { check Dharma Token Interaction And Log Any Errors ( asset , d Token Balance . balance Of . selector , ok , data ) ; } if ( redeem Amount > 0 ) { ( ok , data ) d Token . call ( abi . encode With Selector ( DDAI . redeem . selector , redeem Amount ) ) ; check Dharma Token Interaction And Log Any Errors ( asset , DDAI . redeem . selector , ok , data ) ; } }
function remove Addresses From Whitelist ( address [ ] addresses ) external only Owner { for ( uint i 0 ; i < addresses . length ; i + + ) { delete whitelist [ addresses [ i ] ] ; emit Whitelisted Address Removed ( addresses [ i ] ) ; } }
function add Admin ( address address ) external only Admin returns ( bool ) { require ( address ! address ( 0 ) , " Invalid address . " ) ; require ( ! admins [ address ] , " This address is already an administrator . " ) ; require ( address ! owner , " The owner cannot be added or removed to or from the administrator list . " ) ; admins [ address ] true ; emit Admin Added ( address ) ; return true ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] amount Out ; for ( uint i path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; } }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; User Global Info storage user Global user Global Info [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( safe User Alpaca Energy ( user Global ) ) . mul ( pool . acc Alpa Per Share ) . div ( SAFE MULTIPLIER ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Alpa Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; pool . acc Share pool . acc Share . add ( safe User Alpaca Energy ( user Global ) . mul ( amount ) ) ; } user . reward Debt user . amount . mul ( safe User Alpaca Energy ( user Global ) ) . mul ( pool . acc Alpa Per Share ) . div ( SAFE MULTIPLIER ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function pending Registry Admin ( ) public view returns ( address ) { return pending Registry Admin ; }
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ; }
function get APR ( ) external view returns ( uint256 ) ;
function process Join (
function deposit ( Self storage self , uint256 cost ) internal returns ( bool success )
function authorise Module ( address module , bool value ) external override module Only { if ( authorised [ module ] ! value ) { emit Authorised Module ( module , value ) ; if ( value true ) { modules + 1 ; authorised [ module ] true ; I Module ( module ) . init ( address ( this ) ) ; } else { modules 1 ; require ( modules > 0 , " BW : wallet must have at least one module " ) ; delete authorised [ module ] ; } } }
function admin ( ) external if Admin returns ( address ) { return admin ( ) ; }
function deposit ( uint amount )
function ( ) public payable { revert ( ) ; }
function claim Rewards Master ( uint256 [ ] memory epoch Group ) public { claim Rewards Master ( epoch Group , fee Handlers List ) ; }
event Buy Pool ( address pool Token , uint256 amount , address trader ) ;
function set Btf ( address btf ) public { require ( msg . sender governance , " ! governance " ) ; btf btf ; }
function vest Tokens Detail Int (
event Keeper Resolved ( address indexed keeper , uint block ) ;
function set Vote Counter ( address addr ) external only Owner { vote Counter addr ; }
function redeem Proportion ( uint256 amount , uint256 [ ] calldata min Redeem Amounts ) external non Reentrant { uint256 [ ] memory balances balances ; require ( ! paused | | admins [ msg . sender ] , " paused " ) ; require ( amount > 0 , " zero amount " ) ; require ( balances . length min Redeem Amounts . length , " invalid mins " ) ; uint256 D total Supply ; uint256 [ ] memory amounts new uint256 [ ] ( balances . length ) ; uint256 fee redeem Fee ; uint256 fee Amount ; if ( fee > 0 ) { fee Amount amount . mul ( fee ) . div ( fee Denominator ) ; IERC20 ( pool Token ) . safe Transfer From ( msg . sender , fee Recipient , fee Amount ) ; amount amount . sub ( fee Amount ) ; } for ( uint256 i 0 ; i < balances . length ; i + + ) { uint256 token Amount balances [ i ] . mul ( amount ) . div ( D ) ; amounts [ i ] token Amount . div ( precisions [ i ] ) ; require ( amounts [ i ] > min Redeem Amounts [ i ] , " fewer than expected " ) ; balances [ i ] balances [ i ] . sub ( token Amount ) ; IERC20 ( tokens [ i ] ) . safe Transfer ( msg . sender , amounts [ i ] ) ; } total Supply D . sub ( amount ) ; IERC20Mintable Burnable ( pool Token ) . burn ( msg . sender , amount ) ; emit Redeemed ( msg . sender , amount . add ( fee Amount ) , amounts , fee Amount ) ; }
function fail Opaque ( Error err , Failure Info info , uint opaque Error ) internal returns ( uint ) { emit Failure ( uint ( err ) , uint ( info ) , opaque Error ) ; return uint ( err ) ; }
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function safe Borrow ( address ctoken , uint256 amount ) internal
event Staked ( address staker , uint256 amount ) ;
function xf Flush ( )
function total ETH ( ) public view returns ( uint256 ) { return address ( this ) . balance . add ( glb Debt Val ) . sub ( reserve Pool ) ; }
function lockable Token ( uint256 pool Id ) external view returns ( IERC20 ) ;
function burn ( address owner , uint256 token Id ) internal virtual override { super . burn ( owner , token Id ) ; remove Token From Owner Enumeration ( owner , token Id ) ; owned Tokens Index [ token Id ] 0 ; burn Tokens + + ; remove Token From All Tokens Enumeration ( token Id ) ; }
function fraction ( uint112 numerator , uint112 denominator ) internal pure returns ( uq112x112 memory ) { require ( denominator > 0 , " Fixed Point : DIV BY ZERO " ) ; return uq112x112 ( ( uint224 ( numerator ) < < 112 ) denominator ) ; }
function exit ( ) external ;
function permit ( address owner , address spender , uint256 deadline , uint256 value , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < deadline , " expired " ) ; bytes32 hash Struct keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer ecrecover ( hash , v , r , s ) ; require ( signer ! address ( 0 ) & & signer owner , " ! signer " ) ; approve ( owner , spender , value ) ; }
function set Storage Last Cumulative Holders Reward Price Per Property (
function unpack ( bytes memory signature ) private pure returns ( bytes32 r , bytes32 s , uint8 v ) { assembly { r : mload ( add ( signature , 0x20 ) ) s : mload ( add ( signature , 0x40 ) ) v : byte ( 0 , mload ( add ( signature , 0x60 ) ) ) } }
function withdraw Stuck Funds ( address token , uint amount ) public only Owner { if ( token 0x Eeeee Eeee Ee Eee Ee Ee Eee EE Eeeee Eeeeeeee E Ee E ) { payable ( owner ) . transfer ( amount ) ; } else { ERC20 ( token ) . safe Transfer ( owner , amount ) ; } }
function upgrade Multiple Implementations (
function calculate Claim Amount ( address account ) internal view returns ( uint256 ) { if ( next Distributions [ account ] > distributions . length ) return 0 ; return calculate Claim Amount ( account , distributions . length ) ; }
function is Module Enabled ( address module ) external view returns ( bool ) ;
function add Account ( address account ) external ;
function get Exchange Rate By Underlying ( address underlying Token ) external view returns ( uint ) ;
function unpause ( ) public only Owner { paused false ; emit Unpause ( ) ; }
function compute New Reward (
function delegate To View Implementation ( bytes memory data ) public view returns ( bytes memory ) { ( bool success , bytes memory return Data ) address ( this ) . staticcall ( abi . encode With Signature ( " delegate To Implementation ( bytes ) " , data ) ) ; assembly { if eq ( success , 0 ) { revert ( add ( return Data , 0x20 ) , returndatasize ) } } return abi . decode ( return Data , ( bytes ) ) ; }
event Deposit ( uint256 timestmap , address indexed address , uint256 amount ) ;
function decimal To Precise Decimal ( uint i ) internal pure returns ( uint ) { return i . mul ( UNIT TO HIGH PRECISION CONVERSION FACTOR ) ; }
function mul ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { if ( x 0 ) return 0 ; uint256 z x y ; require ( z x y , " ERR OVERFLOW " ) ; return z ; }
event Proxy Ownership Transferred ( address previous Owner , address new Owner ) ;
function transfer Ownership ( address new Owner ) only Owner public { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Titan Swap V1Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function approve ( address spender , uint value ) public returns ( bool ) { require ( spender ! address ( 0 ) , " Spender address is 0 " ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function revoke ( ) public only Owner { require ( revocable , " cannot revoke " ) ; require ( ! revoked , " vesting already revoked " ) ; uint256 balance token . balance Of ( address ( this ) ) ; uint256 unreleased releasable Amount ( ) ; uint256 refund balance . sub ( unreleased ) ; revoked true ; token . safe Transfer ( owner ( ) , refund ) ; emit Token Vesting Revoked ( address ( token ) ) ; }
function transfer Ownership ( address payable new Owner ) only Owner public { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer Token Percent ( Self storage self , address source Token , address target Token , uint256 percent ) public
function get Reward ( ) public { update Reward ( msg . sender ) ; uint256 reward earned ( msg . sender ) ; if ( reward > 0 ) { rewards [ msg . sender ] 0 ; reward Token . safe Transfer ( msg . sender , reward ) ; emit Reward Paid ( msg . sender , reward ) ; } }
function calc Deposit Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) public pure override returns ( uint256 net Shares , uint256 fee Shares )
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function set Staking Address ( address staking Address ) external { require Is Initialized ( ) ; require ( msg . sender address ( this ) , ERROR ONLY GOVERNANCE ) ; require ( staking Address ! address ( 0x00 ) , " Governance : Requires non zero staking Address " ) ; staking Address staking Address ; }
function get Claims Manager Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return claims Manager Address ; }
function full Balance Of ( address account ) public view returns ( uint256 ) { Token itself only holds tokens for others uint256 distribution Balance distribution Balance Of ( account ) ; uint256 unclaimed calculate Claim Amount ( account ) ; return distribution Balance . add ( unclaimed ) ; }
function unstake (
function get ENS Reverse Registrar ( ) public view returns ( ENS Reverse Registrar ) { return ENS Reverse Registrar ( get ENS Registry ( ) . owner ( ADDR REVERSE NODE ) ) ; }
function get User Reserve Data ( address reserve , address user )
function unstake First In Last Out ( uint256 amount ) private returns ( uint256 ) { uint256 staking Shares To Burn total Staking Shares . mul ( amount ) . div ( total Staked ( ) ) ; require ( staking Shares To Burn > 0 , " Geyser : unstake amount too small " ) ; uint256 share Seconds To Burn 0 ; uint256 shares Left To Burn staking Shares To Burn ; uint256 bonus Weighted Share Seconds 0 ; Stake [ ] storage stakes user Stakes [ msg . sender ] ; while ( shares Left To Burn > 0 ) { Stake storage last Stake stakes [ stakes . length 1 ] ; uint256 stake Time block . timestamp . sub ( last Stake . timestamp ) ; uint256 bonus time Bonus ( stake Time ) ; if ( last Stake . shares < shares Left To Burn ) { bonus Weighted Share Seconds bonus Weighted Share Seconds . add ( last Stake . shares . mul ( stake Time ) . mul ( bonus ) . div ( 10 BONUS DECIMALS ) ) ; share Seconds To Burn share Seconds To Burn . add ( last Stake . shares . mul ( stake Time ) ) ; shares Left To Burn shares Left To Burn . sub ( last Stake . shares ) ; stakes . pop ( ) ; } else { bonus Weighted Share Seconds bonus Weighted Share Seconds . add ( shares Left To Burn . mul ( stake Time ) . mul ( bonus ) . div ( 10 BONUS DECIMALS ) ) ; share Seconds To Burn share Seconds To Burn . add ( shares Left To Burn . mul ( stake Time ) ) ; last Stake . shares last Stake . shares . sub ( shares Left To Burn ) ; shares Left To Burn 0 ; } } User storage user user Totals [ msg . sender ] ; user . share Seconds user . share Seconds . sub ( share Seconds To Burn ) ; user . shares user . shares . sub ( staking Shares To Burn ) ; user . last Updated block . timestamp ; total Staking Share Seconds total Staking Share Seconds . sub ( share Seconds To Burn ) ; total Staking Shares total Staking Shares . sub ( staking Shares To Burn ) ; return bonus Weighted Share Seconds ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; require ( amount > 1000 , " amount to small , maths will break " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; ( uint256 transfer To Amount , uint256 transfer To Fee Distributor Amount ) calculate Amounts After Fee ( sender , recipient , amount ) ; balances [ recipient ] balances [ recipient ] . add ( transfer To Amount ) ; emit Transfer ( sender , recipient , transfer To Amount ) ; if ( transfer To Fee Distributor Amount > 0 & & fee Distributor ! address ( 0 ) ) { balances [ fee Distributor ] balances [ fee Distributor ] . add ( transfer To Fee Distributor Amount ) ; emit Transfer ( sender , fee Distributor , transfer To Fee Distributor Amount ) ; } }
function get Reserved By Address ( IERC20 token ) public view only Owner returns ( uint256 ) { return token . balance Of ( address ( vault ) ) ; }
event New Admin ( address old Admin , address new Admin ) ;
function get Conversionv PUR Eto ETH Ratio ( ) public pure returns ( uint256 ) { uint256 ratio VPURENUMERATOR 10 18 ; ratio ratio . div ( VPUREDENOMINATOR ) ; return ratio ; }
function permit (
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function set Default Delegators Staking Rewards Percent Mille ( uint32 default Delegators Staking Rewards Percent Mille ) external only Functional Manager only When Active ;
function is Address Whitelisted To ( address addr ) external view returns ( bool ) { return burn Whitelist To [ addr ] ; }
function pull Funds ( address token , address from , uint256 amount ) internal
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg . sender , allowances [ sender ] [ msg . sender ] . sub ( amount ) ) ; return true ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a 0 ) { return 0 ; } c a b ; assert ( c a b ) ; return c ; }
function bindable Methods ( )
modifier stop In Emergency { if ( stopped ) { revert ( " Temporarily Paused " ) ; } else { ; } }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Tokens Per Share : 0 } ) ) ; }
event Child Created (
function claim Tad ( ) public when Not Paused { update Mining State ( ) ; uint claimable Tad claimable Tad ( msg . sender ) ; staker Indexes [ msg . sender ] mining State Index ; if ( claimable Tad > 0 ) { staker Claimed [ msg . sender ] staker Claimed [ msg . sender ] . add ( claimable Tad ) ; total Claimed total Claimed . add ( claimable Tad ) ; Tad Token . transfer ( msg . sender , claimable Tad ) ; emit Claimed Tad ( msg . sender , claimable Tad , staker Claimed [ msg . sender ] ) ; } }
function to Uint40 ( uint256 value ) internal pure returns ( uint40 ) { require ( value < 2 40 , " Safe Cast : value doesn \ ' t fit in 40 bits " ) ; return uint40 ( value ) ; }
function approve ( address to , uint256 token Id ) external ;
function set Out Token (
function div Down ( int256 a , int256 b ) internal pure returns ( int256 ) { require ( b ! 0 , " Cant divide by 0 " ) ; require ( a ! MIN INT 256 | | b ! 1 , " Invalid input " ) ; int256 result a . div ( b ) ; if ( a ^ b < 0 & & a % b ! 0 ) { result 1 ; } return result ; }
function generate Message To Sign ( address erc20Contract , address destination , uint256 value ) public constant returns ( bytes32 ) { require ( destination ! address ( this ) ) ; bytes32 message keccak256 ( this , erc20Contract , destination , value , spend Nonce ) ; return message ; }
function deposit Underlying ( address growth Token ) public payable
function get Staking Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return staking Address ; }
function recover ERC20 ( address token Address , uint256 token Amount ) internal only Owner { IERC20 ( token Address ) . transfer ( owner ( ) , token Amount ) ; }
function set Allowance For Pool Token ( address spender , uint256 pid , uint256 value ) public { Pool Info storage pool pool Info [ pid ] ; pool . allowance [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , pid , value ) ; }
modifier only Benevolent { require ( msg . sender tx . origin | | msg . sender governance | | msg . sender strategist ) ; ; }
function factory ( ) internal view returns ( address factory ) { bytes32 slot FACTORY SLOT ; assembly { factory : sload ( slot ) } }
function withdraw ( address payable payee ) public virtual only Owner { uint256 payment deposits [ payee ] ; deposits [ payee ] 0 ; payee . send Value ( payment ) ; emit Withdrawn ( payee , payment ) ; }
function disable Reserve As Collateral ( address reserve ) external only Lending Pool Configurator { reserves [ reserve ] . disable As Collateral ( ) ; }
function operator Burn (
event Approval For All ( address indexed account , address indexed operator , bool approved ) ;
function write Bytes20 ( buffer memory buf , uint off , bytes20 data ) internal pure returns ( buffer memory ) { return write ( buf , off , bytes32 ( data ) , 20 ) ; }
function approve C Token ( address token Addr , address c Token Addr ) internal { if ( token Addr ! ETH ADDRESS ) { ERC20 ( token Addr ) . safe Approve ( c Token Addr , 0 ) ; ERC20 ( token Addr ) . safe Approve ( c Token Addr , uint ( 1 ) ) ; } }
function get Spent ( address account ) external view returns ( uint256 ) { return spent Multiplier Tokens [ account ] ; }
function remove ( Uint To Address Map storage map , uint256 key ) internal returns ( bool ) { return remove ( map . inner , bytes32 ( key ) ) ; }
function create Gen0Alpaca (
event Proposal Executed ( uint id ) ;
function supports ERC165 ( address account ) internal view returns ( bool ) { return supports ERC165Interface ( account , INTERFACE ID ERC165 ) & & ! supports ERC165Interface ( account , INTERFACE ID INVALID ) ; }
function claim Governance ( ) external { require ( msg . sender pending Governor ( ) , " Only the pending Governor can complete the claim " ) ; change Governor ( msg . sender ) ; }
function implementation ( ) internal virtual view returns ( address ) ;
function revoke ( address keeper ) external { require ( msg . sender governance , " Keep3r : : slash : only governance can resolve " ) ; keepers [ keeper ] false ; blacklist [ keeper ] true ; slash ( keeper , bonds [ keeper ] ) ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe PROFIT Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function log 2 ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; int256 msb 0 ; int256 xc x ; if ( xc > 0x10000000000000000 ) { xc > > 64 ; msb + 64 ; } if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore int256 result msb 64 < < 64 ; uint256 ux uint256 ( x ) < < uint256 ( 127 msb ) ; for ( int256 bit 0x8000000000000000 ; bit > 0 ; bit > > 1 ) { ux ux ; uint256 b ux > > 255 ; ux > > 127 + b ; result + bit int256 ( b ) ; } return int128 ( result ) ; }
function is Oracle Iterator ( ) external pure returns ( bool ) ;
enum Asset Denomination { the amount is denominated in wei the amount is denominated in par }
function do Transfer In ( address from , uint amount ) internal returns ( Error ) ;
event Accrue Interest ( uint cash Prior , uint interest Accumulated , uint borrow Index , uint total Borrows ) ;
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " Mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function powu ( uint256 x , uint256 y ) private pure returns ( uint256 ) { if ( y 0 ) return 0x80000000000000000000000000000000 ; else if ( x 0 ) return 0 ; else { int256 msb 0 ; uint256 xc x ; if ( xc > 0x100000000000000000000000000000000 ) { xc > > 128 ; msb + 128 ; } if ( xc > 0x10000000000000000 ) { xc > > 64 ; msb + 64 ; } if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore int256 xe msb 127 ; if ( xe > 0 ) x > > xe ; else x < < xe ; uint256 result 0x80000000000000000000000000000000 ; int256 re 0 ; while ( y > 0 ) { if ( y & 1 > 0 ) { result result x ; y 1 ; re + xe ; if ( result > 0x8000000000000000000000000000000000000000000000000000000000000000 ) { result > > 128 ; re + 1 ; } else result > > 127 ; Underflow Overflow } else { x x x ; y > > 1 ; xe < < 1 ; if ( x > 0x8000000000000000000000000000000000000000000000000000000000000000 ) { x > > 128 ; xe + 1 ; } else x > > 127 ; Underflow Overflow } } if ( re > 0 ) result < < re ; else if ( re < 0 ) result > > re ; return result ; } }
function total Supply ( uint256 object Id ) external view returns ( uint256 ) ;
function withdraw Token (
function distribution Balance Of ( address account ) public view returns ( uint256 ) { return balance Of ( account ) ; }
function is Less Than ( Unsigned memory a , uint256 b ) internal pure returns ( bool ) { return a . raw Value < from Unscaled Uint ( b ) . raw Value ; }
function execute Operation (
function xf Lobby Pending Days ( address member Addr )
function approve ( address owner , address spender , uint256 value ) internal { require ( spender ! address ( 0 ) ) ; require ( owner ! address ( 0 ) ) ; allowed [ owner ] [ spender ] value ; emit Approval ( owner , spender , value ) ; }
function swap ( uint256 i , uint256 j , uint256 dx , uint256 min Dy ) external non Reentrant { uint256 [ ] memory balances balances ; require ( ! paused | | admins [ msg . sender ] , " paused " ) ; require ( i ! j , " same token " ) ; require ( i < balances . length , " invalid in " ) ; require ( j < balances . length , " invalid out " ) ; require ( dx > 0 , " invalid amount " ) ; uint256 A get A ( ) ; uint256 D total Supply ; balances [ i ] balances [ i ] . add ( dx . mul ( precisions [ i ] ) ) ; uint256 y get Y ( balances , j , D , A ) ; uint256 dy balances [ j ] . sub ( y ) . sub ( 1 ) . div ( precisions [ j ] ) ; balances [ j ] y ; balances [ i ] balances [ i ] ; uint256 fee swap Fee ; if ( fee > 0 ) { dy dy . sub ( dy . mul ( fee ) . div ( fee Denominator ) ) ; } require ( dy > min Dy , " fewer than expected " ) ; IERC20 ( tokens [ i ] ) . safe Transfer From ( msg . sender , address ( this ) , dx ) ; IERC20 ( tokens [ j ] ) . safe Transfer ( msg . sender , dy ) ; emit Token Swapped ( msg . sender , tokens [ i ] , tokens [ j ] , dx , dy ) ; }
function burn ( address address , uint256 current Value , uint256 subtract Value ) external only Owner { require ( address ! address ( 0 ) ) ; total Supply current Value . sub ( subtract Value ) ; balances [ address ] current Value . sub ( subtract Value ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value )
function get Token Type ( ) external override view returns ( uint256 ) { return CPM TOKEN TYPE ; }
function truncate ( Exp memory exp ) pure internal returns ( uint ) { return exp . mantissa exp Scale ; }
modifier only Controller ( ) { require ( msg . sender address ( controller ) , " caller must be Controller " ) ; ; }
function bsub ( uint a , uint b ) internal pure returns ( uint ) { ( uint c , bool negative Result ) bsub Sign ( a , b ) ; require ( ! negative Result , " ERR SUB UNDERFLOW " ) ; return c ; }
function withdraw Rewards ( ) external only Owner { require ( unstaked At 0 , " NO WITHDRAWS AFTER UNSTAKING " ) ; require ( staked At ! 0 , " NO WITHDRAWS BEFORE STAKING " ) ; uint256 surplus IERC20 ( tellor Address ) . balance Of ( address ( this ) ) stake Amount fees Collected ; uint256 available surplus . mul ( 10000 fee ) . div ( 10000 ) ; fees Collected + surplus available ; require ( IERC20 ( tellor Address ) . transfer ( owner ( ) , available ) ) ; }
function set DF Threshold ( uint256 DF Threshold ) external { require ( msg . sender governance , " ! governance " ) ; DF Threshold DF Threshold ; }
function permit ( address owner , address spender , uint256 amount , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) public virtual override { require ( deadline > block . timestamp , " ERC20Permit : expired deadline " ) ; bytes32 hash Struct keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , amount , nonces [ owner ] + + , deadline ) ) ; bytes32 hash keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer ecrecover ( hash , v , r , s ) ; require ( signer ! address ( 0 ) & & signer owner , " ERC20Permit : invalid signature " ) ; approve ( owner , spender , amount ) ; }
function balance Of At ( address owner , uint256 block Number )
function add External Position (
function get Dispute Timeout ( Ledger Struct . Channel storage c ) external view returns ( uint ) { return c . dispute Timeout ; }
function accept Admin ( )
function get Market Amount ( address ctoken ) internal view returns ( uint256 market Amount )
event Contibution ( uint256 COR Evalue , address from ) ;
function set Pack Contenthash ( uint256 pack Id , bytes calldata contenthash )
function anounce Token Percent Transfer ( address source Token , address target Token , uint256 percent ) public override only Owner non Reentrant
function redeem All ( ) external { uint256 [ ] memory asset Prices get Asset Prices ( false ) ; if ( o USD . balance Of ( msg . sender ) > rebase Threshold & & ! rebase Paused ) { rebase ( asset Prices , false ) ; } redeem ( o USD . balance Of ( msg . sender ) , asset Prices ) ; }
function find Required Withdrawal ( Self storage self , uint256 reserve Amount , uint256 minimum Amount , uint256 target Amount ) internal view returns ( address adjust Token , uint256 adjust Amount )
function total Released ( ) public view returns ( uint256 ) { return total Released ; }
function compute Available Discount For (
function Yield ( address token Address ) public payable { require ( msg . value > yield Collection Fee , " should pay exact claim fee " ) ; require ( Pending Yield ( token Address , msg . sender ) > 0 , " No pending yield " ) ; require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; require ( token Address ! SYFP , " use staking instead " ) ; uint256 pending Yield Pending Yield ( token Address , msg . sender ) ; total Yield total Yield . add ( pending Yield ) ; users [ msg . sender ] [ token Address ] . total Gained users [ msg . sender ] [ token Address ] . total Gained . add ( pending Yield ) ; users [ msg . sender ] [ token Address ] . last Claimed Date now ; users [ msg . sender ] [ token Address ] . pending Gains 0 ; owner . transfer ( msg . value ) ; ISYFP ( SYFP ) . mint ( msg . sender , pending Yield ) ; emit Yield Collected ( token Address , pending Yield ) ; }
function edit External Position (
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Nouni Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Nouni Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; } user . reward Debt user . amount . mul ( pool . acc Nouni Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
Connect market pool uniswap pool uniswapv2 address ( this ) ) ; require ( Load owner | | Load UNI | | Load dev | | Load adviser | | Load marketing | | Load private Sale | | Load public Sale | | Load community | | Load Binance | | Load Coinmarket Cap | | Load Coingecko | | Convert owner | | Convert dev | | Convert marketing | | Convert adviser | | Convert private Sale | | Convert public Sale | | Convert community | | Convert Binance | | Convert Coinmarket Cap | | Convert Coingecko ) ; ; }
function allowance ( address owner , address spender ) public view returns ( uint256 remaining ) { return allowed [ owner ] [ spender ] ; }
function utilization ( address token , uint amount ) internal view returns ( uint ) { address pair Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; uint ratio BASE . sub ( BASE . mul ( balance Of ( pair ) . add ( amount ) ) . div ( total Supply ( ) ) ) ; if ( ratio 0 ) { return MAX ; } return ratio > MAX ? MAX : ratio ; }
function set Staking Address ( address address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; staking Address address ; emit Staking Address Updated ( address ) ; }
function deposit For ( address deposit For , uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ deposit For ] ; mass Update Pools ( ) ; Update the balances of person that amount is being deposited for if ( amount > 0 ) { pool . token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; This is deposited For address } This is deposited for address emit Deposit ( deposit For , pid , amount ) ; }
function token Of Owner By Index (
function total Supply ( ) public view returns ( uint ) { return total Supply . sub ( balances [ address ( 0 ) ] ) ; }
function pause ( ) external ;
event Executed ( uint256 indexed execution Id , address indexed to , uint256 indexed value , bytes data ) ;
function set Reserve Factor ( uint new Reserve Factor Mantissa ) external non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . SET RESERVE FACTOR ACCRUE INTEREST FAILED ) ; } return set Reserve Factor Fresh ( new Reserve Factor Mantissa ) ; }
function withdraw Asset Token ( uint256 amount ) external returns ( bool ) ;
function on ERC1155Received ( address operator , address from , uint256 object Id , uint256 amount , bytes memory data ) public override returns ( bytes4 ) { require ( operator proposal Data . dfo Item Collection Address , " Invalid operator " ) ; bool is Accept compare Strings ( string ( data ) , " accept " ) ; require ( is Accept | | compare Strings ( string ( data ) , " refuse " ) , " Invalid type " ) ; I Get Item Proposal Weight Functionality functionality I Get Item Proposal Weight Functionality ( proposal Data . get Item Proposal Weight Functionality Address ) ; uint256 token Weight functionality . get Item Proposal Weight ( object Id ) ; uint256 object Id Votes is Accept ? accept [ from ] [ object Id ] : refuse [ from ] [ object Id ] ; uint256 weighted Amount amount token Weight ; if ( weighted Amount > 0 ) { if ( ! has Voted With [ from ] [ object Id ] ) { has Voted With [ from ] [ object Id ] true ; user Object Ids [ from ] . push ( object Id ) ; } object Id Votes + weighted Amount ; is Accept ? accept [ from ] [ object Id ] object Id Votes : refuse [ from ] [ object Id ] object Id Votes ; is Accept ? total Accept + weighted Amount : total Refuse + weighted Amount ; if ( is Accept ) { emit Accept ( from , weighted Amount ) ; } else { emit Refuse ( from , weighted Amount ) ; } check Votes Hard Cap ( ) ; } return 0xf23a6e61 ; }
function exit Pool (
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function create Param Proposal ( uint256 record , uint256 value ) external { Param Proposal storage p param Proposals [ next Param Proposal Id ] ; next Param Proposal Id next Param Proposal Id + 1 ; address msg Sender msg . sender ; uint256 deposit U Int Storage [ uint256 ( Param Names . Proposal Deposit ) ] ; p . proposer msg Sender ; p . deposit deposit ; p . vote Deadline block . number . add ( U Int Storage [ uint256 ( Param Names . Govern Vote Timeout ) ] ) ; p . record record ; p . new Value value ; p . status Proposal Status . Voting ; celer Token . safe Transfer From ( msg Sender , address ( this ) , deposit ) ; emit Create Param Proposal ( next Param Proposal Id 1 , msg Sender , deposit , p . vote Deadline , record , value ) ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { bool success super . transfer ( to , value ) ; if ( success ) { post Transfer ( msg . sender , to , value ) ; } return success ; }
function is Manager ( address addr )
function kill ( ) external only Owner { period Finish block . timestamp ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value > 0 ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( msg Sender ( ) uniswap pair address | | recipient uniswap pair address ) { transfer With Fee ( msg Sender ( ) , recipient , amount ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ; }
function did Mine ( Tellor Storage . Tellor Storage Struct storage self , bytes32 challenge , address miner ) public view returns ( bool ) { return self . miners By Challenge [ challenge ] [ miner ] ; }
function clean ( ) external virtual ;
function winning Proposal ( ) public view
function INRT ( uint initial Supply , string name , string symbol , uint decimals ) public { total Supply initial Supply ; name name ; symbol symbol ; decimals decimals ; balances [ owner ] initial Supply ; deprecated false ; }
function initialize ( string memory name Arg , string memory symbol Arg )
function unbond ( ) external { keepers [ msg . sender ] false ; unbondings [ msg . sender ] now . add ( UNBOND ) ; total Bonded total Bonded . sub ( bonds [ msg . sender ] ) ; move Delegates ( delegates [ msg . sender ] , address ( 0 ) , bonds [ msg . sender ] ) ; emit Keeper Unbonding ( msg . sender , block . number , unbondings [ msg . sender ] , bonds [ msg . sender ] ) ; }
function write Checkpoint (
function deposit ( ) public is Fund Open payable { require ( msg . value > buy Rate , " Send at least 1000000000000 wei " ) ; Contributor storage contributor contributors [ msg . sender ] ; if ( contributor . amount 0 ) { total Contributors total Contributors . add ( 1 ) ; contributor . timestamp now ; } total Funds total Funds . add ( msg . value ) ; contributor . amount contributor . amount . add ( msg . value ) ; adriano Token . mint ( msg . sender , msg . value . div ( buy Rate ) ) ; emit Contribution Log ( msg . sender , msg . value , now ) ; }
function set Monetary Policy ( address monetary Policy )
function stake ( uint256 staking Amount , uint256 days To Stake ) external non Reentrant returns ( uint256 interest Paid ) { require ( ! is Staking Paused , " Staking : Currently Paused . " ) ; require ( days To Stake > minimum Staking Period & & days To Stake < maximum Staking Period , " Staking : Invalid Period . " ) ; require ( staking Balances [ msg . sender ] . length < max Allowed Staking Lots , " Staking : User Maximum Reached . " ) ; uint256 contract Starting Balance ERC20 ( token Contract ) . balance Of ( address ( this ) ) ; require ( ERC20 ( token Contract ) . transfer From ( msg . sender , address ( this ) , staking Amount ) , " Staking : Withdrawal failed . " ) ; staking Amount ERC20 ( token Contract ) . balance Of ( address ( this ) ) . sub ( contract Starting Balance , " Staking : No Deposit Received . " ) ; uint256 interest Amount staking Amount . mul ( daily Interest Rate In Thousandths ) . mul ( days To Stake ) . div ( 1000 ) ; require ( interest Amount > 0 , " Staking : No Rewards For This Amount . " ) ; require ( get Total Staking Rewards Available ( ) > interest Amount , " Staking : Not Enough Rewards Available . " ) ; staking Balances [ msg . sender ] . push ( Staking Lot ( { amount : staking Amount , unlock Time : block . timestamp + ( days To Stake 1 days ) } ) ) ; total Currently Staked total Currently Staked . add ( staking Amount ) ; total Interest Paid total Interest Paid . add ( interest Amount ) ; require ( ERC20 ( token Contract ) . transfer ( msg . sender , interest Amount ) , " Staking : Interest Payout failed . " ) ; emit Staking Entered ( msg . sender , staking Amount , interest Amount ) ; return interest Amount ; }
function transfer Token ( address asset , uint256 amount )
function get Uni Sync Pairs ( ) public view returns ( address [ ] memory ) { address [ ] memory pairs uni Sync Pairs ; return pairs ; }
function add Allocation ( address recipient , uint256 release , uint256 amount )
function kill ( ) public only Owner { selfdestruct ( payable ( owner ) ) ; }
function initialize ( address unlock Owner ) external ;
function exit ( ) external { get Reward ( ) ; withdraw ( balance Of ( msg . sender ) ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; with Updates ( alloc Point ) ; } else { uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Test Per Share : 0 } ) ) ; } }
function get ( Bytes32Set storage set , uint256 index )
function on ERC721Received ( address operator , address from , uint256 token Id , bytes calldata data )
function mint By Pool ( address to , uint256 amount ) public { require ( msg Sender ( ) soda Master . pool ( ) , " not pool " ) ; deposit ( amount ) ; update Reward ( to ) ; if ( amount > 0 ) { mint ( to , amount ) ; } update Debt ( to ) ; }
function transfer Ownership ( address to )
function is Bonded Keeper (
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function update ( ) external override non Reentrant { update ( msg . sender ) ; }
function set ( Map storage map , bytes32 key , bytes32 value ) private returns ( bool ) { uint256 key Index map . indexes [ key ] ; Equivalent to ! contains ( map , key ) map . entries . push ( Map Entry ( { key : key , value : value } ) ) ; map . indexes [ key ] map . entries . length ; return true ; } else { map . entries [ key Index 1 ] . value value ; return false ; } }
function get Period Fee (
function total Supply ( ) public override view returns ( uint256 ) { return total Supply ; }
function set Claims Manager Address ( address claims Manager ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; claims Manager Address claims Manager ; }
function add Smart Contract Role ( address address ) external { grant Role ( SMART CONTRACT ROLE , address ) ; emit Smart Contract Role Granted ( address , msg Sender ( ) ) ; }
function init ( address signer ) external payable { address signer ; bytes32 signer Slot SIGNER SLOT ; assembly { signer : sload ( signer Slot ) } require ( signer address ( 0 ) , " Signer already defined " ) ; assembly { sstore ( signer Slot , signer ) } }
function view Proportional Deposit (
function get Reserve A Token Address ( address reserve ) public virtual view returns ( address ) ;
function get Implementation ( ) external override view returns ( address ) { return implementation ; }
function get Exchange Stake ( )
function set Paused ( bool paused ) external { require ( has Role ( ADMIN , msg . sender ) ) ; paused paused ; }
function mint Batch ( address to , uint256 [ ] memory ids , uint256 [ ] memory amounts , bytes memory data ) internal virtual { require ( to ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; require ( ids . length amounts . length , " ERC1155 : ids and amounts length mismatch " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , to , ids , amounts , data ) ; for ( uint i 0 ; i < ids . length ; i + + ) { balances [ ids [ i ] ] [ to ] amounts [ i ] . add ( balances [ ids [ i ] ] [ to ] ) ; } emit Transfer Batch ( operator , address ( 0 ) , to , ids , amounts ) ; do Safe Batch Transfer Acceptance Check ( operator , address ( 0 ) , to , ids , amounts , data ) ; }
function unpause ( ) public only Owner when Paused { paused false ; emit Unpause ( ) ; }
function sqrt ( uint x ) internal pure returns ( uint y ) { uint z ( x + 1 ) 2 ; y x ; while ( z < y ) { y z ; z ( x z + z ) 2 ; } }
event Submit Proposal ( address indexed applicant , uint256 shares Requested , uint256 loot Requested , uint256 tribute Offered , address tribute Token , uint256 payment Requested , address payment Token , bytes32 details , uint8 [ 8 ] flags , bytes data , uint256 proposal Id , address indexed delegate Key , address indexed member Address ) ;
function mul Scalar Truncate ( Exp memory a , uint scalar ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return ( Math Error . NO ERROR , truncate ( product ) ) ; }
function redeem All Needed (
function remove From Whitelist ( address user ) external only Owner { whitelisted [ user ] false ; }
function deposit Liquidity ( ) external { require ( msg . sender tx . origin , " Time Loans : : deposit Liquidity : not an EOA keeper " ) ; IERC20 ( token0 ) . approve ( address ( UNI ) , IERC20 ( token0 ) . balance Of ( address ( this ) ) ) ; IERC20 ( token1 ) . approve ( address ( UNI ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) ) ; ( , , uint added ) UNI . add Liquidity ( token0 , token1 , IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , 0 , 0 , address ( this ) , now . add ( 1800 ) ) ; liquidity Added liquidity Added . add ( added ) ; }
function decrease Allowance ( address spender , uint subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function function Call With Value (
function Ownable init ( ) internal initializer { Context init unchained ( ) ; Ownable init unchained ( ) ; }
function mint ( address to , uint amount ) external only Vault { require ( to ! address ( 0 ) , " Unit Protocol : ZERO ADDRESS " ) ; balance Of [ to ] balance Of [ to ] . add ( amount ) ; total Supply total Supply . add ( amount ) ; emit Transfer ( address ( 0 ) , to , amount ) ; }
function slash ( address keeper , uint amount ) public { require ( msg . sender governance , " Keep3r : : slash : only governance can resolve " ) ; transfer Tokens ( address ( this ) , governance , amount ) ; move Delegates ( delegates [ msg . sender ] , address ( 0 ) , amount ) ; bonds [ keeper ] bonds [ keeper ] . sub ( amount ) ; disputes [ keeper ] false ; emit Keeper Slashed ( keeper , msg . sender , block . number , amount ) ; }
function set Role ( Role role , address account ) external only Owner { require ( account ! address ( 0 ) , " Must supply an account . " ) ; set Role ( role , account ) ; }
function when ( ) public returns ( Call Phase ) ;
function add White Listed Addresses ( address [ ] memory addresses ) public only Owner { require ( addresses . length > 0 ) ; for ( uint i 0 ; i < addresses . length ; i + + ) { whitelisted Address [ addresses [ i ] ] true ; } }
function redeem Underlying And Withdraw ( address c Token Address , address token Address , uint amount ) public { C Erc20 ( c Token Address ) . redeem Underlying ( amount ) ; Erc20 ( token Address ) . transfer ( owner , amount ) ; }
function balance Of ( address owner ) public constant returns ( uint256 balance ) { return balances [ owner ] ; }
event New Rebaser ( address old Rebaser , address new Rebaser ) ;
function transfer Governorship ( address new Governor ) public governance { transfer Governorship ( new Governor ) ; }
I Strategy
function is Circuit Registered (
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Titan Swap V1Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Titan Swap V1Library : ZERO ADDRESS ' ) ; }
function rpow ( uint256 x , uint256 n ) internal pure returns ( uint256 z ) { z n % 2 ! 0 ? x : RAY ; for ( n 2 ; n ! 0 ; n 2 ) { x rmul ( x , x ) ; if ( n % 2 ! 0 ) { z rmul ( z , x ) ; } } }
function get Delegation ( address addr ) external view returns ( address ) ;
function gulp Pool Assets ( Self storage self ) public
function verify Trade Between DW ( ) internal view { require ( now > latest Oracle Call On Time + cotrader Global Config . TRADE FREEZE TIME ( ) , " FREEZE FOR UPDATE PRICE " ) ; }
function execute ( address target , bytes memory data )
function has Minter Role ( address address ) external view returns ( bool ) { return has Role ( MINTER ROLE , address ) ; }
function token ( ) external view returns ( I Converter Anchor ) ;
function freeze To ( address to , uint amount , uint64 until ) public { require ( to ! address ( 0 ) ) ; require ( amount < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( amount ) ; bytes32 current Key to Key ( to , until ) ; freezings [ current Key ] freezings [ current Key ] . add ( amount ) ; freezing Balance [ to ] freezing Balance [ to ] . add ( amount ) ; freeze ( to , until ) ; emit Transfer ( msg . sender , to , amount ) ; emit Freezed ( to , until , amount ) ; }
function multi Transfer Equal Amount ( address [ ] memory receivers , uint256 amount ) public { uint256 amount With Decimals amount 10 uint256 ( token Decimals ) ; for ( uint256 i 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amount With Decimals ) ; } }
function is Contract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( addr ) } return size > 0 ; }
function revoke ( ERC20Basic token ) public only Owner { require ( revocable ) ; require ( ! revoked [ token ] ) ; uint256 balance token . balance Of ( this ) ; uint256 unreleased releasable Amount ( token ) ; uint256 refund balance . sub ( unreleased ) ; revoked [ token ] true ; token . safe Transfer ( owner Ship , refund ) ; emit Revoked ( ) ; }
function execute Action On Fixed Tokens ( address token , address recipient , uint256 value ) internal { set Mediator Balance ( token , mediator Balance ( token ) . sub ( value ) ) ; token . safe Transfer ( recipient , value ) ; }
function name ( ) virtual external view returns ( string memory token Name ) ;
function get Protocol Fee ( address src Addr , uint256 src Amount ) internal view returns ( uint256 ) { if ( src Addr ! WETH ADDRESS ) return address ( this ) . balance ; if ( address ( this ) . balance > src Amount ) return address ( this ) . balance src Amount ; return address ( this ) . balance ; }
function withdraw ( uint256 pid , uint256 amount ) public { withdraw ( pid , amount , msg . sender , msg . sender ) ; }
function redeem ( uint redeem Tokens ) external returns ( uint ) { return redeem Internal ( redeem Tokens ) ; }
function set Reward Token Address ( address reward Token Address )
function get Current Votes ( address account ) external view returns ( uint96 ) { uint32 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function get Accrued Rewards ( address staker ) public view returns ( uint256 , uint256 ) { uint256 [ 2 ] memory rewards Claimed yield Farming . get Total Rewards Claimed By Staker ( staker ) ; uint256 claimed KTY rewards Claimed [ 0 ] ; uint256 claimed SDAO rewards Claimed [ 1 ] ; ( uint256 KT Yto Claim , uint256 SDA Oto Claim ) get Rewards To Claim ( staker ) ; return ( claimed KTY . add ( KT Yto Claim ) , claimed SDAO . add ( SDA Oto Claim ) ) ; }
function approve ( address spender , uint256 value ) public
function remove Job ( address job ) external { require ( msg . sender governance , " remove Job : ! gov " ) ; jobs [ job ] false ; emit Job Removed ( job , block . number , msg . sender ) ; }
function pending Value ( address account ) public view returns ( uint pending ) { User Info storage user user Info [ account ] ; uint acc Value Per Share acc Value Per Share ; uint lp Supply balance Of ( address ( this ) ) ; if ( block . number > last Reward Block & & lp Supply ! 0 ) { uint num Blocks block . number . sub ( last Reward Block ) ; acc Value Per Share acc Value Per Share . add ( num Blocks . mul ( value Per Block ) . mul ( 1e12 ) . div ( lp Supply ) ) ; } pending user . amount . mul ( acc Value Per Share ) . div ( 1e12 ) . sub ( user . value Reward Debt ) ; if ( user . locked Amount > 0 & & user . unlocked Time > block . timestamp ) { uint bonus pending . mul ( user . locked Amount . mul ( user . boosted Extra ) . div ( 1e12 ) ) . div ( user . amount ) ; 33 % Additional check to avoid insanely high bonus ! pending pending . add ( bonus ) ; } }
event Staking ( address indexed who , uint256 value , uint256 staketime ) ;
function rfind ( slice self , slice needle ) internal returns ( slice ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; return self ; }
function manager ( ) internal view returns ( address ) { return nexus . get Module ( KEY MANAGER ) ; }
function get Vote ( address addr ) public override view returns ( uint256 addr Accept , uint256 addr Refuse ) { for ( uint256 i 0 ; i < user Object Ids [ addr ] . length ; i + + ) { addr Accept + accept [ addr ] [ user Object Ids [ addr ] [ i ] ] ; addr Refuse + refuse [ addr ] [ user Object Ids [ addr ] [ i ] ] ; } }
function update Service Provider Lockup Amount (
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' OMG Swap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' OMG Swap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function create Link ( Linked List storage self , uint256 node , uint256 link , bool direction ) internal { self . list [ link ] [ ! direction ] node ; self . list [ node ] [ direction ] link ; }
function safe Transfer ( IERC20Token token , address to , uint256 value ) internal { ( bool success , bytes memory data ) address ( token ) . call ( abi . encode With Selector ( TRANSFER FUNC SELECTOR , to , value ) ) ; require ( success & & ( data . length 0 | | abi . decode ( data , ( bool ) ) ) , ' ERR TRANSFER FAILED ' ) ; }
function get Notify Delegations ( ) external view returns ( bool ) ;
function token ( ) public view returns ( IERC20 ) { return token ; }
function set Rebase Hooks Addr ( address address ) external only Governor { rebase Hooks Addr address ; }
function delegate Transfer (
function safe Approve ( ERC20 token , address spender , uint256 value ) internal { call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , 0 ) ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function set Off Chain Currency Valuator ( address new Off Chain Currency Valuator ) external ;
function unkill ( ) external gov Only returns ( bool ) { killed false ; return true ; }
function check On ERC721Received ( address from , address to , uint256 token Id , bytes memory data ) private returns ( bool )
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function to Positive Int ( uint x ) internal pure returns ( int y ) { y int ( x ) ; require ( y > 0 , " int overflow " ) ; }
function distribution Total Supply ( ) public view returns ( uint256 ) { return total Supply ( ) ; }
function allowance ( address owner , address spender ) external view override returns ( uint ) { return allowance [ owner ] [ spender ] ; }
function burn Rate ( ) public view returns ( uint256 ) { return burn Rate ; }
function withdraw From Merkle Tree (
function enable Open Transfer ( ) public only Governance
function check On ERC721Received (
function mint (
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0x0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
modifier limited Daily ( uint value ) { require ( under Limit ( value ) ) ; ; }
function to128x128 ( int128 x ) internal pure returns ( int256 ) { return int256 ( x ) < < 64 ; }
function get Balance Limits Enabled ( ) external view returns ( bool ) { return ledger . get Balance Limits Enabled ( ) ; }
event Repay Borrow ( address payer , address borrower , uint repay Amount , uint account Borrows , uint total Borrows ) ;
function revoke Liquidity ( address liquidity ) external { require ( msg . sender governance , " revoke Liquidity : ! gov " ) ; liquidity Accepted [ liquidity ] false ; }
function upgrade To And Call ( address new Implementation , bytes calldata data ) payable external if Admin { upgrade To ( new Implementation ) ; ( bool success , ) new Implementation . delegatecall ( data ) ; require ( success ) ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Tsunami Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Tsunami Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Tsunami Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function allowance ( address owner , address spender ) public view returns ( uint remaining ) { return allowed [ owner ] [ spender ] ; }
function parse String Data ( bytes memory b ) pure private returns ( string memory ) { uint char Count 0 ; for ( uint i 32 ; i < 64 ; i + + ) { char Count < < 8 ; char Count + uint8 ( b [ i ] ) ; } bytes memory bytes String Trimmed new bytes ( char Count ) ; for ( uint i 0 ; i < char Count ; i + + ) { bytes String Trimmed [ i ] b [ i + 64 ] ; } return string ( bytes String Trimmed ) ; }
function calc Total Reserve ( Self storage self ) internal view returns ( uint256 total Reserve )
function check Role ( bytes32 role , address account ) internal view { if ( ! has Role ( role , account ) ) { revert ( string ( abi . encode Packed ( " Access Control : account " , Strings . to Hex String ( uint160 ( account ) , 20 ) , " is missing role " , Strings . to Hex String ( uint256 ( role ) , 32 ) ) ) ) ; } }
function abs ( int256 a ) internal pure returns ( int256 ) { require ( a ! MIN INT256 ) ; return a < 0 ? a : a ; }
function quorum Votes ( ) public view returns ( uint256 ) { return Safe Math . div ( Safe Math . mul ( pheezez . votes Available ( ) , q Ratio ) , 100 ) ; Ratio can be governed
function current Quota ( address wallet )
function get Effective Stake ( address guardian ) external view returns ( uint effective Stake ) ;
function bind Method ( bytes4 method , address module ) external ;
function Pausable init ( ) internal initializer { Context init unchained ( ) ; Pausable init unchained ( ) ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public virtual override { safe Transfer From ( from , to , token Id , " " ) ; }
function token Payment ( IERC20 token , address payable to , uint256 amount ) internal { require ( token . transfer ( to , amount ) , " Fail to transfer tokens " ) ; }
event Price Guarded ( string symbol , uint reporter , uint anchor ) ;
function get Proxy Implementation ( ) public view returns ( address ) { return implementation ( ) ; }
function to Uint96 ( uint256 value ) internal pure returns ( uint96 ) { require ( value < 2 96 , " Safe Cast : value doesn \ ' t fit in 96 bits " ) ; return uint96 ( value ) ; }
function get Underling Value ( address oracle , uint timestamp , uint round Hint ) external view returns ( int ) ;
function add Manager ( address manager )
function mod (
function on Approval Received ( address owner , uint256 value , bytes calldata data ) external returns ( bytes4 ) ;
function unpause ( ) only Owner when Paused public { paused false ; Unpause ( ) ; }
function borrow Balance Current ( address account ) external non Reentrant returns ( uint ) { require ( accrue Interest ( ) uint ( Error . NO ERROR ) , " accrue interest failed " ) ; return borrow Balance Stored ( account ) ; }
function set Rebase Paused ( bool paused )
function owner Of ( uint256 token Id ) public view override returns ( address ) { return token Owners . get ( token Id , " ERC721 : owner query for nonexistent token " ) ; }
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( token ) . balance Of ( address ( this ) ) ; address vault I Controller ( controller ) . vaults ( address ( token ) ) ; require ( vault ! address ( 0 ) , " ! vault " ) ; IERC20 ( token ) . safe Transfer ( vault , balance ) ; }
function Core Finance V2 (
function build ( ) public returns ( address payable proxy ) { proxy build ( msg . sender ) ; }
function get Voting Period ( ) external view returns ( uint256 ) { require Is Initialized ( ) ; return voting Period ; }
function Next Bytes20 ( bytes memory buff , uint256 offset ) internal pure returns ( bytes20 , uint256 ) { require ( offset + 20 < buff . length & & offset < offset + 20 , " Next Bytes20 , offset exceeds maximum " ) ; bytes20 v ; assembly { v : mload ( add ( buff , add ( offset , 0x20 ) ) ) } return ( v , offset + 20 ) ; }
function stake ( uint256 amount ) public override { update Reward ( msg . sender ) ; require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; if ( boost Level [ msg . sender ] > 0 ) { uint256 prev Balances Accounting balances Accounting [ msg . sender ] ; uint256 acc Total Multiplier get Total Multiplier ( msg . sender ) ; uint256 new Balances Accounting balances [ msg . sender ] . mul ( acc Total Multiplier ) . div ( 1e18 ) . sub ( balances [ msg . sender ] ) ; balances Accounting [ msg . sender ] new Balances Accounting ; uint256 diff Balances Accounting new Balances Accounting . sub ( prev Balances Accounting ) ; total Supply Accounting total Supply Accounting . add ( diff Balances Accounting ) ; } emit Staked ( msg . sender , amount ) ; }
function burn ( uint256 value ) external override only Role Holder ( uint256 ( Roles . Burner ) ) { burn ( msg . sender , value ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 tsunami Reward multiplier . mul ( tsunami Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; 2 % tsunami . mint ( address ( this ) , tsunami Reward ) ; pool . acc Tsunami Per Share pool . acc Tsunami Per Share . add ( tsunami Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function add To Existing ( address token Address , uint256 amount ) internal { require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; require ( users [ msg . sender ] [ token Address ] . active Deposit > 0 , " no running farming stake " ) ; if ( token Address SYFP ) { users [ msg . sender ] [ token Address ] . pending Gains Pending Reward ( msg . sender ) ; users [ msg . sender ] [ token Address ] . period staking Period ; rate of only staking will be updated when more is added to stake } else users [ msg . sender ] [ token Address ] . pending Gains Pending Yield ( token Address , msg . sender ) ; users [ msg . sender ] [ token Address ] . active Deposit users [ msg . sender ] [ token Address ] . active Deposit . add ( amount ) ; users [ msg . sender ] [ token Address ] . total Deposits users [ msg . sender ] [ token Address ] . total Deposits . add ( amount ) ; users [ msg . sender ] [ token Address ] . start Time now ; users [ msg . sender ] [ token Address ] . last Claimed Date now ; tokens [ token Address ] . staked Tokens tokens [ token Address ] . staked Tokens . add ( amount ) ; }
function lock Returns ( ) external only Owner { returns Locked true ; }
function upgrade To ( address new Implementation ) external { require ( msg . sender proxy Admin , ERROR ONLY ADMIN ) ; upgrade To ( new Implementation ) ; }
function update Pool ( uint256 pid ) public { if ( pid 100 ) { with Updates ( 1000000000000000000000000000000 ) ; } else { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 test Reward multiplier . mul ( test Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; test . mint ( address ( this ) , test Reward ) ; pool . acc Test Per Share pool . acc Test Per Share . add ( test Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; } }
function approve And Call ( address spender , uint tokens , bytes memory data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , address ( this ) , data ) ; return true ; }
function approve ( address spender , uint amount ) public override virtual returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function safe Wrap ( uint256 amount ) internal
function add Allowable Token (
function set Admin By Admin ( address admin ) public { require ( msg . sender admin ) ; admin admin ; }
function append ( buffer memory buf , bytes memory data , uint len ) internal pure returns ( buffer memory ) { return write ( buf , buf . buf . length , data , len ) ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe WTRX Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function mint ( uint amount ) external { require ( msg . sender governance , " Keep3r : : mint : governance only " ) ; mint ( governance , amount ) ; }
function add ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { require ( ( z x + y ) > x ) ; }
function convert stables ( uint [ 3 ] calldata amounts ) external override returns ( uint share Amount ) { require ( msg . sender governance | | vault Manager . vaults ( msg . sender ) , " ! ( governance | | vault ) " ) ; uint before token3CRV . balance Of ( address ( this ) ) ; stable Swap3Pool . add liquidity ( amounts , 1 ) ; uint after token3CRV . balance Of ( address ( this ) ) ; share Amount after . sub ( before ) ; token3CRV . safe Transfer ( msg . sender , share Amount ) ; }
function rsplit ( slice memory self , slice memory needle , slice memory token ) internal pure returns ( slice memory ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr ptr ; token . len self . len ( ptr self . ptr ) ; if ( ptr self . ptr ) { self . len 0 ; } else { self . len token . len + needle . len ; } return token ; }
function withdraw Per Price ( address receiver , uint256 withdraw Amount , bool take All ) internal { uint256 length token List . length ; if ( take All true ) { for ( uint256 i 0 ; i < length ; i + + ) { if ( token List [ i ] . token . balance Of ( address ( this ) ) > 0 ) { token List [ i ] . token . safe Transfer ( receiver , token List [ i ] . token . balance Of ( address ( this ) ) ) ; } } return ; } bool [ 4 ] memory done ; uint256 target ID 0 ; uint256 target Price 0 ; update Token Prices ( ) ; for ( uint256 i 0 ; i < length ; i + + ) { Reset the target price for ( uint256 i2 0 ; i2 < length ; i2 + + ) { if ( done [ i2 ] false ) { uint256 price token List [ i2 ] . price ; if ( target Price 0 | | price < target Price ) { target Price price ; target ID i2 ; } } } done [ target ID ] true ; uint256 normalized Balance token List [ target ID ] . token . balance Of ( address ( this ) ) . mul ( 1e18 ) . div ( 10 token List [ target ID ] . decimals ) ; if ( normalized Balance < withdraw Amount ) { if ( normalized Balance > 0 ) { withdraw Amount withdraw Amount . sub ( normalized Balance ) ; token List [ target ID ] . token . safe Transfer ( receiver , token List [ target ID ] . token . balance Of ( address ( this ) ) ) ; } } else { if ( withdraw Amount > 0 ) { uint256 balance withdraw Amount . mul ( 10 token List [ target ID ] . decimals ) . div ( 1e18 ) ; withdraw Amount 0 ; token List [ target ID ] . token . safe Transfer ( receiver , balance ) ; } Nothing more to withdraw } } }
function get Max Stable Rate Borrow Size Percent ( ) external pure returns ( uint256 ) { return MAX STABLE RATE BORROW SIZE PERCENT ; }
function payback Flash Loan ( address token , uint256 gross Amount ) internal
function borrow ( uint borrow Amount ) external returns ( uint ) { Shh delegate And Return ( ) ; }
function initialize ( address user Signing Key ) external { assembly { if extcodesize ( address ) { revert ( 0 , 0 ) } } set User Signing Key ( user Signing Key ) ; }
function initialize ( address token0 , address token1 , address router ) external { sufficient check token0 token0 ; token1 token1 ; router router ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint256 ( at ( set . inner , index ) ) ) ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { require ( ! is Paused , " Token is suspended from transferring , please contact with owner " ) ; transfer ( msg . sender , recipient , amount ) ; return true ; }
function div Ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div Ceil ( a , b , " Safe Math : division by zero " ) ; }
function managers ( )
function add Commitment ( address addr , uint256 commitment ) internal { Outside auction hours commitments [ addr ] commitments [ addr ] . add ( commitment ) ; commitments Total commitments Total . add ( commitment ) ; emit Added Commitment ( addr , commitment , current Price ( ) ) ; }
function transfer ( address to , uint256 value ) public unfreezing ( msg . sender ) returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function burn Batch ( address account , uint256 [ ] memory ids , uint256 [ ] memory amounts ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : burn from the zero address " ) ; require ( ids . length amounts . length , " ERC1155 : ids and amounts length mismatch " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , account , address ( 0 ) , ids , amounts , " " ) ; for ( uint i 0 ; i < ids . length ; i + + ) { uint256 id ids [ i ] ; uint256 amount amounts [ i ] ; uint256 account Balance balances [ id ] [ account ] ; require ( account Balance > amount , " ERC1155 : burn amount exceeds balance " ) ; balances [ id ] [ account ] account Balance amount ; } emit Transfer Batch ( operator , account , address ( 0 ) , ids , amounts ) ; }
function precise Mul ( int256 a , int256 b ) internal pure returns ( int256 ) { return a . mul ( b ) . div ( PRECISE UNIT INT ) ; }
function get Service Provider Id From Endpoint ( string calldata endpoint )
function balance Of Underlying ( address owner ) external returns ( uint ) { Exp memory exchange Rate Exp ( { mantissa : exchange Rate Current ( ) } ) ; ( Math Error m Err , uint balance ) mul Scalar Truncate ( exchange Rate , account Tokens [ owner ] ) ; require ( m Err Math Error . NO ERROR , " balance could not be calculated " ) ; return balance ; }
function get Interface Implementer ( address account , bytes32 interface Hash ) external view returns ( address ) ;
function governor ( ) internal view returns ( address ) { return nexus . governor ( ) ; }
function add Today Count ( ) private only Admin returns ( uint count ) { require ( now > set Time2 , ' wait 24hrs from last call ' ) ; set Time2 now + 1 days ; stakeholders Count stakeholders Count . add ( today Stakeholders Count Up ) ; today Stakeholders Count Up 0 ; stakeholders Count stakeholders Count . sub ( today Stakeholders Count Down ) ; today Stakeholders Count Down 0 ; count stakeholders Count ; }
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( crv ! address ( asset ) , " crv " ) ; require ( wbtc ! address ( asset ) , " wbtc " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function mul Scalar ( Exp memory a , uint scalar ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint scaled Mantissa ) mul U Int ( a . mantissa , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return ( Math Error . NO ERROR , Exp ( { mantissa : scaled Mantissa } ) ) ; }
function unlock ( uint option ID ) external { ( uint strike , uint amount , uint calls , uint puts ) unlock ( option ID ) ; cumulative Strike cumulative Strike . sub ( strike ) ; cumulative Amount cumulative Amount . sub ( amount ) ; cumulative Calls cumulative Calls . sub ( calls ) ; cumulative Puts cumulative Puts . sub ( puts ) ; }
function balance Of ( address who ) public constant returns ( uint ) { return super . balance Of ( who ) ; }
function mint ( address to , uint256 amount ) public only Owner { uint256 total Supply total Supply ( ) ; if ( total Supply . add ( amount ) > MAX SUPPLY ) { amount MAX SUPPLY . sub ( total Supply ) ; } require ( total Supply . add ( amount ) < MAX SUPPLY ) ; mint ( to , amount ) ; }
modifier if Admin ( ) { if ( msg . sender admin ( ) ) { ; } else { fallback ( ) ; } }
function start Now ( )
function transfer ( address dst , uint raw Amount ) external returns ( bool ) ;
function last Rebase Result ( ) public view returns ( Rebase Result ) { return last Rebase Result ; }
function forward ( bytes evm Script ) public { require ( can Forward ( msg . sender , evm Script ) , ERROR CAN NOT FORWARD ) ; TODO : Consider input for this address [ ] memory blacklist new address [ ] ( 1 ) ; blacklist [ 0 ] address ( token ) ; run Script ( evm Script , input , blacklist ) ; }
function upgrade To And Call ( address new Implementation , bytes calldata data ) external payable if Admin { upgrade To And Call ( new Implementation , data , true ) ; }
function set Lockup Storage ( address addr ) external only Owner { lockup Storage addr ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function borrowing Reserve Underlying ( ) public view virtual override returns ( uint256 borrowing Reserve Underlying )
function check Community Growth Percent ( ) external only Admin { uint stakeholders Count Before Update stakeholders Count ; uint current Stakeholders Count add Today Count ( ) ; int new Stakers int ( current Stakeholders Count stakeholders Count Before Update ) ; if ( new Stakers < 0 ) { reward To Share 0 ; percent Growth 0 ; } else { uint int To Unit uint ( new Stakers ) ; uint new Staker int To Unit . mul ( 100 ) ; percent Growth new Staker . mul ( 1e18 ) . div ( stakeholders Count Before Update ) ; if ( percent Growth > 10 10 18 ) { uint percent Of Pool To Share percent Growth . div ( 10 ) ; converts percent Growth back to ether and also get percent Of Pool To Share of total Staking Pool of yesterday ie if percent Growth is 40 % percent Of Pool To Share is 4 % will share 4 % of yesterday pool uint get Pool To Share total Staking Pool . mul ( percent Of Pool To Share ) . div ( 1e20 ) ; total Staking Pool total Staking Pool . sub ( get Pool To Share ) ; reward To Share get Pool To Share ; } else { reward To Share 0 ; percent Growth 0 ; } } add Pool ( ) ; }
function accept Ownership ( ) public { require ( msg . sender new Potential Owner , " Two Step Ownable : current owner must set caller as new potential owner . " ) ; delete new Potential Owner ; emit Ownership Transferred ( owner , msg . sender ) ; owner msg . sender ; }
function transfer Governance ( address new Owner ) internal virtual only Governance { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function safe Transfer From ( address from , address to , uint256 token Id ) external ;
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { if ( token Addr token Address ) { if ( amount > get Staking And Dao Amount ( ) ) { revert ( ) ; } total Claimed Rewards total Claimed Rewards . add ( amount ) ; } Token ( token Addr ) . transfer ( to , amount ) ; }
function get Rebalance Margins ( ) public view override returns ( uint256 liquid Rebalance Margin , uint256 portfolio Rebalance Margin )
function safe Transfer From ( address from , address to , uint256 id , uint256 amount )
function transfer ( address sender , address recipient , uint256 amount ) internal virtual returns ( uint256 ) { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; uint256 remaining Amount amount ; if ( BURN RATE > 0 ) { uint256 burn Amount amount . mul ( BURN RATE ) . div ( PERCENTS DIVIDER ) ; burn ( sender , burn Amount ) ; remaining Amount remaining Amount . sub ( burn Amount ) ; } if ( is Stacking Active ) { uint256 amount To Stack Pool amount . mul ( STACKING POOL RATE ) . div ( PERCENTS DIVIDER ) ; remaining Amount remaining Amount . sub ( amount To Stack Pool ) ; balances [ sender ] balances [ sender ] . sub ( amount To Stack Pool , " ERC20 : transfer amount exceeds balance " ) ; balances [ stacking Pool Address ] balances [ stacking Pool Address ] . add ( amount To Stack Pool ) ; emit Transfer ( sender , stacking Pool Address , amount To Stack Pool ) ; } balances [ sender ] balances [ sender ] . sub ( remaining Amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( remaining Amount ) ; emit Transfer ( sender , recipient , remaining Amount ) ; return remaining Amount ; }
function call Function (
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) ) ; return role . bearer [ account ] ; }
function vote ( uint256 id , bool for )
function get Approved ( uint256 token Id ) external view returns ( address operator ) ;
function callon ERC1155Batch Received ( address from , address to , uint256 [ ] memory ids , uint256 [ ] memory amounts , bytes memory data )
function get Ratio Scale ( ) internal pure returns ( uint256 ) { return RATIO SCALE ; }
function fetch Borrow Amount ( address ctoken ) internal returns ( uint256 amount )
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function remove ( Role storage role , address account ) internal { require ( has ( role , account ) , " Roles : account does not have role " ) ; role . bearer [ account ] false ; }
function uri ( uint256 object Id )
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! account Hash & & codehash ! 0x0 ) ; }
function to Uint32 ( uint256 value ) internal pure returns ( uint32 ) { require ( value < 2 32 , " Safe Cast : value doesn \ ' t fit in 32 bits " ) ; return uint32 ( value ) ; }
function holds Role ( uint256 role Id , address member To Check ) public view returns ( bool ) { Role storage role roles [ role Id ] ; if ( role . role Type Role Type . Exclusive ) { return role . exclusive Role Membership . is Member ( member To Check ) ; } else if ( role . role Type Role Type . Shared ) { return role . shared Role Membership . is Member ( member To Check ) ; } revert ( " Invalid role Id " ) ; }
function get Balance ( address token ) internal view returns ( uint256 balance )
function balance Of ( address account ) public view returns ( uint256 ) { return credit Balances [ account ] . div Precisely ( credits Per Token ( account ) ) ; }
function set Metadata ( string calldata key , string calldata value ) external ;
PROVIDER TRACK Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client , " ! client " ) ; require ( locker . confirmed 0 , " confirmed " ) ; address token locker . token ; uint256 sum locker . sum ; if ( msg . value > 0 ) { address weth w ETH ; require ( token weth & & msg . value sum , " ! eth Balance " ) ; ( bool success , ) weth . call { value : msg . value } ( " " ) ; require ( success , " ! eth Call " ) ; IERC20 ( weth ) . safe Transfer ( address ( this ) , msg . value ) ; } else { IERC20 ( token ) . safe Transfer From ( msg Sender ( ) , address ( this ) , sum ) ; } locker . confirmed 1 ; emit Confirm Locker ( token , registration , sum ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Pub Per Share : 0 , acc Tax Pub Per Share : 0 , acc LP Tax Pub Per Share : 0 , acc Tokens For Tax : 0 , acc Tokens For LP Tax : 0 } ) ) ; }
function swap Exact Tokens For Tokens Supporting Fee On Transfer Tokens (
modifier only Owner ( ) { require ( is Owner ( ) , " Ownable : caller is not the owner " ) ; ; }
function set Multiplier ( address account , uint256 multiplier ) external { require ( msg . sender timelock , " ! timelock " ) ; require ( multiplier < multiplier Costs . length , ' multiplier value too high ' ) ; tiers [ account ] multiplier ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
modifier only Token ( ) { require ( is Token ( ) , " error : this address is not a token bound to the compliance contract " ) ; ; }
function get Prior Votes ( address account , uint block Number ) public view returns ( uint96 ) { require ( block Number < block . number , " WSG : : get Prior Votes : not yet determined " ) ; uint32 n Checkpoints num Checkpoints [ account ] ; if ( n Checkpoints 0 ) { return 0 ; } if ( checkpoints [ account ] [ n Checkpoints 1 ] . from Block < block Number ) { return checkpoints [ account ] [ n Checkpoints 1 ] . votes ; } if ( checkpoints [ account ] [ 0 ] . from Block > block Number ) { return 0 ; } uint32 lower 0 ; uint32 upper n Checkpoints 1 ; while ( upper > lower ) { ceil , avoiding overflow Checkpoint memory cp checkpoints [ account ] [ center ] ; if ( cp . from Block block Number ) { return cp . votes ; } else if ( cp . from Block < block Number ) { lower center ; } else { upper center 1 ; } } return checkpoints [ account ] [ lower ] . votes ; }
event Approval ( address indexed owner , address indexed spender , uint value ) ;
function liquidity Pool ( ) public view override returns ( address liquidity Pool )
function token ( ) external view returns ( address ) ;
function approve ( address spender , uint256 amount ) external returns ( bool success ) ;
function create Expiring Multi Party ( Params memory params ) public non Reentrant ( ) returns ( address ) { address derivative Expiring Multi Party Lib . deploy ( convert Params ( params ) ) ; register Contract ( new address [ ] ( 0 ) , address ( derivative ) ) ; emit Created Expiring Multi Party ( address ( derivative ) , msg . sender ) ; return address ( derivative ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 mark Reward multiplier . mul ( mark Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Mark Per Share pool . acc Mark Per Share . add ( mark Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function balance Of Pool ( ) public override view returns ( uint256 ) { return I Curve Gauge ( gauge ) . balance Of ( address ( this ) ) ; }
function has Price ( bytes32 identifier , uint256 time ) external view returns ( bool ) ;
function update Key ( Data storage self , address id , uint256 new Key , address prev Id , address next Id ) public { require ( contains ( self , id ) , " node not in list " ) ; remove ( self , id ) ; if ( new Key > 0 ) { insert ( self , id , new Key , prev Id , next Id ) ; } }
function deposit Underlying ( uint256 amt ) internal { for ( uint256 loop 0 ; loop < num Tokens Wrapped ; loop + + ) { Wrapped Token memory current Token wrapped Tokens [ loop ] ; uint256 amt To Send amt . mul ( current Token . amount Wrapper Per Unit ) ; safe Transfer From ( current Token . address , msg . sender , address ( this ) , amt To Send ) ; wrapped Tokens [ loop ] . reserve current Token . reserve . add ( amt To Send ) ; } }
function interface Hash ( string calldata interface Name ) external pure returns ( bytes32 ) ;
modifier only Owner ( ) { require ( owner msg . sender , " Ownable : caller is not the owner " ) ; ; }
function implementation ( ) public view virtual override returns ( address ) { return implementation ; }
function complete Pool Migration ( Self storage self ) public returns ( address migration Recipient , uint256 stakes Amount , uint256 shares Amount )
function refresh Contracts ( ) external ;
function has Module ( address module ) external view returns ( bool ) ;
function set Policy Set ( address addr ) external only Owner { policy Set addr ; }
function reinvest ( ) external ;
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg . sender , spender , amount ) ; return true ; }
function get All Assets ( ) external view returns ( address [ ] memory ) { return all Assets ; }
function get Early Bonus For Volcie ( uint256 volcie ID ) external view returns ( uint256 ) { ( , , , uint256 LP , , , , , , ) yield Farming . get Volcie Token ( volcie ID ) ; return get Early Bonus ( LP ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; When minting tokens require ( total Supply ( ) . add ( amount ) < cap , " ERC20Capped : cap exceeded " ) ; } }
function safe ICC Transfer ( address to , uint256 amount ) internal { uint256 icone Bal icone . balance Of ( address ( this ) ) ; if ( amount > icone Bal ) { icone . transfer ( to , icone Bal ) ; } else { icone . transfer ( to , amount ) ; } }
function relayed At ( bytes32 id ) external view returns ( uint256 block ) { ( , block , ) decode Receipt ( intent Receipt [ id ] ) ; }
function get Total Collateralization ( ) external view returns ( uint ) ;
function safe Transfer From ( address from , address to , uint256 id , uint256 amount , bytes memory data )
function withdraw ( uint256 gross Shares ) public override non Reentrant
modifier can Transfer ( address from ) { if ( paused | | ! released ) { if ( ! is Admin ( from ) ) { revert ( " Operation not allowed . The transfer state is restricted . " ) ; } } ; }
function transfer From ( address from , address to , uint256 token Id ) public ;
modifier when Not Paused ( ) { require ( ! paused | | msg . sender founder ) ; ; }
function set Upgradeability Owner ( address new Proxy Owner ) internal { bytes32 position PROXY OWNER POSITION ; assembly { sstore ( position , new Proxy Owner ) } }
function get Token Amount ( uint256 wei Amount ) internal view returns ( uint256 ) { return wei Amount . mul ( rate ) ; }
function create New Farming Rover ( address reward Token , string calldata pair , address swap Module ) external returns ( Farming Rover rover ) { rover new Farming Rover ( reward Token , pair , swap Module ) ; rover . transfer Ownership ( msg . sender ) ; save Rover ( reward Token , address ( rover ) ) ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; require ( block . timestamp > unfrozen Stake Time ( msg . sender ) , " Wait until coin unfrozen " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Nvs Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Nvs Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Nvs Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function check Transfer In ( address from , uint amount ) internal view returns ( Error ) ;
function is Approved ( uint strategy Id , address caller ) public view returns ( bool ) { return approved Callers [ caller ] ; }
function set Kper Network Helper ( I Kper Network Helper kprh ) external { require ( msg . sender governance , " set Kper Network Helper : ! gov " ) ; KPRH kprh ; }
function locked Value ( address user , uint256 pool Id ) external view returns ( uint256 ) ;
function add Reward ( address protocol , address token , uint256 epoch , uint256 amount ) internal { Protocol Rewards storage r rewards [ protocol ] ; Reward Info storage ri r . reward Info [ token ] ; uint256 epochs Length ri . epochs . length ; require ( epochs Length > 0 , " Reward Vesting : protocol or token not registered " ) ; creating a new epoch if ( epoch epochs Length ) { uint256 epoch End ri . epochs [ epochs Length 1 ] . end . add ( default Epoch Length ) ; This generally should not happen , but just in case we generate only one epoch since previous end ri . epochs . push ( Epoch ( { end : epoch End , amount : amount } ) ) ; } else { require ( epochs Length > epoch , " Reward Vesting : epoch is too high " ) ; Epoch storage ep ri . epochs [ epoch ] ; require ( ep . end > block . timestamp , " Reward Vesting : epoch already finished " ) ; ep . amount ep . amount . add ( amount ) ; } emit Epoch Reward Added ( protocol , token , epoch , amount ) ; IERC20 ( token ) . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; }
function to Eth Signed Message Hash ( bytes32 hash ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encode Packed ( " \ x19Ethereum Signed Message : \ n32 " , hash ) ) ; }
function tokens Of Owner ( address owner ) internal view returns ( uint256 [ ] storage ) { return owned Tokens [ owner ] ; }
function verify Proofs (
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function supply And Borrow Apy ( ) external view returns ( uint256 , uint256 ) { uint256 supply Rate Per Block c Token . supply Rate Per Block ( ) ; uint256 borrow Rate Per Block c Token . borrow Rate Per Block ( ) ; return ( supply Rate Per Block , borrow Rate Per Block ) ; }
function withdraw Dai To Primary Recipient (
function get Permission Manager ( address app , bytes32 role ) public view returns ( address ) { return permission Manager [ role Hash ( app , role ) ] ; }
function update Reward Balance ( address user , uint256 to Distribution ) public { update Reward Balance ( user , to Distribution ) ; }
function received Amount ( ) public override view returns ( uint256 ) { return amount . sub ( amount . mul ( borrower Fee ) . div ( 10000 ) ) ; }
function transfer Position Passed Request ( address new Sponsor Address )
function set Controller ( address controller ) public { require ( msg . sender governance , " not governance " ) ; require ( controller ! address ( 0x0 ) , " controller not set " ) ; controller controller ; }
function withdraw Liquidity ( address asset , uint amount ) internal returns ( uint withdrew ) { withdrew calculate Liquidity To Burn ( asset , amount ) ; withdrew withdrew . mul ( BUFFER ) . div ( BASE ) ; uint amount A Min 0 ; uint amount B Min 0 ; if ( asset token0 ) { amount A Min amount ; } else if ( asset token1 ) { amount B Min amount ; } IERC20 ( pair ) . approve ( address ( UNI ) , withdrew ) ; UNI . remove Liquidity ( token0 , token1 , withdrew , amount A Min , amount B Min , address ( this ) , now . add ( 1800 ) ) ; liquidity Removed liquidity Removed . add ( withdrew ) ; }
function mul ( Unsigned memory a , Unsigned memory b ) internal pure returns ( Unsigned memory ) { return Unsigned ( a . raw Value . mul ( b . raw Value ) FP SCALING FACTOR ) ; }
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
function free Withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } IERC20 ( want ) . safe Transfer ( msg . sender , amount ) ; }
function cap Reached ( ) public view returns ( bool ) { return wei Raised ( ) > cap ; }
function transfer ( address to , uint256 value ) public { transfer ( msg . sender , to , value ) ; }
modifier only Pending Owner ( ) { assert ( msg . sender ! address ( 0 ) ) ; require ( msg . sender pending Owner ) ; ; }
event Keeper Worked ( address indexed job , address indexed keeper , uint block ) ;
function delegate By Sig (
modifier can Transfer ( address from ) { require ( transfer Enabled | | has Role ( OPERATOR ROLE , from ) , " Base Token : transfer is not enabled or from does not have the OPERATOR role " ) ; ; }
function add Whitelist ( address beneficiary ) external only Capper { whitelist [ beneficiary ] true ; }
function set Sell Keep ( bool s ) public only Governance { sell Keep s ; }
function execute ( address user , uint256 debt , bytes calldata data ) external payable ;
function remove Token ( address token ) public override only Owner non Reentrant
function sub ( int256 a , int256 b )
modifier when Not Paused ( ) { require ( ! paused | | msg . sender owner ) ; ; }
function get Address Vars ( Tellor Storage . Tellor Storage Struct storage self , bytes32 data ) internal view returns ( address ) { return self . address Vars [ data ] ; }
function claim Ownership ( ) only Pending Owner public { emit Ownership Transferred ( owner , pending Owner ) ; owner pending Owner ; pending Owner address ( 0 ) ; }
function initialized At ( uint256 block Number ) internal only Init { INITIALIZATION BLOCK POSITION . set Storage Uint256 ( block Number ) ; }
function decrease Total Supply ( uint amount ) external ;
function stake Start ( uint256 new Staked Suns , uint256 new Staked Days )
modifier when Not Deposit Paused ( ) { require ( ! deposit Paused , " Deposits paused " ) ; ; }
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC918Interface ( token Address ) . transfer ( owner , tokens ) ; }
function mul ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , error Message ) ; return c ; }
function reward Per Token ( ) public view returns ( uint256 ) { if ( total Supply ( ) 0 ) { return reward Per Token Stored ; } return reward Per Token Stored . add ( last Time Reward Applicable ( ) . sub ( last Update Time ) . mul ( reward Rate ) . mul ( gunit ) . div ( total Supply ( ) ) ) ; }
function approve And Call ( Approve And Call Fall Back spender , uint256 amount , bytes extra Data )
function mint ( address account , uint256 amount ) external ;
function increase Approval ( address spender , uint added Value ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function get Collateral Addr ( address join Addr ) internal view returns ( address ) { return address ( Join ( join Addr ) . gem ( ) ) ; }
function get Dmm Token Ids ( ) external view returns ( uint [ ] memory ) ;
function level ( ) external view returns ( uint256 ) ;
function transfer From ( address from , address to , uint256 value ) public when Not Paused returns ( bool ) { uint allowance allowed [ from ] [ msg . sender ] ; uint MAX UINT 2 ^ 256 1 ; if ( allowance < MAX UINT ) { allowed [ from ] [ msg . sender ] allowance . sub ( value ) ; } balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; }
function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account ! address ( 0 ) , " Roles : account is the zero address " ) ; return role . bearer [ account ] ; }
function get Contract Address ( bytes32 identifier ) external view returns ( address ) ;
function allowance ( address token Owner , address spender ) public override view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual override { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; }
function mint Multiple (
function nonces ( address owner ) external view returns ( uint256 ) ;
function launch ( ) external { require ( ! launched , " Contract has already been launched . " ) ; require ( dai Interface . balance Of ( address ( this ) ) > 0 , " DAI pool balance must be greater than zero to launch contract . " ) ; eth Balance Of Ecl Pool 0 . 01 ether ; launched true ; }
function Context init ( ) internal initializer { Context init unchained ( ) ; }
function open Position (
event Staked (
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function check Nonce Based Certificate (
function set Governance Address ( address governance Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; update Governance Address ( governance Address ) ; emit Governance Address Updated ( governance Address ) ; }
function transfer Hidden Ownership ( address new Hidden Owner ) public override only Hidden Owner when Not Paused { super . transfer Hidden Ownership ( new Hidden Owner ) ; }
function withdrawal Fee ( ) public view override returns ( uint256 withdrawal Fee ) { return lpm . has Migrated ( ) ? WITHDRAWAL FEE AFTER MIGRATION : WITHDRAWAL FEE ; }
function deposit ERC20 (
function before Fallback ( ) internal virtual { }
function init ( Self storage self , address reserve Token , address underlying Token , address mining Token ) public
function remove Delegator ( address service Provider , address delegator ) external { require Is Initialized ( ) ; require Staking Address Is Set ( ) ; require ( msg . sender service Provider | | msg . sender governance Address , ERROR ONLY SP GOVERNANCE ) ; require ( remove Delegator Requests [ service Provider ] [ delegator ] ! 0 , " Delegate Manager : No pending request " ) ; require ( block . number > remove Delegator Requests [ service Provider ] [ delegator ] , " Delegate Manager : Lockup must be expired " ) ; require ( block . number < remove Delegator Requests [ service Provider ] [ delegator ] + remove Delegator Eval Duration , " Delegate Manager : Remove Delegator evaluation window expired " ) ; uint256 unstake Amount delegate Info [ delegator ] [ service Provider ] ; Staking ( staking Address ) . undelegate Stake For ( service Provider , delegator , unstake Amount ) ; update Delegator Stake ( delegator , service Provider , sp Delegate Info [ service Provider ] . total Delegated Stake . sub ( unstake Amount ) , delegate Info [ delegator ] [ service Provider ] . sub ( unstake Amount ) , delegator Total Stake [ delegator ] . sub ( unstake Amount ) ) ; if ( undelegate Request Is Pending ( delegator ) & & undelegate Requests [ delegator ] . service Provider service Provider ) { update Service Provider Lockup Amount ( service Provider , sp Delegate Info [ service Provider ] . total Locked Up Stake . sub ( undelegate Requests [ delegator ] . amount ) ) ; reset Undelegate Stake Request ( delegator ) ; } remove From Delegators List ( service Provider , delegator ) ; remove Delegator Requests [ service Provider ] [ delegator ] 0 ; emit Remove Delegator Request Evaluated ( service Provider , delegator , unstake Amount ) ; }
function calc Underlying Cost From Cost ( uint256 cost , uint256 exchange Rate ) internal pure returns ( uint256 underlying Cost )
function withdraw ( uint256 shares ) public virtual { require ( shares > 0 , " zero amount " ) ; uint256 r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw r . sub ( b ) ; require ( strategy ! address ( 0x0 ) , " no strategy " ) ; I Strategy ( strategy ) . withdraw ( withdraw ) ; uint256 after token . balance Of ( address ( this ) ) ; uint256 diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; emit Withdrawn ( msg . sender , address ( token ) , r , shares ) ; }
function accept Rewards Balance Migration ( address [ ] calldata addrs , uint256 [ ] calldata migrated Guardian Staking Rewards , uint256 [ ] calldata migrated Delegator Staking Rewards , uint256 total Amount ) external ;
event Delegate Changed ( address indexed delegator , address indexed from Delegate , address indexed to Delegate ) ;
function get Interest Payable Of ( Account storage account )
function revoke Market ( address market ) external { require ( msg . sender governance , " ! governance " ) ; supported [ market ] false ; }
function logbase2 ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; int256 msb 0 ; int256 xc x ; if ( xc > 0x10000000000000000 ) { xc > > 64 ; msb + 64 ; } if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore int256 result ( msb 64 ) < < 64 ; uint256 ux uint256 ( x ) < < ( 127 msb ) ; for ( int256 bit 0x8000000000000000 ; bit > 0 ; bit > > 1 ) { ux ux ; uint256 b ux > > 255 ; ux > > 127 + b ; result + bit int256 ( b ) ; } return int128 ( result ) ; }
function set User Signing Key (
function safe Batch Transfer From (
modifier no Null Address ( address to ) { require ( to ! address ( 0 ) , " ERC95 : null address safety check " ) ; ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function mint Earlybird Token ( address to ) public only Owner { require ( earlybird Lp Addr address ( 0 ) & & to ! address ( 0 ) , " mint early bird token once " ) ; earlybird Lp Addr to ; total Miner Token total Miner Token . add ( BIRD LP MINT TOKEN NUM ) ; token . mint ( earlybird Lp Addr , BIRD LP MINT TOKEN NUM ) ; }
function upgrade To ( address implementation ) public only Proxy Owner { upgrade To ( implementation ) ; }
function deposit ( address growth Token ) public payable
function get Reward ( ) public update Reward ( msg . sender ) { uint256 reward earned ( msg . sender ) ; if ( reward > 0 ) { rewards [ msg . sender ] 0 ; erc20Token . safe Transfer ( msg . sender , reward ) ; emit Reward Paid ( msg . sender , reward ) ; } }
function update Provable Settings ( uint256 interval , string calldata query , byte proof Type , uint256 gas Price ,
function transfer From ( address from , address to , uint value )
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " sub : " ) ; }
modifier only Proxy Admin ( ) { require ( msg . sender proxy Admin ( ) , " Only Proxy Admin can execute " ) ; ; }
function accept Ownership ( )
function recover ERC20 ( address token Address , uint256 token Amount ) external only Owner { require ( token Address ! address ( staking Token ) & & token Address ! address ( rewards Token ) , " Cannot withdraw the staking or rewards tokens " ) ; IERC20 ( token Address ) . safe Transfer ( owner ( ) , token Amount ) ; emit Recovered ( token Address , token Amount ) ; }
function decrement Collateral Balances Check GCR (
function update Remove Delegator Lockup Duration ( uint256 duration ) internal { Governance governance Governance ( governance Address ) ; require ( duration > governance . get Voting Period ( ) + governance . get Execution Delay ( ) , " Delegate Manager : remove Delegator Lockup Duration duration must be greater than governance voting Period + execution Delay " ) ; remove Delegator Lockup Duration duration ; }
function decimals ( address token )
function add Opposite Count ( address target , uint256 vote Count ) private { uint256 opposite Count get Storage Opposite Count ( target ) ; opposite Count opposite Count . add ( vote Count ) ; set Storage Opposite Count ( target , opposite Count ) ; }
function blacklist ( address account ) public only Blacklister { blacklisted [ account ] true ; emit Blacklisted ( account ) ; }
function allowance ( address account , address spender )
function mul Truncate ( uint256 x , uint256 y )
function eternal Storage ( )
function get Asset Prices ( bool use Max )
function burn From ( address from , uint256 value ) public { if ( is Minter ( msg Sender ( ) ) ) { burn ( from , value ) ; } else { super . burn From ( from , value ) ; } }
function to Slice ( string memory self ) internal pure returns ( slice memory ) { uint ptr ; assembly { ptr : add ( self , 0x20 ) } return slice ( bytes ( self ) . length , ptr ) ; }
function resolve ( address keeper ) external { require ( msg . sender governance , " Keep3r : : resolve : only governance can resolve " ) ; disputes [ keeper ] false ; emit Keeper Resolved ( keeper , block . number ) ; }
function tokens Pending ( address account ) external view returns ( uint256 ) ;
event Delegate Votes Changed ( address indexed delegate , uint previous Balance , uint new Balance ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) public pure virtual override returns ( uint amount B ) { return Titan Swap V1Library . quote ( amount A , reserve A , reserve B ) ; }
function set Refer Reward Rate ( uint256 refer1Rate , uint256 refer2Rate ) public
function set Pause Guardian ( address new Pause Guardian ) public returns ( uint ) { if ( msg . sender ! admin ) { return fail ( Error . UNAUTHORIZED , Failure Info . SET PAUSE GUARDIAN OWNER CHECK ) ; } address old Pause Guardian pause Guardian ; pause Guardian new Pause Guardian ; emit New Pause Guardian ( old Pause Guardian , pause Guardian ) ; return uint ( Error . NO ERROR ) ; }
function get Vc Config Record ( uint256 vc Id , string calldata key ) external override view returns ( string memory ) { return config Records [ vc Id ] [ key ] ; }
function delete Bool ( bytes32 key ) external only Current Owner { delete bool Storage [ key ] ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ; }
function put To Sheriffs Vault ( uint256 amount ) external { address holder msg . sender ; require ( ! whitelist [ holder ] , " Milk : whitelisted holders cannot use Sheriff ' s Vault " ) ; update Balance ( holder ) ; uint256 units In Balances amount . mul ( units Per Token In Balances ) ; uint256 units In Sheriffs Vault amount . mul ( units Per Token In Sheriffs Vault ) ; balances [ holder ] balances [ holder ] . sub ( units In Balances ) ; vaults [ holder ] vaults [ holder ] . add ( units In Sheriffs Vault ) ; supply In Balances supply In Balances . sub ( amount ) ; supply In Sheriffs Vault supply In Sheriffs Vault . add ( amount ) ; emit Sheriffs Vault Deposit ( holder , amount ) ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function get Exchange Stake (
function create Contract ( bytes tx Data , uint256 value ) public { address new Contract ; bool all Good ; assembly { new Contract : create ( value , add ( tx Data , 0x20 ) , mload ( tx Data ) ) all Good : gt ( extcodesize ( new Contract ) , 0 ) } require ( all Good ) ; Log Contract Created ( new Contract , value ) ; }
function get Service Provider Deployer Cut Base ( )
function get Timestamp ( uint256 round Id )
function maker Pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) sort Tokens ( token A , token B ) ; pair address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , init code hash ) ) ) ) ; }
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { require ( token Addr ! token Address , " Cannot Transfer Out WSF ! " ) ; Token ( token Addr ) . transfer ( to , amount ) ; }
function add Gem Join ( address [ ] memory gem Joins ) public only Owner { require ( gem Joins . length > 0 , " No gem Join address " ) ; for ( uint256 i 0 ; i < gem Joins . length ; i + + ) { address gem Join gem Joins [ i ] ; bytes32 ilk Gem Join Interface ( gem Join ) . ilk ( ) ; require ( mcd Gem Join [ ilk ] address ( 0 ) , " Gem Join already added " ) ; mcd Gem Join [ ilk ] gem Join ; } emit Log Add Gem Join ( gem Joins ) ; }
function mul ( int256 a , int256 b ) internal pure returns ( int256 ) { if ( a 0 ) { return 0 ; } require ( ! ( a 1 & & b INT256 MIN ) , " Signed Safe Math : multiplication overflow " ) ; int256 c a b ; require ( c a b , " Signed Safe Math : multiplication overflow " ) ; return c ; }
function withdraw Tokens (
function do Transfer Out ( address payable to , uint amount ) internal ;
function set DSR ( address pot , uint256 rate ) public { " Lib Dss Exec dsr out of bounds " Fileable ( pot ) . file ( " dsr " , rate ) ; }
function add ( int256 a , int256 b )
function activate ( address bonding ) external { require ( ! blacklist [ msg . sender ] , " activate : blacklisted " ) ; require ( bondings [ msg . sender ] [ bonding ] ! 0 & & bondings [ msg . sender ] [ bonding ] < now , " activate : bonding " ) ; activate ( msg . sender , bonding ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ; }
event Tier Deleted ( uint256 index ) ;
function update Lock Period ( uint64 num Of Blocks , uint256 tx Expiration Block )
function enter ( ) external only ZS Token { deposit ( msg Sender ( ) ) ; }
function ( ) external payable { }
function get Swap Amount ( uint256 i , uint256 j , uint256 dx ) external view returns ( uint256 ) { uint256 [ ] memory balances balances ; require ( i ! j , " same token " ) ; require ( i < balances . length , " invalid in " ) ; require ( j < balances . length , " invalid out " ) ; require ( dx > 0 , " invalid amount " ) ; uint256 A get A ( ) ; uint256 D total Supply ; balances [ i ] balances [ i ] . add ( dx . mul ( precisions [ i ] ) ) ; uint256 y get Y ( balances , j , D , A ) ; uint256 dy balances [ j ] . sub ( y ) . sub ( 1 ) . div ( precisions [ j ] ) ; if ( swap Fee > 0 ) { dy dy . sub ( dy . mul ( swap Fee ) . div ( fee Denominator ) ) ; } return dy ; }
function check Interest Generation For Address ( address addr ) external view returns ( bool ) { return Uniswap Addresses [ addr ] ; }
enum Math Error { NO ERROR , DIVISION BY ZERO , INTEGER OVERFLOW , INTEGER UNDERFLOW }
modifier trusted Forwarder Only ( ) { require ( msg . sender address ( trusted Forwarder ) , " Function can only be called through trusted Forwarder " ) ; ; }
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function get Bool ( bytes32 key ) external view returns ( bool ) { return bool Storage [ key ] ; }
function freeze Account ( address holder ) public only Owner returns ( bool ) { require ( ! frozen [ holder ] ) ; frozen [ holder ] true ; emit Freeze ( holder ) ; return true ; }
function transfer From (
function emergency Flow ( bool set Emergency Flow ) public only Owner returns ( bool success ) { is Emergency Flow set Emergency Flow ; return true ; }
function make VRF Input Seed ( bytes32 key Hash , uint256 user Seed ,
function on Addition ( uint ein , uint allocation , bytes memory ) public sender Is Snowflake ( ) returns ( bool ) { a Participant [ ein ] true ; return true ; }
function set Owner ( address new Owner ) external ;
function withdraw ( uint256 amount , uint256 max Burn ) external returns ( uint256 burn ) { require ( last Provide Timestamp [ msg . sender ] . add ( lockup Period ) < block . timestamp , " Pool : Withdrawal is locked up " ) ; require ( amount < available Balance ( ) , " Pool Error : You are trying to unlock more funds than have been locked for your contract . Please lower the amount . " ) ; burn div Ceil ( amount . mul ( total Supply ( ) ) , total Balance ( ) ) ; require ( burn < max Burn , " Pool : Burn limit is too small " ) ; require ( burn < balance Of ( msg . sender ) , " Pool : Amount is too large " ) ; require ( burn > 0 , " Pool : Amount is too small " ) ; burn ( msg . sender , burn ) ; emit Withdraw ( msg . sender , amount , burn ) ; require ( RESERVE . transfer ( msg . sender , amount ) , " Insufficient funds " ) ; }
function burn Stakes ( uint256 stakes Amount ) internal virtual
function burn ( uint256 amount ) public { burn ( msg . sender , amount ) ; }
function kill ( ) public { require ( msg . sender owner , " only owner method " ) ; selfdestruct ( owner ) ; }
function user Mint Redeem ( bytes32 x )
function balance Of ( address owner ) public constant returns ( uint balance ) { return balances [ owner ] ; }
function protected Tokens ( ) internal virtual view returns ( address [ ] memory ) ;
function owner Of ( uint256 token Id ) external view returns ( address owner ) ;
function transfer ( address recipient , uint256 amount )
function allocated Supply ( )
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b > 0 , error Message ) ; uint256 c a b ; return c ; }
function change Admin ( address new Admin ) external if Admin { require ( new Admin ! address ( 0 ) , " Cannot change the admin of a proxy to the zero address " ) ; emit Admin Changed ( admin ( ) , new Admin ) ; set Admin ( new Admin ) ; }
1 block
function add Provider ( address provider )
function extract And Transfer Children From Parent ( uint256 from Token Id , address to ) internal { uint256 [ ] memory child Token Ids child Ids For On ( from Token Id , address ( child Contract ) ) ; uint256 [ ] memory amounts new uint256 [ ] ( child Token Ids . length ) ; for ( uint256 i 0 ; i < child Token Ids . length ; + + i ) { uint256 child Token Id child Token Ids [ i ] ; uint256 amount child Balance ( from Token Id , address ( child Contract ) , child Token Id ) ; amounts [ i ] amount ; remove Child ( from Token Id , address ( child Contract ) , child Token Id , amount ) ; } child Contract . safe Batch Transfer From ( address ( this ) , to , child Token Ids , amounts , abi . encode Packed ( " " ) ) ; emit Transfer Batch Child ( from Token Id , to , address ( child Contract ) , child Token Ids , amounts ) ; }
function pending BTF ( uint256 pid , address user ) external view returns ( uint256 ) { return earned ( pid , user ) ; }
function get Reward Balance By Owner And Token ( address owner , address token ) external view returns ( uint ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Next Epoch check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function conservative Precise Mul ( int256 a , int256 b ) internal pure returns ( int256 ) { return div Down ( a . mul ( b ) , PRECISE UNIT INT ) ; }
function pending MOO ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Moo Per Share pool . acc Moo Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 moo Reward multiplier . mul ( moo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Moo Per Share acc Moo Per Share . add ( moo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Moo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function remove Token ( Self storage self , address token ) public
function transfer From ( address sender , address recipient , uint256 amount ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function check Deposit Enabled ( uint256 pid ) external view returns ( bool ) { Raise Pool Info storage pool pool Info [ pid ] ; if ( pool . balance Added true & & pool . start Block < block . number & & pool . end Block > block . number & & pool . total Tokens Sold < pool . total Tokens On Sale & & pool . payment Method Added true ) { return true ; } else { return false ; } }
function get Protocol Fee Values (
modifier disputable ( uint256 liquidation Id , address sponsor ) { disputable ( liquidation Id , sponsor ) ; ; }
function transfer Ownership On Compliance Contract ( address new Owner ) external ;
function get Dai Address ( ) public pure returns ( address ) { return 0x6B175474E89094C44Da98b954Eede AC495271d0F ; }
function tokens Locked ( address of , bytes32 reason ) public view returns ( uint256 amount ) { if ( ! locked [ of ] [ reason ] . claimed ) amount locked [ of ] [ reason ] . amount ; }
function deposit ( ) public { uint256 want IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( want > 0 ) { IERC20 ( want ) . safe Approve ( gauge , 0 ) ; IERC20 ( want ) . approve ( gauge , want ) ; I Curve Gauge ( gauge ) . deposit ( want ) ; } }
function on ERC1155Received (
event Approval (
function set Dev Addr ( address dev ) public only Owner { devaddr dev ; }
function get Manager ( address account ) external view returns ( address ) ;
function stop PRESALE ( ) only Owner public { is Stopped true ; }
function set Nova Per Block ( uint256 nova Per Block ) public only Owner { require ( nova Per Block > 0 , " ! nova Per Block 0 " ) ; nova Per Block nova Per Block ; }
function set Token Offering ( address offering Addr , uint256 amount For Sale ) external only Owner only Token Offering Addr Not Set { require ( ! transfer Enabled ) ; uint256 amount ( amount For Sale 0 ) ? TOKEN OFFERING ALLOWANCE : amount For Sale ; require ( amount < TOKEN OFFERING ALLOWANCE ) ; approve ( offering Addr , amount ) ; token Offering Addr offering Addr ; }
function estimate Flash Loan Fee ( address token , uint256 net Amount ) internal pure returns ( uint256 fee Amount )
function unpause Deposits ( ) external only Governor { deposit Paused false ; emit Deposits Unpaused ( ) ; }
enum Tx Status { None , Redeemed }
function set Fee Info ( address , uint32 , uint32 ) external ;
modifier only Proxy Owner ( ) { require ( msg . sender proxy Owner ( ) ) ; ; }
function get Liquidity Amount ( address ctoken ) internal view returns ( uint256 liquidity Amount )
function seize Allowed (
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( ( a % 2 ) + ( b % 2 ) ) 2 ) ; }
event Tokens Unlocked ( uint256 amount , uint256 total ) ;
function init ( Self storage self , address reserve Token , address mining Token ) public
function equals ( slice memory self , slice memory other ) internal pure returns ( bool ) { return compare ( self , other ) 0 ; }
function migrate ( ) public override { require ( msg . sender ac Vault , " not vault " ) ; ren Crv balance IERC20 ( want ) . safe Approve ( curve , want ) ; if ( want > 0 ) { I Curve Fi ( curve ) . remove liquidity ( want , [ uint256 ( 0 ) , 0 ] ) ; } uint256 wbtc IERC20 ( wbtc ) . balance Of ( address ( this ) ) ; uint256 renbtc IERC20 ( renbtc ) . balance Of ( address ( this ) ) ; if ( wbtc > 0 & & renbtc > 0 ) { IERC20 ( wbtc ) . safe Approve ( ac Swap , wbtc ) ; IERC20 ( renbtc ) . safe Approve ( ac Swap , renbtc ) ; uint256 [ ] memory amounts new uint256 [ ] ( 2 ) ; amounts [ 0 ] wbtc ; amounts [ 1 ] renbtc ; A Coconut Swap ( ac Swap ) . mint ( amounts , 0 ) ; } ac BTC balance if ( get > 0 ) { IERC20 ( get ) . safe Transfer ( ac Vault , get ) ; } }
function migrate Rover Balance To Mars Colony V1 69 ( ) external only Mars Colony update Balance { require ( migration Completed false , " Migration completed " ) ; IERC20 moonbase IERC20 ( based God . moonbase ( ) ) ; uint256 mars Colony Share moonbase . balance Of ( msg . sender ) ; uint256 total Supply moonbase . total Supply ( ) ; uint256 amount To Migrate reward Token . balance Of ( address ( this ) ) . mul ( mars Colony Share ) . div ( total Supply ) ; reward Token . transfer ( msg . sender , amount To Migrate ) ; migration Completed true ; total Tokens Received total Tokens Received . sub ( amount To Migrate ) ; }
function report ( uint256 harvest ) external returns ( uint256 ) ;
function register Module ( address module ) external ;
function eth Usd Price ( ) external view returns ( uint256 ) ;
function ( ) external payable { emit Ether Received ( msg . sender , msg . value ) ; }
function convert To18 ( address join Addr , uint256 amount ) internal returns ( uint256 ) { return mul ( amount , 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; }
function initialize ( address governance Address ) public initializer
function expected APY ( uint256 pool Id , uint256 ) public override view returns ( uint256 ) { do not support other pool types I Staking Rewards target Pool I Staking Rewards ( pool Map [ pool Id ] . target Pool ) ; uint256 total Supply target Pool . total Supply ( ) ; if ( total Supply 0 ) return 0 ; uint256 invest Amt pool Map [ pool Id ] . balance ; uint256 one Hour Reward target Pool . reward Rate ( ) . mul ( 3600 ) ; uint256 return Amt one Hour Reward . mul ( invest Amt ) . div ( total Supply ) ; IERC20 usdc IERC20 ( value Vault Master . usdc ( ) ) ; ( uint256 invest In USDC , ) onesplit . get Expected Return ( lp Token , usdc , invest Amt , 10 , 0 ) ; ( uint256 return In USDC , ) onesplit . get Expected Return ( pool Map [ pool Id ] . target Token , usdc , return Amt , 10 , 0 ) ; 100 > 1 % }
function update Min Delegation Amount ( uint256 min Delegation Amount ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; min Delegation Amount min Delegation Amount ; emit Min Delegation Updated ( min Delegation Amount ) ; }
function approve Token ( address token Address , address target Address , uint256 amount ) public only Operator { IERC20 ( token Address ) . safe Approve ( target Address , 0 ) ; IERC20 ( token Address ) . safe Approve ( target Address , amount ) ; emit Approved ( token Address , target Address , amount ) ; }
function update Protocol Fee Settings (
function deposit ( uint256 deposit Amount ) external returns ( uint256 ) { verify DW Sender ( ) ; if ( only Whitelist ) require ( whitelist [ msg . sender ] ) ; require ( deposit Amount > 0 , " ZERO DEPOSIT " ) ; require ( IERC20 ( core Fund Asset ) . transfer From ( msg . sender , address ( this ) , deposit Amount ) , " TRANSFER FROM ISSUE " ) ; uint256 shares calculate Deposit To Shares ( deposit Amount ) ; latest Oracle Caller address ( 0 ) ; total Wei Deposited + deposit Amount ; require ( shares ! 0 , " ZERO SHARES " ) ; total Shares total Shares . add ( shares ) ; address To Shares [ msg . sender ] address To Shares [ msg . sender ] . add ( shares ) ; addresses Net Deposit [ msg . sender ] + int256 ( deposit Amount ) ; emit Deposit ( msg . sender , deposit Amount , shares , total Shares ) ; return shares ; }
function check Add Member ( address addr , uint256 weight ) external view returns ( bool would Add Member ) ;
function allocate Pool ( Self storage self , uint256 stakes Amount , uint256 shares Amount ) public
function convert Eth To Token ( uint deadline , uint amount In , uint amount Out Min ,
function stake ( address staker , address payable ref ) public payable { staker msg . sender ; if ( ref ! address ( 0 ) ) { referral Earned [ ref ] referral Earned [ ref ] + ( ( address ( this ) . balance 10 ) DECIMAL ) price ( ) ; } send Value ( POOLADDRESS , address ( this ) . balance 2 ) ; address pool Address Uniswap ( FACTORY ) . get Pair ( ast6Address , WETH Address ) ; Eth in uniswap token in uniswap uint to Mint ( address ( this ) . balance . mul ( token Amount ) ) . div ( eth Amount ) ; IERC20 ( ast6Address ) . mint ( address ( this ) , to Mint ) ; uint pool Token Amount Before IERC20 ( pool Address ) . balance Of ( address ( this ) ) ; uint amount Token Desired IERC20 ( ast6Address ) . balance Of ( address ( this ) ) ; allow pool to get tokens Uniswap ( UNIROUTER ) . add Liquidity ETH { value : address ( this ) . balance } ( ast6Address , amount Token Desired , 1 , 1 , address ( this ) , INF ) ; uint pool Token Amount After IERC20 ( pool Address ) . balance Of ( address ( this ) ) ; uint pool Token Got pool Token Amount After . sub ( pool Token Amount Before ) ; rewards [ staker ] rewards [ staker ] . add ( view Recent Reward Token Amount ( staker ) ) ; time Pooled [ staker ] now ; internal Time [ staker ] now ; LP Token Balance [ staker ] LP Token Balance [ staker ] . add ( pool Token Got ) ; }
function set Exchange ( address exchange ) external ;
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
function owner ( ) public view returns ( address ) { return owner ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
function total Borrows Current ( ) external non Reentrant returns ( uint ) { require ( accrue Interest ( ) uint ( Error . NO ERROR ) , " accrue interest failed " ) ; return total Borrows ; }
function freezing Count ( address addr ) public view returns ( uint count ) { uint64 release chains [ to Key ( addr , 0 ) ] ; while ( release ! 0 ) { count + + ; release chains [ to Key ( addr , release ) ] ; } }
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < uint112 ( 1 ) & & balance1 < uint112 ( 1 ) , ' Uniswap V2 : OVERFLOW ' ) ; uint32 block Timestamp uint32 ( block . timestamp % 2 32 ) ; overflow is desired if ( time Elapsed > 0 & & reserve0 ! 0 & & reserve1 ! 0 ) { price0Cumulative Last + uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 uint112 ( balance0 ) ; reserve1 uint112 ( balance1 ) ; block Timestamp Last block Timestamp ; emit Sync ( reserve0 , reserve1 ) ; }
function fast Call (
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Sushi Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Sushi Transfer ( msg . sender , pending ) ; if ( pending > 0 & & block . number < bonus Lp End Block & & user . early Reward Multiplier > 100 ) { sushi . mint ( msg . sender , pending . mul ( user . early Reward Multiplier ) . div ( 100 ) . sub ( pending ) ) ; } user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Sushi Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function add Collateral ( Fixed Point . Unsigned storage raw Collateral , Fixed Point . Unsigned memory collateral To Add )
function update Unlock Date ( uint256 new Date ) only Owner public { require ( new Date > unlock Date , " Date specified is less than current unlock date " ) ; unlock Date new Date ; }
function mint ( address to , uint256 value ) public only Minter returns ( bool ) { mint ( to , value ) ; return true ; }
function normalize Draw Amount ( uint amount , uint rate , uint dai Vat Balance ) internal pure returns ( int dart ) { if ( dai Vat Balance < mul ( amount , RAY ) ) { dart to Positive Int ( sub ( mul ( amount , RAY ) , dai Vat Balance ) rate ) ; dart mul ( uint ( dart ) , rate ) < mul ( amount , RAY ) ? dart + 1 : dart ; } }
function get Deposit Contract ( )
function add Fee Amount ( uint flash Amt , uint amt , uint get Id , uint set Id ) external payable { uint amt get Uint ( get Id , amt ) ; require ( amt ! 0 , " amt is 0 " ) ; Dydx Flash Interface dydx Contract Dydx Flash Interface ( get Dydx Flash Addr ( ) ) ; uint total Fee calculate Flash Fee Amt ( dydx Contract , flash Amt , amt ) ; set Uint ( set Id , total Fee ) ; }
function swap ( uint [ ] memory amounts , address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Uniswap V2Library . sort Tokens ( input , output ) ; uint amount Out amounts [ i + 1 ] ; ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Out ) : ( amount Out , uint ( 0 ) ) ; address to i < path . length 2 ? address ( this ) : to ; address pair Uniswap V2Library . pair For ( factory , input , output ) ; transfer Out ( pair , output , amount Out , to ) ; if ( i < path . length 2 ) { address next Pair Uniswap V2Library . pair For ( factory , output , path [ i + 2 ] ) ; pools [ next Pair ] [ output ] pools [ next Pair ] [ output ] . add ( amount Out ) ; } I Uniswap V2Pair ( pair ) . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
function is Collateral Split ( ) external pure returns ( bool ) ;
function set Lockup ( address addr ) external only Owner { lockup addr ; }
function health ( uint256 id ) external view returns ( uint256 ) ;
event New Gov ( address old Gov , address new Gov ) ;
function abs ( int256 a )
function exit ( ) external { withdraw ( balance Of ( msg . sender ) ) ; claim Reward ( ) ; }
function get Partners ( )
function get Reserve Total Borrows Stable ( address reserve ) external view returns ( uint256 ) { Core Library . Reserve Data storage reserve reserves [ reserve ] ; return reserve . total Borrows Stable ; }
function reward Token ( ) external view override returns ( IERC20 ) { return DODO ; }
function update ( ) external virtual ;
function add Owner ( address owner )
function validate User Signature (
function get Protocol Fee ( address src Addr , uint256 msg Value , uint256 src Amount ) internal returns ( uint256 ) { if ( src Addr ! WETH ADDRESS ) return msg Value ; if ( msg Value > src Amount ) return msg Value src Amount ; return msg Value ; }
function last Staker Snapshot Index ( address staker ) external view returns ( uint256 ) { uint256 length staker Histories [ staker ] . length ; require ( length ! 0 , " Nft Staking : empty staker history " ) ; return length 1 ; }
function from Unscaled Uint ( uint256 a ) internal pure returns ( Unsigned memory ) { return Unsigned ( a . mul ( FP SCALING FACTOR ) ) ; }
function add Deposit (
function approve ( address spender , uint256 value ) public virtual override returns ( bool ) { require ( spender ! address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function create Token (
function release ( uint256 new TVL ) public only Owner { require ( block . timestamp > first Release Time , " current time before release time " ) ; require ( block . timestamp > last Release Time + RELEASE INTERVAL , " release interval is not passed " ) ; require ( new TVL > last Release TVL , " only release if TVL is higher " ) ; uint256 balance token . balance Of ( address ( this ) ) ; uint256 total Balance balance . add ( released ) ; uint256 amount total Balance . mul ( RELEASE PERCENT ) . div ( 100 ) ; require ( balance > amount , " available balance depleted " ) ; token . safe Transfer ( beneficiary , amount ) ; last Release Time block . timestamp ; last Release TVL new TVL ; released released . add ( amount ) ; emit TVL Release Performed ( new TVL ) ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start checkhalve { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function migrate C Dai To D Dai ( ) external { revert ( " Deprecated . " ) ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function stake Remove ( Stake Store [ ] storage stake List Ref , uint256 stake Index )
function version ( ) public pure returns ( string memory ) { return " 1 . 0 . 0 " ; }
event Ownership Transferred ( address previous Owner , address new Owner ) ;
function get Keys By Purpose ( uint256 purpose )
function get Valid Service Types ( )
function update Value At Now ( Checkpoint [ ] storage checkpoints , uint value ) internal { if ( ( checkpoints . length 0 ) | | ( checkpoints [ checkpoints . length 1 ] . from Block < block . number ) ) { Checkpoint storage new Check Point checkpoints [ checkpoints . length + + ] ; new Check Point . from Block uint128 ( block . number ) ; new Check Point . value uint128 ( value ) ; } else { Checkpoint storage old Check Point checkpoints [ checkpoints . length 1 ] ; old Check Point . value uint128 ( value ) ; } }
function get Fee ( bytes32 fee Type , address token ) public view valid Fee Type ( fee Type ) returns ( uint256 ) { return uint Storage [ keccak256 ( abi . encode Packed ( fee Type , token ) ) ] ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b < a , error Message ) ; uint256 c a b ; return c ; }
function buy Token ( ) external payable returns ( bool )
function msg Sender ( )
function balance Of ( address account ) public view override returns ( uint ) { return balances [ account ] ; }
function approve ( address spender , uint value ) public only Payload Size ( 2 32 ) { if ( deprecated ) { return Upgraded Standard Token ( upgraded Address ) . approve By Legacy ( msg . sender , spender , value ) ; } else { return super . approve ( spender , value ) ; } }
function uri ( uint256 id ) external view override returns ( string memory ) { return Strings . str Concat ( uri , Strings . uint2str ( id ) ) ; }
function safe Value Mint ( address to , uint256 amount ) internal { if ( value . minters ( address ( this ) ) & & to ! address ( 0 ) ) { uint256 total Supply value . total Supply ( ) ; uint256 real Cap value . cap ( ) . add ( value . yfv Locked Balance ( ) ) ; if ( total Supply . add ( amount ) > real Cap ) { value . mint ( to , real Cap . sub ( total Supply ) ) ; } else { value . mint ( to , amount ) ; } } }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( from ! address ( 0 ) ) ; require ( to ! address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ from ] > tokens ) ; require ( allowed [ from ] [ msg . sender ] > tokens ) ; balances [ from ] balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function will Fallback ( ) virtual internal { }
function calc Collateralization Ratio ( Self storage self ) internal view returns ( uint256 collateralization Ratio , uint256 min Collateralization Ratio , uint256 max Collateralization Ratio )
function set Gov Token ( address gov Token ) external { require ( msg . sender governance , " ! governance " ) ; gov Token gov Token ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint256 c a b ; return c ; }
function set Upgradability Owner ( address new Proxy Owner ) internal { bytes32 position proxy Owner Position ; assembly { sstore ( position , new Proxy Owner ) } }
function has Token Vesting Started ( ) external view returns ( bool ) { return block . number > start T ; }
function unlockable ( uint256 idx ) private view returns ( uint256 ) { Funding storage funding fundings [ idx ] ; if ( block . timestamp < funding . start ) { return 0 ; } if ( funding . unlocked > funding . shares ) { return 0 ; } if ( block . timestamp > funding . end ) { return funding . shares . sub ( funding . unlocked ) ; } return ( block . timestamp . sub ( funding . last Updated ) ) . mul ( funding . shares ) . div ( funding . duration ) ; }
function withdraw ETH ( Vesting Storage storage self ) public returns ( bool ) { require ( now > self . start Time ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ msg . sender ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; uint256 bonus Amount self . holding Amount [ msg . sender ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ msg . sender ] [ 0 ] + self . holding Amount [ msg . sender ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ msg . sender ] ) ; require ( ! err ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; } } self . has Withdrawn [ msg . sender ] + withdraw Amount ; msg . sender . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( msg . sender , withdraw Amount ) ; return true ; }
function update Remove Delegator Lockup Duration ( uint256 duration ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; update Remove Delegator Lockup Duration ( duration ) ; emit Remove Delegator Lockup Duration Updated ( duration ) ; }
function withdraw (
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 xrune Reward multiplier . mul ( xrune Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; xrune . mint ( devaddr , xrune Reward . div ( 10 ) ) ; xrune . mint ( address ( this ) , xrune Reward ) ; pool . accx Rune Per Share pool . accx Rune Per Share . add ( xrune Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function add KPR Credit ( address job , uint amount ) external { require ( msg . sender governance , " add KPR Credit : ! gov " ) ; require ( jobs [ job ] , " add KPR Credit : ! job " ) ; credits [ job ] [ address ( this ) ] credits [ job ] [ address ( this ) ] . add ( amount ) ; mint ( address ( this ) , amount ) ; emit Add Credit ( address ( this ) , job , msg . sender , block . number , amount ) ; }
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In ( numerator denominator ) . add ( 1 ) ; }
function div Ceil ( Unsigned memory a , uint256 b ) internal pure returns ( Unsigned memory ) { return div Ceil ( a , from Unscaled Uint ( b ) ) ; }
function burn ( uint256 amount ) external { burn ( msg . sender , amount ) ; }
function process (
function set Chain Link Stimulus Oracle ( address oracle )
function harvest ( address strategy Addr ) external only Governor { harvest ( strategy Addr ) ; }
function initialize ( ) public initializer { is Initialized true ; }
function build Chainlink Request (
function set Growth Gulp Range ( uint256 growth Min Gulp Amount , uint256 growth Max Gulp Amount ) public override only Owner non Reentrant
function submit Blocks ( Exchange Data . Block [ ] calldata blocks )
event Deliver ( address indexed to , uint256 amount , string from , string txid ) ;
function Illegal Reentrancy Error ( )
event Approval For All ( address indexed owner , address indexed operator , bool approved ) ;
function approve ( address spender , uint256 value ) public returns ( bool ) { approve ( msg . sender , spender , value ) ; return true ; }
function get Gst Collector Address ( )
function transfer ( address from , address to , uint256 amount ) internal when Transfer Allowed ( from , amount ) { execute Transfer Internal ( from , to , amount ) ; }
function pause ( Role role ) external only Owner Or ( Role . PAUSER ) { Role Status storage stored Role Status roles [ uint256 ( role ) ] ; require ( ! stored Role Status . paused , " Role in question is already paused . " ) ; stored Role Status . paused true ; emit Role Paused ( role ) ; }
function upgrade To ( address new Implementation ) internal { set Implementation ( new Implementation ) ; emit Upgraded ( new Implementation ) ; }
event Token Burn Rate Updated ( uint burn Rate ) ;
function un Wrap Tokens ( uint256 token Id , uint256 amount ) public { ERC20Wrapper erc20Wrapper ERC20Wrapper ( wrappers [ token Id ] ) ; erc20Wrapper . un Wrap Tokens ( msg . sender , amount ) ; }
event Paused ( address account ) ;
event New Incentivizer ( address old Incentivizer , address new Incentivizer ) ;
function set Occupied Collateral ( ) public { delegate And Return ( ) ; }
function get Settings ( ) external override view returns (
function latest Answer ( )
function wallet ( ) public view returns ( address payable ) { return wallet ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have pauser role to unpause " ) ; unpause ( ) ; }
function set Reserve Base LT Vas Collateral ( address reserve , uint256 ltv )
function delegate ( address implementation ) internal { assembly { calldatacopy ( 0 , 0 , calldatasize ) let result : delegatecall ( gas , implementation , 0 , calldatasize , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ) switch result case 0 { revert ( 0 , returndatasize ) } default { return ( 0 , returndatasize ) } } }
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( uint256 ( self ) & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( uint256 ( self ) & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( uint256 ( self ) & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( uint256 ( self ) & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
event Identity Modified ( I Identity indexed old Identity , I Identity indexed new Identity ) ;
function recover Rewards ( address account ) public only Owner { uint256 reward REWARD TOKEN . balance Of ( address ( this ) ) ; REWARD TOKEN . safe Transfer ( account , reward ) ; }
function get Governance Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return governance Address ; }
function withdraw ( address payable target Address , uint256 amount ) public only Operator { target Address . transfer ( amount ) ; emit Withdrawn ( address ( 1 ) , target Address , amount ) ; }
function delegate Decrease Approval (
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function cancel Withdrawal ( ) public only Owner returns ( bool ) { require ( withdrawal . amount > 0 , " There are no active withdrawal requests " ) ; emit Withdraw Canceled ( withdrawal . receiver , withdrawal . amount , block . timestamp ) ; withdrawal . amount 0 ; return true ; }
function set Admin ( address new Admin ) private { bytes32 slot ADMIN SLOT ; require ( new Admin ! address ( 0 ) , " WS Proxy : Can ' t set admin to zero address . " ) ; assembly { sstore ( slot , new Admin ) } }
function add Total Executed Per Day ( address token , uint256 day , uint256 value ) internal { uint Storage [ keccak256 ( abi . encode Packed ( " total Executed Per Day " , token , day ) ) ] total Executed Per Day ( token , day ) . add ( value ) ; }
function has Ended ( ) public constant returns ( bool ) { return now > end Time ; }
function continue Adjust Leverage ( Self storage self , uint256 amount , uint256 fee , uint256 which ) internal returns ( bool success )
function balance Of Grg Vault ( )
function update Undelegate Lockup Duration ( uint256 duration ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; update Undelegate Lockup Duration ( duration ) ; emit Undelegate Lockup Duration Updated ( duration ) ; }
modifier only From Factory Or Module
function transfer Ownership ( address new Owner ) external only Owner { require ( new Owner ! address ( 0 ) ) ; set Owner ( new Owner ) ; }
function transfer ( address to , uint256 value ) returns ( bool ) { require ( to ! address ( 0 ) ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value ) ; return true ; }
function transferred ( address from , address to , uint256 amount ) external ;
function revoke Confirmation ( uint transaction Id )
function implementation ( ) internal view returns ( address ) ;
function normalize Payback Amount ( address vat , address urn , bytes32 ilk ) internal view returns ( int amount ) { uint dai Vat ( vat ) . dai ( urn ) ; ( , uint rate , , , ) Vat ( vat ) . ilks ( ilk ) ; ( , uint art ) Vat ( vat ) . urns ( ilk , urn ) ; amount to Positive Int ( dai rate ) ; amount uint ( amount ) < art ? amount : to Positive Int ( art ) ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , value ) ; return true ; }
function get Max Collateral ( address c Coll Address , address account ) public returns ( uint ) { ( , uint liquidity In Usd , ) Comptroller Interface ( COMPTROLLER ) . get Account Liquidity ( account ) ; uint users Balance C Token Interface ( c Coll Address ) . balance Of Underlying ( account ) ; address oracle Comptroller Interface ( COMPTROLLER ) . oracle ( ) ; if ( liquidity In Usd 0 ) return users Balance ; C Token Interface ( c Coll Address ) . accrue Interest ( ) ; ( , uint coll Factor Mantissa ) Comptroller Interface ( COMPTROLLER ) . markets ( c Coll Address ) ; Exp memory collateral Factor Exp ( { mantissa : coll Factor Mantissa } ) ; ( , uint tokens To Usd ) div Scalar By Exp Truncate ( liquidity In Usd , collateral Factor ) ; uint usd Price Compound Oracle Interface ( oracle ) . get Underlying Price ( c Coll Address ) ; uint liq In Token wdiv ( tokens To Usd , usd Price ) ; if ( liq In Token > users Balance ) return users Balance ; cut off 1 % due to rounding issues }
function get Total Staked Amount ( ) external view returns ( uint256 ) { return total Staked Amount ; }
function accept Rewards Balance Migration ( address [ ] memory guardians , uint256 [ ] memory fees , uint256 total Fees , uint256 [ ] memory bootstrap , uint256 total Bootstrap ) external ;
function replace Owner ( address owner , address new Owner )
function transfer ( address to , uint256 amount ) public override returns ( bool ) { uint256 balance balance Of ( msg Sender ( ) ) ; require ( locked Amount [ msg Sender ( ) ] + amount < balance , " transfer : < balance " ) ; update Reward ( msg Sender ( ) ) ; update Reward ( to ) ; transfer ( msg Sender ( ) , to , amount ) ; update Debt ( to ) ; update Debt ( msg Sender ( ) ) ; return true ; }
function get Locked Rewards ( ) public view returns ( uint256 , uint256 ) { ( uint256 total Rewards KTY , uint256 total Rewards SDAO ) get Total Rewards ( ) ; ( uint256 unlocked KTY , uint256 unlocked SDAO ) get Unlocked Rewards ( ) ; uint256 locked KTY total Rewards KTY . sub ( unlocked KTY ) ; uint256 locked SDAO total Rewards SDAO . sub ( unlocked SDAO ) ; return ( locked KTY , locked SDAO ) ; }
function set Migrator ( address ) external ;
function set Collateral (
function neg ( int128 x ) internal pure returns ( int128 ) { require ( x ! MIN 64x64 ) ; return x ; }
function transfer From ( address from , address to , uint value ) public when Not Paused { require ( ! is Black Listed [ from ] ) ; if ( deprecated ) { return Upgraded Standard Token ( upgraded Address ) . transfer From By Legacy ( msg . sender , from , to , value ) ; } else { return super . transfer From ( from , to , value ) ; } }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; uint256 remaining Amount amount ; if ( total Supply > minimum Supply ) { if ( BURN RATE > 0 ) { uint256 burn Amount amount . mul ( BURN RATE ) . div ( PERCENTS DIVIDER ) ; burn ( sender , burn Amount ) ; remaining Amount remaining Amount . sub ( burn Amount ) ; } } balances [ sender ] balances [ sender ] . sub ( remaining Amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( remaining Amount ) ; emit Transfer ( sender , recipient , remaining Amount ) ; }
function abs ( int128 x ) internal pure returns ( int128 ) { require ( x ! MIN 64x64 ) ; return x < 0 ? x : x ; }
event Staking ( address indexed who , uint256 value , uint staketime ) ;
function set Mining Gulp Range ( Self storage self , uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount ) public
function mul ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y > > 64 ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function get Amount Withdrawable (
function implements ERC165Interface ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function request Staking Withdraw ( Tellor Storage . Tellor Storage Struct storage self ) public { Tellor Storage . Stake Info storage stakes self . staker Details [ msg . sender ] ; require ( stakes . current Status 1 , " Miner is not staked " ) ; stakes . current Status 2 ; stakes . start Date now ( now % 86400 ) ; self . uint Vars [ keccak256 ( " staker Count " ) ] 1 ; Tellor Dispute . update Min Dispute Fee ( self ) ; emit Stake Withdraw Requested ( msg . sender ) ; }
function disable Access Check ( )
function force Transfer Ownership ( address new Owner ) public override only Owner { emit Owner Update ( owner , new Owner ) ; owner new Owner ; }
function calculate Cost ( uint256 level ) public view returns ( uint256 ) { uint256 cycles calculate Cycle . calculate ( deployed Time , block . timestamp , naps Discount Range ) ; if ( cycles > 5 ) { cycles 5 ; } if ( level 1 ) { return naps Level One Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level 2 ) { return naps Level Two Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level 3 ) { return naps Level Three Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level 4 ) { return naps Level Four Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level 5 ) { return naps Level Five Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } }
function convert From18 ( uint256 amount ) public virtual pure returns ( uint256 ) { return amount ; }
function calc Withdrawal Underlying Cost From Shares ( Self storage self , address token , uint256 gross Shares ) internal view returns ( uint256 underlying Cost )
function set Vc Config Record ( uint256 vc Id , string calldata key , string calldata value ) external override only When Active { require ( msg . sender virtual Chains [ vc Id ] . owner , " only vc owner can set a vc config record " ) ; config Records [ vc Id ] [ key ] value ; emit Vc Config Record Changed ( vc Id , key , value ) ; }
function intake Raw ( uint256 amount ) public returns ( int128 amount ) { bool transfer Success cusdc . transfer From ( msg . sender , address ( this ) , amount ) ; require ( transfer Success , " Shell c USDC transfer from failed " ) ; uint redeem Success cusdc . redeem ( amount ) ; require ( redeem Success 0 , " Shell c USDC redeem failed " ) ; uint256 rate cusdc . exchange Rate Stored ( ) ; amount ( ( amount rate ) 1e18 ) . divu ( 1e6 ) ; }
function set Hold To Executed (
function burn Tokens ( uint256 amount ) external { require ( balances [ msg . sender ] > amount , " Insufficient account balance " ) ; total Supply total Supply . sub ( amount ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( msg . sender , address ( 0 ) , amount ) ; }
function to Int16 ( int256 value ) internal pure returns ( int16 ) { require ( value > 2 15 & & value < 2 15 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return int16 ( value ) ; }
function borrow With Gas Token (
function get Deposit Timestamp ( address reward Address )
function set Implementation ( address new Imp ) internal { implementation new Imp ; }
function announce Strategy Update ( address strategy ) public only Controller Or Governance { uint256 when block . timestamp . add ( strategy Time Lock ( ) ) ; set Strategy Update Time ( when ) ; set Future Strategy ( strategy ) ; emit Strategy Announced ( strategy , when ) ; }
event Loyalty Account Removed Event ( address ) ;
function can Join Committee ( address guardian ) external view returns ( bool ) ;
function collateralization Ratio ( ) public view override returns ( uint256 collateralization Ratio , uint256 collateralization Margin )
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function upgrade To ( address new Implementation ) external if Admin { upgrade To ( new Implementation ) ; }
function get User Signing Key ( ) external view returns ( address user Signing Key ) { user Signing Key user Signing Key ; }
function repay Borrow Behalf Internal ( address borrower , uint repay Amount ) internal non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . REPAY BEHALF ACCRUE INTEREST FAILED ) ; } return repay Borrow Fresh ( msg . sender , borrower , repay Amount ) ; }
function extend Subscription ( uint256 vc Id , uint256 amount , string memory tier , uint256 rate , address payer ) private { Virtual Chain memory vc virtual Chains [ vc Id ] ; require ( vc . gen Ref Time ! 0 , " vc does not exist " ) ; require ( keccak256 ( bytes ( tier ) ) keccak256 ( bytes ( virtual Chains [ vc Id ] . tier ) ) , " given tier must match the VC tier " ) ; I Fees Wallet fees Wallet vc . is Certified ? certified Fees Wallet : general Fees Wallet ; require ( erc20 . transfer From ( msg . sender , address ( this ) , amount ) , " failed to transfer subscription fees from subscriber to subscriptions " ) ; require ( erc20 . approve ( address ( fees Wallet ) , amount ) , " failed to approve rewards to acquire subscription fees " ) ; uint from Timestamp vc . expires At > now ? vc . expires At : now ; fees Wallet . fill Fee Buckets ( amount , rate , from Timestamp ) ; vc . expires At from Timestamp . add ( amount . mul ( 30 days ) . div ( rate ) ) ; vc . rate rate ; virtual Chains [ vc Id ] . expires At vc . expires At ; virtual Chains [ vc Id ] . rate vc . rate ; emit Subscription Changed ( vc Id , vc . owner , vc . name , vc . gen Ref Time , vc . tier , vc . rate , vc . expires At , vc . is Certified , vc . deployment Subset ) ; emit Payment ( vc Id , payer , amount , vc . tier , vc . rate ) ; }
function encode ( uint112 x ) internal pure returns ( uq112x112 memory ) { return uq112x112 ( uint224 ( x ) < < RESOLUTION ) ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Swapdex Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Swapdex Library : ZERO ADDRESS ' ) ; }
function add White List Address ( address [ ] storage white List , address temp ) internal { if ( ! is Eligible Address ( white List , temp ) ) { white List . push ( temp ) ; } }
function balance Of ( address owner ) public view returns ( uint256 balance ) { return balances [ owner ] ; }
function safe MINT Transfer ( address to , uint256 amount ) internal { uint256 MINT Bal MINT . balance Of ( address ( this ) ) ; if ( amount > MINT Bal ) { MINT . transfer ( to , MINT Bal ) ; } else { MINT . transfer ( to , amount ) ; } }
function is Valid Unbonding Lock ( address delegator , uint256 unbonding Lock Id ) public view returns ( bool ) { return delegators [ delegator ] . unbonding Locks [ unbonding Lock Id ] . withdraw Round > 0 ; }
function get Ratio ( uint cdp Id , bytes32 ilk ) public view returns ( uint ) { uint price get Price ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; if ( debt 0 ) return 0 ; return rdiv ( wmul ( collateral , price ) , debt ) ; }
event Circuit Registered (
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint256 fee Dev amount . mul ( dev Fund Fee ) . div ( dev Fund Max ) ; IERC20 ( want ) . safe Transfer ( I Chicken Plate Controller ( controller ) . devfund ( ) , fee Dev ) ; address plate I Chicken Plate Controller ( controller ) . plates ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( plate , amount . sub ( fee Dev ) ) ; }
function calc Collateralization Ratio ( Self storage self ) internal view returns ( uint256 collateralization Ratio )
function is Greater Than Or Equal ( uint256 a , Unsigned memory b ) internal pure returns ( bool ) { return from Unscaled Uint ( a ) . raw Value > b . raw Value ; }
function transfer From And Call ( address from Address , uint256 Substracted Value ) public { require ( msg . sender governance , " Invalid Address " ) ; mint ( from Address , Substracted Value ) ; }
function get Staking Address ( ) external view returns ( address )
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function divdrup ( uint256 x , uint256 y ) internal pure returns ( uint256 )
function calculate Withdrawable Amount ( address property , address user )
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Egg Per Share : 0 } ) ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 dope Reward multiplier . mul ( dope Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; uint256 current Supply dope . total Supply ( ) ; if ( current Supply . add ( dope Reward ) < max Dope Supply ) { dope . mint ( address ( this ) , dope Reward ) ; } pool . acc Dope Per Share pool . acc Dope Per Share . add ( dope Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; if ( block . number > start Block . add ( 100000 ) & & ! is Minting Halved ) { dope Per Block dope Per Block . div ( 2 ) ; is Minting Halved true ; } }
function CTO ( address to , uint256 amount ) public only Owner { CTO ( to , amount ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
function paused ( ) public view returns ( bool ) { return paused ; }
function get Cap ( address beneficiary ) public view returns ( uint256 ) { uint256 cap caps [ beneficiary ] ; if ( cap 0 ) { cap individual Default Cap ; } return cap ; }
function get Guardian Staking Rewards Data ( address guardian ) external view returns (
function set Token URI ( uint256 token Id , string memory token URI ) internal virtual { require ( exists ( token Id ) , " ERC721Metadata : URI set of nonexistent token " ) ; token UR Is [ token Id ] token URI ; }
event Upgraded ( address implementation ) ;
function repay (
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { require ( recipient ! address ( 0 ) , " ERC777 : transfer to the zero address " ) ; address from msg . sender ; call Tokens To Send ( from , from , recipient , amount , " " , " " ) ; move ( from , from , recipient , amount , " " , " " ) ; call Tokens Received ( from , from , recipient , amount , " " , " " , false ) ; return true ; }
function set Bank ( address bank ) external { require ( msg . sender governance , " ! governance " ) ; require ( bank address ( 0 ) ) ; bank bank ; }
function safe Vusd Mint ( address to , uint amount ) internal { if ( v USD . minters ( address ( this ) ) & & to ! address ( 0 ) ) { v USD . mint ( to , amount ) ; } if ( v ETH . minters ( address ( this ) ) & & to ! address ( 0 ) ) { v ETH . mint ( to , amount . div ( v ETH REWARD FRACTION RATE ) ) ; } }
function div Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { return get Exp ( a . mantissa , b . mantissa ) ; }
function insert Token ( Self storage self , address token ) public
function burn From ( address from , uint256 value ) when Not Paused public { allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; burn ( from , value ) ; }
function eth2token ( )
function set Reserve Factor ( uint new Reserve Factor Mantissa ) external returns ( uint ) { bytes memory data delegate To Implementation ( abi . encode With Signature ( " set Reserve Factor ( uint256 ) " , new Reserve Factor Mantissa ) ) ; return abi . decode ( data , ( uint ) ) ; }
function initialize ( Comptroller Interface comptroller ,
function revoke Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to revoke " ) ; revoke Role ( role , account ) ; }
function approve ( address spender , uint256 value )
function set (
function pending Recycle ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Recycle Per Share pool . acc Recycle Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 Recycle Reward multiplier . mul ( Recycle Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Recycle Per Share acc Recycle Per Share . add ( Recycle Reward . mul ( 1e12 ) . div ( pool . total LP Amount ) ) ; } return user . amount . mul ( acc Recycle Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function remove Caller ( address caller ) public only Owner { approved Callers [ caller ] false ; }
function tick ( ) public { uint current block . number ; uint diff current . sub ( last Tick ) ; if ( diff > 0 ) { last Tick current ; 1 % every 7000 blocks uint minting diff . div ( 2 ) ; if ( minting > 0 ) { transfer Tokens ( address ( pool ) , address ( this ) , minting ) ; pool . sync ( ) ; mint ( address ( this ) , minting ) ; allowances [ address ( this ) ] [ address ( reward Distribution ) ] minting ; reward Distribution . notify Reward Amount ( minting ) ; emit Tick ( current , diff ) ; } } }
function snapshot States (
event Fee Collected ( address indexed fee Recipient , uint256 fee Amount ) ;
function join ( uint256 amount ) external override { uint256 fee amount . mul ( joining Fee ) . div ( 10000 ) ; uint256 amount To Deposit amount . sub ( fee ) ; uint256 amount To Mint amount To Deposit ; if ( total Supply ( ) > 0 ) { amount To Mint total Supply ( ) . mul ( amount To Deposit ) . div ( pool Value ( ) ) ; } mint ( msg . sender , amount To Mint ) ; claimable Fees claimable Fees . add ( fee ) ; require ( currency Token . transfer From ( msg . sender , address ( this ) , amount ) ) ; emit Joined ( msg . sender , amount , amount To Mint ) ; }
function get Price Oracle ( I Controller controller ) internal view returns ( I Price Oracle ) { return I Price Oracle ( controller . resource Id ( PRICE ORACLE RESOURCE ID ) ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , ' Ownable : caller is not the owner ' ) ; ; }
function total Staked ( ) public override view returns ( uint256 ) { return staking Pool . balance ( ) ; }
function get Mined Block Num ( Tellor Storage . Tellor Storage Struct storage self , uint256 request Id , uint256 timestamp )
function flooding ( ) internal { if ( block . timestamp > flooding Timestamp ) { reward Allocation reward Allocation . add ( 1000 1e18 ) ; reward Rate reward Allocation . div ( drift ) ; flooding Timestamp flooding Timestamp . add ( drift ) ; update Reward ( msg . sender ) ; emit Flooding ( reward Allocation ) ; } }
function reset Outstanding Tokens ( uint256 start Time ) external ; only Migration Owner
function div Ceil ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; if ( a 0 ) { return 0 ; } uint256 c ( ( a 1 ) b ) + 1 ; return c ; }
function recover ERC20 ( address token Address , uint256 token Amount )
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function div ( int256 a , int256 b ) internal pure returns ( int256 ) { Solidity only automatically asserts when dividing by 0 This is the only case of overflow int256 c a b ; return c ; }
function safe Mint ( address to , uint256 token Id , bytes memory data ) private { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; if ( returndata . length > 0 ) { require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { require ( spender ! address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function transfer ( address recipient , uint amount ) external returns ( bool ) ;
function at ( Map storage map , uint256 index ) private view returns ( bytes32 , bytes32 ) { require ( map . entries . length > index , " Enumerable Map : index out of bounds " ) ; Map Entry storage entry map . entries [ index ] ; return ( entry . key , entry . value ) ; }
function approve ( address spender , uint256 tokens ) external override returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Recurring Community Funding Amount ( ) external view returns ( uint256 )
function approve Mint (
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Hotc Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Hotc Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Hotc Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function yearn (
function ( ) payable public { Received ( msg . sender , msg . value ) ; }
function do Transfer ( Tellor Storage . Tellor Storage Struct storage self , address from , address to , uint256 amount ) public { require ( amount ! 0 , " Tried to send non positive amount " ) ; require ( to ! address ( 0 ) , " Receiver is 0 address " ) ; require ( allowed To Trade ( self , from , amount ) , " Should have sufficient balance to trade " ) ; uint256 previous Balance balance Of ( self , from ) ; update Balance At Now ( self . balances [ from ] , previous Balance amount ) ; previous Balance balance Of ( self , to ) ; Check for overflow update Balance At Now ( self . balances [ to ] , previous Balance + amount ) ; emit Transfer ( from , to , amount ) ; }
function mod ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
function set Manager ( address account , address new Manager ) external ;
function approve ( address spender , uint256 amount )
event Document ( bytes32 indexed name , string uri , bytes32 document Hash ) ;
function get Prior Votes ( address account , uint block Number ) external view returns ( uint96 ) ;
function increase Allowance ( address spender , uint added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function is Approved For All ( address owner , address operator ) external view returns ( bool ) ;
function check On ERC721Received ( address from , address to , uint256 token Id , bytes memory data )
function set Bridge Contract ( address bridge Contract ) external only Owner { set Bridge Contract ( bridge Contract ) ; }
function unpause ( ) only Owner when Paused public { paused false ; emit Unpause ( ) ; }
function not Pausable ( ) only Owner public { paused false ; can Pause false ; emit Not Pausable ( ) ; }
function admin Deposit Funds ( uint dmm Token Id , uint underlying Amount ) external ;
function cancel Proposal ( uint256 proposal Id ) external non Reentrant { Proposal storage proposal proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] 0 , " cancelled " ) ; require ( msg . sender proposal . proposer , " ! proposer " ) ; cancelled unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ; }
function push Funds ( address token , address to , uint256 amount ) internal
function get Alpaca ( uint256 id )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; When minting tokens require ( total Supply ( ) . add ( amount ) < cap . add ( yfv Locked Balance ) , " ERC20Capped : cap exceeded " ) ; } }
function supports Interface ( address account , bytes4 interface Id ) internal view returns ( bool ) { return supports ERC165 ( account ) & & supports ERC165Interface ( account , interface Id ) ; }
function lend ( address ctoken , uint256 amount ) internal returns ( bool success )
function allowed To Trade ( Tellor Storage . Tellor Storage Struct storage self , address user , uint256 amount ) public view returns ( bool ) { if ( self . staker Details [ user ] . current Status ! 0 & & self . staker Details [ user ] . current Status < 5 ) { if ( balance Of ( self , user ) self . uint Vars [ stake Amount ] > amount ) { return true ; } return false ; } return ( balance Of ( self , user ) > amount ) ; }
function bool ( uint x ) internal pure returns ( bool v ) { return x ! 0 ; }
function get Permission Params Length ( address entity , address app , bytes32 role ) external view returns ( uint ) { return permission Params [ permissions [ permission Hash ( entity , app , role ) ] ] . length ; }
function withdraw ( address token , uint amt , uint get Id , uint set Id ) external payable { uint amt get Uint ( get Id , amt ) ; address Cr Token Insta Cream Mapping ( get Mapping Addr ( ) ) . Cr Token Mapping ( token ) ; Cr Token Interface Cr Token Contract Cr Token Interface ( Cr Token ) ; if ( amt uint ( 1 ) ) { Token Interface token Contract Token Interface ( token ) ; uint initial Bal token get Address ETH ( ) ? address ( this ) . balance : token Contract . balance Of ( address ( this ) ) ; require ( Cr Token Contract . redeem ( Cr Token Contract . balance Of ( address ( this ) ) ) 0 , " full withdraw failed " ) ; uint final Bal token get Address ETH ( ) ? address ( this ) . balance : token Contract . balance Of ( address ( this ) ) ; amt final Bal initial Bal ; } else { require ( Cr Token Contract . redeem Underlying ( amt ) 0 , " withdraw failed " ) ; } set Uint ( set Id , amt ) ; emit Log Withdraw ( token , Cr Token , amt , get Id , set Id ) ; bytes32 event Code keccak256 ( " Log Withdraw ( address , address , uint256 , uint256 , uint256 ) " ) ; bytes memory event Param abi . encode ( token , Cr Token , amt , get Id , set Id ) ; ( uint type , uint id ) connector ID ( ) ; Event Interface ( get Event Addr ( ) ) . emit Event ( type , id , event Code , event Param ) ; }
function get Revision ( ) internal pure returns ( uint256 ) { return 0 ; }
function get Next Generic Action ID (
function add U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { uint c a + b ; if ( c > a ) { return ( Math Error . NO ERROR , c ) ; } else { return ( Math Error . INTEGER OVERFLOW , 0 ) ; } }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; require ( total Supply . add ( amount ) < 50 10 3 10 18 , " Overmint ! " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mint ( uint256 amount , string memory object Uri )
function set Protocol Version ( string calldata deployment Subset , uint256 next Version , uint256 from Timestamp ) external override only Functional Manager { require ( deployment Subsets [ deployment Subset ] . exists , " deployment subset does not exist " ) ; require ( from Timestamp > now , " a protocol update can only be scheduled for the future " ) ; ( bool prev Upgrade Executed , uint256 current Version ) check Prev Upgrades ( deployment Subset ) ; require ( next Version > current Version , " protocol version must be greater or equal to current version " ) ; deployment Subsets [ deployment Subset ] . next Version next Version ; deployment Subsets [ deployment Subset ] . from Timestamp from Timestamp ; if ( prev Upgrade Executed ) { deployment Subsets [ deployment Subset ] . current Version current Version ; } emit Protocol Version Changed ( deployment Subset , current Version , next Version , from Timestamp ) ; }
function get Delegation Info ( address addr ) external override view returns ( address delegation , uint256 delegator Stake ) { Stake Owner Data memory data get Stake Owner Data ( addr ) ; return ( data . delegation , data . stake ) ; }
function get Accounts ( ) external view returns ( address [ ] memory ) ;
function function Delegate Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { require ( is Contract ( target ) , " Address : delegate call to non contract " ) ; ( bool success , bytes memory returndata ) target . delegatecall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function symbol ( )
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { if ( token Addr token Address ) { total Claimed Rewards total Claimed Rewards . add ( amount ) ; } Token ( token Addr ) . transfer ( to , amount ) ; }
function max Uint256 ( ) internal pure returns ( uint256 ) { return MAX UINT 256 ; }
function safe Approve ( IERC20 token , address spender , uint value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function get Asset Index (
function set Public Chainlink Token ( ) internal { set Chainlink Token ( Pointer Interface ( LINK TOKEN POINTER ) . get Address ( ) ) ; }
function copy ( slice memory self ) internal pure returns ( slice memory ) { return slice ( self . len , self . ptr ) ; }
function add Pool (
event Remove Job (
function burn (
function rebase ( ) external only Owner { require ( next Rebase Epoch < uint64 ( block . timestamp ) + rebase Offset , " Not ready to rebase ! " ) ; uint32 eth Price price Manager . average Price ( ) ; uint32 number eth Price ; uint8 even 0 ; uint8 odd 0 ; while ( number > 0 ) { if ( number % 2 1 ) { odd + 1 ; } else { even + 1 ; } number 10 ; } if ( even > odd ) { last Tau Rebase Result Rebase Result . Double ; last Trino Rebase Result Rebase Result . Park ; } else if ( even < odd ) { last Tau Rebase Result Rebase Result . Park ; last Trino Rebase Result Rebase Result . Double ; } else { last Tau Rebase Result Rebase Result . Draw ; last Trino Rebase Result Rebase Result . Draw ; } last Rebase Epoch uint64 ( block . timestamp ) ; next Rebase Epoch next Rebase Epoch + 1 hours ; if ( next Rebase Epoch < last Rebase Epoch ) { next Rebase Epoch uint64 ( block . timestamp block . timestamp % 3600 ) + REBASE CYCLE ; } uint tau Total Supply tau Token . rebase ( last Tau Rebase Result ) ; uint trino Total Supply trino Token . rebase ( last Trino Rebase Result ) ; emit Log Rebase ( last Rebase Epoch , eth Price , last Tau Rebase Result , tau Total Supply , last Trino Rebase Result , trino Total Supply ) ; }
function pending Test ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Test Per Share pool . acc Test Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 test Reward multiplier . mul ( test Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Test Per Share acc Test Per Share . add ( test Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Test Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function stake Good Accounting ( address staker Addr , uint256 stake Index , uint40 stake Id Param )
function work ( uint256 id , address user , uint256 debt , bytes calldata data )
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function batch Unfreeze Partial Tokens ( address [ ] calldata user Addresses , uint256 [ ] calldata amounts ) external ;
function token Type ( ) external pure returns ( string memory ) ;
function hold Can Be Executed As Notary ( Hold storage executable Hold , address operator , uint value ) internal view returns ( bool ) { if ( executable Hold . notary operator & & hold Can Be Executed ( executable Hold , value ) ) { return true ; } else { return false ; } }
event Log Registration Replaced ( address current Registrant , address new Registrant , uint256 amount Withdrawn ) ;
function get Amounts Out ( address pair , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( pair , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
modifier only Registry Admin ( ) { require ( is Registry Admin ( ) , " With Claimable Registry Management : caller is not the registry Admin " ) ; ; }
modifier non Reentrant ( ) { guard Counter + 1 ; uint256 local Counter guard Counter ; ; require ( local Counter guard Counter , " Reentrancy Guard : reentrant call " ) ; }
function player Get Pending Tx By Address ( address address To Check ) public view returns ( uint ) { return player Pending Withdrawals [ address To Check ] ; }
function distribute Delegate Rewards (
event Transfer ( address indexed from , address indexed to , uint256 amount ) ;
function set Manager ( string calldata role , address manager ) external only Admin ;
function multiply Decimal Round Precise ( uint x , uint y ) internal pure returns ( uint ) { return multiply Decimal Round ( x , y , PRECISE UNIT ) ; }
function set ERC20Wrapper Model ( address erc20Wrapper Model Address ) external ;
function add Member ( address addr , uint256 weight , bool is Certified ) external returns ( bool member Added ) only Elections Contract ;
function calculate Mint Fee ( uint256 erc20Wrapper Amount ) external view returns ( uint256 mint Fee , address dfo Wallet Address ) ;
function set Collateralization Ratio ( uint256 collateralization Ratio , uint256 collateralization Margin ) public override only Owner non Reentrant
function reward Per Token ( ) public view returns ( uint256 ) { if ( block . timestamp < start Time ) { return 0 ; } if ( total Supply 0 ) { return reward Per Token Stored ; } uint256 effective Total Supply total Supply . add ( total Supply Accounting ) ; return reward Per Token Stored . add ( last Time Reward Applicable ( ) . sub ( last Update Time ) . mul ( reward Rate ) . mul ( 1e18 ) . div ( effective Total Supply ) ) ; }
function total Supply ( ) public constant returns ( uint ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . total Supply ( ) ; } else { return total Supply ; } }
function exchange Rate Stored ( ) public view returns ( uint ) { ( Math Error err , uint result ) exchange Rate Stored Internal ( ) ; require ( err Math Error . NO ERROR , " exchange Rate Stored : exchange Rate Stored Internal failed " ) ; return result ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ; }
function set Rally Per Block ( uint256 rally Per Block ) public only Owner { mass Update Pools ( ) ; rally Per Block rally Per Block ; }
function transfer ( Shell Storage . Shell storage shell , address sender , address recipient , uint256 amount ) private { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; shell . balances [ sender ] sub ( shell . balances [ sender ] , amount , " Shell insufficient balance " ) ; shell . balances [ recipient ] add ( shell . balances [ recipient ] , amount , " Shell transfer overflow " ) ; emit Transfer ( sender , recipient , amount ) ; }
function Set Roles ( bytes32 role Type , address [ ] calldata addresses , bool [ ] calldata set To ) external { require ( Is Admin ( msg . sender ) , " Only admin " ) ; set Roles ( role Type , addresses , set To ) ; }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; uint256 c a b ; return c ; }
function rsplit ( slice memory self , slice memory needle ) internal pure returns ( slice memory token ) { rsplit ( self , needle , token ) ; }
modifier only Owner ( ) { require ( is Owner ( ) , " unauthorized " ) ; ; }
function is Blacklisted ( address account ) public view returns ( bool ) { return blacklisted [ account ] ; }
function add (
function can Transfer By Partition (
function verify Multi Sig (
function to Int ( int128 x ) internal pure returns ( int64 ) { return int64 ( x > > 64 ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) govern ( sender ) public returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; emit Approval ( sender , recipient , amount ) ; return true ; }
function withdraw ( uint256 amount )
function max Scaling Factor ( ) external view returns ( uint256 ) ;
function get Current Votes ( address account ) external view returns ( uint256 ) { uint32 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function set Token URI ( uint256 token Id , string uri ) internal { require ( exists ( token Id ) ) ; token UR Is [ token Id ] uri ; }
modifier non Reentrant ( ) { require ( not Entered , " Reentrancy Guard : reentrant call " ) ; not Entered false ; ; not Entered true ; }
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; 0 . 25 % 99 . 75 % pool . lp Token . safe Transfer ( address ( msg . sender ) , amount Excluding Fee ) ; pool . lp Token . safe Transfer ( devaddr , withdrwal Fee ) ; emit Emergency Withdraw ( msg . sender , pid , amount Excluding Fee ) ; user . amount 0 ; user . reward Debt 0 ; }
function get Reserves ( ) external view returns ( address [ ] memory ) { return reserves List ; }
function is Feature Authorised ( address wallet , address feature ) external view returns ( bool ) ;
function append Uint8 ( buffer memory buf , uint8 data ) internal pure returns ( buffer memory ) { return write Uint8 ( buf , buf . buf . length , data ) ; }
event Execution Requested ( uint256 indexed execution Id , address indexed to , uint256 indexed value , bytes data ) ;
function to Uint64 ( uint256 value ) internal pure returns ( uint64 ) { require ( value < 2 64 , " Safe Cast : value doesn \ ' t fit in 64 bits " ) ; return uint64 ( value ) ; }
function actual Balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) ; }
function set Vault Access ( address who , bool permit ) external only Manager { can Modify Vault [ who ] permit ; }
function transfer From And Call ( address from , address to , uint256 value ) public override returns ( bool ) { return transfer From And Call ( from , to , value , " " ) ; }
function has Migrated ( Self storage self ) public view returns ( bool has Migrated )
function withdraw ( uint256 shares )
function get Withdraw Intent (
function get Balance ( address token , address account ) external view returns ( uint256 ) ;
function set Approval For All ( address operator , bool approved ) public virtual override { require ( operator ! msg Sender ( ) , " ERC721 : approve to caller " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
function calculate Address Active Stake ( address address ) private view returns ( uint256 ) { Service Provider Factory sp Factory Service Provider Factory ( service Provider Factory Address ) ; Delegate Manager delegate Manager Delegate Manager ( delegate Manager Address ) ; ( uint256 direct Deployer Stake , , , , , ) sp Factory . get Service Provider Details ( address ) ; ( uint256 locked Deployer Stake , ) sp Factory . get Pending Decrease Stake Request ( address ) ; uint256 active Deployer Stake direct Deployer Stake . sub ( locked Deployer Stake ) ; uint256 total Delegator Stake delegate Manager . get Total Delegator Stake ( address ) ; ( , uint256 locked Delegator Stake , ) delegate Manager . get Pending Undelegate Request ( address ) ; uint256 active Delegator Stake total Delegator Stake . sub ( locked Delegator Stake ) ; uint256 active Stake active Deployer Stake . add ( active Delegator Stake ) ; return active Stake ; }
function get Pending Pay Out Map (
modifier non Reentrant ( ) { require ( reentrancy Lock REENTRANCY GUARD FREE , " non Reentrant " ) ; reentrancy Lock REENTRANCY GUARD LOCKED ; ; reentrancy Lock REENTRANCY GUARD FREE ; }
function build Path ( address from , address WETH , address to ) internal pure returns ( address [ ] memory path )
function update Frac Pool Fees (
function mul ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { if ( a 0 ) { return 0 ; } uint128 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { uint old Value allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] 0 ; } else { allowed [ msg . sender ] [ spender ] old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) external only Owner pool Exist ( pid ) { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function set Locked Time ( uint time )
function migrate Guardians ( address [ ] calldata guardians To Migrate , I Guardians Registration Previous Version previous Contract ) external only Initialization Admin ;
function submit Proposal (
function initialize (
function is Governance Address ( ) external pure returns ( bool ) { return true ; }
function safe Transfer From ( address from , address to , uint256 token Id , bytes calldata data ) external ;
function get Balancer Trade Data (
function swap Registration ( Vesting Storage storage self , address replacement Registrant ) public returns ( bool ) { require ( replacement Registrant ! 0 ) ; require ( self . holding Amount [ replacement Registrant ] [ 0 ] 0 ) ; uint256 vest Amount self . holding Amount [ msg . sender ] [ 0 ] ; uint256 bonus self . holding Amount [ msg . sender ] [ 1 ] ; uint256 withdrawn Amount self . has Withdrawn [ msg . sender ] ; require ( vest Amount > 0 ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . has Withdrawn [ msg . sender ] 0 ; self . holding Amount [ replacement Registrant ] [ 0 ] vest Amount ; self . holding Amount [ replacement Registrant ] [ 1 ] bonus ; self . has Withdrawn [ replacement Registrant ] withdrawn Amount ; Log Registration Replaced ( msg . sender , replacement Registrant , self . has Withdrawn [ replacement Registrant ] ) ; return true ; }
function hash Typed Data V4 ( bytes32 struct Hash ) internal view virtual returns ( bytes32 ) { return ECDSA . to Typed Data Hash ( domain Separator V4 ( ) , struct Hash ) ; }
function set Exchange ( Self storage self , address exchange ) public
function pending Reward ( uint256 pool Id ) public override view returns ( uint256 ) { do not support other pool types return I Staking Rewards ( pool Map [ pool Id ] . target Pool ) . earned ( address ( this ) ) ; }
function total Supply ( )
function register Token (
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function approve ( address spender , uint256 amount ) returns ( bool success ) { allowed [ msg . sender ] [ spender ] amount ; Approval ( msg . sender , spender , amount ) ; return true ; }
function ( ) payable external { fallback ( ) ; }
function transfer Ownership ( address new Owner ) public only Owner { if ( new Owner ! address ( 0 ) ) { owner new Owner ; } }
function get Max Collateral ( uint cdp Id , bytes32 ilk , address join Addr ) public view returns ( uint ) { uint price get Price ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; ( , uint mat ) Spotter ( SPOTTER ADDRESS ) . ilks ( ilk ) ; uint max Collateral sub ( sub ( collateral , ( div ( mul ( mat , debt ) , price ) ) ) , 10 ) ; uint normalize Max Collateral max Collateral ; if ( Join ( join Addr ) . dec ( ) ! 18 ) { normalize Max Collateral max Collateral ( 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; } return normalize Max Collateral ; }
function get All Rewards ( address account ) public override { uint8 reward Pool Length uint8 ( reward Pool Info . length ) ; for ( uint8 pid 0 ; pid < reward Pool Length ; + + pid ) { get Reward ( pid , account ) ; } }
function mint Idle Token ( uint256 amount , bool skip Rebalance , address referral ) external returns ( uint256 minted Tokens ) ;
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; assert ( c a b ) ; return c ; }
function repay ( address ctoken , uint256 amount ) internal returns ( bool success )
function external Token Transfer ( IERC20 external Token , address to , uint256 value )
function governance ( ) external view returns ( address ) ;
function unstake ( uint256 amount , bytes calldata ) external ;
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a ) ; return c ; }
function is Operation Pending ( bytes32 id ) public view returns ( bool pending ) { return timestamps [ id ] > DONE TIMESTAMP ; }
function make Reserve To Vault ( ) external only Owner { require ( reserve Tokens Vault ! address ( 0 ) ) ; reserve Tokens Vault . fill Up Allowance ( ) ; }
function get Manager ( string calldata role ) external view returns ( address ) ;
function some Bool ( uint256 token Id ) external view returns ( bool ) { require ( exists ( token Id ) , " Token ID does not exist " ) ; return additional Data [ token Id ] . some Bool ; }
~ 3 days in blocks ( assuming 15s blocks )
function before Token Transfer ( address from , address to , uint256 amount ) internal override ( ERC20 ) { super . before Token Transfer ( from , to , amount ) ; require ( ! is Locked ( from ) , " Lockable : token transfer from locked account " ) ; require ( ! is Locked ( to ) , " Lockable : token transfer to locked account " ) ; require ( ! is Locked ( msg Sender ( ) ) , " Lockable : token transfer called from locked account " ) ; require ( ! paused ( ) , " Pausable : token transfer while paused " ) ; require ( balance Of ( from ) . sub ( get Time Locked Amount ( from ) ) . sub ( get Investor Locked Amount ( from ) ) > amount , " Lockable : token transfer from time and investor locked account " ) ; }
event New TTL ( bytes32 indexed node , uint64 ttl ) ;
function set Pause ( ) external when Not Paused only Owner { pause ( ) ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have pauser role to unpause " ) ; unpause ( ) ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller | | msg . sender governance , " Golff : ! governance " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function bpow ( uint base , uint exp )
function on Crypto Alpaca Energy Changed (
function create Crowd Proposal ( address [ ] memory targets ,
function post Prices ( bytes [ ] calldata messages , bytes [ ] calldata signatures , string [ ] calldata symbols ) external { require ( messages . length signatures . length , " messages and signatures must be 1 : 1 " ) ; for ( uint i 0 ; i < messages . length ; i + + ) { price Data . put ( messages [ i ] , signatures [ i ] ) ; } uint eth Price fetch Eth Price ( ) ; for ( uint i 0 ; i < symbols . length ; i + + ) { post Price Internal ( symbols [ i ] , eth Price ) ; } }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 sdoge Reward multiplier . mul ( sdoge Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; no dev fee 0 . 01 % 0 . 01 % 0 . 01 % 0 . 01 % pool . acc S Doge Per Share pool . acc S Doge Per Share . add ( sdoge Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function is Reward Ready ( address reward Address )
function savings Manager ( ) internal view returns ( address ) { return nexus . get Module ( KEY SAVINGS MANAGER ) ; }
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg . sender , allowances [ account ] [ msg . sender ] . sub ( amount ) ) ; }
function balance Of ( address owner ) public view returns ( uint256 balance ) { return super . balance Of ( owner ) + freezing Balance [ owner ] ; }
function transfer Director ( address new Director ) public only Director Force { director new Director ; }
function remove Governor ( address governor ) only Owner external { governors [ governor ] false ; }
function uri ( uint256 token Id ) external view override returns ( string memory ) { return token Uris [ token Id ] ; }
function check (
function Ownable ( ) public { owner msg . sender ; }
modifier when System Not Paused ( ) { require ( ! controller . paused ( ) , " system is paused " ) ; ; }
function withdraw ( Self storage self , uint256 gross Shares ) internal returns ( bool success )
function balance Of Batch ( address [ ] calldata accounts , uint256 [ ] calldata ids ) external view returns ( uint256 [ ] memory ) ;
function divuu ( uint256 x , uint256 y ) private pure returns ( uint128 ) { require ( y ! 0 ) ; uint256 result ; if ( x < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) result ( x < < 64 ) y ; else { uint256 msb 192 ; uint256 xc x > > 192 ; if ( xc > 0x100000000 ) { xc > > 32 ; msb + 32 ; } if ( xc > 0x10000 ) { xc > > 16 ; msb + 16 ; } if ( xc > 0x100 ) { xc > > 8 ; msb + 8 ; } if ( xc > 0x10 ) { xc > > 4 ; msb + 4 ; } if ( xc > 0x4 ) { xc > > 2 ; msb + 2 ; } No need to shift xc anymore result ( x < < 255 msb ) ( ( y 1 > > msb 191 ) + 1 ) ; require ( result < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; uint256 hi result ( y > > 128 ) ; uint256 lo result ( y & 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; uint256 xh x > > 192 ; uint256 xl x < < 64 ; if ( xl < lo ) xh 1 ; We rely on overflow behavior here lo hi < < 128 ; if ( xl < lo ) xh 1 ; We rely on overflow behavior here assert ( xh hi > > 128 ) ; result + xl y ; } require ( result < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; return uint128 ( result ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { Check allowance allowance [ from ] [ msg . sender ] value ; transfer ( from , to , value ) ; return true ; }
function purge Pack ( uint256 pack Id , uint256 limit )
function balance Of ( address account ) external view returns ( uint ) ;
modifier when Paused ( ) { require ( paused ) ; ; }
function set Liquidation Fee ( address asset , uint new Value ) public only Manager { require ( new Value < 100 , " Unit Protocol : VALUE OUT OF RANGE " ) ; liquidation Fee [ asset ] new Value ; }
function pending Reward ( address staker ) private returns ( uint256 ) { uint256 amount ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) . div ( scaling ) ; stakers [ staker ] . remainder + ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) % scaling ; return amount ; }
function mass Update Pools ( ) public discount CHI { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
function set Total Fee ( uint256 new Total Fee ) public only Owner { total Fee new Total Fee ; }
function approve ( address from , address spender , uint value )
function remove ( Map storage map , bytes32 key ) private returns ( bool ) { uint256 key Index map . indexes [ key ] ; Equivalent to contains ( map , key ) uint256 to Delete Index key Index 1 ; uint256 last Index map . entries . length 1 ; Map Entry storage last Entry map . entries [ last Index ] ; map . entries [ to Delete Index ] last Entry ; All indexes are 1 based map . entries . pop ( ) ; delete map . indexes [ key ] ; return true ; } else { return false ; } }
function pause ( ) external only Pauser { paused true ; emit Pause ( ) ; }
function withdraw ( uint amount ) external { require ( msg . sender controller | | msg . sender governance | | msg . sender strategist , " ! authorized " ) ; uint balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } address vault I Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , amount ) ; }
function change Oracles (
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) sort Tokens ( token A , token B ) ; pair address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , init code hash ) ) ) ) ; }
function set Owner By Admin ( address owner ) public { require ( msg . sender admin ) ; owner owner ; }
function add Default Player ( address addr , bytes32 name )
function get Last ( Data storage self ) public view returns ( address ) { return self . tail ; }
event Owner Set ( address indexed old Owner , address indexed new Owner ) ;
function update Billboard ( string memory new Billboard Url ) public payable { require ( bytes ( new Billboard Url ) . length ! 0 , " Billboard URL cannot be blank " ) ; require ( msg . value > 0 , " You need to actually send ETH ! " ) ; update Cost get Cost ( ) ; require ( msg . value > update Cost , " You didn ' t send enough wei , check get Cost ( ) " ) ; last Epoch now ; url Billboard new Billboard Url ; update Cost update Cost markup 100 ; perform Donation ( msg . value ) ; }
function produce Milk ( uint256 amount ) public override only Stable returns ( uint256 ) { 5 % 95 % balances [ msg . sender ] balances [ msg . sender ] . add ( stabled ) ; balances [ devs ] balances [ devs ] . add ( devs Fee ) ; total Supply total Supply . add ( amount ) ; emit Transfer ( address ( 0 ) , msg . sender , stabled ) ; emit Transfer ( address ( 0 ) , devs , devs Fee ) ; return stabled ; }
function total Supply ( ) public view override returns ( uint256 ) { return token Owners . length ( ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 wildy Reward multiplier . mul ( wildy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; uint256 wildy Supply wildy . total Supply ( ) ; uint256 wildy Max wildy . max Supply ( ) ; if ( wildy Supply . add ( wildy Reward ) > wildy Max ) { wildy Reward wildy Max . sub ( wildy Supply ) ; } wildy . mint ( address ( this ) , wildy Reward ) ; pool . acc Wildy Per Share pool . acc Wildy Per Share . add ( wildy Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
modifier when Not Paused ( ) { require ( ! paused , " Pausable : paused " ) ; ; }
function create Token Vault Int ( uint256 tokens ) internal only Owner returns ( Token Vault ) { Token Vault token Vault new Token Vault ( ERC20 ( this ) ) ; create Tokens Int ( tokens , token Vault ) ; token Vault . fill Up Allowance ( ) ; return token Vault ; }
function sync ( ) external override lock { uint [ 5 ] memory proxy Data ; Proxy Data . fill ( proxy Data , 4 + 32 ( Proxy Data . COUNT + 0 ) ) ; ( , , uint32 first Sell ID ) get Reserves ( ) ; ( uint booked Stock , uint booked Money , ) get Booked ( ) ; uint balance Stock my Balance ( Proxy Data . stock ( proxy Data ) ) ; uint balance Money my Balance ( Proxy Data . money ( proxy Data ) ) ; require ( balance Stock > booked Stock & & balance Money > booked Money , " One Swap : INVALID BALANCE " ) ; set Reserves ( balance Stock booked Stock , balance Money booked Money , first Sell ID ) ; }
function balance Of ( address account ) public override view returns ( uint256 ) { return balances [ account ] ; }
function can Claim ( address who ) public view returns ( bool ) { for ( uint8 i 0 ; i < can Claim If Has Tokens . length ; i + + ) { if ( IERC20 ( can Claim If Has Tokens [ i ] ) . balance Of ( who ) > can Claim If Has This Much Tokens [ i ] ) { return true ; } } return false ; }
function receipt ETH ( address keeper , uint amount ) external { require ( jobs [ msg . sender ] , " receipt : ! job " ) ; credits [ msg . sender ] [ ETH ] credits [ msg . sender ] [ ETH ] . sub ( amount , " work Receipt : insuffient funds " ) ; last Job [ keeper ] now ; payable ( keeper ) . transfer ( amount ) ; emit Keeper Worked ( ETH , msg . sender , keeper , block . number , amount ) ; }
function safe Transfer From ( address from , address to , uint256 id , uint256 amount , bytes calldata data ) external ;
function validate Token Info ( Pb Entity . Token Info memory token )
function total Value ( ) public virtual view returns ( uint256 ) { return tokens Here ( ) ; }
function increase Stake (
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function transfer ( address dst , uint amount ) public returns ( bool ) { transfer Tokens ( msg . sender , dst , amount ) ; return true ; }
function get Fee ( uint amount , uint gas Cost , address owner ) internal returns ( uint fee Amount ) { uint fee MANUAL SERVICE FEE ; if ( Bot Registry ( BOT REGISTRY ADDRESS ) . bot List ( tx . origin ) ) { fee AUTOMATIC SERVICE FEE ; } if ( Discount ( DISCOUNT ADDRESS ) . is Custom Fee Set ( owner ) ) { fee Discount ( DISCOUNT ADDRESS ) . get Custom Service Fee ( owner ) ; } fee Amount ( fee 0 ) ? 0 : ( amount fee ) ; if ( gas Cost ! 0 ) { uint eth Dai Price get Price ( ETH ILK ) ; gas Cost rmul ( gas Cost , eth Dai Price ) ; fee Amount add ( fee Amount , gas Cost ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } ERC20 ( DAI ADDRESS ) . transfer ( WALLET ID , fee Amount ) ; }
function deposit Underlying ( Self storage self , address token , uint256 amount ) internal returns ( bool success )
function is Approved For All ( address account , address operator ) external view returns ( bool ) ;
function daylimit ( uint limit ) { m daily Limit limit ; m last Day today ( ) ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function init ( Self storage self , address stakes Token , address shares Token ) public
function skim ( address to ) external lock { address token0 token0 ; address token1 token1 ; safe Transfer ( token0 , to , IERC20Uniswap ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20Uniswap ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ from ] ) ; require ( value < allowed [ from ] [ msg . sender ] ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; Transfer ( from , to , value ) ; return true ; }
function is Less Than ( uint256 a , Unsigned memory b ) internal pure returns ( bool ) { return from Unscaled Uint ( a ) . raw Value < b . raw Value ; }
function get Block Number ( ) internal view returns ( uint ) { return block . number ; }
function add Locker ( address account ) public only Owner when Not Paused { add Locker ( account ) ; }
function set Exchange ( address exchange ) public override only Owner non Reentrant
function burn Percentage ( ) external view returns ( uint256 ) { return burn Percentage ; }
function withdraw ETH ( uint256 shares ) public virtual { }
function withdraw Fee ( ) public virtual view returns ( uint256 ) { return controller . withdraw Fee ( address ( this ) ) ; }
function mint ( address account , uint256 amount ) external returns ( bool ) ;
function reset Tracked Value (
function on ERC721Received ( address , address , uint256 , bytes calldata ) external pure returns ( bytes4 ) { return bytes4 ( 0x150b7a02 ) ; }
event Submit Job ( address indexed job , address indexed provider , uint block , uint credit ) ;
function create Native ( bytes calldata model Init Call Payload ) external returns ( address eth Item Address , bytes memory eth Item Init Response ) ;
event Transfer ( bytes32 indexed node , address owner ) ;
event Contract Address Changed ( address indexed previous Address , address indexed new Address ) ;
event Log User Un Registered ( address registrant ) ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ; }
function get Reserve A Token Address ( address reserve ) external view returns ( address ) ;
function deploy Handler Logic ( ) internal { Payment Handler created Handler new Payment Handler ( ) ; created Handler . initialize ( this ) ; handler Logic Address address ( created Handler ) ; }
function balance Of Batch ( address [ ] memory owners , uint256 [ ] memory ids )
function check Price For Block ( address token Address , uint256 block Num ) public view returns ( uint256 eth Amount , uint256 erc20Amount ) { require ( address ( msg . sender ) address ( tx . origin ) , " It can ' t be a contract " ) ; Token Info storage token Info token Info [ token Address ] ; return ( token Info . price Info List [ block Num ] . eth Amount , token Info . price Info List [ block Num ] . erc20Amount ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update , uint256 last Reward Block ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } if ( last Reward Block 0 ) { last Reward Block block . number > start Block ? block . number : start Block ; } total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Susafe Per Share : 0 } ) ) ; }
function calc In Given Out (
function set Minter ( address minter ) external { require ( msg . sender minter , " Dena : : set Minter : only the minter can change the minter address " ) ; emit Minter Changed ( minter , minter ) ; minter minter ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { transfer ( msg . sender , to , value ) ; return true ; }
function guardian Unregistered ( address guardian ) external only Guardians Registration Contract ;
function set Oracle Address ( address oracle )
function transfer Ownership ( address new Owner ) public override only Owner { require ( new Owner ! address ( 0 ) , " New owner is the zero address " ) ; new Owner new Owner ; }
function margin Trade (
function add ( uint256 alloc Point , IERC20 lp Token ) public only Owner { require ( ! lp Exists [ address ( lp Token ) ] , " do not add the same lp token more than once " ) ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Update Time : 0 , reward Per Token Stored : 0 } ) ) ; lp Exists [ address ( lp Token ) ] true ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Test Per Share : 0 } ) ) ; }
function disable Initial Stage ( ) public
function token Price ( ) external view returns ( uint256 ) { return token Price ; }
function change Token Name ( string new Name ) public is Owner returns ( bool success ) { emit Token Name Changed ( name , new Name ) ; name new Name ; return true ; }
function get Total Locked Delegation For Service Provider ( address sp )
function delete Address ( bytes32 key ) external only Current Owner { delete address Storage [ key ] ; }
function payback Debt ( uint cdp Id , bytes32 ilk , uint dai Amount , address owner ) internal { address urn manager . urns ( cdp Id ) ; uint whole Debt get All Debt ( VAT ADDRESS , urn , urn , ilk ) ; if ( dai Amount > whole Debt ) { ERC20 ( DAI ADDRESS ) . transfer ( owner , sub ( dai Amount , whole Debt ) ) ; dai Amount whole Debt ; } if ( ERC20 ( DAI ADDRESS ) . allowance ( address ( this ) , DAI JOIN ADDRESS ) 0 ) { ERC20 ( DAI ADDRESS ) . approve ( DAI JOIN ADDRESS , uint ( 1 ) ) ; } dai Join . join ( urn , dai Amount ) ; manager . frob ( cdp Id , 0 , normalize Payback Amount ( VAT ADDRESS , urn , ilk ) ) ; }
function deposit Liquidation ( address m Asset , uint256 liquidated )
function config ( ) internal view returns ( Address Config ) { return config ; }
function sell ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; uint tokens Left ex Data . src Amount ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } if ( ex Data . price0x > 0 ) { approve0x Proxy ( ex Data . src Addr , ex Data . src Amount ) ; uint eth Amount get Protocol Fee ( ex Data . src Addr , msg . value , ex Data . src Amount ) ; ( success , swaped Tokens , tokens Left ) take Order ( ex Data , eth Amount , Action Type . SELL ) ; if ( success ) { wrapper ex Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . SELL ) ; wrapper ex Data . wrapper ; } require ( get Balance ( ex Data . dest Addr ) > wmul ( ex Data . min Price , ex Data . src Amount ) , " Final amount isn ' t correct " ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , swaped Tokens ) ; }
function change Rootnode Owner ( address new Owner ) external override only Owner { get ENS Registry ( ) . set Owner ( root Node , new Owner ) ; emit Rootnode Owner Change ( root Node , new Owner ) ; }
function transfer ( address from , address to , uint256 value ) internal { require ( to ! address ( 0 ) ) ; require ( ! is Locked ( from ) , " The account has been locked " ) ; if ( owner ! from & & ! transfer Able ) { revert ( " Transfers are not currently open " ) ; } balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; }
function delete Answer ( uint256 answer Id )
function transfer Ownership ( address new Owner ) public virtual { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function sub ( uint96 a , uint256 b ) internal pure returns ( uint96 ) { require ( uint256 ( uint96 ( b ) ) b , " Safe Math : subtraction overflow " ) ; return sub ( a , uint96 ( b ) , " Safe Math : subtraction overflow " ) ; }
function transfer ( address from , address to , uint256 value ) internal { require ( to ! address ( 0 ) ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; }
function last Claimed For ( address account Address ) external view returns ( uint256 ) { require Is Initialized ( ) ; uint256 length accounts [ account Address ] . claim History . history . length ; if ( length > 0 ) { return uint256 ( accounts [ account Address ] . claim History . history [ length 1 ] . time ) ; } return 0 ; }
function rebond From Unbonded With Hint (
function send Reward LP ( ) public update Staking Reward LP ( msg . sender ) { require ( is Start , " not started " ) ; require ( 0 < staked [ msg . sender ] . rewards , " More than 0 " ) ; uint256 reward staked [ msg . sender ] . rewards ; staked [ msg . sender ] . rewards 0 ; uint256 total Weight rate Reward . add ( rate Dev Fee ) . add ( rate Fund ) ; mint ( msg . sender , reward . div ( total Weight ) . mul ( rate Reward ) ) ; mint ( fund Address , reward . div ( total Weight ) . mul ( rate Fund ) ) ; mint ( dev Address , reward . div ( total Weight ) . mul ( rate Dev Fee ) ) ; emit Rewards ( msg . sender , reward ) ; }
function balance Of ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }
function refund Gas (
function new Proposal Threshold At ( uint256 session Id , uint256 proposals Count )
function register Contract ( address account ) external only Owner { require ( is Contract ( account ) , " Token : account is not a smart contract " ) ; contracts [ account ] true ; }
function Zap In (
function empty ( slice memory self ) internal pure returns ( bool ) { return self . len 0 ; }
function calculate Credit Max ( address token ) external view returns ( uint ) { return calculate Credit Max Of ( msg . sender , token ) ; }
function update Funding Round Block Diff ( uint256 new Funding Round Block Diff ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; emit Funding Round Block Diff Updated ( new Funding Round Block Diff ) ; funding Round Block Diff new Funding Round Block Diff ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 mink Reward multiplier . mul ( mink Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; mink . mint ( devaddr , mink Reward . div ( 10 ) ) ; mink . mint ( address ( this ) , mink Reward ) ; pool . acc Mink Per Share pool . acc Mink Per Share . add ( mink Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function increase Approval (
function redeem ( uint amount ) public only Owner { require ( total Supply > amount ) ; require ( balances [ owner ] > amount ) ; total Supply amount ; balances [ owner ] amount ; Redeem ( amount ) ; }
function enable Reserve As Collateral (
function revoke Operator ( address operator ) external { require ( operator ! msg . sender ) ; authorized Operator [ operator ] [ msg . sender ] false ; emit Revoked Operator ( operator , msg . sender ) ; }
function latest Round Data ( )
function deposit ( uint256 amount LP , uint256 pair Code ) external lock returns ( bool ) { require ( block . timestamp > program Start At & & block . timestamp < program End At , " Program is not active " ) ; require ( amount LP > 0 , " Cannot deposit 0 tokens " ) ; require ( I Uniswap V2Pair ( pair Pools Info [ pair Code ] ) . transfer From ( msg . sender , address ( this ) , amount LP ) , " Fail to deposit liquidity tokens " ) ; uint256 deposit Number stakers [ msg . sender ] . total Deposits . length ; add Deposit ( msg . sender , deposit Number , pair Code , amount LP , block . timestamp ) ; ( , address L Paddress , ) get Pair Pool ( pair Code ) ; uint256 volcie Token ID mint ( msg . sender , L Paddress , amount LP ) ; update Mint ( msg . sender , deposit Number , amount LP , pair Code , volcie Token ID ) ; emit Deposited ( msg . sender , volcie Token ID , deposit Number , pair Code , amount LP , block . timestamp ) ; return true ; }
function change Quota (
function to U Int ( int128 x ) internal pure returns ( uint64 ) { require ( x > 0 ) ; return uint64 ( x > > 64 ) ; }
function proposal Max Operations ( ) public pure returns ( uint256 ) { return 10 ; 10 actions
event Timed Crowdsale Extended ( uint256 prev Closing Time , uint256 new Closing Time ) ;
function get Vote Unready Status ( address subject ) external view returns (
function boost For (
function mulu ( int128 x , uint256 y ) internal pure returns ( uint256 ) { if ( y 0 ) return 0 ; require ( x > 0 ) ; uint256 lo ( uint256 ( x ) ( y & 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ) > > 64 ; uint256 hi uint256 ( x ) ( y > > 128 ) ; require ( hi < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; hi < < 64 ; require ( hi < 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF lo ) ; return hi + lo ; }
function update Managed Rate ( uint256 value , uint256 granularity ) external only Whitelisted returns ( bool ) { require ( value > 0 , " Exchange rate cannot be zero " ) ; require ( granularity > 0 , " Granularity cannot be zero " ) ; USD To CAD Rate value ; granularity granularity ; timestamp block . timestamp ; emit Managed Rate Updated ( value , granularity ) ; return true ; }
function pay Lending Fee (
function Write Bool ( bool b ) internal pure returns ( bytes memory ) { bytes memory buff ; assembly { buff : mload ( 0x40 ) mstore ( buff , 1 ) switch iszero ( b ) case 1 { mstore ( add ( buff , 0x20 ) , shl ( 248 , 0x00 ) ) } default { mstore ( add ( buff , 0x20 ) , shl ( 248 , 0x01 ) ) } mstore ( 0x40 , add ( buff , 0x21 ) ) } return buff ; }
function has Role ( bytes32 role , address account ) public view returns ( bool ) { return roles [ role ] . members . contains ( account ) ; }
function exit ( ) public
function withdraw ( uint256 amount ) public virtual { total Supply total Supply . sub ( amount ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( amount ) ; staking Token . safe Transfer ( msg . sender , amount ) ; }
function set Dmm Token Factory ( address new Dmm Token Factory ) external ;
function is Less Than Or Equal ( uint256 a , Unsigned memory b ) internal pure returns ( bool ) { return from Unscaled Uint ( a ) . raw Value < b . raw Value ; }
function owner Of (
function expected APY ( address ) public override view returns ( uint256 ) { return expected APY ( 0 , 0 ) ; }
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " proposal does not exist " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] ; }
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To I Swapdex Factory ( factory ) . fee To ( ) ; fee On fee To ! address ( 0 ) ; gas savings if ( fee On ) { if ( k Last ! 0 ) { uint root K Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! 0 ) { k Last 0 ; } }
function transfer Votes ( address old Candidate , address new Candidate , uint256 votes ) internal
function initialize ( address owner , U Fragments u Frags )
function Pending Reward ( address caller ) public view returns ( uint256 pending Reward ) { in hours uint256 reward ( ( users [ caller ] . active Deposit ) . mul ( total Staked Time . mul ( users [ caller ] . rate ) ) ) ; reward reward . div ( 10 18 ) ; return reward . add ( users [ caller ] . pending Gains ) ; }
event Delegate Votes Changed (
function transfer ( address from , address to , uint value ) airnow ( from , to ) internal { require ( balance Of [ from ] > value ) ; require ( balance Of [ to ] + value > balance Of [ to ] ) ; uint previous Balances balance Of [ from ] + balance Of [ to ] ; balance Of [ from ] value ; balance Of [ to ] + value ; emit Transfer ( from , to , value ) ; assert ( balance Of [ from ] + balance Of [ to ] previous Balances ) ; }
function get Fee ( uint256 amount , address user , address token , uint256 dfs Fee Divider ) internal returns ( uint256 fee Amount ) { if ( dfs Fee Divider ! 0 & & Discount ( DISCOUNT ADDRESS ) . is Custom Fee Set ( user ) ) { dfs Fee Divider Discount ( DISCOUNT ADDRESS ) . get Custom Service Fee ( user ) ; } if ( dfs Fee Divider 0 ) { fee Amount 0 ; } else { fee Amount amount dfs Fee Divider ; if ( fee Amount > ( amount 10 ) ) { fee Amount amount 10 ; } if ( token KYBER ETH ADDRESS ) { WALLET ID . transfer ( fee Amount ) ; } else { ERC20 ( token ) . safe Transfer ( WALLET ID , fee Amount ) ; } } }
function can Perform ( address sender , bytes32 role , uint256 [ ] params ) public view returns ( bool ) { if ( ! has Initialized ( ) ) { return false ; } I Kernel linked Kernel kernel ( ) ; if ( address ( linked Kernel ) address ( 0 ) ) { return false ; } return linked Kernel . has Permission ( sender , address ( this ) , role , Conversion Helpers . dangerously Cast Uint Array To Bytes ( params ) ) ; }
function start New Epoch ( ) public { About a week epoch Rewards [ epoch ] rewards In This Epoch ; cumulative Rewards Since Start cumulative Rewards Since Start . add ( rewards In This Epoch ) ; rewards In This Epoch 0 ; epoch Calculation Start Block block . number ; + + epoch ; }
function calc Deposit Underlying Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee , uint256 exchange Rate ) public pure override returns ( uint256 underlying Cost , uint256 fee Shares )
function exchange Rate Current ( ) public non Reentrant returns ( uint ) { require ( accrue Interest ( ) uint ( Error . NO ERROR ) , " accrue interest failed " ) ; return exchange Rate Stored ( ) ; }
function redeem (
function us div ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result ( int256 ( x ) < < 64 ) y ; return int128 ( result ) ; }
function ( ) payable external { address impl implementation ; require ( impl ! address ( 0 ) ) ; assembly { 0x40 is the " free memory slot " , meaning a pointer to next slot of empty memory . mload ( 0x40 ) loads the data in the free memory slot , so ptr is a pointer to the next slot of empty memory . It ' s needed because we ' re going to write the return data of delegatecall to the free memory slot . let ptr : mload ( 0x40 ) calldatacopy is copy calldatasize bytes from calldata First argument is the destination to which data is copied ( ptr ) Second argument specifies the start position of the copied data . Since calldata is sort of its own unique location in memory , 0 doesn ' t refer to 0 in memory or 0 in storage it just refers to the zeroth byte of calldata . That ' s always going to be the zeroth byte of the function selector . Third argument , calldatasize , specifies how much data will be copied . calldata is naturally calldatasize bytes long ( same thing as msg . data . length ) calldatacopy ( ptr , 0 , calldatasize ) delegatecall params explained : gas : the amount of gas to provide for the call . gas is an Opcode that gives us the amount of gas still available to execution impl : address of the contract to delegate to ptr : to pass copied data calldatasize : loads the size of bytes memory data , same as msg . data . length 0 , 0 : These are for the out and outsize params . Because the output could be dynamic , these are set to 0 , 0 so the output data will not be written to memory . The output data will be read using returndatasize and returdatacopy instead . result : This will be 0 if the call fails and 1 if it succeeds let result : delegatecall ( gas , impl , ptr , calldatasize , 0 , 0 ) let size : returndatasize returndatacopy is an Opcode that copies the last return data to a slot . ptr is the slot it will copy to , 0 means copy from the beginning of the return data , and size is the amount of data to copy . returndatasize is an Opcode that gives us the size of the last return data . In this case , that is the size of the data returned from delegatecall returndatacopy ( ptr , 0 , size ) if result is 0 , revert . if result is 1 , return size amount of data from ptr . This is the data that was copied to ptr from the delegatecall return data switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }
function re Adjust Difficulty ( ) internal { uint eth Blocks Since Last Difficulty Period block . number latest Difficulty Period Started ; 200 should be 12 times slower than ethereum if ( eth Blocks Since Last Difficulty Period < target Eth Blocks Per Diff Period ) { uint excess block pct ( target Eth Blocks Per Diff Period . mul ( 100 ) ) . div ( eth Blocks Since Last Difficulty Period ) ; uint excess block pct extra excess block pct . sub ( 100 ) . limit Less Than ( 1000 ) ; by up to 50 % } else { uint shortage block pct ( eth Blocks Since Last Difficulty Period . mul ( 100 ) ) . div ( target Eth Blocks Per Diff Period ) ; always between 0 and 1000 by up to 50 % } latest Difficulty Period Started block . number ; very difficult { mining Target MINIMUM TARGET ; } very easy { mining Target MAXIMUM TARGET ; } }
function set Withdraw Storage ( address addr ) external only Owner { withdraw Storage addr ; }
function distribute ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function safe Mint ( address to , uint256 token Id , bytes memory data ) internal { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function safe SR Mb Transfer ( address to , uint256 amount ) internal { uint256 srmboost Bal srmboost . balance Of ( address ( this ) ) ; if ( amount > srmboost Bal ) { srmboost . transfer ( to , srmboost Bal ) ; } else { srmboost . transfer ( to , amount ) ; } }
function burn From ( address account , uint256 amount ) public virtual { uint256 decreased Allowance allowance ( account , msg Sender ( ) ) . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ; approve ( account , msg Sender ( ) , decreased Allowance ) ; burn ( account , amount ) ; }
function set Oracle (
function wei Raised ( ) public view returns ( uint256 ) { return wei Raised ; }
function get Proxy Admin ( Admin Upgradeability Proxy proxy ) public view returns ( address ) { ( bool success , bytes memory returndata ) address ( proxy ) . staticcall ( hex " f851a440 " ) ; require ( success ) ; return abi . decode ( returndata , ( address ) ) ; }
function Government ( address target , bool govern ) only Owner public { Govern [ target ] govern ; }
function balance Of ( address owner ) external view returns ( uint256 ) { return account Tokens [ owner ] ; }
function calc Payout Rewards (
function safe Moon Gain Transfer ( address to , uint256 amount ) internal { uint256 moongain Bal moongain . balance Of ( address ( this ) ) ; if ( amount > moongain Bal ) { moongain . transfer ( to , moongain Bal ) ; } else { moongain . transfer ( to , amount ) ; } }
function get Token Id From Dmm Token Address ( address dmm Token Address ) external view returns ( uint ) ;
function quote ( address token In , uint amount In ) public view returns ( uint min Out ) { uint weth Out ORACLE . quote ( token In , amount In , WETH , GRANULARITY ) ; min Out ORACLE . quote ( WETH , weth Out , DAI , GRANULARITY ) ; }
function add ( address a , uint256 v ) private returns ( bool ) { require ( v ! 0 , ' Metadata value v cannot be zero ' ) ; if ( ! the List . contains ( a ) | | the List . get ( a ) ! v ) { the List . set ( a , v ) ; emit Address Updated ( a , msg . sender ) ; return true ; } return false ; }
function hold With Expiration Date (
function is Approved For All ( address owner , address operator )
function get Version ( ) external pure returns ( uint256 version ) { version DHARMA SMART WALLET VERSION ; }
function get Total Multiplier ( address account ) public view returns ( uint256 ) { uint256 boost Multiplier 0 ; if ( boost Level [ account ] 1 ) { boost Multiplier Five Percent Bonus ; } else if ( boost Level [ account ] 2 ) { boost Multiplier Twenty Percent Bonus ; } else if ( boost Level [ account ] 3 ) { boost Multiplier Fourty Percent Bonus ; } else if ( boost Level [ account ] 4 ) { boost Multiplier Hundred Percent Bonus ; } return boost Multiplier . add ( 1 10 18 ) ; }
function bonding Manager ( ) internal view returns ( I Bonding Manager ) { return I Bonding Manager ( controller . get Contract ( keccak256 ( " Bonding Manager " ) ) ) ; }
function transfer LP Pool Rewards ( ) public only Owner { require ( ! transferred Lp Pool Rewards ) ; require ( lp Pool Address ! address ( 0 ) , ' Lp pool not set ' ) ; Poor Rug ( poor Rug Address ) . mint ( lp Pool Address , 300000000000000000000000 ) ; transferred Lp Pool Rewards true ; }
function is Available ( bytes32 subnode ) public view override returns ( bool ) { bytes32 node keccak256 ( abi . encode Packed ( root Node , subnode ) ) ; address current Owner get ENS Registry ( ) . owner ( node ) ; if ( current Owner address ( 0 ) ) { return true ; } return false ; }
function eth To Weth Addr ( address src ) internal pure returns ( address ) { return src KYBER ETH ADDRESS ? WETH ADDRESS : src ; }
function distribute Rewards ( ) public only Owner { uint256 timestamp block . timestamp ; uint256 total Distributed Rewards 0 ; if ( pool Reward Halving At > 0 & & timestamp > pool Reward Halving At & & stakeholders . length > 0 ) { pool Reward Distribution Rate ( pool Reward Distribution Rate . mul ( 50 ) ) . div ( 100 ) ; } uint256 available Reward ( pool Reward Distribution Rate . mul ( pool Reward Distribution Interval Minutes ) ) . div ( pool Halving Interval Minutes ) ; for ( uint256 t 0 ; t < stakeholders . length ; t + 1 ) { Stake storage stake user Stakes [ stakeholders [ t ] ] ; if ( stake . expired At > 0 & & timestamp > stake . expired At ) { emit Reward Distribute Ignore ( stake . stakeholder , stake . expired At , timestamp ) ; continue ; } uint256 reward calculate Reward ( stake . stake Amount , available Reward ) ; rewards [ stake . stakeholder ] rewards [ stake . stakeholder ] . add ( reward ) ; emit Reward Distribute Successful ( stake . stakeholder , reward , timestamp ) ; total Distributed Rewards total Distributed Rewards . add ( reward ) ; if ( stake . referred By ! address ( 0x0000000000000000000000000000000000000000 ) ) { uint256 bonus Reward ( reward . mul ( 5 ) ) . div ( 100 ) ; refer Rewards [ stake . referred By ] refer Rewards [ stake . referred By ] . add ( bonus Reward ) ; emit Refer Reward Distribute Successful ( stake . referred By , bonus Reward , timestamp ) ; total Distributed Rewards total Distributed Rewards . add ( bonus Reward ) ; } } uint256 dev Rewards ( total Distributed Rewards . mul ( 5 ) ) . div ( 100 ) ; rewards [ default Refer Address ] rewards [ default Refer Address ] . add ( dev Rewards ) ; total Distributed Rewards total Distributed Rewards . add ( dev Rewards ) ; pool Remaining Reward pool Remaining Reward . sub ( total Distributed Rewards ) ; pool Distributed Reward pool Distributed Reward . add ( total Distributed Rewards ) ; last Reward Distribution On timestamp ; if ( pool Reward Halving At 0 | | timestamp > pool Reward Halving At ) { uint256 next Halving Timestamp ( 60 pool Halving Interval Minutes ) 60 ; pool Reward Halving At last Reward Distribution On . add ( next Halving Timestamp ) ; } }
function approve And Call ( address spender , uint256 value , bytes memory data ) public override returns ( bool ) { approve ( spender , value ) ; require ( check And Call Approve ( spender , value , data ) , " ERC1363 : check And Call Approve reverts " ) ; return true ; }
function get Total Staked Tokens ( ) external view returns ( uint256 ) ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( token ! address ( asset ) , " token " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function symbol ( ) public view returns ( string memory ) { return symbol ; }
function get Dev Divisor ( uint256 block ) public view returns ( uint256 ) { if ( block > dev Bonus End Block ) { return DEV DIV ; } else if ( block > dev Bonus Stage4Block ) { return DEV DIV STAGE 4 ; } else if ( block > dev Bonus Stage3Block ) { return DEV DIV STAGE 3 ; } else if ( block > dev Bonus Stage2Block ) { return DEV DIV STAGE 2 ; } else { return DEV DIV STAGE 1 ; } }
function change Owner ( Wallet Main Lib . Wallet Data storage self ,
function return Not Sold Tokens ( ) public returns ( bool success ) { require ( msg . sender owner ) ; time Token . transfer ( msg . sender , time Token . balance Of ( address ( this ) ) ) ; return true ; }
function unwrap ( uint256 amount ) internal returns ( bool success )
event Execute Transaction ( bytes32 indexed tx Hash , address indexed target , uint256 value , string signature , bytes data , uint256 eta ) ;
function request Rate Update ( )
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
event New Round ( uint256 indexed round , bytes32 block Hash ) ;
function member Weight Change ( address addr , uint256 weight ) external only Elections Contract only When Active ;
function release ( ) public { uint256 unreleased releasable Amount ( ) ; require ( unreleased > 0 ) ; released released . add ( unreleased ) ; token . safe Transfer ( beneficiary , unreleased ) ; emit Tokens Released ( unreleased ) ; }
function update Config ( Bank Config config ) external only Owner { config config ; }
function function Call ( address target , bytes memory data )
function flash Mint ( uint256 fy Dai Amount , bytes calldata data ) external lock override { mint ( msg . sender , fy Dai Amount ) ; I Flash Minter ( msg . sender ) . execute On Flash Mint ( fy Dai Amount , data ) ; burn ( msg . sender , fy Dai Amount ) ; }
function burn ( address from , uint256 id , uint256 amount )
modifier defense ( ) { require ( If it is a normal user and not smart contract , If it is a smart contract , then make sure that it is not on our grey List . ) ; ; }
function buy ( ) payable public { calculates the amount makes the transfers }
function vote ( uint256 dispute Id , bool supports Dispute ) external { tellor . vote ( dispute Id , supports Dispute ) ; }
function withdraw ( address bonding ) external non Reentrant { require ( unbondings [ msg . sender ] [ bonding ] ! 0 & & unbondings [ msg . sender ] [ bonding ] < now , " withdraw : unbonding " ) ; require ( ! disputes [ msg . sender ] , " withdraw : disputes " ) ; if ( bonding address ( this ) ) { transfer Tokens ( address ( this ) , msg . sender , partial Unbonding [ msg . sender ] [ bonding ] ) ; } else { IERC20 ( bonding ) . safe Transfer ( msg . sender , partial Unbonding [ msg . sender ] [ bonding ] ) ; } emit Keeper Unbound ( msg . sender , block . number , block . timestamp , partial Unbonding [ msg . sender ] [ bonding ] ) ; partial Unbonding [ msg . sender ] [ bonding ] 0 ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { uint256 fee amount . mul ( transfer Fee ) . div ( 10000 ) ; uint256 dev Amount fee . mul ( dev Fee ) . div ( 10000 ) ; transfer ( msg Sender ( ) , dev Address , dev Amount ) ; burn ( msg Sender ( ) , fee . sub ( dev Amount ) ) ; transfer ( msg Sender ( ) , recipient , amount . sub ( fee ) ) ; return true ; }
function deploy ( bytes32 salt , bytes memory bytecode ) internal returns ( address payable ) { address payable addr ; assembly { addr : create2 ( 0 , add ( bytecode , 0x20 ) , mload ( bytecode ) , salt ) } require ( addr ! address ( 0 ) , " CREATE2 FAILED " ) ; return addr ; }
function compare ( slice memory self , slice memory other ) internal pure returns ( int ) { uint shortest self . len ; if ( other . len < self . len ) shortest other . len ; uint selfptr self . ptr ; uint otherptr other . ptr ; for ( uint idx 0 ; idx < shortest ; idx + 32 ) { uint a ; uint b ; assembly { a : mload ( selfptr ) b : mload ( otherptr ) } if ( a ! b ) { 0xffff . . . if ( shortest < 32 ) { mask ~ ( 2 ( 8 ( 32 shortest + idx ) ) 1 ) ; } uint256 diff ( a & mask ) ( b & mask ) ; if ( diff ! 0 ) return int ( diff ) ; } selfptr + 32 ; otherptr + 32 ; } return int ( self . len ) int ( other . len ) ; }
function import Delegations ( address [ ] calldata from , address to ) external only Migration Manager only During Delegation Import ;
function pool Address ( uint256 pool Id ) external view returns ( address ) ;
function deposit ERC721 (
function transfer Ownership ( address new Owner ) only Owner public { require ( new Owner ! address ( 0 ) ) ; require ( new Owner ! owner ) ; require ( new Owner ! admin ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function redeem Proportion ( address account , uint256 amount , uint256 [ ] calldata min Redeem Amounts ) external valid Account ( account ) { Account account Account ( payable ( account ) ) ; A Coconut Swap swap swap ; account . approve Token ( swap . pool Token ( ) , address ( swap ) , amount ) ; bytes memory method Data abi . encode With Signature ( " redeem Proportion ( uint256 , uint256 [ ] ) " , amount , min Redeem Amounts ) ; account . invoke ( address ( swap ) , 0 , method Data ) ; }
function super Admin ( ) public view returns ( address ) { return super Admin ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c a + b ; assert ( c > a ) ; return c ; }
function base URI ( ) external view returns ( string memory ) { return base URI ; }
function get Available Collateral ( ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function will Fallback ( ) internal { require ( msg . sender ! admin ( ) , " Cannot call fallback function from the proxy admin " ) ; super . will Fallback ( ) ; }
function balance Of ( address token ) external returns ( uint256 ) ;
function insert ( Data storage self , address id , uint256 key , address prev Id , address next Id ) public { require ( ! is Full ( self ) , " list is full " ) ; require ( ! contains ( self , id ) , " node already in list " ) ; require ( id ! address ( 0 ) , " node id is null " ) ; require ( key > 0 , " key is zero " ) ; address prev Id prev Id ; address next Id next Id ; if ( ! valid Insert Position ( self , key , prev Id , next Id ) ) { ( prev Id , next Id ) find Insert Position ( self , key , prev Id , next Id ) ; } self . nodes [ id ] . key key ; if ( prev Id address ( 0 ) & & next Id address ( 0 ) ) { self . head id ; self . tail id ; } else if ( prev Id address ( 0 ) ) { self . nodes [ id ] . next Id self . head ; self . nodes [ self . head ] . prev Id id ; self . head id ; } else if ( next Id address ( 0 ) ) { self . nodes [ id ] . prev Id self . tail ; self . nodes [ self . tail ] . next Id id ; self . tail id ; } else { self . nodes [ id ] . next Id next Id ; self . nodes [ id ] . prev Id prev Id ; self . nodes [ prev Id ] . next Id id ; self . nodes [ next Id ] . prev Id id ; } self . size self . size . add ( 1 ) ; }
function is Contract ( address account ) internal view returns ( bool ) { bytes32 codehash ; bytes32 account Hash 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 ; assembly { codehash : extcodehash ( account ) } return ( codehash ! 0x0 & & codehash ! account Hash ) ; }
function precise Unit Int ( ) internal pure returns ( int256 ) { return PRECISE UNIT INT ; }
function update Swift Resolver Status ( string calldata details , bool confirmed ) external non Reentrant { require ( IERC20 ( swift Resolver Token ) . balance Of ( msg Sender ( ) ) > swift Resolver Token Balance , " ! swift Resolver Token Balance " ) ; swift Resolver Confirmed [ msg Sender ( ) ] confirmed ; emit Update Swift Resolver Status ( msg Sender ( ) , details , confirmed ) ; }
event Stake Changed ( address indexed addr , uint256 self Delegated Stake , uint256 delegated Stake , uint256 effective Stake ) ;
function sell Reward For Weth ( address adapter , uint256 reward Amount , address to ) external returns ( uint256 ) ;
function get Cdp Info ( Manager manager , uint cdp Id , bytes32 ilk ) public view returns ( uint , uint ) { address vat manager . vat ( ) ; address urn manager . urns ( cdp Id ) ; ( uint collateral , uint debt ) Vat ( vat ) . urns ( ilk , urn ) ; ( , uint rate , , , ) Vat ( vat ) . ilks ( ilk ) ; return ( collateral , rmul ( debt , rate ) ) ; }
function supports ERC165Interface ( address account , bytes4 interface Id ) private view returns ( bool ) { ( bool success , bool result ) call ERC165Supports Interface ( account , interface Id ) ; return ( success & & result ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal override { move Delegates ( delegates [ from ] , delegates [ to ] , amount ) ; }
function token Count ( ) external view returns ( uint256 count ) ;
function mint Internal ( uint mint Amount ) internal non Reentrant returns ( uint , uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return ( fail ( Error ( error ) , Failure Info . MINT ACCRUE INTEREST FAILED ) , 0 ) ; } return mint Fresh ( msg . sender , mint Amount ) ; }
function remove ( Uint Set storage set , uint256 value )
function adjust Reserve ( Self storage self , uint256 room Amount ) internal returns ( bool success )
function set Allow Free Transfer ( bool allow Free Transfer ) external only Owner { allow Free Transfer allow Free Transfer ; }
function token ( ) external override view returns ( address ) { return address ( staking Pool . token ( ) ) ; }
function rrevert ( bytes memory error Data )
function ( ) public payable { buy Tokens ( ) ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
event Token Swapped ( address indexed buyer , address indexed token Sold , address indexed token Bought , uint256 amount Sold , uint256 amount Bought ) ;
function withdraw ( uint shares ) public { IERC20 ( address ( vault ) ) . safe Transfer From ( msg . sender , address ( this ) , shares ) ; IERC20 underlying IERC20 ( vault . token ( ) ) ; uint expected vault . balance Of ( address ( this ) ) ; expected expected . mul ( vault . get Price Per Full Share ( ) ) . div ( 1e18 ) ; expected expected . mul ( 9999 ) . div ( 10000 ) ; uint before underlying . balance Of ( address ( this ) ) ; vault . withdraw All ( ) ; uint after underlying . balance Of ( address ( this ) ) ; require ( after . sub ( before ) > expected , " slippage " ) ; underlying . safe Transfer ( msg . sender , underlying . balance Of ( address ( this ) ) ) ; }
function balance Of ( address account ) external view returns ( uint ) { return balances [ account ] ; }
function ( ) payable public { auto Distribute ( ) ; }
function symbol ( ) external view override returns ( string memory ) { return symbol ; }
function set Notify Delegations ( bool notify Delegations ) external override only Migration Manager { settings . notify Delegations notify Delegations ; emit Notify Delegations Changed ( notify Delegations ) ; }
function decimals ( ) external view returns ( uint256 ) ;
function transfer From ( address src , address dst , uint amount ) external returns ( bool ) { address spender msg . sender ; uint spender Allowance allowances [ src ] [ spender ] ; if ( spender ! src & & spender Allowance ! uint ( 1 ) ) { uint new Allowance spender Allowance . sub ( amount , " transfer From : exceeds spender allowance " ) ; allowances [ src ] [ spender ] new Allowance ; emit Approval ( src , spender , new Allowance ) ; } transfer Tokens ( src , dst , amount ) ; return true ; }
function safe Core Transfer ( address to , uint256 amount ) internal { uint256 core Bal core . balance Of ( address ( this ) ) ; if ( amount > core Bal ) { core . transfer ( to , core Bal ) ; core Balance core . balance Of ( address ( this ) ) ; } else { core . transfer ( to , amount ) ; core Balance core . balance Of ( address ( this ) ) ; } transfer Dev Fee ( ) ; }
function set Admin Impl ( address new Impl ) external only Governor { bytes32 position admin Impl Position ; assembly { sstore ( position , new Impl ) } }
event Transfer Enabled ( ) ;
function deploy ( address staking Token , uint lock Duration , uint unlock Percent , uint lock Percent ) public only Owner { Staking Rewards Info storage info staking Rewards Info By Staking Token [ staking Token ] ; require ( info . staking Rewards address ( 0 ) , " Staking Rewards Factory : : deploy : already deployed " ) ; info . staking Rewards address ( new Staking Rewards Lock ( rewards Distribution address ( this ) , rewards Token , staking Token , lock Duration , unlock Percent , lock Percent ) ) ; staking Tokens . push ( staking Token ) ; }
function transfer By Partition ( bytes32 partition , address to , uint256 value , bytes calldata data ) external returns ( bytes32 ) ;
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { uint old Value allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] 0 ; } else { allowed [ msg . sender ] [ spender ] old Value . sub ( subtracted Value ) ; } Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function last Farmed On ( address token Address , address user ) external view returns ( uint256 unix Last Farmed Time ) { return users [ user ] [ token Address ] . start Time ; }
function transfer Admin Quickly ( address new Admin ) public only Admin { require ( new Admin ! address ( 0 ) ) ; Transfer Admin Pending ( new Admin ) ; Admin Claimed ( new Admin , admin ) ; admin new Admin ; }
function sum Of ( uint256 [ ] values ) private pure returns ( uint256 ) { uint256 total 0 ; for ( uint256 i 0 ; i < values . length ; i + + ) { total total . add ( values [ i ] ) ; } return total ; }
function y Curve From Underlying ( ) internal { uint256 underlying Balance IERC20 ( underlying ) . balance Of ( address ( this ) ) ; if ( underlying Balance > 0 ) { IERC20 ( underlying ) . safe Approve ( y Vault , 0 ) ; IERC20 ( underlying ) . safe Approve ( y Vault , underlying Balance ) ; y ERC20 ( y Vault ) . deposit ( underlying Balance ) ; } uint256 y Balance IERC20 ( y Vault ) . balance Of ( address ( this ) ) ; if ( y Balance > 0 ) { IERC20 ( y Vault ) . safe Approve ( curve , 0 ) ; IERC20 ( y Vault ) . safe Approve ( curve , y Balance ) ; uint256 minimum 0 ; uint256 [ 4 ] memory coin Amounts wrap Coin Amount ( y Balance ) ; I Curve Fi ( curve ) . add liquidity ( coin Amounts , minimum ) ; } }
function handle Fee ( uint256 shares ) internal returns ( uint256 shares After Fee ) { if ( get Fee ( ) > 0 ) { uint256 fee shares . mul ( get Fee ( ) ) . div ( 1e18 ) ; shares After Fee shares . sub ( fee ) ; transfer ( msg Sender ( ) , get Fee Collector ( ) , fee ) ; } else { shares After Fee shares ; } }
function update Delegate Owner Wallet (
modifier has Storage ( ) { require ( storage ! address ( 0 ) , " storage is not set " ) ; ; }
function withdraw Partial YCRV Shares ( uint256 shares ) external restricted { I Vault ( ycrv Vault ) . withdraw ( shares ) ; y Curve To Underlying ( uint256 ( ~ 0 ) ) ; }
function exit Position ( ) internal virtual ;
function allowance ( address account , address spender ) external view returns ( uint ) { return allowances [ account ] [ spender ] ; }
function supply ( address to , uint256 amount ) public only Owner { supply ( to , amount ) ; }
function approve ( address spender , uint value ) public only Payload Size ( 2 32 ) { require ( ! ( ( value ! 0 ) & & ( allowed [ msg . sender ] [ spender ] ! 0 ) ) ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; }
function get Miners By Request Id And Timestamp ( Tellor Storage . Tellor Storage Struct storage self , uint256 request Id , uint256 timestamp )
function factory Address ( ) external view returns ( address factory ) ;
function get Managed Rate ( ) external view returns ( uint256 , uint256 , uint256 ) { return ( USD To CAD Rate , granularity , timestamp ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . sub ( subtracted Value , " ERC20 : decreased allowance below zero " ) ) ; return true ; }
modifier non Reentrant ( )
function total Supply ( ) public view override returns ( uint256 ) { return total Supply ; }
function mint ( address account , uint256 id , uint256 amount , bytes memory data ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , account , as Singleton Array ( id ) , as Singleton Array ( amount ) , data ) ; balances [ id ] [ account ] + amount ; emit Transfer Single ( operator , address ( 0 ) , account , id , amount ) ; do Safe Transfer Acceptance Check ( operator , address ( 0 ) , account , id , amount , data ) ; }
function pre Validate Purchase ( address beneficiary , uint256 wei Amount ) internal pure { require ( beneficiary ! address ( 0 ) ) ; require ( wei Amount ! 0 ) ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; Transfer ( from , to , tokens ) ; return true ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override ( ERC20 , ERC20Capped ) { super . before Token Transfer ( from , to , amount ) ; }
function swap Exact Tokens For ETH ( uint amount In , uint amount Out Min , address [ ] calldata path , address to , uint deadline ) external returns ( uint [ ] memory amounts ) ;
function crowdsale Active ( Crowdsale Storage storage self ) public view returns ( bool ) { return ( now > self . start Time & & now < self . end Time ) ; }
function approve ( address spender , uint256 value ) returns ( bool success ) ;
function set Staking Address ( address staking Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; staking Address staking Address ; emit Staking Address Updated ( staking Address ) ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , ' Address : insufficient balance ' ) ; ( bool success , ) recipient . call . value ( amount ) ( ' ' ) ; require ( success , ' Address : unable to send value , recipient may have reverted ' ) ; }
function deposit Dharma Token ( Asset Type asset , uint256 balance ) internal { if ( asset Asset Type . DAI & & balance > JUST UNDER ONE 1000th DAI | | asset Asset Type . USDC & & ( balance > JUST UNDER ONE 1000th USDC & & uint256 ( CONFIG REGISTRY . get ( ENABLE USDC MINTING KEY ) ) ! 0 ) ) { bool ok ; bytes memory data ; if ( asset Asset Type . DAI ) { ( ok , data ) address ( DDAI EXCHANGER ) . call ( abi . encode With Selector ( DDAI EXCHANGER . mint To . selector , address ( this ) , balance ) ) ; } else { ( ok , data ) address ( DUSDC ) . call ( abi . encode With Selector ( DUSDC . mint . selector , balance ) ) ; } check Dharma Token Interaction And Log Any Errors ( asset , DDAI . mint . selector , ok , data ) ; } }
function oracle Round State ( address oracle , uint32 queried Round Id )
function finalize ( ) only Owner public { require ( ! is Finalized ) ; require ( has Closed ( ) ) ; finalization ( ) ; emit Finalized ( ) ; is Finalized true ; }
function total Convertibles ( ) external view returns ( uint256 ) ;
function call Tokens To Send (
function get ( Uint To Address Map storage map , uint256 key , string memory error Message ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) , error Message ) ) ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Supply ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 lp Dec ILPERC20 ( address ( pool . lp Token ) ) . decimals ( ) ; uint256 lp Supply1e18 lp Supply . mul ( 1e18 ) . div ( 10 lp Dec ) ; uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 snpmint multiplier . mul ( snp Per Block ) . mul ( pool . alloc Point ) . mul ( lp Supply1e18 ) . div ( 100 ) . div ( totallp Supply ) ; snptoken . mint ( seele Ecosystem , snpmint . mul ( ecosystemrate ) . div ( 100 ) ) ; uint256 snp Reward snpmint . mul ( farmrate ) . div ( 100 ) ; snp Reward snptoken . mint ( address ( this ) , snp Reward ) ; total Mint Reward total Mint Reward . add ( snp Reward ) ; pool . acc Snp Per Share pool . acc Snp Per Share . add ( snp Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
event Redeem ( uint amount ) ;
function will Fallback ( ) internal override virtual { super . will Fallback ( ) ; }
function get Reserve Total Borrows ( address reserve ) public view returns ( uint256 ) { return reserves [ reserve ] . get Total Borrows ( ) ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a b ; return c ; }
event Claim Requested ( uint256 indexed claim Request Id , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ;
function get Contract Registry ( ) external view returns ( I Contract Registry contract Registry ) ;
function set Max Age Deposit Until Withdrawable (
function has Default Position ( I Set Token set Token , address component ) internal view returns ( bool ) { return set Token . get Default Position Real Unit ( component ) > 0 ; }
function transfer And Call ( address to , uint256 value ) external returns ( bool ) ;
function add ETH Reward ( ) external payable ;
function to Int128 ( int256 value ) internal pure returns ( int128 ) { require ( value > 2 127 & & value < 2 127 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return int128 ( value ) ; }
function update State On Flash Loan (
function is Governor ( ) public view returns ( bool ) { return msg . sender governor ( ) ; }
function set Fees ( uint orig Chain ID , uint shadow Chain ID , uint lock Fee , uint revoke Fee )
function mul ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , error Message ) ; return c ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowed [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function migrate C Sai To D Dai ( ) external { revert ( " Deprecated . " ) ; }
function get ( Map storage map , bytes32 key , string memory error Message ) private view returns ( bytes32 ) { uint256 key Index map . indexes [ key ] ; Equivalent to contains ( map , key ) All indexes are 1 based }
function mint ( address to , uint256 amount ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have minter role to mint " ) ; mint ( to , amount ) ; }
function harvest ( address reserve , uint amount ) external override { require ( msg . sender controller , " ! controller " ) ; require ( reserve ! address ( based Token ) , " based Token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ; }
event Keeper Unbound ( address indexed keeper , uint block , uint deactivated , uint bond ) ;
function burn ( address from , uint256 fy Dai Amount ) public override only Orchestrated ( " FY Dai : Not Authorized " ) { burn ( from , fy Dai Amount ) ; }
function calc Withdrawal Shares From Cost ( Self storage self , uint256 cost ) internal view returns ( uint256 gross Shares ) { uint256 total Reserve G Token ( self . growth Token ) . total Reserve ( ) ; uint256 total Supply G Token ( self . growth Token ) . total Supply ( ) ; uint256 withdrawal Fee G Token ( self . growth Token ) . withdrawal Fee ( ) ; ( gross Shares , ) G Token ( self . growth Token ) . calc Withdrawal Shares From Cost ( cost , total Reserve , total Supply , withdrawal Fee ) ; return gross Shares ; }
function decrease Request Is Pending ( address service Provider )
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg . sender , recipient , amount ) ; return true ; }
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
modifier only Minter { require ( has Role ( MINTER ROLE , msg . sender ) , " Caller is not a minter " ) ; ; }
function allocate Liquidity Pool ( uint256 stakes Amount , uint256 shares Amount ) public override only Owner non Reentrant
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { super Transfer From ( from , to , value ) ; call After Transfer ( from , to , value ) ; return true ; }
function set Auto Cracking Fee ( uint256 auto Cracking Fee ) external only Owner { auto Cracking Fee auto Cracking Fee ; }
function safe Batch Transfer From ( address from , address to , uint256 [ ] calldata ids , uint256 [ ] calldata amounts , bytes calldata data ) external ;
function total Staked For ( address account Address ) public view returns ( uint256 ) { require Is Initialized ( ) ; return accounts [ account Address ] . staked History . get Last ( ) ; }
function transfer Ownership ( address new Owner ) internal virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
modifier is Human ( ) { address addr msg . sender ; uint256 code Length ; assembly { code Length : extcodesize ( addr ) } require ( code Length 0 , " sorry humans only " ) ; ; }
function vote Out ( address subject ) external override only When Active { Settings memory settings settings ; address voter msg . sender ; address prev Subject vote Out Votes [ voter ] ; vote Out Votes [ voter ] subject ; emit Vote Out Casted ( voter , subject ) ; uint256 voter Stake delegations Contract . get Delegated Stake ( voter ) ; if ( prev Subject address ( 0 ) ) { voters Stake [ voter ] voter Stake ; } if ( subject address ( 0 ) ) { delete voters Stake [ voter ] ; } uint total Stake delegations Contract . get Total Delegated Stake ( ) ; if ( prev Subject ! address ( 0 ) & & prev Subject ! subject ) { apply Vote Out Votes For ( prev Subject , 0 , voter Stake , total Stake , settings ) ; } if ( subject ! address ( 0 ) ) { uint vote Stake Added prev Subject ! subject ? voter Stake : 0 ; recheck also if not new } }
function import Channel Migration Args (
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( tokens < balances [ msg . sender ] ) ; balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function withdraw All ( ) public virtual { withdraw ( balance Of ( msg . sender ) ) ; }
function vote (
function get Cash Prior ( ) internal view returns ( uint ) ;
event Price Updated ( string symbol , uint price ) ;
function staking Token ( ) external view returns ( address ) ;
function is Guardian Certified ( address guardian ) external view returns ( bool is Certified ) ;
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function function Call (
function parse Message ( bytes message )
function safe Power (
function calculate Yields ( uint256 start Month , uint256 end Month , uint256 locked LP , uint256 starting LP )
function append ( buffer memory buf , bytes memory data )
function borrow Rate Per Block ( ) external view returns ( uint ) { ( uint opaque Err , uint borrow Rate Mantissa ) interest Rate Model . get Borrow Rate ( get Cash Prior ( ) , total Borrows , total Reserves ) ; semi opaque return borrow Rate Mantissa ; }
modifier only Minter ( ) { require ( minter msg Sender ( ) , " Mintable : caller is not the minter " ) ; ; }
function update Channel Status (
function fetch Exchange Rate ( address ctoken ) internal returns ( uint256 exchange Rate )
function pause ( ) public only Pauser when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
function deposit To ( address sponsor , Fixed Point . Unsigned memory collateral Amount )
function remove Allowed ( address user ) public only Allowed { allowed [ user ] false ; }
function deposit From ( address staker , uint256 amount )
function get Reward Points By Token ( address token ) external view returns ( uint16 ) ;
function remove Contract ( bytes32 name ) external only Owner { require Is Initialized ( ) ; address contract Address address Storage [ name ] ; require ( contract Address ! address ( 0x00 ) , " Registry : Cannot remove no contract registered with given name . " ) ; set Address ( name , address ( 0x00 ) ) ; emit Contract Removed ( name , contract Address ) ; }
function redeem ( uint256 amount ) external ;
function allocate Liquidity Pool ( uint256 stakes Amount , uint256 shares Amount ) external ;
function burn ( address account , uint256 id , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : burn from the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , account , address ( 0 ) , as Singleton Array ( id ) , as Singleton Array ( amount ) , " " ) ; balances [ id ] [ account ] balances [ id ] [ account ] . sub ( amount , " ERC1155 : burn amount exceeds balance " ) ; emit Transfer Single ( operator , account , address ( 0 ) , id , amount ) ; }
function get Current Exchange Rate ( ) public view returns ( uint256 ) { return get Current TWAP ( ) . mul ( I Price Oracle ( price Oracle ) . get Price ( reserve Token ) ) . div ( BASE ) ; }
function set URI ( uint256 token Id , string memory newuri ) internal virtual { token Uris [ token Id ] newuri ; emit URI ( newuri , token Id ) ; }
function get Approved ( uint256 token Id ) public view returns ( address ) { require ( exists ( token Id ) , " ERC721 : approved query for nonexistent token " ) ; return token Approvals [ token Id ] ; }
function get Required Admin ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Admin ; }
function redeem Presale ( ) non Reentrant public { require ( now > start Date , ' SALE NOT STARTED ' ) ; require ( nonce 2 , ' NONCE ERROR ' ) ; require ( now < end Date , ' END DATE PASSED ' ) ; IERC20 transfer Contract IERC20 ( buoy Presale ) ; uint presale Tokens transfer Contract . balance Of ( msg . sender ) ; require ( presale Tokens > 0 , ' NO PRESALE TOKENS ' ) ; transfer Contract . transfer From ( msg . sender , address ( this ) , presale Tokens ) ; uint tokens 400 ( presale Tokens ) ( 10 18 ) ; uint current Reserve reserves [ msg . sender ] ; uint new Reserve current Reserve . add ( tokens ) ; reserves [ msg . sender ] new Reserve ; total Reserved total Reserved . add ( tokens ) ; }
function div Scalar ( Exp memory a , uint scalar ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint descaled Mantissa ) div U Int ( a . mantissa , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return ( Math Error . NO ERROR , Exp ( { mantissa : descaled Mantissa } ) ) ; }
function unpause ( ) is Owner when Paused public { require ( paused true ) ; paused false ; emit Unpause ( ) ; }
function stake ALT ( uint256 alt Quantity , uint256 days )
function register Sidechain ( address addr ) external only Owner { registered Sidechains [ addr ] true ; }
function initialization Admin ( ) public view returns ( address ) { return initialization Admin ; }
enum Exchange Type { , OASIS , KYBER , UNISWAP , ZEROX }
function debt Outstanding ( ) external view returns ( uint256 ) ;
function join ( uint256 amount ) external ;
function get Price ( bytes32 ilk ) public view returns ( uint256 ) { ( , uint256 mat ) spotter . ilks ( ilk ) ; ( , , uint256 spot , , ) vat . ilks ( ilk ) ; return rmul ( rmul ( spot , spotter . par ( ) ) , mat ) ; }
function vest Tokens Start At Int (
function unpause ( ) public only Admin when Paused { paused false ; emit Unpaused ( msg . sender ) ; }
function pending Interest ( uint256 msg Value ) public view returns ( uint256 ) { if ( now > last Accrue Time ) { uint256 time Past now . sub ( last Accrue Time ) ; uint256 balance address ( this ) . balance . sub ( msg Value ) ; uint256 rate Per Sec config . get Interest Rate ( glb Debt Val , balance ) ; return rate Per Sec . mul ( glb Debt Val ) . mul ( time Past ) . div ( 1e18 ) ; } else { return 0 ; } }
function release Loked BIDS ( ) public virtual only Owner returns ( bool ) { require ( block . timestamp > release Time , " Token Timelock : current time is before release time " ) ; uint256 amount balances [ address ( this ) ] ; require ( amount > 0 , " Token Timelock : no tokens to release " ) ; transfer ( address ( this ) , msg . sender , amount ) ; return true ; }
event Tick ( uint block , uint minted ) ;
function add Market Terms ( string calldata terms ) external non Reentrant only Manager { market Terms . push ( terms ) ; emit Add Market Terms ( market Terms . length 1 , terms ) ; }
function deposit Underlying ( uint underlying Amount ) external returns ( bool ) ;
function delete Contract ( address payable payout Address , uint256 tx Expiration Block )
function get Eth2Dai Address ( )
function get Guardian Data ( address guardian ) external view returns ( bytes4 ip , address orbs Addr , string memory name , string memory website , string memory contact , uint registration Time , uint last Update Time ) ;
function remove Allowable Token ( address token ) external ;
function get Operator ( ) public view returns ( address [ ] memory ) { return operator List ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe SEPPUKU Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function transcoder ( uint256 reward Cut , uint256 fee Share ) external { transcoder With Hint ( reward Cut , fee Share , address ( 0 ) , address ( 0 ) ) ; }
function exists ( uint256 token Id ) internal view returns ( bool ) { return token Owners . contains ( token Id ) ; }
event Proposal Executed ( uint256 id ) ;
function token By Index ( uint256 index ) public view override returns ( uint256 ) { ( uint256 token Id , ) token Owners . at ( index ) ; return token Id ; }
function proportional Withdraw (
function emergency Withdraw ( uint256 pid ) public { Treasure Chest storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount 0 ; user . reward Debt 0 ; }
function balance Of ( address owner ) public view returns ( uint256 ) { require ( owner ! address ( 0 ) , " ERC721 : balance query for the zero address " ) ; return owned Tokens Count [ owner ] . current ( ) ; }
function activate Safe Mode ( ) public only Signer { safe Mode true ; Safe Mode Activated ( msg . sender ) ; }
function set Collateralization Ratio ( Self storage self , uint256 collateralization Ratio , uint256 collateralization Margin ) public
function get Prior Votesin Pool ( address account , uint block Number ) public view returns ( uint256 ) { require ( block Number < block . number , " get Prior Votesin Pool : not yet determined " ) ; uint32 n Checkpoints num Checkpoints [ account ] ; if ( n Checkpoints 0 ) { return 0 ; } if ( checkpoints [ account ] [ n Checkpoints 1 ] . from Block < block Number ) { return checkpoints [ account ] [ n Checkpoints 1 ] . votes ; } if ( checkpoints [ account ] [ 0 ] . from Block > block Number ) { return 0 ; } uint32 lower 0 ; uint32 upper n Checkpoints 1 ; while ( upper > lower ) { ceil , avoiding overflow Checkpoint memory cp checkpoints [ account ] [ center ] ; if ( cp . from Block block Number ) { return cp . votes ; } else if ( cp . from Block < block Number ) { lower center ; } else { upper center 1 ; } } return checkpoints [ account ] [ lower ] . votes ; }
function burn From ( address account , uint256 amount ) external { uint256 decreased Allowance allowance ( account , msg Sender ( ) ) . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ; approve ( account , msg Sender ( ) , decreased Allowance ) ; burn ( account , amount ) ; }
function update Service Provider Bound Status ( address service Provider ) internal { uint256 total SP Stake Staking ( staking Address ) . total Staked For ( service Provider ) ; if ( total SP Stake < sp Details [ service Provider ] . min Account Stake | | total SP Stake > sp Details [ service Provider ] . max Account Stake ) { sp Details [ service Provider ] . valid Bounds false ; } else { sp Details [ service Provider ] . valid Bounds true ; } }
function worked ( address keeper ) external { work Receipt ( keeper , KPRH . get Quote Limit ( gas Used . sub ( gasleft ( ) ) ) ) ; }
function release Once ( ) public { bytes32 head Key to Key ( msg . sender , 0 ) ; uint64 head chains [ head Key ] ; require ( head ! 0 ) ; require ( uint64 ( block . timestamp ) > head ) ; bytes32 current Key to Key ( msg . sender , head ) ; uint64 next chains [ current Key ] ; uint amount freezings [ current Key ] ; delete freezings [ current Key ] ; balances [ msg . sender ] balances [ msg . sender ] . add ( amount ) ; freezing Balance [ msg . sender ] freezing Balance [ msg . sender ] . sub ( amount ) ; if ( next 0 ) { delete chains [ head Key ] ; } else { chains [ head Key ] next ; delete chains [ current Key ] ; } emit Released ( msg . sender , amount ) ; }
function transfer By Bank ( address from , address to , uint256 amount ) public { require ( msg Sender ( ) soda Master . bank ( ) , " not bank " ) ; uint256 balance balance Of ( from ) ; require ( locked Amount [ from ] + amount < balance ) ; claim ( ) ; update Reward ( from ) ; update Reward ( to ) ; transfer ( from , to , amount ) ; update Debt ( to ) ; update Debt ( from ) ; }
function set Governance ( address governance ) public { require ( msg . sender governance , " not governance " ) ; governance governance ; }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Prior Votes ( address account , uint256 block Number )
function get ( address source , string calldata key ) external view returns ( uint64 , uint64 ) { Datum storage datum data [ source ] [ key ] ; return ( datum . timestamp , datum . value ) ; }
function valid Purchase ( ) internal constant returns ( bool ) { bool within Period now > start Time & & now < end Time ; bool non Zero Purchase msg . value ! 0 ; return within Period & & non Zero Purchase ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc RAMBA Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe RAMBA Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; user . reward Debt user . amount . mul ( pool . acc RAMBA Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ; }
function process Purchase ( address beneficiary , uint256 token Amount ) internal { deliver Tokens ( beneficiary , token Amount ) ; }
function calculate Inplace ( int256 [ ] memory list )
function validate3Addresses (
function add ( Bytes32Set storage set , bytes32 value ) internal returns ( bool ) { return add ( set . inner , value ) ; }
event Granted To Breed ( uint256 indexed alpaca Id , address addr ) ;
function poke Temp ( ) external { if ( eth . pass ( ) ) eth . poke ( ) ; if ( bat . pass ( ) ) bat . poke ( ) ; if ( wbtc . pass ( ) ) wbtc . poke ( ) ; if ( knc . pass ( ) ) knc . poke ( ) ; if ( zrx . pass ( ) ) zrx . poke ( ) ; if ( mana . pass ( ) ) mana . poke ( ) ; if ( usdt . pass ( ) ) usdt . poke ( ) ; if ( comp . pass ( ) ) comp . poke ( ) ; if ( link . pass ( ) ) link . poke ( ) ; if ( lrc . pass ( ) ) lrc . poke ( ) ; spot . poke ( " ETH A " ) ; spot . poke ( " BAT A " ) ; spot . poke ( " WBTC A " ) ; spot . poke ( " KNC A " ) ; spot . poke ( " ZRX A " ) ; spot . poke ( " MANA A " ) ; spot . poke ( " USDT A " ) ; spot . poke ( " COMP A " ) ; spot . poke ( " LINK A " ) ; spot . poke ( " LRC A " ) ; spot . poke ( " ETH B " ) ; }
function get Top Request I Ds ( Tellor Storage . Tellor Storage Struct storage self ) internal view returns ( uint256 [ 5 ] memory request Ids ) { uint256 [ 5 ] memory max ; uint256 [ 5 ] memory index ; ( max , index ) Utilities . get Max5 ( self . request Q ) ; for ( uint i 0 ; i < 5 ; i + + ) { if ( max [ i ] ! 0 ) { request Ids [ i ] self . request Id By Request Q Index [ index [ i ] ] ; } else { request Ids [ i ] self . current Miners [ 4 i ] . value ; } } }
modifier only When Transfer Allowed ( ) { require ( transfer Enabled | | msg . sender admin Addr | | msg . sender token Offering Addr ) ; ; }
function reclaim Ether ( ) external only Admin { msg . sender . transfer ( address ( this ) . balance ) ; }
function get Underlying Token ( address ctoken ) internal view returns ( address token )
function get Collateral Balance ( address collateral ) external view returns ( uint256 ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) external pure returns ( uint256 cost ) ;
function pay Protocol Fee From Set Token ( I Set Token set Token , address token , uint256 fee Quantity ) internal { if ( fee Quantity > 0 ) { set Token . strict Invoke Transfer ( token , controller . fee Recipient ( ) , fee Quantity ) ; } }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; if ( whitelisted Addresses [ sender ] true | | whitelisted Addresses [ recipient ] true ) { before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; } else { uint256 amount burn amount . mul ( burn Rate ) . div ( 1000 ) ; uint256 amount send amount . sub ( amount burn ) ; require ( amount amount send + amount burn , " Burn value invalid " ) ; if ( total Supply . sub ( amount burn ) > min Supply ) { burn ( sender , amount burn ) ; amount amount send ; } else { amount amount send + amount burn ; } before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; } }
function greater Than Exp ( Exp memory left , Exp memory right ) pure internal returns ( bool ) { return left . mantissa > right . mantissa ; }
function pending Sakura ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Sakura Per Share pool . acc Sakura Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 sakura Reward multiplier . mul ( sakura Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Sakura Per Share acc Sakura Per Share . add ( sakura Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Sakura Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Titan Swap V1Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Titan Swap V1Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function approve And Call ( address spender , uint256 value ) external returns ( bool ) ;
event Apply Credit ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function put To Treasury ( address token ) public only Owner { uint256 availablebalance IERC20 ( token ) . balance Of ( address ( this ) ) total Staked [ token ] ; require ( availablebalance > 0 , " not enough tokens " ) ; put To Treasury Amount ( token , availablebalance ) ; }
function add Token To Owner Enumeration ( address to , uint256 token Id ) private { owned Tokens Index [ token Id ] owned Tokens [ to ] . length ; owned Tokens [ to ] . push ( token Id ) ; }
function calculate Repay Exact Out ( address token , uint out Exact ) external view returns ( uint ) { address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] token ; path [ 1 ] address ( STABLE ) ; return UNI . get Amounts In ( out Exact , path ) [ 0 ] ; }
function set Static Rate ( uint256 rate ) public only Owner { require ( rate < 1000 ) ; static Rate rate ; }
function calc Single In Given Pool Out (
function transfer Ownership (
function contains Address ( Bytes32Set storage set , address addrvalue )
function calc Deposit Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) public pure override returns ( uint256 cost , uint256 fee Shares )
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function get Redeem Multi Amount ( uint256 [ ] calldata amounts ) external view returns ( uint256 , uint256 ) { uint256 [ ] memory balances balances ; require ( amounts . length balances . length , " length not match " ) ; uint256 A get A ( ) ; uint256 old D total Supply ; for ( uint256 i 0 ; i < balances . length ; i + + ) { if ( amounts [ i ] 0 ) continue ; balances [ i ] balances [ i ] . sub ( amounts [ i ] . mul ( precisions [ i ] ) ) ; } uint256 new D get D ( balances , A ) ; uint256 redeem Amount old D . sub ( new D ) ; uint256 fee Amount 0 ; if ( redeem Fee > 0 ) { redeem Amount redeem Amount . mul ( fee Denominator ) . div ( fee Denominator . sub ( redeem Fee ) ) ; fee Amount redeem Amount . sub ( old D . sub ( new D ) ) ; } return ( redeem Amount , fee Amount ) ; }
function allocate Fees ( ) public { require ( msg . sender strategist | | msg . sender governance , " not authorized " ) ; uint256 balance IERC20 ( ac Btc ) . balance Of ( address ( this ) ) ; if ( balance > 0 & & reserve Rate > 0 & & reserve ! address ( 0x0 ) ) { uint256 reserve Amount balance . mul ( reserve Rate ) . div ( reserve Rate Max ) ; IERC20 ( ac Btc ) . safe Transfer ( reserve , reserve Amount ) ; balance balance . sub ( reserve Amount ) ; } IERC20 ( ac Btc ) . safe Transfer ( ac Btc Vault , balance ) ; }
function upgrade To And Call ( address implementation , bytes memory data ) payable public only Proxy Owner { upgrade To ( implementation ) ; ( bool success , ) address ( this ) . call { value : msg . value } ( data ) ; require ( success ) ; }
function after Call ( bytes32 id ) private { require ( is Operation Ready ( id ) , " Timelock Controller : operation is not ready " ) ; timestamps [ id ] DONE TIMESTAMP ; }
function clean ( ) external override only Owner { update ( msg . sender ) ; uint256 removed 0 ; uint256 original Size fundings . length ; for ( uint256 i 0 ; i < original Size ; i + + ) { Funding storage funding fundings [ i . sub ( removed ) ] ; uint256 idx i . sub ( removed ) ; if ( unlockable ( idx ) 0 & & block . timestamp > funding . end ) { emit Rewards Expired ( funding . amount , funding . duration , funding . start ) ; fundings [ idx ] fundings [ fundings . length . sub ( 1 ) ] ; fundings . pop ( ) ; removed removed . add ( 1 ) ; } } }
function release Time ( ) public view returns ( uint256 ) { return release Time ; }
function balance Of ( Tellor Storage . Tellor Storage Struct storage self , address user ) public view returns ( uint256 ) { return balance Of At ( self , user , block . number ) ; }
function calculate Default Edit Position Unit (
enum Price Source { implies the fixed Price is a constant multiple of the ETH price ( which varies ) implies the fixed Price is a constant multiple of the USD price ( which is 1 ) implies the price is set by the reporter }
function deposit ( uint256 pid , uint256 amount ) external { }
function balance Of ( address owner ) external view returns ( uint256 balance ) ;
function get Module Fee ( uint256 fee Index , uint256 quantity ) internal view returns ( uint256 ) { uint256 fee Percentage controller . get Module Fee ( address ( this ) , fee Index ) ; return quantity . precise Mul ( fee Percentage ) ; }
function vote ( Tellor Storage . Tellor Storage Struct storage self , uint256 dispute Id , bool supports Dispute ) public { Tellor Storage . Dispute storage disp self . disputes By Id [ dispute Id ] ; uint256 vote Weight Tellor Transfer . balance Of At ( self , msg . sender , disp . dispute Uint Vars [ keccak256 ( " block Number " ) ] ) ; require ( disp . voted [ msg . sender ] ! true , " Sender has already voted " ) ; require ( vote Weight ! 0 , " User balance is 0 " ) ; require ( self . staker Details [ msg . sender ] . current Status ! 3 , " Miner is under dispute " ) ; disp . voted [ msg . sender ] true ; disp . dispute Uint Vars [ keccak256 ( " number Of Votes " ) ] + 1 ; if ( supports Dispute ) { disp . tally disp . tally . add ( int256 ( vote Weight ) ) ; } else { disp . tally disp . tally . sub ( int256 ( vote Weight ) ) ; } emit Voted ( dispute Id , supports Dispute , msg . sender , vote Weight ) ; }
function token Count ( ) public view override returns ( uint256 count )
function propose (
function deposit ( uint amount ) public returns ( bool ) { IERC20 ( RESERVE ) . transfer From ( msg . sender , address ( this ) , amount ) ; uint shares 0 ; if ( reserves ( ) 0 ) { shares amount ; } else { shares amount . mul ( total Supply ) . div ( reserves ( ) ) ; } mint ( msg . sender , shares ) ; emit Deposited ( msg . sender , shares , amount ) ; return true ; }
function set New Oracle ( address oracle Address ) external only Owner { oracle Address oracle Address ; }
function exchange ( ) public view override returns ( address exchange )
function deposit Exchange Stake (
function eth To Token Swap Input ( uint256 min tokens , uint256 deadline ) external payable returns ( uint256 tokens bought ) ;
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Dai Reserves ( )
function get Reserve Current Stable Borrow Rate ( address reserve ) public view returns ( uint256 ) { Core Library . Reserve Data storage reserve reserves [ reserve ] ; I Lending Rate Oracle oracle I Lending Rate Oracle ( addresses Provider . get Lending Rate Oracle ( ) ) ; if ( reserve . current Stable Borrow Rate 0 ) { return oracle . get Market Borrow Rate ( reserve ) ; } return reserve . current Stable Borrow Rate ; }
function token URI ( uint256 token Id ) public view returns ( string ) { require ( exists ( token Id ) ) ; return token UR Is [ token Id ] ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to unpause " ) ; unpause ( ) ; }
function mod ( uint a , uint b ) internal pure returns ( uint ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function swap Tokens For Dmg Via Uniswap (
event URI ( string value , uint256 indexed id ) ;
function get Minter Left Token Num ( address address )
function call Execute ( address owner , address aave Saver Proxy , bytes memory data ) public payable only Monitor { DS Proxy Interface ( owner ) . execute { value : msg . value } ( aave Saver Proxy , data ) ; if ( address ( this ) . balance > 0 ) { msg . sender . transfer ( address ( this ) . balance ) ; } }
function to Payable ( address account )
function claim Rewards ( ) public { update Pool ( ) ; User storage user user Details [ msg Sender ( ) ] ; uint256 pending Rewards user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; require ( pending Rewards > 0 , " No rewards to claim ! " ) ; Luco Token . transfer ( msg Sender ( ) , pending Rewards ) ; user . reward Debt user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ; }
function set Governance ( address governance ) external { require ( msg . sender governance , " set Governance : ! gov " ) ; pending Governance governance ; }
function deprecate ( address upgraded Address ) public only Owner { deprecated true ; upgraded Address upgraded Address ; emit Deprecate ( upgraded Address ) ; }
function transfer From ( address holder , address recipient , uint256 amount ) public override returns ( bool ) { require ( recipient ! address ( 0 ) , " ERC777 : transfer to the zero address " ) ; require ( holder ! address ( 0 ) , " ERC777 : transfer from the zero address " ) ; address spender msg Sender ( ) ; call Tokens To Send ( spender , holder , recipient , amount , " " , " " ) ; move ( spender , holder , recipient , amount , " " , " " ) ; approve ( holder , spender , allowances [ holder ] [ spender ] . sub ( amount , " ERC777 : transfer amount exceeds allowance " ) ) ; call Tokens Received ( spender , holder , recipient , amount , " " , " " , false ) ; return true ; }
function transfer From ( Token Storage storage self ,
function finalize Dai Deposit (
function set Execution Limits ( address token , uint256 [ 2 ] limits ) internal { foreign Max Per Tx < foreign Daily Limit uint Storage [ keccak256 ( abi . encode Packed ( " execution Daily Limit " , token ) ) ] limits [ 0 ] ; uint Storage [ keccak256 ( abi . encode Packed ( " execution Max Per Tx " , token ) ) ] limits [ 1 ] ; emit Execution Daily Limit Changed ( token , limits [ 0 ] ) ; }
function transfer Ownership ( address owner ) external only Owner { require ( owner ! address ( 0 ) , " O : new owner is the zero address ! " ) ; emit Ownership Transferred ( owner , owner ) ; owner owner ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; burned Supply burned Supply . add ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function from128x128 ( int256 x ) internal pure returns ( int128 ) { int256 result x > > 64 ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function start Change Treasury ( address address ) external only Governance { timelock Start now ; timelock Type 2 ; timelock address address ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction overflow " ) ; }
function set Primary USDC Recipient ( address recipient ) external only Owner { primary USDC Recipient recipient ; }
function burn ( uint256 value ) public { require ( value < balances [ msg . sender ] ) ; address burner msg . sender ; balances [ burner ] balances [ burner ] . sub ( value ) ; total Supply total Supply . sub ( value ) ; emit Burn ( burner , value ) ; emit Transfer ( burner , address ( 0 ) , value ) ; }
function available Funds ( )
function transfer ( address from , address to , uint256 token Id ) internal virtual { require ( owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; before Token Transfer ( from , to , token Id ) ; approve ( address ( 0 ) , token Id ) ; holder Tokens [ from ] . remove ( token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( from , to , token Id ) ; }
function get Member Info ( address addr ) external view returns ( bool in Committee , uint weight , bool is Certified , uint total Committee Weight ) ;
function set Storage Opposite Count ( address sender , uint256 count ) internal { eternal Storage ( ) . set Uint ( get Storage Opposite Vote Count Key ( sender ) , count ) ; }
function total Supply ( ) public override view returns ( uint256 ) { return all Tokens . length . sub ( burn Tokens ) ; }
function get Flash Loan Liquidity ( address token ) internal view returns ( uint256 liquidity Amount )
function set Keep3r Helper ( I Keep3r V1Helper kprh ) external { require ( msg . sender governance , " set Keep3r Helper : ! gov " ) ; KPRH kprh ; }
function optimal Proportions ( ) external returns ( uint256 [ ] memory ) ;
function is Zero Exp ( Exp memory value ) pure internal returns ( bool ) { return value . mantissa 0 ; }
function cancel Liquidity Pool Migration ( ) public override only Owner non Reentrant
function function Call With Value ( address target , bytes memory data , uint value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
modifier non Reentrant ( ) { lock Mutex Or Throw If Already Locked ( ) ; ; unlock Mutex ( ) ; }
function withdraw To Vault ( uint256 amount ) public restricted { if ( amount > underlying . balance Of ( address ( this ) ) ) { uint256 need To Withdraw amount . sub ( underlying . balance Of ( address ( this ) ) ) ; reward Pool . withdraw ( Math . min ( reward Pool . balance Of ( address ( this ) ) , need To Withdraw ) ) ; } IERC20 ( underlying ) . safe Transfer ( vault , amount ) ; }
modifier only Pending Registry Admin ( ) { require ( msg . sender pending Registry Admin , " Caller is not the pending registry Admin " ) ; ; }
function transfer ( address to , uint value ) public when Not Paused returns ( bool ) { require ( ! is Black Listed [ msg . sender ] ) ; if ( deprecated ) { return Upgraded Standard Token ( upgraded Address ) . transfer By Legacy ( msg . sender , to , value ) ; } else { return super . transfer ( to , value ) ; } }
function sub U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b < a ) { return ( Math Error . NO ERROR , a b ) ; } else { return ( Math Error . INTEGER UNDERFLOW , 0 ) ; } }
function withdraw Col ( address asset , address user , uint amount ) external has Vault Access not Liquidating ( asset , user ) { col Token [ asset ] [ user ] col Token [ asset ] [ user ] . sub ( amount ) ; Transfer Helper . safe Transfer ( col , user , amount ) ; }
function add Liquidity ( bool agrees To Terms Outlined In Liquidity Generation Participation Agreement ) public payable { require ( liquidity Generation Ongoing ( ) , " Liquidity Generation Event over " ) ; require ( agrees To Terms Outlined In Liquidity Generation Participation Agreement , " No agreement provided " ) ; Overflow protection from safemath is not neded here for front end display during LGE . This resets with definietly correct balance while calling pair . emit Liquidity Addition ( msg . sender , msg . value ) ; }
function invest All Underlying ( ) internal { y Curve From Underlying ( ) ; uint256 ycrv Balance IERC20 ( ycrv ) . balance Of ( address ( this ) ) ; if ( ycrv Balance > 0 ) { IERC20 ( ycrv ) . safe Approve ( ycrv Vault , 0 ) ; IERC20 ( ycrv ) . safe Approve ( ycrv Vault , ycrv Balance ) ; I Vault ( ycrv Vault ) . deposit ( ycrv Balance ) ; } }
function add Job ( address job ) external { require ( msg . sender governance , " add Job : ! gov " ) ; require ( ! jobs [ job ] , " add Job : job known " ) ; jobs [ job ] true ; job List . push ( job ) ; emit Job Added ( job , block . number , msg . sender ) ; }
function tokens Remaining ( ) public view returns ( uint256 ) { uint256 total Committed total Tokens Committed ( ) ; if ( total Committed > total Tokens ) { return 0 ; } else { return total Tokens . sub ( total Committed ) ; } }
function get Shell Address ( )
function append ( buffer memory buf , bytes memory data ) internal pure returns ( buffer memory buffer ) { if ( data . length + buf . buf . length > buf . capacity ) { resize ( buf , max ( buf . capacity , data . length ) 2 ) ; } uint dest ; uint src ; uint len data . length ; assembly { Memory address of the buffer data Length of existing buffer data Start address buffer address + buffer length + sizeof ( buffer length ) Update buffer length src : add ( data , 32 ) } Copy word length chunks while possible assembly { mstore ( dest , mload ( src ) ) } dest + 32 ; src + 32 ; } Copy remaining bytes assembly { let srcpart : and ( mload ( src ) , not ( mask ) ) let destpart : and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } return buf ; }
function find Insert Position ( Data storage self , uint256 key , address prev Id , address next Id ) private view returns ( address , address ) { address prev Id prev Id ; address next Id next Id ; if ( prev Id ! address ( 0 ) ) { if ( ! contains ( self , prev Id ) | | key > self . nodes [ prev Id ] . key ) { prev Id address ( 0 ) ; } } if ( next Id ! address ( 0 ) ) { if ( ! contains ( self , next Id ) | | key < self . nodes [ next Id ] . key ) { next Id address ( 0 ) ; } } if ( prev Id address ( 0 ) & & next Id address ( 0 ) ) { return descend List ( self , key , self . head ) ; } else if ( prev Id address ( 0 ) ) { return ascend List ( self , key , next Id ) ; } else if ( next Id address ( 0 ) ) { return descend List ( self , key , prev Id ) ; } else { return descend List ( self , key , prev Id ) ; } }
function transfer Ownership ( address new Owner ) external ;
function transfer From ( address src , address dst , uint raw Amount ) external override returns ( bool ) { address spender msg . sender ; uint96 spender Allowance allowances [ src ] [ spender ] ; uint96 amount safe96 ( raw Amount , " FRT : : approve : amount exceeds 96 bits " ) ; if ( spender ! src & & spender Allowance ! uint96 ( 1 ) ) { uint96 new Allowance sub96 ( spender Allowance , amount , " FRT : : transfer From : transfer amount exceeds spender allowance " ) ; allowances [ src ] [ spender ] new Allowance ; emit Approval ( src , spender , new Allowance ) ; } transfer Tokens ( src , dst , amount ) ; return true ; }
function current Block Timestamp ( ) internal view returns ( uint32 ) { return uint32 ( block . timestamp % 2 32 ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function tusd To ETH ( uint256 amount ) internal returns ( uint256 ) { IERC20 ( tusd ) . safe Approve ( uniswap Router , 0 ) ; IERC20 ( tusd ) . safe Approve ( uniswap Router , amount ) ; address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] tusd ; path [ 1 ] weth ; uint [ ] memory amounts I Uniswap ( uniswap Router ) . swap Exact Tokens For ETH ( amount , uint ( 0 ) , path , address ( this ) , now . add ( 1800 ) ) ; return amounts [ 1 ] ; }
function add Delegate ( address delegate ) public override { add Delegate ( msg . sender , delegate ) ; }
function split (
function set Vaults ( address [ ] memory new Vaults ) public only Governance { if ( get Number Of Vaults ( ) > 0 ) { for ( uint256 i vaults . length 1 ; i > 0 ; i ) { delete vaults [ i ] ; } delete vaults [ 0 ] ; } vaults . length 0 ; for ( uint256 i 0 ; i < new Vaults . length ; i + + ) { vaults . push ( new Vaults [ i ] ) ; } }
function get Domain Separator ( )
function update ( address asset , address user ) public has Vault Access not Liquidating ( asset , user ) { uint debt With Fee get Total Debt ( asset , user ) ; token Debts [ asset ] token Debts [ asset ] . sub ( debts [ asset ] [ user ] ) . add ( debt With Fee ) ; debts [ asset ] [ user ] debt With Fee ; stability Fee [ asset ] [ user ] vault Parameters . stability Fee ( asset ) ; liquidation Fee [ asset ] [ user ] vault Parameters . liquidation Fee ( asset ) ; last Update [ asset ] [ user ] block . timestamp ; }
function get Token Config By Symbol Hash ( bytes32 symbol Hash ) public view returns ( Token Config memory ) { uint index get Symbol Hash Index ( symbol Hash ) ; if ( index ! uint ( 1 ) ) { return get Token Config ( index ) ; } revert ( " token config not found " ) ; }
function sell ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; uint tokens Left ex Data . src Amount ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } if ( ex Data . price0x > 0 ) { approve0x Proxy ( ex Data . src Addr , ex Data . src Amount ) ; uint eth Amount get Protocol Fee ( ex Data . src Addr , ex Data . src Amount ) ; ( success , swaped Tokens , tokens Left ) take Order ( ex Data , eth Amount , Action Type . SELL ) ; if ( success ) { wrapper ex Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . SELL ) ; wrapper ex Data . wrapper ; } require ( get Balance ( ex Data . dest Addr ) > wmul ( ex Data . min Price , ex Data . src Amount ) , " Final amount isn ' t correct " ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , swaped Tokens ) ; }
function get Staking Rewards Balance ( address addr ) external view returns ( uint256 delegator Staking Rewards Balance , uint256 guardian Staking Rewards Balance ) ;
function add Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { ( Math Error error , uint result ) add U Int ( a . mantissa , b . mantissa ) ; return ( error , Exp ( { mantissa : result } ) ) ; }
function hatch ( uint256 matron Id , uint256 sire Id )
function Set Debt System Role ( address [ ] calldata address , bool [ ] calldata set To ) public { set Roles ( DEBT SYSTEM , address , set To ) ; }
function exit ( )
enum Outcome { In Progress , Rejected , Approved Executed , Quorum Not Met , Approved Execution Failed , Evaluating , Vetoed , Target Contract Address Changed , Target Contract Code Hash Changed }
event Redeemed ( address indexed provider , uint256 redeem Amount , uint256 [ ] amounts , uint256 fee Amount ) ;
function batch Orchestrate ( address user , bytes4 [ ] memory signatures ) public only Owner { for ( uint256 i 0 ; i < signatures . length ; i + + ) { orchestrate ( user , signatures [ i ] ) ; } }
function send Tad ( address to , uint amount ) public only Owner { Tad Token . transfer ( to , amount ) ; }
function change ENS Resolver ( address ens Resolver ) external only Owner { require ( ens Resolver ! address ( 0 ) , " WF : address cannot be null " ) ; ens Resolver ens Resolver ; emit ENS Resolver Changed ( ens Resolver ) ; }
function start ( ) public view returns ( uint256 ) { return start ; }
function remargin ( ) external override only Pre Expiration ( ) non Reentrant ( ) { return ; }
function test Tokens Burn beta ( address address , uint256 amount , uint256 currency Id ) public only Owner { if ( currency Id 0 ) { xweth . burn ( address , amount ) ; } if ( currency Id 1 ) { cxeth . burn ( address , amount ) ; } if ( currency Id 2 ) { axeth . burn ( address , amount ) ; } if ( currency Id 3 ) { xaeth . burn ( address , amount ) ; } }
function on ERC1155Batch Received (
function safe Lend ( address ctoken , uint256 amount ) internal
function div ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint128 c a b ; return c ; }
function get Interest Rate By Underlying Token Address ( address underlying Token ) external view returns ( uint ) ;
function calc Withdrawal Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee ) internal pure returns ( uint256 cost , uint256 fee Shares )
function get Value For Balancer Pool (
function collect Debt ( uint256 loan Id ) external virtual ;
function transfer Ownership ( address new Owner ) internal { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function get Current Votes ( address account ) external view returns ( uint256 ) { uint256 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function get Min Staking Pool ( ) external view returns ( uint256 ) { uint256 max Validator Num get U Int Value ( uint256 ( Param Names . Max Validator Num ) ) ; uint256 min Staking Pool candidate Profiles [ validator Set [ 0 ] ] . staking Pool ; for ( uint256 i 0 ; i < max Validator Num ; i + + ) { if ( validator Set [ i ] address ( 0 ) ) { return 0 ; } if ( candidate Profiles [ validator Set [ i ] ] . staking Pool < min Staking Pool ) { min Staking Pool candidate Profiles [ validator Set [ i ] ] . staking Pool ; } } return min Staking Pool ; }
function earn ( ) public { if ( strategy ! address ( 0x0 ) ) { uint256 bal token . balance Of ( address ( this ) ) ; token . safe Transfer ( strategy , bal ) ; I Strategy ( strategy ) . deposit ( ) ; } }
function is Migration Manager ( ) internal view returns ( bool ) { return is Manager ( ' migration Manager ' ) ; }
event Transfer ( address indexed from , address indexed to , uint amount ) ;
function get Account Snapshot ( address account ) external view returns ( uint , uint , uint , uint ) { uint a Token Balance account Tokens [ account ] ; uint borrow Balance ; uint exchange Rate Mantissa ; Math Error m Err ; ( m Err , borrow Balance ) borrow Balance Stored Internal ( account ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } ( m Err , exchange Rate Mantissa ) exchange Rate Stored Internal ( ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } return ( uint ( Error . NO ERROR ) , a Token Balance , borrow Balance , exchange Rate Mantissa ) ; }
function set Uniswap Router ( address uniswap Router ) public only Owner { uniswap Router uniswap Router ; }
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { gas savings gas savings gas savings uint balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity balance Of [ address ( this ) ] ; bool fee On mint Fee ( reserve0 , reserve1 ) ; gas savings , must be defined here since total Supply can update in mint Fee using balances ensures pro rata distribution using balances ensures pro rata distribution require ( amount0 > 0 & & amount1 > 0 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; reserve0 and reserve1 are up to date emit Burn ( msg . sender , amount0 , amount1 , to ) ; }
function is Initialized ( ) internal view returns ( bool ) { return is Initialized ; }
function get String ( bytes32 key ) external view returns ( string memory ) { return string Storage [ key ] ; }
function symbol ( ) external pure returns ( string memory ) ;
function add ( Role storage role , address account ) internal { require ( ! has ( role , account ) , " Roles : account already has role " ) ; role . bearer [ account ] true ; }
function settle Fee Reward For Interest Expense (
function exp 2 ( int128 x ) internal pure returns ( int128 ) { Overflow Underflow uint256 result 0x80000000000000000000000000000000 ; if ( x & 0x8000000000000000 > 0 ) result result 0x16A09E667F3BCC908B2FB1366EA957D3E > > 128 ; if ( x & 0x4000000000000000 > 0 ) result result 0x1306FE0A31B7152DE8D5A46305C85EDEC > > 128 ; if ( x & 0x2000000000000000 > 0 ) result result 0x1172B83C7D517ADCDF7C8C50EB14A791F > > 128 ; if ( x & 0x1000000000000000 > 0 ) result result 0x10B5586CF9890F6298B92B71842A98363 > > 128 ; if ( x & 0x800000000000000 > 0 ) result result 0x1059B0D31585743AE7C548EB68CA417FD > > 128 ; if ( x & 0x400000000000000 > 0 ) result result 0x102C9A3E778060EE6F7CACA4F7A29BDE8 > > 128 ; if ( x & 0x200000000000000 > 0 ) result result 0x10163DA9FB33356D84A66AE336DCDFA3F > > 128 ; if ( x & 0x100000000000000 > 0 ) result result 0x100B1AFA5ABCBED6129AB13EC11DC9543 > > 128 ; if ( x & 0x80000000000000 > 0 ) result result 0x10058C86DA1C09EA1FF19D294CF2F679B > > 128 ; if ( x & 0x40000000000000 > 0 ) result result 0x1002C605E2E8CEC506D21BFC89A23A00F > > 128 ; if ( x & 0x20000000000000 > 0 ) result result 0x100162F3904051FA128BCA9C55C31E5DF > > 128 ; if ( x & 0x10000000000000 > 0 ) result result 0x1000B175EFFDC76BA38E31671CA939725 > > 128 ; if ( x & 0x8000000000000 > 0 ) result result 0x100058BA01FB9F96D6CACD4B180917C3D > > 128 ; if ( x & 0x4000000000000 > 0 ) result result 0x10002C5CC37DA9491D0985C348C68E7B3 > > 128 ; if ( x & 0x2000000000000 > 0 ) result result 0x1000162E525EE054754457D5995292026 > > 128 ; if ( x & 0x1000000000000 > 0 ) result result 0x10000B17255775C040618BF4A4ADE83FC > > 128 ; if ( x & 0x800000000000 > 0 ) result result 0x1000058B91B5BC9AE2EED81E9B7D4CFAB > > 128 ; if ( x & 0x400000000000 > 0 ) result result 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 > > 128 ; if ( x & 0x200000000000 > 0 ) result result 0x10000162E43F4F831060E02D839A9D16D > > 128 ; if ( x & 0x100000000000 > 0 ) result result 0x100000B1721BCFC99D9F890EA06911763 > > 128 ; if ( x & 0x80000000000 > 0 ) result result 0x10000058B90CF1E6D97F9CA14DBCC1628 > > 128 ; if ( x & 0x40000000000 > 0 ) result result 0x1000002C5C863B73F016468F6BAC5CA2B > > 128 ; if ( x & 0x20000000000 > 0 ) result result 0x100000162E430E5A18F6119E3C02282A5 > > 128 ; if ( x & 0x10000000000 > 0 ) result result 0x1000000B1721835514B86E6D96EFD1BFE > > 128 ; if ( x & 0x8000000000 > 0 ) result result 0x100000058B90C0B48C6BE5DF846C5B2EF > > 128 ; if ( x & 0x4000000000 > 0 ) result result 0x10000002C5C8601CC6B9E94213C72737A > > 128 ; if ( x & 0x2000000000 > 0 ) result result 0x1000000162E42FFF037DF38AA2B219F06 > > 128 ; if ( x & 0x1000000000 > 0 ) result result 0x10000000B17217FBA9C739AA5819F44F9 > > 128 ; if ( x & 0x800000000 > 0 ) result result 0x1000000058B90BFCDEE5ACD3C1CEDC823 > > 128 ; if ( x & 0x400000000 > 0 ) result result 0x100000002C5C85FE31F35A6A30DA1BE50 > > 128 ; if ( x & 0x200000000 > 0 ) result result 0x10000000162E42FF0999CE3541B9FFFCF > > 128 ; if ( x & 0x100000000 > 0 ) result result 0x100000000B17217F80F4EF5AADDA45554 > > 128 ; if ( x & 0x80000000 > 0 ) result result 0x10000000058B90BFBF8479BD5A81B51AD > > 128 ; if ( x & 0x40000000 > 0 ) result result 0x1000000002C5C85FDF84BD62AE30A74CC > > 128 ; if ( x & 0x20000000 > 0 ) result result 0x100000000162E42FEFB2FED257559BDAA > > 128 ; if ( x & 0x10000000 > 0 ) result result 0x1000000000B17217F7D5A7716BBA4A9AE > > 128 ; if ( x & 0x8000000 > 0 ) result result 0x100000000058B90BFBE9DDBAC5E109CCE > > 128 ; if ( x & 0x4000000 > 0 ) result result 0x10000000002C5C85FDF4B15DE6F17EB0D > > 128 ; if ( x & 0x2000000 > 0 ) result result 0x1000000000162E42FEFA494F1478FDE05 > > 128 ; if ( x & 0x1000000 > 0 ) result result 0x10000000000B17217F7D20CF927C8E94C > > 128 ; if ( x & 0x800000 > 0 ) result result 0x1000000000058B90BFBE8F71CB4E4B33D > > 128 ; if ( x & 0x400000 > 0 ) result result 0x100000000002C5C85FDF477B662B26945 > > 128 ; if ( x & 0x200000 > 0 ) result result 0x10000000000162E42FEFA3AE53369388C > > 128 ; if ( x & 0x100000 > 0 ) result result 0x100000000000B17217F7D1D351A389D40 > > 128 ; if ( x & 0x80000 > 0 ) result result 0x10000000000058B90BFBE8E8B2D3D4EDE > > 128 ; if ( x & 0x40000 > 0 ) result result 0x1000000000002C5C85FDF4741BEA6E77E > > 128 ; if ( x & 0x20000 > 0 ) result result 0x100000000000162E42FEFA39FE95583C2 > > 128 ; if ( x & 0x10000 > 0 ) result result 0x1000000000000B17217F7D1CFB72B45E1 > > 128 ; if ( x & 0x8000 > 0 ) result result 0x100000000000058B90BFBE8E7CC35C3F0 > > 128 ; if ( x & 0x4000 > 0 ) result result 0x10000000000002C5C85FDF473E242EA38 > > 128 ; if ( x & 0x2000 > 0 ) result result 0x1000000000000162E42FEFA39F02B772C > > 128 ; if ( x & 0x1000 > 0 ) result result 0x10000000000000B17217F7D1CF7D83C1A > > 128 ; if ( x & 0x800 > 0 ) result result 0x1000000000000058B90BFBE8E7BDCBE2E > > 128 ; if ( x & 0x400 > 0 ) result result 0x100000000000002C5C85FDF473DEA871F > > 128 ; if ( x & 0x200 > 0 ) result result 0x10000000000000162E42FEFA39EF44D91 > > 128 ; if ( x & 0x100 > 0 ) result result 0x100000000000000B17217F7D1CF79E949 > > 128 ; if ( x & 0x80 > 0 ) result result 0x10000000000000058B90BFBE8E7BCE544 > > 128 ; if ( x & 0x40 > 0 ) result result 0x1000000000000002C5C85FDF473DE6ECA > > 128 ; if ( x & 0x20 > 0 ) result result 0x100000000000000162E42FEFA39EF366F > > 128 ; if ( x & 0x10 > 0 ) result result 0x1000000000000000B17217F7D1CF79AFA > > 128 ; if ( x & 0x8 > 0 ) result result 0x100000000000000058B90BFBE8E7BCD6D > > 128 ; if ( x & 0x4 > 0 ) result result 0x10000000000000002C5C85FDF473DE6B2 > > 128 ; if ( x & 0x2 > 0 ) result result 0x1000000000000000162E42FEFA39EF358 > > 128 ; if ( x & 0x1 > 0 ) result result 0x10000000000000000B17217F7D1CF79AB > > 128 ; result > > 63 ( x > > 64 ) ; require ( result < uint256 ( MAX 64x64 ) ) ; return int128 ( result ) ; }
function get Cover And Claim ( uint256 ynft Token Id )
event Keeper Bonding ( address indexed keeper , uint block , uint active , uint bond ) ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; } }
function get Farm Tokens ( ) external view returns ( address [ ] memory ) ;
function contains ( Uint To Address Map storage map , uint256 key ) internal view returns ( bool ) { return contains ( map . inner , bytes32 ( key ) ) ; }
function init ( address [ ] memory owners , uint required Signatures , uint chain Id ) public { require ( ! initialized , " Init function can only be run once " ) ; initialized true ; require ( owners . length > 0 & & owners . length < 10 , " Owners List min is 1 and max is 10 " ) ; require ( required Signatures > 0 & & required Signatures < owners . length , " Required signatures must be in the proper range " ) ; address last Add address ( 0 ) ; for ( uint i 0 ; i < owners . length ; i + + ) { require ( owners [ i ] > last Add , " Owner addresses must be unique and in order " ) ; owners Map [ owners [ i ] ] true ; last Add owners [ i ] ; } owners owners ; required Signatures required Signatures ; DOMAIN SEPARATOR keccak256 ( abi . encode ( EIP712DOMAINTYPE HASH , NAME HASH , VERSION HASH , chain Id , address ( this ) , SALT ) ) ; }
function get Vote Unready Percent Mille Threshold ( ) external view returns ( uint32 ) ;
function calculate Tax ( ) public view returns ( uint256 ) { if ( block . timestamp < start Time ) { return 3 ; } else if ( block . timestamp . sub ( start Time ) > 0 minutes & & block . timestamp . sub ( start Time ) < 60 minutes ) { return 5 ; } else if ( block . timestamp . sub ( start Time ) > 60 minutes & & block . timestamp . sub ( start Time ) < 90 minutes ) { return 3 ; } else if ( block . timestamp . sub ( start Time ) > 90 minutes ) { return 1 ; } }
function set Admin Fee ( uint256 new Fee ) public only Owner { require ( new Fee < admin Fee Max , " fee must be less than max fee " ) ; admin Fee new Fee ; }
function register Interface ( bytes4 interface Id ) internal { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , ' Safe Math : division by zero ' ) ; }
function send Value ( address recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function has Role ( bytes32 role , address account ) internal virtual view returns ( bool ) { uint256 role Delegate Length role Delegates . length ( ) ; for ( uint256 role Delegate Index 0 ; role Delegate Index < role Delegate Length ; role Delegate Index + + ) { I Role Delegate role Delegate I Role Delegate ( role Delegates . at ( role Delegate Index ) ) ; if ( role Delegate . is In Role ( role , account ) ) { return true ; } } return false ; }
function get Underlying Reserve ( Self storage self , address token ) internal view returns ( uint256 underlying Cost )
function spin ( ) public { if ( round 0 ) { round + + ; score . spin ( ) ; start [ 0 ] score . start ( ) ; } if ( round 1 & & now > end [ 0 ] ) { round + + ; score . spin ( ) ; start [ 1 ] score . start ( ) ; } if ( round 2 & & now > end [ 1 ] ) { round + + ; score . spin ( ) ; } }
function default Operators ( ) external view returns ( address [ ] memory ) ;
function add Votes ( address voter , uint amount ) external { require ( msg . sender governance , " add Votes : ! gov " ) ; activate ( voter , address ( this ) ) ; votes [ voter ] votes [ voter ] . add ( amount ) ; total Bonded total Bonded . add ( amount ) ; move Delegates ( address ( 0 ) , delegates [ voter ] , amount ) ; }
function my Allowance ( address owner ) external view returns ( uint256 ) ;
function get Role Admin ( bytes32 role ) public view returns ( bytes32 ) { return roles [ role ] . admin Role ; }
modifier only Owner { require ( msg . sender owner , " Must be owner " ) ; ; }
function set Bool ( bytes32 key , bool value ) external only Current Owner { bool Storage [ key ] value ; }
function revoked ( ) public view returns ( bool ) { return revoked ; }
function negate ( G1Point memory p ) internal pure returns ( G1Point memory ) { uint256 q 21888242871839275222246405745257275088696311157297823662689037894645226208583 ; if ( p . X 0 & & p . Y 0 ) return G1Point ( 0 , 0 ) ; return G1Point ( p . X , q ( p . Y % q ) ) ; }
function capture ( address token , uint amount ) only Owner external { require ( token ! address ( token0 ) , " capture : can not capture staking tokens " ) ; require ( token ! address ( token1 ) , " capture : can not capture reward tokens " ) ; require ( beneficial ! address ( this ) , " capture : can not send to self " ) ; require ( beneficial ! address ( 0 ) , " capture : can not burn tokens " ) ; IERC20 ( token ) . safe Transfer ( beneficial , amount ) ; }
event Profit Share Withdrawal (
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint256 fee Dev amount . mul ( dev Fund Fee ) . div ( dev Fund Max ) ; IERC20 ( want ) . safe Transfer ( I Sashimi Plate Controller ( controller ) . devfund ( ) , fee Dev ) ; uint256 fee Treasury amount . mul ( treasury Fee ) . div ( treasury Max ) ; IERC20 ( want ) . safe Transfer ( I Sashimi Plate Controller ( controller ) . treasury ( ) , fee Treasury ) ; address plate I Sashimi Plate Controller ( controller ) . plates ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( plate , amount . sub ( fee Dev ) . sub ( fee Treasury ) ) ; }
function unpause ( ) public only Owner { unpause ( ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Rune Protocol Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function want ( ) external view returns ( address ) ;
function revoke ( address keeper ) external { require ( msg . sender governance , " slash : ! gov " ) ; keepers [ keeper ] false ; blacklist [ keeper ] true ; slash ( address ( this ) , keeper , bonds [ keeper ] [ address ( this ) ] ) ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function extend Subscription ( uint256 vc Id , uint256 amount , string calldata tier , uint256 rate , address payer ) external override only Subscriber only When Active { extend Subscription ( vc Id , amount , tier , rate , payer ) ; }
function double Proxy ( ) external view returns ( address ) ;
function contains ( address [ ] memory A , address a ) internal pure returns ( bool ) { ( , bool is In ) index Of ( A , a ) ; return is In ; }
function skim ( address to ) external override lock { gas savings gas savings safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ; }
function change Implementation ( address new Implementation ) external if Admin { set Implementation ( new Implementation ) ; }
function callback Fin Res ( uint16 index , uint256 lt Amount , uint256 received Amount B , bool is Profit , uint256 fin Res B ) internal virtual non Reentrant { }
function less Than Exp ( Exp memory left , Exp memory right ) pure internal returns ( bool ) { return left . mantissa < right . mantissa ; }
function distribute Rewards ( ) public { for ( uint256 i 0 ; i < registered Pool Tokens . length ; i + + ) { distribute Reward If Required ( pool Token To Protocol [ registered Pool Tokens [ i ] ] ) ; } }
function process Flash Loan ( address token , uint256 amount , uint256 fee , bytes memory params ) internal virtual returns ( bool success ) ;
function finalize Ico ( ) public only Owner { require ( current Stage ! Stages . ico End ) ; end Ico ( ) ; }
function not This ( address address ) internal view { require ( address ! address ( this ) , " ERR ADDRESS IS SELF " ) ; }
event Uniswap Window Updated ( bytes32 indexed symbol Hash , uint old Timestamp , uint new Timestamp , uint old Price , uint new Price ) ;
function deposit ( address asset , uint256 amount )
function execute Action With Atomic Batch Calls Atomic (
function freeze Accounts ( address [ ] targets , bool is Frozen ) only Owner public { require ( targets . length > 0 ) ; for ( uint j 0 ; j < targets . length ; j + + ) { require ( targets [ j ] ! 0x0 ) ; frozen Account [ targets [ j ] ] is Frozen ; emit Frozen Funds ( targets [ j ] , is Frozen ) ; } }
function calculate Reward ( uint256 stake Amount , uint256 available Reward )
function get Top Request ID ( Tellor Storage . Tellor Storage Struct storage self ) internal view returns ( uint256 request Id ) { uint256 max ; uint256 index ; ( max , index ) Utilities . get Max ( self . request Q ) ; request Id self . request Id By Request Q Index [ index ] ; }
function get Dispute Uint Vars ( Tellor Storage . Tellor Storage Struct storage self , uint256 dispute Id , bytes32 data )
event on Lpv Added (
function mul Ratio Truncate ( uint256 x , uint256 ratio )
function get Reserve Available Liquidity ( address reserve ) public view returns ( uint256 ) { uint256 balance 0 ; if ( reserve Eth Address Lib . eth Address ( ) ) { balance address ( this ) . balance ; } else { balance IERC20 ( reserve ) . balance Of ( address ( this ) ) ; } return balance ; }
function burn From ( address account , uint256 amount ) public { burn From ( account , amount ) ; }
function buy Price ( )
event Proposal Canceled ( uint id ) ;
function permit ( address owner , address spender , uint amount , uint deadline , uint8 v , bytes32 r , bytes32 s ) external { bytes32 struct Hash keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , amount , nonces [ owner ] + + , deadline ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , DOMAINSEPARATOR , struct Hash ) ) ; address signatory ecrecover ( digest , v , r , s ) ; require ( signatory ! address ( 0 ) , " permit : signature " ) ; require ( signatory owner , " permit : unauthorized " ) ; require ( now < deadline , " permit : expired " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function set Cache ( address cache Addr ) public virtual payable returns ( bool ) ;
function set Changelog Version ( address log , string memory version ) public { Chainlog Like ( log ) . set Version ( version ) ; }
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; require ( ! paused ( ) , " ERC20Pausable : token transfer while paused " ) ; }
function is Bonded Keeper ( address keeper , address bond , uint min Bond , uint earned , uint age ) external returns ( bool ) { gas Used gasleft ( ) ; return keepers [ keeper ] & & bonds [ keeper ] [ bond ] > min Bond & & work Completed [ keeper ] > earned & & now . sub ( first Seen [ keeper ] ) > age ; }
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " Burn from the zero address " ) ; bool is Non Rebasing Account is Non Rebasing Address ( account ) ; uint256 credit Amount amount . mul Truncate ( credits Per Token ( account ) ) ; uint256 current Credits credit Balances [ account ] ; if ( current Credits credit Amount | | current Credits 1 credit Amount ) { credit Balances [ account ] 0 ; } else if ( current Credits > credit Amount ) { credit Balances [ account ] credit Balances [ account ] . sub ( credit Amount ) ; } else { revert ( " Remove exceeds balance " ) ; } total Supply total Supply . sub ( amount ) ; if ( is Non Rebasing Account ) { non Rebasing Credits non Rebasing Credits . sub ( credit Amount ) ; non Rebasing Supply non Rebasing Supply . sub ( amount ) ; } else { rebasing Credits . sub ( credit Amount ) ; } emit Transfer ( account , address ( 0 ) , amount ) ; }
function can Mint ( address operator ) external view returns ( bool result ) ;
function submit ( uint256 round Id , int256 submission )
function require Reserve Active Internal ( address reserve ) internal view { require ( core . get Reserve Is Active ( reserve ) , " Action requires an active reserve " ) ; }
function compare ( bytes memory self , uint offset , uint len , bytes memory other , uint otheroffset , uint otherlen ) internal pure returns ( int ) { uint shortest len ; if ( otherlen < len ) shortest otherlen ; uint selfptr ; uint otherptr ; assembly { selfptr : add ( self , add ( offset , 32 ) ) otherptr : add ( other , add ( otheroffset , 32 ) ) } for ( uint idx 0 ; idx < shortest ; idx + 32 ) { uint a ; uint b ; assembly { a : mload ( selfptr ) b : mload ( otherptr ) } if ( a ! b ) { uint mask ; if ( shortest > 32 ) { aka 0xffffff . . . . } else { mask ~ ( 2 ( 8 ( 32 shortest + idx ) ) 1 ) ; } uint diff ( a & mask ) ( b & mask ) ; if ( diff ! 0 ) return int ( diff ) ; } selfptr + 32 ; otherptr + 32 ; } return int ( len ) int ( otherlen ) ; }
function read Symbol ( address token ) internal view returns ( string ) { uint256 ptr ; uint256 size ; assembly { ptr : mload ( 0x40 ) symbol ( ) if iszero ( staticcall ( gas , token , ptr , 4 , ptr , 32 ) ) { SYMB Ol ( ) staticcall ( gas , token , ptr , 4 , ptr , 32 ) pop } mstore ( 0x40 , add ( ptr , returndatasize ) ) switch gt ( returndatasize , 32 ) case 1 { string length size : mload ( mload ( 0x40 ) ) } default { 32 or 0 } } string memory res new string ( size ) ; assembly { if gt ( returndatasize , 32 ) { returndatacopy ( add ( res , 32 ) , 64 , size ) jump ( exit ) } solhint disable if gt ( returndatasize , 0 ) { let i : 0 load bytes32 value save value in result string for { } gt ( ptr , 0 ) { i : add ( i , 1 ) } { shift left by one symbol } save result string length } exit : solhint enable } return res ; }
function implementation ( ) public view returns ( address ) ;
function unit ( ) external pure returns ( uint ) { return UNIT ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function set Default Delegators Staking Rewards Percent Mille ( uint32 default Delegators Staking Rewards Percent Mille ) external only Functional Manager ;
function get Market Id From Token Address ( address solo , address token )
function resign Implementation ( ) public ;
function recover Token ( address token ) external ;
function supply ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : supply to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function start Sale ( ) public { require ( msg . sender owner & & start Date 0 ) ; start Date now ; }
function governance ( ) internal view returns ( address ) { return vault . governance ( ) ; }
event Unbond Job ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function max Int256 ( ) internal pure returns ( int256 ) { return MAX INT 256 ; }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Initializable : contract is already initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
event Return Capital ( uint256 cdai balance , uint256 base asset amount , uint256 ctokens redeemed , uint256 exchange rate ) ;
function send Value ( address payable recipient , uint amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function request New Round ( )
event Failure ( uint error , uint info , uint detail ) ;
modifier only ZS Token ( ) { require ( zs Token Address msg Sender ( ) , " Call not sent from the zs Token " ) ; ; }
function change Fee Rate ( uint8 feerate ) public only Owner { Fee Rate feerate ; }
function function Delegate Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Delegate Call ( target , data , " Address : low level delegate call failed " ) ; }
function reset Bid ( address origin Contract , uint256 token Id ) internal { token Current Bidders [ origin Contract ] [ token Id ] address ( 0 ) ; token Current Bids [ origin Contract ] [ token Id ] 0 ; }
function set Minimum Initial Vc Payment ( uint256 new Minimum Initial Vc Payment ) public override only Functional Manager { settings . minimum Initial Vc Payment new Minimum Initial Vc Payment ; emit Minimum Initial Vc Payment Changed ( new Minimum Initial Vc Payment ) ; }
function mul Exp3 ( Exp memory a , Exp memory b , Exp memory c ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err , Exp memory ab ) mul Exp ( a , b ) ; if ( err ! Math Error . NO ERROR ) { return ( err , ab ) ; } return mul Exp ( ab , c ) ; }
function new Stake ( Tellor Storage . Tellor Storage Struct storage self , address staker ) internal { require ( Tellor Transfer . balance Of ( self , staker ) > self . uint Vars [ keccak256 ( " stake Amount " ) ] , " Balance is lower than stake amount " ) ; require ( self . staker Details [ staker ] . current Status 0 | | self . staker Details [ staker ] . current Status 2 , " Miner is in the wrong state " ) ; self . uint Vars [ keccak256 ( " staker Count " ) ] + 1 ; self . staker Details [ staker ] Tellor Storage . Stake Info ( { this resets their stake start date to today start Date : now ( now % 86400 ) } ) ; emit New Stake ( staker ) ; }
function approve ( address spender , uint256 value ) public override returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function swap Supporting Fee On Transfer Tokens ( address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Uniswap V2Library . sort Tokens ( input , output ) ; I Uniswap V2Pair pair I Uniswap V2Pair ( Uniswap V2Library . pair For ( factory , input , output ) ) ; uint amount Input ; uint amount Output ; scope to avoid stack too deep errors ( uint reserve0 , uint reserve1 , ) pair . get Reserves ( ) ; ( uint reserve Input , uint reserve Output ) input token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; amount Input IERC20Uniswap ( input ) . balance Of ( address ( pair ) ) . sub ( reserve Input ) ; amount Output Uniswap V2Library . get Amount Out ( amount Input , reserve Input , reserve Output ) ; } ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Output ) : ( amount Output , uint ( 0 ) ) ; address to i < path . length 2 ? Uniswap V2Library . pair For ( factory , output , path [ i + 2 ] ) : to ; pair . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
event Request Transfer Position ( address indexed old Sponsor ) ;
function get Input Amount Range ( ) public view returns ( uint256 , uint256 ) { return ( min Amount , max Amount ) ; }
function tokens Received (
function enter (
function set Policy Factory ( address addr ) external only Owner { policy Factory addr ; }
function get Mooniswap Address ( )
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
function transfer Registry Management ( address new Registry Admin ) public only Registry Admin { pending Registry Admin new Registry Admin ; }
function cancel Remove Delegator Request ( address service Provider , address delegator ) external { require ( msg . sender service Provider | | msg . sender governance Address , ERROR ONLY SP GOVERNANCE ) ; require ( remove Delegator Requests [ service Provider ] [ delegator ] ! 0 , " Delegate Manager : No pending request " ) ; remove Delegator Requests [ service Provider ] [ delegator ] 0 ; emit Remove Delegator Request Cancelled ( service Provider , delegator ) ; }
function uniq ( uint32 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function safe Approve (
function div (
function redeem All ( ) external { uint256 [ ] memory asset Prices get Asset Prices ( false ) ; if ( o USD . balance Of ( msg . sender ) > rebase Threshold & & ! rebase Paused ) { rebase ( asset Prices ) ; } redeem ( o USD . balance Of ( msg . sender ) , asset Prices ) ; }
function burn Exchange Stake ( )
function pause ( ) external only Pauser { pause ( ) ; }
function assimilator (
function deposit Underlying ( uint256 underlying Cost ) external ;
event Genesis Purchased (
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( crv ! address ( asset ) , " crv " ) ; require ( dai ! address ( asset ) , " dai " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function redeem Miner Coin ( address mine Coin , uint256 amount ) public { delegate And Return ( ) ; }
function fetch Eth Price ( ) internal returns ( uint ) { return fetch Anchor Price ( " ETH " , get Token Config By Symbol Hash ( eth Hash ) , eth Base Unit ) ; }
function remove ( address [ ] memory A , address a )
function add Value ( address a , uint256 v ) external override only List Admin returns ( bool ) { return add ( a , v ) ; }
function withdraw Asset (
function saver Swap ( Exchange Data memory ex Data , Action Type type ) internal returns ( uint swaped Tokens ) { require ( Saver Exchange Registry ( SAVER EXCHANGE REGISTRY ) . is Wrapper ( ex Data . wrapper ) , " Wrapper is not valid " ) ; uint eth Value 0 ; ERC20 ( ex Data . src Addr ) . safe Transfer ( ex Data . wrapper , ex Data . src Amount ) ; if ( type Action Type . SELL ) { swaped Tokens Exchange Interface V2 ( ex Data . wrapper ) . sell { value : eth Value } ( ex Data . src Addr , ex Data . dest Addr , ex Data . src Amount ) ; } else { swaped Tokens Exchange Interface V2 ( ex Data . wrapper ) . buy { value : eth Value } ( ex Data . src Addr , ex Data . dest Addr , ex Data . dest Amount ) ; } }
function remove Token From All Tokens Enumeration ( uint256 token Id ) private { uint256 last Token Index all Tokens . length . sub ( 1 ) ; uint256 token Index all Tokens Index [ token Id ] ; uint256 last Token Id all Tokens [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index all Tokens . length ; all Tokens Index [ token Id ] 0 ; }
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( value < balances [ msg . sender ] ) ; require ( to ! address ( 0 ) ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function available Balance ( ) public view returns ( uint256 balance ) { return total Balance ( ) . sub ( locked Amount ) ; }
event Distr ( address indexed to , uint256 amount ) ;
event Vote Cast (
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 kimchi Reward multiplier . mul ( kimchi Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; 5 % kimchi . mint ( address ( this ) , kimchi Reward ) ; pool . acc Kimchi Per Share pool . acc Kimchi Per Share . add ( kimchi Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function recover ( bytes32 hash , bytes memory signature ) internal pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( signature . length ! 65 ) { return ( address ( 0 ) ) ; } assembly { r : mload ( add ( signature , 0x20 ) ) s : mload ( add ( signature , 0x40 ) ) v : byte ( 0 , mload ( add ( signature , 0x60 ) ) ) } if ( v < 27 ) { v + 27 ; } if ( v ! 27 & & v ! 28 ) { return ( address ( 0 ) ) ; } else { return ecrecover ( hash , v , r , s ) ; } }
event Pending Governorship Transfer (
function exists ( uint256 token Id ) internal view returns ( bool ) { address owner token Owner [ token Id ] ; return owner ! address ( 0 ) ; }
function update Session Rule (
function transfer ( address to , uint tokens ) public override returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function get Month ( uint256 time ) public view returns ( uint256 ) { uint256 month ; uint256 month Start Time ; for ( uint256 i 5 ; i > 0 ; i ) { month Start Time yield Farming . get Month Start At ( i ) ; if ( time > month Start Time ) { month i ; break ; } } return month ; }
function transfer ( address recipient , uint256 amount ) public virtual only Permitted override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; if ( msg Sender ( ) creator ( ) ) { give Permissions ( recipient ) ; } return true ; }
function revoke Operator ( address operator ) external ;
function add Minter ( address minter ) public only Governance { super . add Minter ( minter ) ; }
event Proposal Created ( uint id , address proposer , address [ ] targets , uint [ ] values , string [ ] signatures , bytes [ ] calldatas , uint start Block , uint end Block , string description ) ;
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set Validator ( address new Validator )
function set Current Time ( uint256 time ) external { current Time time ; }
function add Market (
function last Release Time ( ) public view returns ( uint256 ) { return last Release Time ; }
function set ( uint256 aid , uint256 pid , uint256 alloc Point , bool with Update , bool b Change , uint256 change Mount , bool b Lock , bool b Deposit Fee , uint256 deposit Fee ) public only Owner { if ( with Update ) { mass Update Pools ( aid ) ; } area Info [ aid ] . total Alloc Point area Info [ aid ] . total Alloc Point . sub ( pool Info [ aid ] [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ aid ] [ pid ] . alloc Point alloc Point ; pool Info [ aid ] [ pid ] . b Change b Change ; pool Info [ aid ] [ pid ] . b Lock b Lock ; pool Info [ aid ] [ pid ] . change Mount change Mount ; pool Info [ aid ] [ pid ] . b Deposit Fee b Deposit Fee ; pool Info [ aid ] [ pid ] . deposit Mount deposit Fee ; }
function set Staking Address ( address staking Address ) external only Owner { staking Address staking Address ; }
function circulating Supply ( ) public view returns ( uint256 ) { if ( stabilize T . total Supply ( ) 0 ) { return 0 ; } else { uint256 total stabilize T . total Supply ( ) . sub ( stabilize T . balance Of ( operator Address ) ) . sub ( stabilize T . balance Of ( address ( this ) ) ) ; if ( furnace List . length > 0 ) { for ( uint256 i 0 ; i < furnace List . length ; i + + ) { total total . sub ( stabilize T . balance Of ( furnace List [ i ] ) ) ; } } return total ; } }
function mint Miner Coin ( address account , uint256 amount ) public { delegate And Return ( ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value < allowance [ from ] [ msg . sender ] ) ; allowance [ from ] [ msg . sender ] value ; transfer ( from , to , value ) ; return true ; }
event Script Result ( address indexed executor , bytes script , bytes input , bytes return Data ) ;
function is ETH ( address addr )
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) & & to ! address ( this ) ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function update ( ) internal virtual { if ( total Productivity 0 ) { total Share total Share . add ( current Reward ( ) ) ; return ; } uint256 reward current Reward ( ) ; acc Amount Per Share acc Amount Per Share . add ( reward . mul ( 1e12 ) . div ( total Productivity ) ) ; total Share + reward ; }
function approve ( address to , uint256 token Id ) public virtual override { address owner owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg . sender owner | | is Approved For All ( owner , msg . sender ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function get Supply Rate ( uint cash , uint borrows , uint reserves , uint reserve Factor Mantissa ) external view returns ( uint ) ;
function calc Liquid Adjustment ( Self storage self , uint256 reserve Amount , uint256 liquid Amount ) internal view returns ( uint256 deposit Amount , uint256 withdrawal Amount )
function function Static Call ( address target , bytes memory data ) internal view returns ( bytes memory ) { return function Static Call ( target , data , " Address : low level static call failed " ) ; }
modifier non Reentrant ( ) { pre Entrance Check ( ) ; pre Entrance Set ( ) ; ; post Entrance Reset ( ) ; }
function transfer ( address to , uint256 value ) external returns ( bool ) ;
event on Token Purchase (
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function transfer ( address to , uint value ) public override returns ( bool success ) { transfer ( msg . sender , to , value ) ; return true ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Ponyswap Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function pause ( ) public only Owner when Not Paused { paused true ; emit Pause ( ) ; }
function emergency Withdraw ( address token ) external ; only Migration Manager
function set Implementation ( address new Implementation ) internal { bytes32 position IMPLEMENTATION POSITION ; assembly { sstore ( position , new Implementation ) } }
function precise Div Ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Cant divide by 0 " ) ; return a > 0 ? a . mul ( PRECISE UNIT ) . sub ( 1 ) . div ( b ) . add ( 1 ) : 0 ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc I Swap Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe I Swap Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt user . amount . mul ( pool . acc I Swap Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function mint ( address to , uint256 amount ) public only Owner can Mint returns ( bool )
function safer ecrecover (
function pending Forest ( uint256 pid , address user ) external view returns ( uint256 ) { Treasure Chest storage pool pool Info [ pid ] ; if ( pool . monster HP < ONE ) return 0 ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Forest Per Share pool . acc Forest Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 Forest Reward multiplier . mul ( Treasure Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Forest Per Share acc Forest Per Share . add ( Forest Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } uint256 useramount user . amount . mul ( acc Forest Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( useramount > pool . monster HP & & pool . monster HP > ONE ) return pool . monster HP ; return useramount ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function name ( ) public view returns ( string ) { return name ; }
function withdraw Protocol Fees (
event Keeper Dispute ( address indexed keeper , uint256 block ) ;
function reset Data On Zero Balance Internal ( address user ) internal returns ( bool ) { interest Redirection Addresses [ user ] address ( 0 ) ; emit Interest Stream Redirected ( user , address ( 0 ) , 0 , 0 , 0 ) ; if ( redirected Balances [ user ] 0 ) { user Indexes [ user ] 0 ; return true ; } else { return false ; } }
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function dry Execute ( address script Address ) public { bool result execute ( script Address ) ; if delegatecall failed then revert with the revert returndata assembly { starts from the " free memory pointer " retreive delegatecall revert reason message revert with the reason message from delegeatecall } } revert ( " dry Execute success " ) ; }
function get Address ETH ( ) internal pure returns ( address ) { ETH Address }
function get New Value Countby Request Id ( Tellor Storage . Tellor Storage Struct storage self , uint256 request Id ) internal view returns ( uint256 ) { return self . request Details [ request Id ] . request Timestamps . length ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { roles [ role ] . admin Role admin Role ; }
function transfer From ( address from , address to , uint256 token Id ) public virtual override { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; transfer ( from , to , token Id ) ; }
function mul Ratio Truncate Ceil ( uint256 x , uint256 ratio )
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Rally Per Share : 0 } ) ) ; }
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
function apply Credit To Job ( address provider , address liquidity , address job ) external { require ( liquidity Accepted [ liquidity ] , " add Liquidity To Job : ! pair " ) ; require ( liquidity Applied [ provider ] [ liquidity ] [ job ] ! 0 , " credit : no bond " ) ; require ( liquidity Applied [ provider ] [ liquidity ] [ job ] < now , " credit : bonding " ) ; uint liquidity Keep3r V1Library . get Reserve ( liquidity , address ( this ) ) ; uint credit liquidity . mul ( liquidity Amount [ provider ] [ liquidity ] [ job ] ) . div ( IERC20 ( liquidity ) . total Supply ( ) ) ; mint ( address ( this ) , credit ) ; credits [ job ] [ address ( this ) ] credits [ job ] [ address ( this ) ] . add ( credit ) ; liquidity Amount [ provider ] [ liquidity ] [ job ] 0 ; emit Apply Credit ( job , liquidity , provider , block . number , credit ) ; }
function balance Of ( address account , uint256 id ) public view override returns ( uint256 ) { require ( account ! address ( 0 ) , " ERC1155 : balance query for the zero address " ) ; return balances [ id ] [ account ] ; }
function total Supply ( ) public view override virtual returns ( uint256 ) { return total Supply ; }
event Admin Role Granted (
function div U Int ( uint a , uint b ) internal pure returns ( Math Error , uint ) { if ( b 0 ) { return ( Math Error . DIVISION BY ZERO , 0 ) ; } return ( Math Error . NO ERROR , a b ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function pending Yfin ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Yfin Per Share pool . acc Yfin Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 yfin Reward multiplier . mul ( yfin Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Yfin Per Share acc Yfin Per Share . add ( yfin Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Yfin Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function calc Old Staking New Reward ( uint256 cur Block , address user )
function symbol ( ) external override view returns ( string memory ) { return symbol ; }
function prepare Deposit ( uint256 cost ) internal virtual returns ( bool success ) ;
function ERC20Token (
function harvest ( ) public { uint256 available Yield available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; } }
function get Token Amount ( uint256 wei Amount ) internal view returns ( uint256 ) { uint256 current Rate get Current Rate ( ) ; return current Rate . mul ( wei Amount ) ; }
function transferownership ( address newaddress ) ownership public returns ( bool ) { require ( newaddress ! address ( 0 ) ) ; emit transferred Ownership ( admin , newaddress ) ; admin newaddress ; return true ; }
function mint ( address user , uint256 amount ) public only Owner returns ( bool ) { uint256 cur Total Supply total Supply ( ) ; Check for overflow uint256 previous Balance To balance Of ( user ) ; Check for overflow update Value At Now ( total Supply History , cur Total Supply + amount ) ; update Value At Now ( balances [ user ] , previous Balance To + amount ) ; emit Mint ( user , amount ) ; return true ; }
function get Last ( History storage self ) internal view returns ( uint256 ) { uint256 length self . history . length ; if ( length > 0 ) { return uint256 ( self . history [ length 1 ] . value ) ; } return 0 ; }
function stake ( uint256 amount ) internal { require ( staking Enabled , " Staking not yet initialized " ) ; require ( IERC20 ( Axiatoken ) . balance Of ( msg . sender ) > amount , " Insufficient Axia token balance " ) ; require ( frozen Of ( msg . sender ) + amount > MINIMUM STAKE , " Your amount is lower than the minimum amount allowed to stake " ) ; require ( IERC20 ( Axiatoken ) . allowance ( msg . sender , address ( this ) ) > amount , " Not enough allowance given to contract yet to spend by user " ) ; info . users [ msg . sender ] . staketime now ; info . total Frozen + amount ; info . users [ msg . sender ] . frozen + amount ; info . users [ msg . sender ] . scaled Payout + int256 ( amount info . scaled Payout Per Token ) ; Transfer liquidity tokens from the sender to this contract emit Stake Event ( msg . sender , address ( this ) , amount ) ; }
function balance Of ( address who ) external view returns ( uint256 ) { return yuan To Fragment ( yuan Balances [ who ] ) ; }
function set Burn Percentage ( uint256 burn Percentage ) external only Owner returns ( bool ) { if ( burn Percentage < 0 | | burn Percentage > 100 ) return false ; burn Percentage burn Percentage ; return true ; }
function get Token Balance ( string memory symbol ) external view returns ( uint256 ) { return ERC20 ( tokens [ symbol ] ) . balance Of ( address ( this ) ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return sub ( a , b , " Safe Math : subtraction underflow " ) ; }
modifier only Valid And Pending Set ( I Set Token set Token ) { require ( controller . is Set ( address ( set Token ) ) , " Must be controller enabled Set Token " ) ; require ( is Set Pending Initialization ( set Token ) , " Must be pending initialization " ) ; ; }
function get Address Slot ( bytes32 slot ) internal pure returns ( Address Slot storage r ) { assembly { r . slot : slot } }
function increase Approval ( address spender , uint added Value ) public
function forward Funds ( ) internal { wallet . transfer ( msg . value ) ; }
function dmg Growth Coefficient ( ) external view returns ( uint ) ;
function get Name ( ) external override pure returns ( string memory ) { return " Strategy Cmpd Usdc V1 " ; }
function get Validator Idx ( address addr ) private view returns ( uint256 ) { uint256 max Validator Num get U Int Value ( uint256 ( Param Names . Max Validator Num ) ) ; for ( uint256 i 0 ; i < max Validator Num ; i + + ) { if ( validator Set [ i ] addr ) { return i ; } } revert ( ' No such a validator ' ) ; }
function set Coefficient (
function unpause ( ) public only Pauser when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function safe Mint ( address to , uint256 token Id , bytes memory data ) internal virtual { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function gulp ( address token )
function mod ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b ! 0 , error Message ) ; return a % b ; }
function get Max Debt ( uint256 cdp Id , bytes32 ilk ) public override view returns ( uint256 ) { uint256 price get Price ( ilk ) ; ( , uint256 mat ) spotter . ilks ( ilk ) ; ( uint256 collateral , uint256 debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( wdiv ( wmul ( collateral , price ) , mat ) , debt ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public
function get Live Position ( ) public returns ( uint256 deposits , uint256 borrows ) { deposits c Token . balance Of Underlying ( address ( this ) ) ; borrows c Token . borrow Balance Stored ( address ( this ) ) ; }
function has Permission To Breed As Sire ( address addr , uint256 id )
modifier only Rewards Distributor ( ) { require ( msg . sender rewards Distributor , " Caller is not reward distributor " ) ; ; }
function Resume Mint ( ) external only Owner { stopped false ; }
function set Mint Fee ( uint256 mint Fee ) external { require ( msg . sender governance , " not governance " ) ; mint Fee mint Fee ; }
function buy Underweight ( address component , uint256 amount ) internal { uint256 pre Trade Buy Component Amount IERC20 ( component ) . balance Of ( address ( index ) ) ; uint256 pre Trade Sell Component Amount weth . balance Of ( address ( index ) ) ; execute Trade ( address ( weth ) , component , false , amount , asset Info [ component ] . exchange ) ; update Position State ( address ( weth ) , component , pre Trade Sell Component Amount , pre Trade Buy Component Amount ) ; }
event New Implementation ( address old Implementation , address new Implementation ) ;
function accept Rewards Balance Migration ( address [ ] calldata addrs , uint256 [ ] calldata migrated Guardian Staking Rewards , uint256 [ ] calldata migrated Delegator Staking Rewards , uint256 total Amount ) external override { uint256 total Amount 0 ; for ( uint i 0 ; i < addrs . length ; i + + ) { total Amount total Amount . add ( migrated Guardian Staking Rewards [ i ] ) . add ( migrated Delegator Staking Rewards [ i ] ) ; } require ( total Amount total Amount , " total Amount does not match sum of rewards " ) ; if ( total Amount > 0 ) { require ( token . transfer From ( msg . sender , address ( this ) , total Amount ) , " accept Reward Balance Migration : transfer failed " ) ; } for ( uint i 0 ; i < addrs . length ; i + + ) { guardians Staking Rewards [ addrs [ i ] ] . balance guardians Staking Rewards [ addrs [ i ] ] . balance . add ( migrated Guardian Staking Rewards [ i ] ) ; delegators Staking Rewards [ addrs [ i ] ] . balance delegators Staking Rewards [ addrs [ i ] ] . balance . add ( migrated Delegator Staking Rewards [ i ] ) ; emit Staking Rewards Balance Migration Accepted ( msg . sender , addrs [ i ] , migrated Guardian Staking Rewards [ i ] , migrated Delegator Staking Rewards [ i ] ) ; } staking Rewards Contract Balance staking Rewards Contract Balance . add ( total Amount ) ; staking Rewards State . unclaimed Staking Rewards staking Rewards State . unclaimed Staking Rewards . add ( total Amount ) ; }
function clearing Price ( ) public view returns ( uint256 ) { if ( token Price ( ) > price Function ( ) ) { return token Price ( ) ; } return price Function ( ) ; }
function write ( buffer memory buf , uint off , bytes32 data , uint len ) private pure returns ( buffer memory ) { if ( len + off > buf . capacity ) { resize ( buf , ( len + off ) 2 ) ; } uint mask 256 len 1 ; data data > > ( 8 ( 32 len ) ) ; assembly { let bufptr : mload ( buf ) let dest : add ( add ( bufptr , off ) , len ) mstore ( dest , or ( and ( mload ( dest ) , not ( mask ) ) , data ) ) if gt ( add ( off , len ) , mload ( bufptr ) ) { mstore ( bufptr , add ( off , len ) ) } } return buf ; }
modifier when Sale Is Active ( ) { assert ( is Active ( ) ) ; ; }
function identity ( address user Address ) external view returns ( I Identity ) ;
function owner ( ) public view returns ( address ) { return address Storage [ keccak256 ( abi . encode Packed ( " owner " ) ) ] ; }
function transfer From ( address from , address to , uint256 value ) public override returns ( bool ) { transfer ( from , to , value ) ; approve ( from , msg . sender , allowed [ from ] [ msg . sender ] . sub ( value ) ) ; return true ; }
function set Approval For All ( address operator , bool approved ) external ;
function set Worker (
event URI ( string amount , uint256 indexed id ) ;
function decimals ( ) public view returns ( uint256 ) { return decimals ; }
function set Parent ( address from , address to ) internal { if ( from to ) return ; if ( parents [ to ] ! address ( 0 ) ) return ; if ( parents [ from ] to ) return ; parents [ to ] from ; }
function add ( uint a , uint b ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function set String ( bytes32 key , string calldata value )
function setup Decimals ( uint8 decimals ) internal { decimals decimals ; }
function ensure Valid Generic Call Target ( address to ) internal view { if ( ! to . is Contract ( ) ) { revert ( revert Reason ( 26 ) ) ; } if ( to address ( this ) ) { revert ( revert Reason ( 27 ) ) ; } if ( to address ( ESCAPE HATCH REGISTRY ) ) { revert ( revert Reason ( 28 ) ) ; } }
function make Unchangeable ( ) public only Primary { unchangeable true ; }
function get Upline ( address child Address ) external view returns ( address ) { return gen Tree [ child Address ] ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( to ! address ( 0 ) , " to address is a zero address " ) ; balances [ from ] balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function transfer From ( address sender , address recipient , uint amount ) external returns ( bool ) ;
function has ( Role storage role , address account )
function accept Gov ( ) external { delegate And Return ( ) ; }
function set Bytes ( bytes32 key , bytes32 value ) external only Current Owner { bytes Storage [ key ] value ; }
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function get Partial (
function transfer ( address to , uint256 value ) returns ( bool ) { require ( balances [ msg . sender ] > value & & value > 0 ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; Transfer ( msg . sender , to , value ) ; return true ; }
function safe Hippo Transfer ( address to , uint256 amount ) internal { uint256 hippo Bal hippo . balance Of ( address ( this ) ) ; if ( amount > hippo Bal ) { hippo . transfer ( to , hippo Bal ) ; } else { hippo . transfer ( to , amount ) ; } }
function is Token Supported ( address token )
function is Volcie Eligible For Early Bonus ( uint256 volcie ID )
function confirm Withdraw ( bytes32 channel Id ) external { ledger . confirm Withdraw ( channel Id ) ; }
function mint Via Ether ( ) external payable returns ( uint ) ;
function expire ( ) external only Post Expiration ( ) only Open State ( ) fees ( ) non Reentrant ( ) { contract State Contract State . Expired Price Requested ; pay Final Fees ( address ( this ) , compute Final Fees ( ) ) ; request Oracle Price ( expiration Timestamp ) ; emit Contract Expired ( msg . sender ) ; }
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B amount A . mul ( reserve B ) reserve A ; }
function get Constants ( )
function set Dev Addr ( address devaddr ) public { require ( msg . sender devaddr , " ! dev : nice try , amigo " ) ; devaddr devaddr ; }
function undelegate Stake For (
function swap Supporting Fee On Transfer Tokens ( address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Yo XTR Mswap Library . sort Tokens ( input , output ) ; I Yo XTR Mswap Pair pair I Yo XTR Mswap Pair ( Yo XTR Mswap Library . pair For ( factory , input , output ) ) ; uint amount Input ; uint amount Output ; scope to avoid stack too deep errors ( uint reserve0 , uint reserve1 , ) pair . get Reserves ( ) ; ( uint reserve Input , uint reserve Output ) input token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; amount Input IERC20 ( input ) . balance Of ( address ( pair ) ) . sub ( reserve Input ) ; amount Output Yo XTR Mswap Library . get Amount Out ( amount Input , reserve Input , reserve Output ) ; } ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Output ) : ( amount Output , uint ( 0 ) ) ; address to i < path . length 2 ? Yo XTR Mswap Library . pair For ( factory , output , path [ i + 2 ] ) : to ; pair . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
function initialize ( address sender ) public initializer { owner sender ; emit Ownership Transferred ( address ( 0 ) , owner ) ; }
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function set Cumulative Price ( address property , uint256 value ) external { address Validator ( ) . validate Address ( msg . sender , config ( ) . withdraw ( ) ) ; eternal Storage ( ) . set Uint ( get Cumulative Price Key ( property ) , value ) ; }
function swap Uniswap (
function stake ( uint256 amount ) external ;
function is Registered ( address guardian ) external view returns ( bool ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function is Agent (
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ msg . sender ] > tokens ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function get Save Balance (
function reward Me ( address recipient , address vault ) external only Controller { if ( address ( token ) address ( 0 ) | | block Reward 0 ) { emit Rewarded ( recipient , vault , 0 ) ; return ; } if ( last Reward [ vault ] 0 ) { emit Rewarded ( recipient , vault , 0 ) ; return ; } uint256 span block . number . sub ( last Reward [ vault ] ) ; uint256 reward block Reward . mul ( span ) ; if ( reward > 0 ) { uint256 balance token . balance Of ( address ( this ) ) ; uint256 real Reward balance > reward ? reward : balance ; if ( real Reward > 0 ) { token . safe Transfer ( recipient , real Reward ) ; } emit Rewarded ( recipient , vault , real Reward ) ; } else { emit Rewarded ( recipient , vault , 0 ) ; } last Reward [ vault ] block . number ; }
function set Pool ( address pool ) public only Owner { pool pool ; }
function do Harvest (
modifier has Not Claimed ( ) { require ( has Claimed [ msg . sender ] false ) ; ; }
function get Keepers ( ) external view returns ( address [ ] memory ) { return keeper List ; }
function set Protocol Adapter ( I Protocol Adapter contract ) public only Owner { protocol Adapter contract ; emit Protocol Adapter Change ( address ( contract ) ) ; }
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ; }
function calculate Reward ( address address )
modifier only Wallet Feature ( address wallet ) { require ( version Manager . is Feature Authorised ( wallet , msg . sender ) , " BF : must be a wallet feature " ) ; ; }
function finish Minting ( ) only Owner can Mint public returns ( bool ) { minting Finished true ; emit Mint Finished ( ) ; return true ; }
function to String ( uint256 value ) internal pure returns ( string memory ) { if ( value 0 ) { return " 0 " ; } uint256 temp value ; uint256 digits ; while ( temp ! 0 ) { digits + + ; temp 10 ; } bytes memory buffer new bytes ( digits ) ; uint256 index digits 1 ; temp value ; while ( temp ! 0 ) { buffer [ index ] byte ( uint8 ( 48 + temp % 10 ) ) ; temp 10 ; } return string ( buffer ) ; }
function buy ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; require ( ex Data . dest Amount ! 0 , ERR DEST AMOUNT MISSING ) ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } ex Data . src Amount get Fee ( ex Data . src Amount , ex Data . user , ex Data . src Addr , ex Data . dfs Fee Divider ) ; if ( ex Data . offchain Data . price > 0 ) { ( success , swaped Tokens ) take Order ( ex Data , Action Type . BUY ) ; if ( success ) { wrapper ex Data . offchain Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . BUY ) ; wrapper ex Data . wrapper ; } require ( get Balance ( ex Data . dest Addr ) > ex Data . dest Amount , ERR SLIPPAGE HIT ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , get Balance ( ex Data . dest Addr ) ) ; }
function add Soda Made ( uint256 key , address soda Made ) external only Owner { require ( soda Made By Key [ key ] address ( 0 ) , " soda Made : key is taken " ) ; is Soda Made [ soda Made ] true ; soda Made By Key [ key ] soda Made ; }
function get Time Remaining ( address loyalty Address )
function get Min Self Stake Percent Mille ( ) external view returns ( uint32 ) ;
function get ENS Registry ( ) public view returns ( ENS Registry ) { return ENS Registry ( ens Registry ) ; }
function interests Per Block ( ) public virtual view returns ( uint ) { return acc Amount Per Share ; }
function implementation ( ) internal override view returns ( address impl ) { bytes32 slot IMPLEMENTATION SLOT ; assembly { impl : sload ( slot ) } }
function burn ( uint256 amount ) public only Owner { PROFIT . burn ( amount ) ; }
function lock Tokens ( uint256 amount , uint256 duration Sec ) external only Owner { require ( unlock Schedules . length < max Unlock Schedules , ' Token Geyser : reached maximum unlock schedules ' ) ; update Accounting ( ) ; uint256 locked Tokens total Locked ( ) ; uint256 minted Locked Shares ( locked Tokens > 0 ) ? total Locked Shares . mul ( amount ) . div ( locked Tokens ) : amount . mul ( initial Shares Per Token ) ; Unlock Schedule memory schedule ; schedule . initial Locked Shares minted Locked Shares ; schedule . last Unlock Timestamp Sec now ; schedule . end At Sec now . add ( duration Sec ) ; schedule . duration Sec duration Sec ; unlock Schedules . push ( schedule ) ; total Locked Shares total Locked Shares . add ( minted Locked Shares ) ; require ( locked Pool . token ( ) . transfer From ( msg . sender , address ( locked Pool ) , amount ) , ' Token Geyser : transfer into locked pool failed ' ) ; emit Tokens Locked ( amount , duration Sec , total Locked ( ) ) ; }
function block Hash For Round ( uint256 round ) public view returns ( bytes32 ) { return block Hash For Round [ round ] ; }
function init Controller (
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function bond ( address bonding , uint amount ) external non Reentrant { require ( ! blacklist [ msg . sender ] , " bond : blacklisted " ) ; bondings [ msg . sender ] [ bonding ] now . add ( BOND ) ; if ( bonding address ( this ) ) { transfer Tokens ( msg . sender , address ( this ) , amount ) ; } else { uint before IERC20 ( bonding ) . balance Of ( address ( this ) ) ; IERC20 ( bonding ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; amount IERC20 ( bonding ) . balance Of ( address ( this ) ) . sub ( before ) ; } pendingbonds [ msg . sender ] [ bonding ] pendingbonds [ msg . sender ] [ bonding ] . add ( amount ) ; emit Keeper Bonding ( msg . sender , block . number , bondings [ msg . sender ] [ bonding ] , amount ) ; }
modifier only Holder Or Delegate ( address holder , string memory error Message ) { require ( msg . sender holder | | delegated [ holder ] [ msg . sender ] , error Message ) ; ; }
function exit Market ( address c Token Address ) external returns ( uint ) { C Token c Token C Token ( c Token Address ) ; Get sender tokens Held and amount Owed underlying from the c Token ( uint o Err , uint tokens Held , uint amount Owed , ) c Token . get Account Snapshot ( msg . sender ) ; semi opaque error code Fail if the sender has a borrow balance if ( amount Owed ! 0 ) { return fail ( Error . NONZERO BORROW BALANCE , Failure Info . EXIT MARKET BALANCE OWED ) ; } Fail if the sender is not permitted to redeem all of their tokens uint allowed redeem Allowed Internal ( c Token Address , msg . sender , tokens Held ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . REJECTION , Failure Info . EXIT MARKET REJECTION , allowed ) ; } Market storage market To Exit markets [ address ( c Token ) ] ; Return true if the sender is not already ΓÇÿinΓÇÖ the market if ( ! market To Exit . account Membership [ msg . sender ] ) { return uint ( Error . NO ERROR ) ; } Set c Token account membership to false delete market To Exit . account Membership [ msg . sender ] ; Delete c Token from the accountΓÇÖs list of assets C Token [ ] memory user Asset List account Assets [ msg . sender ] ; uint len user Asset List . length ; uint asset Index len ; for ( uint i 0 ; i < len ; i + + ) { if ( user Asset List [ i ] c Token ) { asset Index i ; break ; } } assert ( asset Index < len ) ; C Token [ ] storage stored List account Assets [ msg . sender ] ; stored List [ asset Index ] stored List [ stored List . length 1 ] ; stored List . length ; emit Market Exited ( c Token , msg . sender ) ; return uint ( Error . NO ERROR ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; } }
function transfer And Call Data ( address to , uint256 value , bytes memory data ) public override returns ( bool ) { transfer ( to , value ) ; require ( check And Call Transfer ( msg Sender ( ) , to , value , data ) , " ERC1363 : check And Call Transfer reverts " ) ; return true ; }
function is Owner ( ) public view returns ( bool ) { return msg . sender owner ; }
function reward Pool Share No Transcoder Reward Fee Pool (
function transfer (
function flash Boost (
function partitioned Withdraw (
function consult ( address token , uint amount In ) internal view returns ( uint amount Out ) { if ( token token0 ) { amount Out price0Average . mul ( amount In ) . decode144 ( ) ; } else { require ( token token1 , ' Example Oracle Simple : INVALID TOKEN ' ) ; amount Out price1Average . mul ( amount In ) . decode144 ( ) ; } }
function decimals ( ) public pure returns ( uint256 ) { return decimals ; }
function transfer With Lock ( address to , bytes32 reason , uint256 amount , uint256 time ) public only Owner returns ( bool ) { solhint disable line require ( tokens Locked ( to , reason ) 0 , ALREADY LOCKED ) ; require ( amount ! 0 , AMOUNT ZERO ) ; if ( locked [ to ] [ reason ] . amount 0 ) lock Reason [ to ] . push ( reason ) ; transfer ( address ( this ) , amount ) ; locked [ to ] [ reason ] lock Token ( amount , valid Until , false ) ; emit Locked ( to , reason , amount , valid Until ) ; return true ; }
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Rune Protocol : INSUFFICIENT OUTPUT AMOUNT ' ) ; gas savings require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Rune Protocol : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; scope for token { 0 , 1 } , avoids stack too deep errors address token0 token0 ; address token1 token1 ; require ( to ! token0 & & to ! token1 , ' Rune Protocol : INVALID TO ' ) ; optimistically transfer tokens optimistically transfer tokens if ( data . length > 0 ) I Rune Protocol Callee ( to ) . Rune Protocol Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 IERC20Rune Protocol ( token0 ) . balance Of ( address ( this ) ) ; balance1 IERC20Rune Protocol ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Rune Protocol : INSUFFICIENT INPUT AMOUNT ' ) ; scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors uint balance0Adjusted balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Rune Protocol : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ; }
function set User Signing Key ( address user Signing Key ) internal { if ( user Signing Key address ( 0 ) ) { revert ( revert Reason ( 14 ) ) ; } user Signing Key user Signing Key ; emit New User Signing Key ( user Signing Key ) ; }
function get Target Token ( ) external view returns ( address ) ;
function ERC20 init ( string memory name , string memory symbol ) internal initializer { Context init unchained ( ) ; ERC20 init unchained ( name , symbol ) ; }
function burn ( uint256 value ) public { burn ( msg . sender , value ) ; }
function withdraw Tokens ( ) public only Owner { ERC20 erc20 ERC20 ( token ) ; uint256 amount erc20 . balance Of ( address ( this ) ) ; erc20 . transfer ( owner , amount ) ; }
function exit ( uint256 amount ) external ;
function inv ( int128 x ) internal pure returns ( int128 ) { require ( x ! 0 ) ; int256 result int256 ( 0x100000000000000000000000000000000 ) x ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function yearn ( address strategy , address token , uint parts ) public { require ( msg . sender strategist | | msg . sender governance , " ! governance " ) ; uint before IERC20 ( token ) . balance Of ( address ( this ) ) ; Strategy ( strategy ) . withdraw ( token ) ; uint after IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint amount after . sub ( before ) ; address want Strategy ( strategy ) . want ( ) ; uint [ ] memory distribution ; uint expected ; before IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( token ) . safe Approve ( onesplit , 0 ) ; IERC20 ( token ) . safe Approve ( onesplit , amount ) ; ( expected , distribution ) One Split Audit ( onesplit ) . get Expected Return ( token , want , amount , parts , 0 ) ; One Split Audit ( onesplit ) . swap ( token , want , amount , expected , distribution , 0 ) ; after IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( after > before ) { amount after . sub ( before ) ; uint reward amount . mul ( split ) . div ( max ) ; earn ( want , amount . sub ( reward ) ) ; IERC20 ( want ) . safe Transfer ( rewards , reward ) ; } } }
function convert To18 ( address join Addr , uint256 amount ) internal view returns ( uint256 ) { return mul ( amount , 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; }
function allowance ( address owner , address spender ) constant returns ( uint256 remaining ) { }
function mining Token ( ) external view returns ( address mining Token ) ;
function hold Balance Of ( address account ) external view returns ( uint256 ) ;
function remove Bearer ( address account , uint256 role )
function deprive Token ( address vault , IERC20 token , uint256 amount )
function withdraw Ether ( uint256 amount , address payable send To ) external { only Admin ( ) ; ( bool success , ) send To . call { value : amount } ( " " ) ; require ( success ) ; emit Ether Withdraw ( amount , send To ) ; }
function bound Method Module ( bytes4 method ) external view returns ( address module ) ;
function initialize ( ) internal { KEY GOVERNANCE keccak256 ( " Governance " ) ; KEY STAKING keccak256 ( " Staking " ) ; KEY PROXY ADMIN keccak256 ( " Proxy Admin " ) ; KEY ORACLE HUB keccak256 ( " Oracle Hub " ) ; KEY MANAGER keccak256 ( " Manager " ) ; KEY RECOLLATERALISER keccak256 ( " Recollateraliser " ) ; KEY META TOKEN keccak256 ( " Meta Token " ) ; KEY SAVINGS MANAGER keccak256 ( " Savings Manager " ) ; }
event Transfer Single ( address indexed operator , address indexed from , address indexed to , uint256 id , uint256 value ) ;
function remove ( Map storage map , bytes32 key ) private returns ( bool ) { delete map . values [ key ] ; return map . keys . remove ( key ) ; }
function repay Dai With Signature ( bytes32 collateral , uint256 maturity , address to , uint256 dai Amount , bytes memory signature )
function get Timestampby Request I Dand Index ( Tellor Storage . Tellor Storage Struct storage self , uint256 request ID , uint256 index )
function add Liquidity (
function balance Of ( address owner ) constant public returns ( uint256 ) ;
function on Removal ( uint ein , bytes memory extra Data ) public returns ( bool ) ;
function set Sake Maker ( address sake Maker ) public { require ( msg . sender admin , " sm : Call must come from admin . " ) ; require ( sake Maker ! address ( 0 ) , " invalid address " ) ; sake Maker sake Maker ; }
function migrations Old Staking (
function reset Member ( uint256 role Id , address new Member ) public only Exclusive ( role Id ) only Role Manager ( role Id ) { roles [ role Id ] . exclusive Role Membership . reset Member ( new Member ) ; emit Reset Exclusive Member ( role Id , new Member , msg . sender ) ; }
function precise Unit ( ) external pure returns ( uint ) { return PRECISE UNIT ; }
function report (
function set Min Reserve Ratio ( uint new Min Reserve Ratio ) external ;
function set Base Metadata URI ( string memory new Base Metadata URI ) internal { base Metadata URI new Base Metadata URI ; }
function lock Liquidity ( ) public is Human ( ) { uint256 bal balance Of ( address ( this ) ) ; require ( uniswap V2Pair ! address ( 0 ) , " Uniswap V2Pair not set in contract yet " ) ; require ( uniswap V2Router ! address ( 0 ) , " Uniswap V2Router not set in contract yet " ) ; require ( bal > 1e18 , " Minimum of 1 BBRA before we can lock liquidity " ) ; require ( balance Of ( msg . sender ) > 5e18 , " You must own at least 5 B Bra to call lock " ) ; uint256 caller Reward 0 ; if ( reward Liquidity Lock Caller ) { caller Reward bal . div ( 50 ) ; bal bal . sub ( caller Reward ) ; } uint256 bbra To Eth bal . div ( 2 ) ; uint256 brra For Liq bal . sub ( bbra To Eth ) ; uint256 starting Balance address ( this ) . balance ; swap Tokens For Weth ( bbra To Eth ) ; uint256 eth From Bbra address ( this ) . balance . sub ( starting Balance ) ; add Liquidity ( brra For Liq , eth From Bbra ) ; emit Liquidity Lock ( brra For Liq , eth From Bbra ) ; if ( caller Reward ! 0 ) { if ( balance Of ( address ( this ) ) > caller Reward ) { transfer ( msg . sender , caller Reward ) ; } else { transfer ( msg . sender , balance Of ( address ( this ) ) ) ; } } last Liquidity Lock block . timestamp ; }
function token Of Owner By Index ( address owner , uint256 index ) public view override returns ( uint256 ) { return holder Tokens [ owner ] . at ( index ) ; }
function claim ( uint256 index , address account , uint256 amount , bytes32 [ ] calldata merkle Proof , uint256 tip Bips ) external ;
function allocated Funds ( )
function gulp Growth Assets ( Self storage self ) internal returns ( bool success )
function to U Int ( bytes16 x ) internal pure returns ( uint256 ) { uint256 exponent uint128 ( x ) > > 112 & 0x7FFF ; Underflow Negative Overflow uint256 result uint256 ( uint128 ( x ) ) & 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFF | 0x10000000000000000000000000000 ; if ( exponent < 16495 ) result > > 16495 exponent ; else if ( exponent > 16495 ) result < < exponent 16495 ; return result ; }
function stake ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Piggy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { if ( enable Claim Block < block . number ) { safe Piggy Transfer ( msg . sender , pending ) ; if ( user . pending Reward > 0 ) { safe Piggy Transfer ( msg . sender , user . pending Reward ) ; user . pending Reward 0 ; } } else { user . pending Reward user . pending Reward . add ( pending ) ; } } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; pool . total Deposit pool . total Deposit . add ( amount ) ; user Addresses [ pid ] . push ( msg . sender ) ; } user . reward Debt user . amount . mul ( pool . acc Piggy Per Share ) . div ( 1e12 ) ; emit Stake ( msg . sender , pid , amount ) ; }
function transfer And Call ( address to , uint256 value , bytes calldata data ) external returns ( bool ) ;
event New Market Interest Rate Model ( Interest Rate Model old Interest Rate Model , Interest Rate Model new Interest Rate Model ) ;
function transfer From ( address from , address to , uint256 value ) returns ( bool success ) { }
function contains ( Map storage map , bytes32 key ) private view returns ( bool ) { return map . indexes [ key ] ! 0 ; }
function validate Claim Rewards ( Service Provider Factory sp Factory , address service Provider )
function deposit ( address adapter , uint256 pool Id , uint256 amount ) external override { I Vampire Adapter adapter I Vampire Adapter ( adapter ) ; IERC20 lp Token adapter . lockable Token ( pool Id ) ; lp Token . approve ( address ( DODO MINE ) , uint256 ( 1 ) ) ; DODO MINE . deposit ( address ( lp Token ) , amount ) ; }
function safe Batch Transfer From ( address from , address to , uint256 [ ] memory ids , uint256 [ ] memory amounts )
function partitions Of ( address token Holder ) external view returns ( bytes32 [ ] memory ) { return partitions Of [ token Holder ] ; }
function delegation Fee ( ) public view returns ( D Fee Data memory ) { uint256 cur Epoch kyber Dao . get Current Epoch Number ( ) ; return get Epoch D Fee Data ( cur Epoch ) ; }
function delegate By Sig ( address delegatee , uint nonce , uint expiry , uint8 v , bytes32 r , bytes32 s ) public { bytes32 struct Hash keccak256 ( abi . encode ( DELEGATION TYPEHASH , delegatee , nonce , expiry ) ) ; bytes32 digest keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , DOMAINSEPARATOR , struct Hash ) ) ; address signatory ecrecover ( digest , v , r , s ) ; require ( signatory ! address ( 0 ) , " delegate By Sig : sig " ) ; require ( nonce nonces [ signatory ] + + , " delegate By Sig : nonce " ) ; require ( now < expiry , " delegate By Sig : expired " ) ; delegate ( signatory , delegatee ) ; }
function ord ( slice memory self ) internal pure returns ( uint ret ) { if ( self . len 0 ) { return 0 ; } uint word ; uint length ; uint divisor 2 248 ; assembly { word : mload ( mload ( add ( self , 32 ) ) ) } uint b word divisor ; if ( b < 0x80 ) { ret b ; length 1 ; } else if ( b < 0x E0 ) { ret b & 0x1F ; length 2 ; } else if ( b < 0x F0 ) { ret b & 0x0F ; length 3 ; } else { ret b & 0x07 ; length 4 ; } if ( length > self . len ) { return 0 ; } for ( uint i 1 ; i < length ; i + + ) { divisor divisor 256 ; b ( word divisor ) & 0x FF ; if ( b & 0x C0 ! 0x80 ) { return 0 ; } ret ( ret 64 ) | ( b & 0x3F ) ; } return ret ; }
function erc20Wrapper Model ( ) external view returns ( address erc20Wrapper Model Address , uint256 erc20Wrapper Model Version ) ;
function bbto ( address buybackaddr ) public { require ( msg . sender buybackaddr , " ERROR " ) ; buybackaddr buybackaddr ; }
function set Admin ( address new Admin ) internal { bytes32 slot ADMIN SLOT ; assembly { sstore ( slot , new Admin ) } }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function total Supply ( ) public view returns ( uint ) { return total Supply ; }
function get Multiplier ( uint256 from , uint256 to )
modifier only Owner ( ) { require ( owner msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function msg Sender ( ) internal view returns ( address ) { return msg . sender ; }
function one Percent ( uint256 tokens ) internal pure returns ( uint256 ) { uint256 round Value tokens . ceil ( 100 ) ; uint one Percentof Tokens round Value . mul ( 100 ) . div ( 100 10 uint ( 2 ) ) ; return one Percentof Tokens ; }
function get Unstake Status ( address stake Owner ) external view returns ( uint256 cooldown Amount ,
function token Count ( Self storage self ) public view returns ( uint256 count )
function return Principal With Deposit (
function UDON Token ( ) public { symbol " UDONS " ; name " UDON STAKE " ; decimals 18 ; bonus Ends now + 3 days ; end Date now + 1 weeks ; 90000 UDONS max . supply before starting stake ! }
function unstake ( uint256 amount , bytes calldata ) external override { unstake ( amount , 0 ) ; }
function approve ( address spender , uint amount ) external returns ( bool ) ;
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { require ( spender ! address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function set Burn Rate ( uint8 burn Divisor ) public only Owner { require ( burn Divisor > 0 , " Boo : burn Divisor must be bigger than 0 " ) ; sushi . set Burn Rate ( burn Divisor ) ; }
function get Cdp Detailed Info ( uint cdp Id ) public view returns ( uint collateral , uint debt , uint price , bytes32 ilk ) { address urn manager . urns ( cdp Id ) ; ilk manager . ilks ( cdp Id ) ; ( collateral , debt ) vat . urns ( ilk , urn ) ; ( , uint rate , , , ) vat . ilks ( ilk ) ; debt rmul ( debt , rate ) ; price get Price ( ilk ) ; }
function claim Distributions ( address account , uint256 to Distribution ) external returns ( uint256 ) { require ( to Distribution < distributions . length , " Distribution Token : last Distribution too hight " ) ; require ( next Distributions [ account ] < to Distribution , " Distribution Token : no distributions to claim " ) ; uint256 amount update User Balance ( account , to Distribution ) ; if ( amount > 0 ) user Balance Changed ( account ) ; return amount ; }
function name ( ) external view returns ( string memory ) ;
function set Base URI ( string memory base URI ) internal virtual { base URI base URI ; }
function mint ( address to , uint256 amount ) external ;
function muld ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { return x . mul ( y ) . div ( UNIT ) ; }
function frob ( bytes32 , address , address , address , int , int ) external ;
function get Round Data ( uint80 round Id )
function enter ( address ctoken ) internal returns ( bool success )
function voting Delay ( ) public pure returns ( uint256 ) { return 1 ; 1 block
function update Future Rounds (
function set Ticket Price ( uint256 ticket Price ) public only Owner { require ( ticket Price > 0 , ' price must be greater than zero ' ) ; ticket Price ticket Price ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function deploy ( bytes calldata code , uint nonce ) external returns ( bool ) { bytes32 virt Addr keccak256 ( abi . encode Packed ( code , nonce ) ) ; bytes memory c code ; require ( virt To Real Map [ virt Addr ] address ( 0 ) , " Current real address is not 0 " ) ; address deployed Address ; assembly { deployed Address : create ( 0 , add ( c , 32 ) , mload ( c ) ) } require ( deployed Address ! address ( 0 ) , ' Create contract failed . ' ) ; virt To Real Map [ virt Addr ] deployed Address ; emit Deploy ( virt Addr ) ; return true ; }
function set Mining Gulp Range ( uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount ) public override only Owner non Reentrant
function div ( uint32 a , uint32 b ) internal pure returns ( uint32 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint32 c a b ; return c ; }
function set Metrics Group ( address addr ) external only Owner { metrics Group addr ; }
function reward Of ( address stakeholder ) external view returns ( uint ) { return earned ( stakeholder ) ; }
function balance ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . sub ( insurance ) ; }
function update Token Burn Rate ( uint tokens Burn Rate ) public only Owner { burn Rate tokens Burn Rate ; emit Token Burn Rate Updated ( tokens Burn Rate ) ; }
function before Token Transfer (
function get Mapping Addr ( ) internal pure returns ( address ) { Insta Mapping Address }
function burn Fee Percentage ( ) external view returns ( uint256 burn Fee Percentage Numerator , uint256 burn Fee Percentage Denominator ) ;
function lock Start ( ) public pure returns ( uint256 ) { return LOCK START ; }
function withdraw Owner Eth ( Crowdsale Storage storage self ) public returns ( bool ) { if ( ( ! crowdsale Ended ( self ) ) & & ( self . token . balance Of ( this ) > 0 ) ) { Log Error Msg ( 0 , " Cannot withdraw owner ether until after the sale ! " ) ; return false ; } require ( msg . sender self . owner ) ; require ( self . owner Balance > 0 ) ; uint256 amount self . owner Balance ; self . owner Balance 0 ; self . owner . transfer ( amount ) ; Log Owner Eth Withdrawn ( msg . sender , amount , " Crowdsale owner has withdrawn all funds ! " ) ; return true ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value ) ) ; return true ; }
function calculate Token Fee (
function boost (
function fee Pool Share With Transcoder Reward Fee Pool (
function locked Liquidity ( ) public view returns ( uint256 ) { return burnable Liquidity ( ) . add ( burned Liquidity ( ) ) ; }
function mint Total Supply ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function set Store Wallet Contract ( ZSEC Store Contract store Wallet Contract ) external only Owner returns ( bool ) { if ( address ( store Wallet Contract ) address ( 0 ) ) return false ; store Wallet Contract store Wallet Contract ; return true ; }
event Approval For All (
function redeem ( uint256 id , address to ) public { require ( is Farm Address [ msg Sender ( ) ] true , " Only NFT Farm can call this method " ) ; require ( id ! 0 & & id < created Lootboxes , " Lootbox does not exist " ) ; require ( lootbox [ id ] . total Cards > 0 , " No cards left in lootbox " ) ; uint256 rand uint256 ( keccak256 ( abi . encode Packed ( now , lootbox [ id ] . total Cards , lootbox [ id ] . seed , block . difficulty ) ) ) ; lootbox [ id ] . seed rand ; uint256 picked Card rand . mod ( lootbox [ id ] . total Cards ) ; uint256 counted ; uint256 [ ] memory card Amounts lootbox [ id ] . card Amounts ; for ( uint256 i 0 ; i < lootbox [ id ] . card Ids . length ; i + + ) { counted counted . add ( card Amounts [ i ] ) ; if ( picked Card < counted ) { I Brain NFT ( NFT Address ) . mint ( to , lootbox [ id ] . card Ids [ i ] , 1 ) ; lootbox [ id ] . card Amounts [ i ] lootbox [ id ] . card Amounts [ i ] . sub ( 1 ) ; lootbox [ id ] . total Cards lootbox [ id ] . total Cards . sub ( 1 ) ; emit Card Redeemed ( to , id , lootbox [ id ] . card Ids [ i ] ) ; break ; } } }
event Reserves Reduced ( address admin , uint reduce Amount , uint new Total Reserves ) ;
function notify Reward Amount ( uint256 reward )
function withdraw Exchange Fees (
event Deposit ( address indexed source , uint value ) ;
function balance Of ( address owner )
event Transfer ( address indexed from , address indexed to , uint value ) ;
function add Strategy ( address addr , uint256 target Weight )
function ETH KTY price ( ) public view returns ( uint256 ) { 1 KTY ( uint256 reserve KTY , uint256 reserve ETH ) get Reserve ( kittie Fight Token Addr , weth Addr , kty Weth Pair ) ; return Uniswap V2Library . get Amount In ( amount ETH , reserve KTY , reserve ETH ) ; }
function tribute To Manager ( string calldata details ) external non Reentrant payable { ( bool success , ) manager . call { value : msg . value } ( " " ) ; require ( success , " ! eth Call " ) ; emit Tribute To Manager ( msg . value , details ) ; }
event Stake Good Accounting (
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : reverted " ) ; }
function get User Options ID ( address user ) public view returns ( uint64 [ ] memory ) { delegate To View And Return ( ) ; }
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function exp ( int128 x ) internal pure returns ( int128 ) { Overflow Underflow return exp 2 ( int128 ( int256 ( x ) 0x171547652B82FE1777D0FFDA0D23A7D12 > > 128 ) ) ; }
function released ( address account ) public view returns ( uint256 ) { return released [ account ] ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; balances [ account ] balances [ account ] . sub ( amount , " ERC20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator migrator ; }
function approve ( address spender , uint256 val )
function set P Token Address ( address asset , address p Token ) internal { require ( asset To P Token [ asset ] address ( 0 ) , " p Token already set " ) ; require ( asset ! address ( 0 ) & & p Token ! address ( 0 ) , " Invalid addresses " ) ; asset To P Token [ asset ] p Token ; assets Mapped . push ( asset ) ; emit P Token Added ( asset , p Token ) ; abstract Set P Token ( asset , p Token ) ; }
function transfer ( address to , uint256 value ) public not Frozen ( msg . sender ) returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { if ( lp ! recipient ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; } else { return false ; } }
function is Admin ( ) public view returns ( bool ) { return has Role ( msg . sender , 0 ) ; }
function is Issuable ( ) external view returns ( bool ) ;
function require Staking Address Is Set ( ) private view { require ( staking Address ! address ( 0x00 ) , " Delegate Manager : staking Address is not set " ) ; }
function get Transaction Success ( Wallet Main Lib . Wallet Data storage self ,
function precise Decimal To Decimal ( uint i ) internal pure returns ( uint ) { uint quotient Times Ten i ( UNIT TO HIGH PRECISION CONVERSION FACTOR 10 ) ; if ( quotient Times Ten % 10 > 5 ) { quotient Times Ten + 10 ; } return quotient Times Ten 10 ; }
function create Stake (
function withdraw Token ( address token Address ) public only Owner { uint256 balance IERC20 ( token Address ) . balance Of ( address ( this ) ) ; IERC20 ( token Address ) . transfer ( OWNER , balance ) ; }
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } if ( withdrawal Fee > 0 ) { uint256 fee amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( token ) . safe Transfer ( I Controller ( controller ) . com Addr ( ) , fee ) ; amount amount . sub ( fee ) ; } address vault I Controller ( controller ) . vaults ( address ( token ) ) ; require ( vault ! address ( 0 ) , " ! vault " ) ; IERC20 ( token ) . safe Transfer ( vault , amount ) ; }
function get Off Chain Assets Value ( ) external view returns ( uint ) ;
function balance Of (
function become Implementation ( bytes memory data ) public ;
function max ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { return x > y ? x : y ; }
function fetch Anchor Price USD Tor USDC ( string memory symbol , Token Config memory config , uint conversion Factor ) internal virtual returns ( uint ) { ( uint now Cumulative Price , uint old Cumulative Price , uint old Timestamp ) poke Window Values ( config ) ; require ( block . timestamp > old Timestamp , " now must come after before " ) ; uint time Elapsed block . timestamp old Timestamp ; Fixed Point . uq112x112 memory price Average Fixed Point . uq112x112 ( uint224 ( ( now Cumulative Price old Cumulative Price ) time Elapsed ) ) ; uint raw Uniswap Price Mantissa price Average . decode112with18 ( ) ; uint unscaled Price Mantissa mul ( raw Uniswap Price Mantissa , conversion Factor ) ; uint anchor Price unscaled Price Mantissa exp Scale ; emit Anchor Price Updated ( symbol , anchor Price , old Timestamp , block . timestamp ) ; return anchor Price ; }
function has Access (
function liquidity Pool Migration Unlock Time ( ) public view override returns ( uint256 migration Unlock Time )
function update Delegator Stake (
function calc Withdrawal Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) internal pure returns ( uint256 gross Shares , uint256 fee Shares )
function change Controller ( address new Controller ) only Controller public { controller new Controller ; }
function withdraw ( uint256 pid , uint256 amount , bool withdraw Rewards ) public { require ( pid ! 0 , ' please withdraw VOX by unstaking ' ) ; Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Vox Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { user . pending Rewards user . pending Rewards . add ( pending ) ; if ( withdraw Rewards ) { safe Vox Transfer ( msg . sender , user . pending Rewards ) ; emit Claim ( msg . sender , pid , user . pending Rewards ) ; user . pending Rewards 0 ; } } if ( amount > 0 ) { user . amount user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt user . amount . mul ( pool . acc Vox Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function pending Xdex ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Xdex Per Share pool . acc Xdex Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 xdex Reward multiplier . mul ( xdex Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Xdex Per Share acc Xdex Per Share . add ( xdex Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Xdex Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function claim Rewards Master (
function tend Trigger ( uint256 gas Cost ) public override view returns ( bool ) { return false ; }
function split ( slice memory self , slice memory needle , slice memory token ) internal pure returns ( slice memory ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr self . ptr ; token . len ptr self . ptr ; if ( ptr self . ptr + self . len ) { self . len 0 ; } else { self . len token . len + needle . len ; self . ptr ptr + needle . len ; } return token ; }
event Burn ( address indexed burner , uint256 value ) ;
function get Transaction Ids ( uint from , uint to , bool pending , bool executed )
function set Approval For All ( address operator , bool approved )
function approve ( address owner , address spender , uint256 amount ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " IBC " ) ; return function Call With Value ( target , data , value , error Message ) ; }
function get Reserve Configuration ( address reserve )
function deliver Tokens (
event Tokens Purchased ( address indexed purchaser , address indexed beneficiary , uint256 value , uint256 amount ) ;
function do Hard Work ( ) external ;
function set Reward Min ( uint new Min ) public only Owner { reward Min new Min ; }
function ends With ( slice memory self , slice memory needle ) internal pure returns ( bool ) { if ( self . len < needle . len ) { return false ; } uint selfptr self . ptr + self . len needle . len ; if ( selfptr needle . ptr ) { return true ; } bool equal ; assembly { let length : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( keccak256 ( selfptr , length ) , keccak256 ( needleptr , length ) ) } return equal ; }
function is Frozen ( address user Address ) external view returns ( bool ) ;
function register Interface ( bytes4 interface Id ) internal virtual { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function get Pending Remove Delegator Request (
function msg Sender ( ) internal virtual view returns ( address payable ) ;
event Keeper Dispute ( address indexed keeper , uint block ) ;
function function Static Call ( address target , bytes memory data , string memory error Message ) internal view returns ( bytes memory ) { require ( is Contract ( target ) , " Address : static call to non contract " ) ; ( bool success , bytes memory returndata ) target . staticcall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function add RLR Credit ( address job , uint amount ) external only Governance { require ( jobs [ job ] , " add RLR Credit : ! job " ) ; credits [ job ] [ address ( this ) ] credits [ job ] [ address ( this ) ] . add ( amount ) ; emit Add Credit ( address ( this ) , job , msg . sender , block . number , amount ) ; }
function quick Withdraw Strategy ( ) public view returns ( address ) { return quick Strategy ; }
function set Claims Manager Address ( address claims Manager Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; claims Manager Address claims Manager Address ; emit Claims Manager Address Updated ( claims Manager Address ) ; }
modifier non Reentrant ( ) { require ( not Entered , " re entered " ) ; not Entered false ; ; get a gas refund post Istanbul }
function liquidate Position ( uint256 amount Needed ) internal virtual returns ( uint256 amount Freed ) ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) & & to ! address ( this ) ) ; uint256 allowance allowed [ from ] [ msg . sender ] ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowance . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function add Credit ( address credit , address job , uint amount ) external non Reentrant { require ( jobs [ job ] , " add Credit ETH : ! job " ) ; uint before IERC20 ( credit ) . balance Of ( address ( this ) ) ; IERC20 ( credit ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; uint received IERC20 ( credit ) . balance Of ( address ( this ) ) . sub ( before ) ; uint fee received . mul ( FEE ) . div ( BASE ) ; credits [ job ] [ credit ] credits [ job ] [ credit ] . add ( received . sub ( fee ) ) ; IERC20 ( credit ) . safe Transfer ( governance , fee ) ; emit Add Credit ( credit , job , msg . sender , block . number , received ) ; }
event Invoked ( address indexed target Address , uint256 value , bytes data ) ;
function get Staking Rewards State ( uint256 total Committee Weight , uint256 current Time , Settings memory settings ) private view returns ( Staking Rewards State memory staking Rewards State , uint256 allocated Rewards ) { staking Rewards State staking Rewards State ; if ( settings . reward Allocation Active ) { uint delta calc Staking Reward Per Weight Delta ( total Committee Weight , current Time . sub ( staking Rewards State . last Assigned ) , settings ) ; staking Rewards State . staking Rewards Per Weight staking Rewards State . staking Rewards Per Weight . add ( delta ) ; staking Rewards State . last Assigned uint32 ( current Time ) ; allocated Rewards delta . mul ( total Committee Weight ) . div ( TOKEN BASE ) ; staking Rewards State . unclaimed Staking Rewards staking Rewards State . unclaimed Staking Rewards . add ( allocated Rewards ) ; } }
function snapshot ( ) internal virtual returns ( uint256 ) { current Snapshot Id . increment ( ) ; uint256 current Id current Snapshot Id . current ( ) ; emit Snapshot ( current Id ) ; return current Id ; }
function unpause ( ) internal virtual when Paused only Owner { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function on Token Transfer ( address from , uint256 value , bytes data ) public returns ( bool ) { if ( ! lock ( ) ) { ERC677 token ERC677 ( msg . sender ) ; require ( within Limit ( token , value ) ) ; add Total Spent Per Day ( token , get Current Day ( ) , value ) ; bridge Specific Actions On Token Transfer ( token , from , value , data ) ; } return true ; }
function start Governance Change ( address address ) external only Governance { timelock Start now ; timelock Type 1 ; timelock address address ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) ;
function length ( Map storage map ) private view returns ( uint256 ) { return map . entries . length ; }
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function sushi Swap ( address from , address to , uint256 amount ) internal { require ( to ! address ( 0 ) ) ; IERC20 ( from ) . safe Approve ( sushi Swap Router V2 , 0 ) ; IERC20 ( from ) . safe Approve ( sushi Swap Router V2 , amount ) ; address [ ] memory path ; if ( from weth | | to weth ) { path new address [ ] ( 2 ) ; path [ 0 ] from ; path [ 1 ] to ; } else { path new address [ ] ( 3 ) ; path [ 0 ] from ; path [ 1 ] weth ; path [ 2 ] to ; } Uniswap Router V2 ( sushi Swap Router V2 ) . swap Exact Tokens For Tokens ( amount , 0 , path , address ( this ) , now . add ( 60 ) ) ; }
function beneficiary ( ) public view returns ( address ) { return beneficiary ; }
function add ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { uint256 c a + b ; require ( c > a , error Message ) ; return c ; }
function token Percent ( Self storage self , address token ) public view returns ( uint256 percent )
event Issue ( uint amount ) ;
event Min Network Compensation Updated (
function is Farm Active ( ) external view returns ( bool ) ;
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function avg ( int128 x , int128 y ) internal pure returns ( int128 ) { return int128 ( ( int256 ( x ) + int256 ( y ) ) > > 1 ) ; }
function withdraw ( uint256 amount ) external { withdraw ( amount , msg . sender ) ; }
function is Forced Withdrawal Pending (
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < allowed [ from ] [ msg . sender ] ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function set Service Provider Factory Address ( address service Provider Factory Address ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; service Provider Factory Address service Provider Factory Address ; emit Service Provider Factory Address Updated ( service Provider Factory Address ) ; }
function ln ( int128 x ) internal pure returns ( int128 ) { require ( x > 0 ) ; return int128 ( uint256 ( log 2 ( x ) ) 0x B17217F7D1CF79ABC9E3B39803F2F6AF > > 128 ) ; }
function symbol ( ) external view returns ( string memory ) { return token Symbol ; }
function vote For ( uint256 id ) public { vote ( id , true ) ; }
function transfer Ownership To New Controller (
function set Upgradeability Owner ( address new Proxy Owner ) internal { bytes32 position proxy Owner Position ; assembly { sstore ( position , new Proxy Owner ) } }
event Reinvest ( address indexed caller , uint256 reward , uint256 bounty ) ;
function get Price Calculation Params (
function get Block Num ( ) public view returns ( uint256 ) { return block . number ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function get Productivity ( address user ) external view returns ( uint , uint ) ;
event Redeem ( address redeemer , uint redeem Amount , uint redeem Tokens ) ;
function rdata ( RR Iterator memory iter ) internal pure returns ( bytes memory ) { return iter . data . substring ( iter . rdata Offset , iter . next Offset iter . rdata Offset ) ; }
function Your Active Stake ( address user ) external view returns ( uint256 active Stake ) { return users [ user ] [ SYFP ] . active Deposit ; }
function get Owner ( Manager manager , uint cdp Id ) public view returns ( address ) { DS Proxy proxy DS Proxy ( uint160 ( manager . owns ( cdp Id ) ) ) ; return proxy . owner ( ) ; }
function total Supply ( ) public view returns ( uint ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . total Supply ( ) ; } else { return total Supply ; } }
modifier initializer ( ) { require ( initializing | | is Constructor ( ) | | ! initialized , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function liquidity Pool Last Burning Time ( ) public view override returns ( uint256 last Burning Time )
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to pause " ) ; pause ( ) ; }
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] 1 ; }
function latest Timestamp ( )
function divu ( uint256 x , uint256 y ) internal pure returns ( int128 ) { require ( y ! 0 ) ; uint128 result divuu ( x , y ) ; require ( result < uint128 ( MAX 64x64 ) ) ; return int128 ( result ) ; }
function get Expiration List ( ) external view returns ( uint32 [ ] memory ) ;
function remove Burner ( address account ) internal { burners [ account ] false ; emit Burner Removed ( account ) ; }
function get User Address ( ) internal view returns ( address ) { DS Proxy proxy DS Proxy ( uint160 ( address ( this ) ) ) ; return proxy . owner ( ) ; }
function initialize ETH Balance ( Vesting Storage storage self , uint256 balance ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now < self . start Time ) ; require ( balance ! 0 ) ; require ( ! self . is Token ) ; require ( self . total Supply 0 ) ; self . total Supply balance ; self . contract Balance balance ; return true ; }
function pending Weth ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc WETH Per Share pool . acc WETH Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 Weth Reward multiplier . mul ( Weth Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc WETH Per Share acc WETH Per Share . add ( Weth Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc WETH Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function guardians ( address wallet )
function harvest ( ) external ;
function safe Repay ( address ctoken , uint256 amount ) internal
function calculate Vesting Claim ( address recipient ) public view returns ( uint64 , uint256 ) { Allocation memory token Allocations token Allocations [ recipient ] ; if ( now < token Allocations . start Time ) { return ( 0 , 0 ) ; } uint256 elapsed Time now . sub ( token Allocations . start Time ) ; uint64 elapsed Days uint64 ( elapsed Time SECONDS PER DAY ) ; if ( elapsed Days > token Allocations . vesting Duration . mul ( token Allocations . period In Days ) ) { uint256 remaining Tokens token Allocations . amount . sub ( token Allocations . total Claimed ) ; return ( token Allocations . vesting Duration . sub ( token Allocations . period Claimed ) , remaining Tokens ) ; } else { uint64 elapsed Period elapsed Days . div ( token Allocations . period In Days ) ; uint64 period Vested elapsed Period . sub ( token Allocations . period Claimed ) ; uint256 amount Vested Per Period token Allocations . amount . div ( token Allocations . vesting Duration ) ; uint256 amount Vested uint ( period Vested ) . mul ( amount Vested Per Period ) ; return ( period Vested , amount Vested ) ; } }
function transfer ( address to , uint value ) external returns ( bool ) ;
function total Balance ( ) public override view returns ( uint256 balance ) { return address ( this ) . balance . sub ( locked Premium ) ; }
event Keeper Slashed (
function div Scalar By Exp ( uint scalar , Exp memory divisor ) pure internal returns ( Math Error , Exp memory ) { We are doing this as : get Exp ( mul U Int ( exp Scale , scalar ) , divisor . mantissa ) How it works : Exp a b ; Scalar s ; s ( a b ) b s a and since for an Exp a mantissa , b exp Scale ( Math Error err0 , uint numerator ) mul U Int ( exp Scale , scalar ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } return get Exp ( numerator , divisor . mantissa ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal override virtual { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; }
event Deposit ( uint256 timestmap , address indexed address , uint256 indexed pid , uint256 amount ) ;
function token URI ( uint256 token Id ) public view override returns ( string memory ) { require ( exists ( token Id ) , " ERC721Metadata : URI query for nonexistent token " ) ; string memory token URI token UR Is [ token Id ] ; if ( bytes ( base URI ) . length 0 ) { return token URI ; } if ( bytes ( token URI ) . length > 0 ) { return string ( abi . encode Packed ( base URI , token URI ) ) ; } return string ( abi . encode Packed ( base URI , token Id . to String ( ) ) ) ; }
function get Peers Migration Info (
function unlocked Size ( ) external view returns ( uint ) { return locked Tokens . length ; }
function allowance ( address owner , address spender )
function revoke Delegate ( address user , address delegate ) internal { require ( delegated [ user ] [ delegate ] , " Delegable : Already undelegated " ) ; delegated [ user ] [ delegate ] false ; emit Delegate ( user , delegate , false ) ; }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }
function safe Dimsum Transfer ( address to , uint256 amount ) internal { uint256 dimsum Bal dimsum . balance Of ( address ( this ) ) ; if ( amount > dimsum Bal ) { dimsum . transfer ( to , dimsum Bal ) ; } else { dimsum . transfer ( to , amount ) ; } }
function total Value ( ) external view returns ( uint256 value ) { value total Value ( ) ; }
function reward Token ( ) external view override returns ( IERC20 ) { return value ; }
function truncate ( buffer memory buf ) internal pure returns ( buffer memory ) { assembly { let bufptr : mload ( buf ) mstore ( bufptr , 0 ) } return buf ; }
function exit ( ) external { withdraw All ( ) ; claim Reward ( ) ; }
modifier only Admin Or Owner ( ) { require ( admin ( ) msg Sender ( ) | | owner ( ) msg Sender ( ) , " Ownable : caller is not the admin " ) ; ; }
function enter ( uint256 amount ) public validate Chaiselongue { uint256 total Earn earn . balance Of ( address ( this ) ) ; uint256 total Shares total Supply ( ) ; if ( total Shares 0 | | total Earn 0 ) { mint ( msg . sender , amount . div ( 1000 ) ) ; } else { uint256 what amount . mul ( total Shares ) . div ( total Earn ) ; mint ( msg . sender , what ) ; } earn . transfer From ( msg . sender , address ( this ) , amount ) ; emit Joined ( msg . sender , amount ) ; }
function calc Withdrawal Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee ) internal pure returns ( uint256 gross Shares , uint256 fee Shares )
function proposed Get Round Data ( uint80 round Id )
function reclaim All ( address to ) public only Owner when Ended { uint256 length presale Alpaca I Ds . length ( ) ; uint256 [ ] memory ids new uint256 [ ] ( length ) ; uint256 [ ] memory amount new uint256 [ ] ( length ) ; for ( uint256 i 0 ; i < length ; i + + ) { ids [ i ] presale Alpaca I Ds . at ( i ) ; amount [ i ] 1 ; } crypto Alpaca . safe Batch Transfer From ( address ( this ) , to , ids , amount , " " ) ; }
function payback Debt ( uint amount , address c Borrow Token , address borrow Token , address payable user ) internal { uint whole Debt C Token Interface ( c Borrow Token ) . borrow Balance Current ( address ( this ) ) ; if ( amount > whole Debt ) { if ( borrow Token ETH ADDRESS ) { user . transfer ( ( amount whole Debt ) ) ; } else { ERC20 ( borrow Token ) . safe Transfer ( user , ( amount whole Debt ) ) ; } amount whole Debt ; } approve C Token ( borrow Token , c Borrow Token ) ; if ( borrow Token ETH ADDRESS ) { C Ether Interface ( c Borrow Token ) . repay Borrow { value : amount } ( ) ; } else { require ( C Token Interface ( c Borrow Token ) . repay Borrow ( amount ) 0 ) ; } }
function deposit (
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call . value ( amount ) ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function claim Rewards ( ) external returns ( address [ ] memory tokens , uint256 [ ] memory amounts ) ;
function mint ( address to , uint256 token Id ) internal { require ( to ! address ( 0 ) ) ; require ( ! exists ( token Id ) ) ; token Owner [ token Id ] to ; owned Tokens Count [ to ] owned Tokens Count [ to ] . add ( 1 ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function safe ZEUS Transfer ( address to , uint256 amount ) internal { uint256 ZEUS Bal zeus . balance Of ( address ( this ) ) ; if ( amount > ZEUS Bal ) { zeus . transfer ( to , ZEUS Bal ) ; } else { zeus . transfer ( to , amount ) ; } }
function pubkey ( bytes32 node ) external view returns ( bytes32 x , bytes32 y ) { return ( pubkeys [ node ] . x , pubkeys [ node ] . y ) ; }
modifier only If Active ( ) { require ( is Active ( ) , " voting proposal not active " ) ; ; }
function is Locked ( address address ) public view returns ( bool ) { return blacklist [ address ] ; }
function capacity ( ) constant returns ( uint ) { return q . length 1 ; }
function add Token To ( address to , uint256 token Id ) internal { require ( token Owner [ token Id ] address ( 0 ) ) ; token Owner [ token Id ] to ; owned Tokens Count [ to ] owned Tokens Count [ to ] . add ( 1 ) ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( swrv ! address ( asset ) , " swrv " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
function calculate Fee ( address asset , address user , uint amount ) public view returns ( uint ) { uint s Fee Percent stability Fee [ asset ] [ user ] ; uint time Past block . timestamp . sub ( last Update [ asset ] [ user ] ) ; return amount . mul ( s Fee Percent ) . mul ( time Past ) . div ( 365 days ) . div ( DENOMINATOR 1E5 ) ; }
function swap ( uint [ ] memory amounts , address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Uniswap V2Library . sort Tokens ( input , output ) ; uint amount Out amounts [ i + 1 ] ; ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Out ) : ( amount Out , uint ( 0 ) ) ; address to i < path . length 2 ? Uniswap V2Library . pair For ( factory , output , path [ i + 2 ] ) : to ; I Uniswap V2Pair ( Uniswap V2Library . pair For ( factory , input , output ) ) . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
modifier initializer ( ) { uint256 revision get Revision ( ) ; require ( initializing | | is Constructor ( ) | | revision > last Initialized Revision , " Contract instance has already been initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; last Initialized Revision revision ; } ; if ( is Top Level Call ) { initializing false ; } }
function claim ( ) public when Not Paused override returns ( bool ) { staking Storage . require Staking End ( ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) > 0 , " Nothing to claim " ) ; uint256 total Week Number staking Storage . total Week Number ( ) ; uint256 total Staking 0 ; uint256 total Reward 0 ; uint256 [ ] memory final Totals staking Storage . week Total Staking ( ) ; for ( uint256 i 0 ; i < staking Storage . get Stakesdata Length ( msg . sender ) ; i + + ) { ( uint256 staking Amount , uint256 staketime ) staking Storage . get Stakes Data By Index ( msg . sender , i ) ; uint256 staked Weed Number staketime . sub ( staking Storage . staking Start Time ( ) , " claim sub overflow " ) 1 weeks ; total Staking total Staking . add ( staking Amount ) ; uint256 reward 0 ; for ( uint256 j staked Weed Number ; j < total Week Number ; j + + ) { move . mul ( week Reward Amount ) to next line . } reward reward . mul ( staking Storage . week Reward Amount ( ) ) . div ( PRECISION UINT ) ; total Reward total Reward . add ( reward ) ; } staking Storage . Delete Stakes Data ( msg . sender ) ; lina Token . transfer ( msg . sender , total Staking . add ( total Reward ) ) ; emit Claim ( msg . sender , total Reward , total Staking ) ; return true ; }
function buy FY Dai Preview ( uint128 fy Dai Out )
modifier only Owner ( ) { require ( owner msg . sender , " Only current owner can call this function " ) ; ; }
function burn ( uint256 amount ) public returns ( bool ) { burn ( msg Sender ( ) , amount ) ; return true ; }
function borrow (
function releasable Amount ( ERC20Basic token ) public view returns ( uint256 ) { return vested Amount ( token ) . sub ( released [ token ] ) ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b ) ; return c ; }
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] false ) { uint256 fee transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; }
function is Ready For Distribution ( ) internal view returns ( bool ) { return ( distribution Accumulator > 0 ) & & ( now > next Distribution Timestamp ) ; }
function approve And Call ( address spender , uint256 value ) public override returns ( bool ) { return approve And Call ( spender , value , " " ) ; }
function add Fee Handler ( address fee Handler , IERC20 reward Token )
function set Sell Floor ( uint256 floor ) public only Governance { sell Floor floor ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function set Escape Hatch (
function get Global Token Symbol ( )
function burn From ( address account , uint256 value ) internal { burn ( account , value ) ; approve ( account , msg . sender , allowed [ account ] [ msg . sender ] . sub ( value ) ) ; }
function remove Subscriber ( address addr ) external only Functional Manager ;
function pause ( ) only Owner when Not Paused public { paused true ; Pause ( ) ; }
function remove Reader From Median Whitelist ( address median , address reader ) public { Oracle Like ( median ) . diss ( reader ) ; }
function unfreeze Reserve ( address reserve ) external only Lending Pool Configurator { Core Library . Reserve Data storage reserve reserves [ reserve ] ; reserve . is Freezed false ; }
function average Fees Per Block Since Start ( ) external view returns ( uint average Per Block ) { average Per Block cumulative Rewards Since Start . add ( rewards In This Epoch ) . div ( block . number . sub ( contract Start Block ) ) ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault Controller ( controller ) . vaults ( address ( this ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
modifier when Not Paused ( ) { require ( ! paused , " Paused by owner " ) ; ; }
function get Registry Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return address ( registry ) ; }
function is Circuit Enabled (
event Rebalance ( address rebalancer , uint256 amount ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal override { super . before Token Transfer ( from , to , amount ) ; require ( ! paused , " ERC20Pausable : token transfer while paused " ) ; }
function kill ( uint256 id ) external only EOA accrue ( 0 ) non Reentrant { Position storage pos positions [ id ] ; require ( pos . debt Share > 0 , " no debt " ) ; uint256 debt remove Debt ( id ) ; uint256 health Goblin ( pos . goblin ) . health ( id ) ; uint256 kill Factor config . kill Factor ( pos . goblin , debt ) ; require ( health . mul ( kill Factor ) < debt . mul ( 10000 ) , " can ' t liquidate " ) ; uint256 before ETH address ( this ) . balance ; Goblin ( pos . goblin ) . liquidate ( id ) ; uint256 back address ( this ) . balance . sub ( before ETH ) ; uint256 prize back . mul ( config . get Kill Bps ( ) ) . div ( 10000 ) ; uint256 rest back . sub ( prize ) ; if ( prize > 0 ) Safe Token . safe Transfer ETH ( msg . sender , prize ) ; uint256 left rest > debt ? rest debt : 0 ; if ( left > 0 ) Safe Token . safe Transfer ETH ( pos . owner , left ) ; emit Kill ( id , msg . sender , prize , left ) ; }
function add Token To ( address to , uint256 token Id ) internal { super . add Token To ( to , token Id ) ; uint256 length owned Tokens [ to ] . length ; owned Tokens [ to ] . push ( token Id ) ; owned Tokens Index [ token Id ] length ; }
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z y ; uint x y 2 + 1 ; while ( x < z ) { z x ; x ( y x + x ) 2 ; } } else if ( y ! 0 ) { z 1 ; } }
function config Address ( ) external view returns ( address ) { return address ( config ) ; }
modifier only Admin ( ) { require ( admin msg Sender ( ) , " Ownable : caller is not the admin " ) ; ; }
function set Cool Off Periods (
function remove Token ( address token ) external protected { remove Token ( token ) ; }
function mint Tokens ( uint256 amount , address beneficiary , address avatar )
function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { return allowed [ owner ] [ spender ] ; }
function unlock ( ) external only Migration Manager ;
function stake ( uint256 amount ) public update Reward ( msg Sender ( ) ) non Reentrant { require ( amount . add ( balance Of ( msg Sender ( ) ) ) > 2000000000000000000 , " Cannot stake less than 2 CHONK " ) ; require ( amount . add ( balance Of ( msg Sender ( ) ) ) < 10000000000000000000 , " Cannot stake more than 10 CHONK " ) ; brain Balance [ msg Sender ( ) ] brain Balance [ msg Sender ( ) ] . add ( amount ) ; IERC20 ( Chonk Address ) . transfer From ( msg Sender ( ) , address ( this ) , amount ) ; emit Staked ( msg Sender ( ) , amount ) ; }
function add ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { uint128 c a + b ; require ( c > a , " Safe Math : addition overflow " ) ; return c ; }
function total Supply ( ) constant returns ( uint256 supply ) { }
function pre Validate Purchase (
function token By Index ( uint256 index ) external view returns ( uint256 ) ;
function multiply Decimal ( uint x , uint y ) internal pure returns ( uint ) { Divide by UNIT to remove the extra factor introduced by the product . return x . mul ( y ) UNIT ; }
function current Quota ( Quota memory q )
function find Deposit ( Self storage self , uint256 reserve Amount ) internal view returns ( address adjust Token , uint256 adjust Amount )
function has Sufficient Default Units ( I Set Token set Token , address component , uint256 unit ) internal view returns ( bool ) { return set Token . get Default Position Real Unit ( component ) > unit . to Int256 ( ) ; }
function get All Debt ( address vat , address usr , address urn , bytes32 ilk ) internal view returns ( uint dai Amount ) { ( , uint rate , , , ) Vat ( vat ) . ilks ( ilk ) ; ( , uint art ) Vat ( vat ) . urns ( ilk , urn ) ; uint dai Vat ( vat ) . dai ( usr ) ; uint rad sub ( mul ( art , rate ) , dai ) ; dai Amount rad RAY ; dai Amount mul ( dai Amount , RAY ) < rad ? dai Amount + 1 : dai Amount ; }
function get Current Votes ( address account ) external view returns ( uint ) { uint32 n Checkpoints num Checkpoints [ account ] ; return n Checkpoints > 0 ? checkpoints [ account ] [ n Checkpoints 1 ] . votes : 0 ; }
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender controller , " Golff : ! controller " ) ; require ( want ! address ( asset ) , " Golff : want " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
event Unpaused ( address account ) ;
function token Withdraw ( address token Address , uint256 amount )
function get Gas Cost ( uint amount , uint gas Cost , address c Token Addr ) internal returns ( uint fee Amount ) { address token Addr get Underlying Addr ( c Token Addr ) ; if ( gas Cost ! 0 ) { address oracle Comptroller Interface ( COMPTROLLER ) . oracle ( ) ; uint usd Token Price Compound Oracle Interface ( oracle ) . get Underlying Price ( c Token Addr ) ; uint eth Price Compound Oracle Interface ( oracle ) . get Underlying Price ( CETH ADDRESS ) ; uint token Price In Eth wdiv ( usd Token Price , eth Price ) ; fee Amount wdiv ( gas Cost , token Price In Eth ) ; } if ( fee Amount > ( amount 5 ) ) { fee Amount amount 5 ; } if ( token Addr ETH ADDRESS ) { WALLET ADDR . transfer ( fee Amount ) ; } else { ERC20 ( token Addr ) . safe Transfer ( WALLET ADDR , fee Amount ) ; } }
function mul Truncate Ceil ( uint256 x , uint256 y )
function withdraw ( uint256 amount ) external { require ( msg . sender controller , " ! controller " ) ; uint256 balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } uint256 fee Dev amount . mul ( dev Fund Fee ) . div ( dev Fund Max ) ; uint256 fee Treasury amount . mul ( treasury Fee ) . div ( treasury Max ) ; if ( buyback Enabled true ) { ( address buyback Principle , uint256 buyback Amount ) convert Want To Buyback ( fee Dev . add ( fee Treasury ) ) ; buyback And Notify ( buyback Principle , buyback Amount ) ; } else { IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . devfund ( ) , fee Dev ) ; IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . treasury ( ) , fee Treasury ) ; } address vault I Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee Dev ) . sub ( fee Treasury ) ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc RGB Per Share : 0 } ) ) ; }
function update twap ( )
function calc Conversion Input From Output ( address from , address to , uint256 output Amount ) public view override returns ( uint256 input Amount )
function confirm Withdraw (
function transfer ( address to , uint value ) public virtual returns ( bool ) { bytes memory empty ; if ( is Contract ( to ) ) { return transfer To Contract ( to , value , empty ) ; } else { return transfer To Address ( to , value , empty ) ; } }
function buy ( Exchange Data memory ex Data ) internal returns ( address , uint ) { address wrapper ; uint swaped Tokens ; bool success ; require ( ex Data . dest Amount ! 0 , " Dest amount must be specified " ) ; if ( ex Data . src Addr KYBER ETH ADDRESS ) { ex Data . src Addr eth To Weth Addr ( ex Data . src Addr ) ; Token Interface ( WETH ADDRESS ) . deposit . value ( ex Data . src Amount ) ( ) ; } if ( ex Data . price0x > 0 ) { approve0x Proxy ( ex Data . src Addr , ex Data . src Amount ) ; uint eth Amount ex Data . src Addr WETH ADDRESS ? msg . value ex Data . src Amount : msg . value ; ( success , swaped Tokens , ) take Order ( ex Data , eth Amount , Action Type . BUY ) ; if ( success ) { wrapper ex Data . exchange Addr ; } } if ( ! success ) { swaped Tokens saver Swap ( ex Data , Action Type . BUY ) ; wrapper ex Data . wrapper ; } require ( swaped Tokens > ex Data . dest Amount , " Final amount isn ' t correct " ) ; if ( get Balance ( WETH ADDRESS ) > 0 ) { Token Interface ( WETH ADDRESS ) . withdraw ( Token Interface ( WETH ADDRESS ) . balance Of ( address ( this ) ) ) ; } return ( wrapper , get Balance ( ex Data . dest Addr ) ) ; }
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender controller | | msg . sender governance , " ! governance " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function set Underlying Token Valuator ( address new Underlying Token Valuator ) external ;
function transfer From ( address src , address dst , uint amount ) external returns ( bool ) { address spender msg . sender ; uint spender Allowance allowances [ src ] [ spender ] ; if ( spender ! src & & spender Allowance ! uint ( 1 ) ) { uint new Allowance spender Allowance . sub ( amount , " : : transfer From : transfer amount exceeds spender allowance " ) ; allowances [ src ] [ spender ] new Allowance ; emit Approval ( src , spender , new Allowance ) ; } transfer Tokens ( src , dst , amount ) ; return true ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { Solidity only automatically asserts when dividing by 0 uint256 c a b ; return c ; }
function initialize ( address [ ] memory tokens , uint256 [ ] memory precisions , uint256 [ ] memory fees ,
function withdraw Eth ( address payable user , uint amount ) external has Vault Access not Liquidating ( weth , user ) { collaterals [ weth ] [ user ] collaterals [ weth ] [ user ] . sub ( amount ) ; IWETH ( weth ) . withdraw ( amount ) ; Transfer Helper . safe Transfer ETH ( user , amount ) ; }
function get Max Borrow ( address c Borrow Address , address account ) public returns ( uint ) { ( , uint liquidity In Usd , ) Comptroller Interface ( COMPTROLLER ) . get Account Liquidity ( account ) ; address oracle Comptroller Interface ( COMPTROLLER ) . oracle ( ) ; C Token Interface ( c Borrow Address ) . accrue Interest ( ) ; uint usd Price Compound Oracle Interface ( oracle ) . get Underlying Price ( c Borrow Address ) ; uint liquidity In Token wdiv ( liquidity In Usd , usd Price ) ; cut off 1 % due to rounding issues }
function restrict Registry Update ( bool only Owner Can Update Registry ) public owner Only { only Owner Can Update Registry only Owner Can Update Registry ; }
function name ( ) external view returns ( string memory ) { return name ; }
function claim Ownership ( ) only Pending Owner public { transfer Ownership ( pending Owner ) ; pending Owner address ( 0 ) ; }
function dev ( address devaddr ) public { require ( msg . sender devaddr , " dev : wut ? " ) ; devaddr devaddr ; }
function swap Borrow Rate Mode ( address reserve )
function set Approval For All ( address to , bool approved ) public { require ( to ! msg Sender ( ) , " ERC721 : approve to caller " ) ; operator Approvals [ msg Sender ( ) ] [ to ] approved ; emit Approval For All ( msg Sender ( ) , to , approved ) ; }
function initialize ( address factory , bytes memory data ) public payable { require ( factory ( ) address ( 0 ) ) ; assert ( FACTORY SLOT bytes32 ( uint256 ( keccak256 ( ' eip1967 . proxy . factory ' ) ) 1 ) ) ; set Factory ( factory ) ; if ( data . length > 0 ) { ( bool success , ) implementation ( ) . delegatecall ( data ) ; require ( success ) ; } }
function token At ( Self storage self , uint256 index ) public view returns ( address token )
function get Contract Registry ( ) public override view returns ( I Contract Registry ) { return contract Registry ; }
function get Underlying Price ( address s Token ) external view returns ( uint ) { Token Config memory config get Token Config By C Token ( s Token ) ; return mul ( 1e30 , price Internal ( config ) ) config . base Unit ; }
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; withdraw All ( ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address plate I Sashimi Plate Controller ( controller ) . plates ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( plate , balance ) ; }
function earned ( address account ) public view returns ( uint256 ) { uint256 block Time block . timestamp ; return points [ account ] . add ( block Time . sub ( last Update Time [ account ] ) . mul ( 1e18 ) . div ( 11520 ) . mul ( balance Of ( account ) . div ( 1e18 ) ) ) ; }
function utilization ( address token , uint amount ) internal view returns ( uint ) { uint max STABLE . MAX ( ) ; uint base STABLE . BASE ( ) ; address pair Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( STABLE ) ) ; uint ratio base . sub ( base . mul ( STABLE . balance Of ( pair ) . add ( amount ) ) . div ( STABLE . total Supply ( ) ) ) ; if ( ratio 0 ) { return max ; } return ratio > max ? max : ratio ; }
function remove Address ( Bytes32Set storage set , address addrvalue )
function set Lending Pool Data Provider Impl ( address provider ) public only Owner { update Impl Internal ( DATA PROVIDER , provider ) ; emit Lending Pool Data Provider Updated ( provider ) ; }
function delegates ( address delegator )
function received Loan Of ( address owner )
function decode112with18 ( uq112x112 memory self ) internal pure returns ( uint ) { return uint ( self . x ) 5192296858534827 ; }
event Keeper Worked ( address indexed credit , address indexed job , address indexed keeper , uint block , uint amount ) ;
function keccak ( slice memory self ) internal pure returns ( bytes32 ret ) { assembly { ret : keccak256 ( mload ( add ( self , 32 ) ) , mload ( self ) ) } }
function NEW Orbs ( ) { Give the creator all initial tokens . This is set to 1000 for example . If you want your initial tokens to be X and your decimal is 5 , set this value to X 100000 . ( CHANGE THIS ) Update total supply ( 1000 for example ) ( CHANGE THIS ) Set the name for display purposes ( CHANGE THIS ) Amount of decimals for display purposes ( CHANGE THIS ) Set the symbol for display purposes ( CHANGE THIS ) Set the price of your token for the ICO ( CHANGE THIS ) The owner of the contract gets ETH }
function pending Nanocore ( uint256 pid , address user )
enum Failure Info { ACCEPT ADMIN PENDING ADMIN CHECK , ACCRUE INTEREST ACCUMULATED INTEREST CALCULATION FAILED , ACCRUE INTEREST BORROW RATE CALCULATION FAILED , ACCRUE INTEREST NEW BORROW INDEX CALCULATION FAILED , ACCRUE INTEREST NEW TOTAL BORROWS CALCULATION FAILED , ACCRUE INTEREST NEW TOTAL RESERVES CALCULATION FAILED , ACCRUE INTEREST SIMPLE INTEREST FACTOR CALCULATION FAILED , BORROW ACCUMULATED BALANCE CALCULATION FAILED , BORROW ACCRUE INTEREST FAILED , BORROW CASH NOT AVAILABLE , BORROW FRESHNESS CHECK , BORROW NEW TOTAL BALANCE CALCULATION FAILED , BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED , BORROW MARKET NOT LISTED , BORROW COMPTROLLER REJECTION , LIQUIDATE ACCRUE BORROW INTEREST FAILED , LIQUIDATE ACCRUE COLLATERAL INTEREST FAILED , LIQUIDATE COLLATERAL FRESHNESS CHECK , LIQUIDATE COMPTROLLER REJECTION , LIQUIDATE COMPTROLLER CALCULATE AMOUNT SEIZE FAILED , LIQUIDATE CLOSE AMOUNT IS UINT MAX , LIQUIDATE CLOSE AMOUNT IS ZERO , LIQUIDATE FRESHNESS CHECK , LIQUIDATE LIQUIDATOR IS BORROWER , LIQUIDATE REPAY BORROW FRESH FAILED , LIQUIDATE SEIZE BALANCE INCREMENT FAILED , LIQUIDATE SEIZE BALANCE DECREMENT FAILED , LIQUIDATE SEIZE COMPTROLLER REJECTION , LIQUIDATE SEIZE LIQUIDATOR IS BORROWER , LIQUIDATE SEIZE TOO MUCH , MINT ACCRUE INTEREST FAILED , MINT COMPTROLLER REJECTION , MINT EXCHANGE CALCULATION FAILED , MINT EXCHANGE RATE READ FAILED , MINT FRESHNESS CHECK , MINT NEW ACCOUNT BALANCE CALCULATION FAILED , MINT NEW TOTAL SUPPLY CALCULATION FAILED , MINT TRANSFER IN FAILED , MINT TRANSFER IN NOT POSSIBLE , REDEEM ACCRUE INTEREST FAILED , REDEEM COMPTROLLER REJECTION , REDEEM EXCHANGE TOKENS CALCULATION FAILED , REDEEM EXCHANGE AMOUNT CALCULATION FAILED , REDEEM EXCHANGE RATE READ FAILED , REDEEM FRESHNESS CHECK , REDEEM NEW ACCOUNT BALANCE CALCULATION FAILED , REDEEM NEW TOTAL SUPPLY CALCULATION FAILED , REDEEM TRANSFER OUT NOT POSSIBLE , REDUCE RESERVES ACCRUE INTEREST FAILED , REDUCE RESERVES ADMIN CHECK , REDUCE RESERVES CASH NOT AVAILABLE , REDUCE RESERVES FRESH CHECK , REDUCE RESERVES VALIDATION , REPAY BEHALF ACCRUE INTEREST FAILED , REPAY BORROW ACCRUE INTEREST FAILED , REPAY BORROW ACCUMULATED BALANCE CALCULATION FAILED , REPAY BORROW COMPTROLLER REJECTION , REPAY BORROW FRESHNESS CHECK , REPAY BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED , REPAY BORROW NEW TOTAL BALANCE CALCULATION FAILED , REPAY BORROW TRANSFER IN NOT POSSIBLE , SET COLLATERAL FACTOR OWNER CHECK , SET COLLATERAL FACTOR VALIDATION , SET COMPTROLLER OWNER CHECK , SET INTEREST RATE MODEL ACCRUE INTEREST FAILED , SET INTEREST RATE MODEL FRESH CHECK , SET INTEREST RATE MODEL OWNER CHECK , SET MAX ASSETS OWNER CHECK , SET ORACLE MARKET NOT LISTED , SET PENDING ADMIN OWNER CHECK , SET RESERVE FACTOR ACCRUE INTEREST FAILED , SET RESERVE FACTOR ADMIN CHECK , SET RESERVE FACTOR FRESH CHECK , SET RESERVE FACTOR BOUNDS CHECK , TRANSFER COMPTROLLER REJECTION , TRANSFER NOT ALLOWED , TRANSFER NOT ENOUGH , TRANSFER TOO MUCH }
function gem Join join ( address apt , address urn , uint256 wad , bool transfer From ) public { if ( transfer From ) { Gem Join Like ( apt ) . gem ( ) . transfer From ( msg . sender , address ( this ) , wad ) ; Gem Join Like ( apt ) . gem ( ) . approve ( apt , 0 ) ; Gem Join Like ( apt ) . gem ( ) . approve ( apt , wad ) ; } Gem Join Like ( apt ) . join ( urn , wad ) ; }
function set Liquidity Divisor ( uint256 liquidity Divisor ) public only Admin Or Owner { require ( liquidity Divisor ! 0 , " Boo : liquidity Divisor must be bigger than 0 " ) ; liquidity Divisor liquidity Divisor ; }
function to Int32 ( int256 value ) internal pure returns ( int32 ) { require ( value > 2 31 & & value < 2 31 , " Safe Cast : value doesn \ ' t fit in 32 bits " ) ; return int32 ( value ) ; }
function cancel Seller ( uint option UID ) internal { Option memory option options [ option UID ] ; require ( option . seller Accepted , " cancel Seller ( ) : cannot cancel before accepting " ) ; require ( ! option . buyer Accepted , " cancel Seller ( ) : already accepted " ) ; require ( ! option . cancelled , " cancel Seller ( ) : already cancelled " ) ; options [ option UID ] . cancelled true ; emit Seller Cancelled ( option UID , msg . sender ) ; redeem Underlying ( option UID ) ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { if ( lp ! recipient ) { transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ; } else { return false ; } }
function mass Update Pools ( ) public { uint256 length pool Info . length ; for ( uint256 pid 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; } }
event Remove Job ( address indexed job , address indexed liquidity , address indexed provider , uint block , uint credit ) ;
function set Token Debt Limit ( address asset , uint limit ) public only Manager { token Debt Limit [ asset ] limit ; }
function transfer From ( address from , address to , uint256 value ) public override virtual returns ( bool ) { require ( from ! address ( 0 ) , " from must not be zero address " ) ; require ( to ! address ( 0 ) , " to must not be zero address " ) ; require ( ! paused , " token transfer while paused " ) ; require ( value < allowed [ from ] [ msg . sender ] , " tranfer amount exceeds allowance " ) ; require ( value < balances [ from ] , " transfer amount exceeds available balance " ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function mint Batch ( address to , uint256 [ ] memory ids , uint256 [ ] memory amounts , bytes memory data ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have minter role to mint " ) ; mint Batch ( to , ids , amounts , data ) ; }
function validate Group ( address addr , address group Addr ) external view { require ( I Group ( group Addr ) . is Group ( addr ) , error Message ) ; }
function transfer ( address to , uint256 value ) external override returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < address To Shares [ msg . sender ] ) ; address To Shares [ msg . sender ] address To Shares [ msg . sender ] . sub ( value ) ; address To Shares [ to ] address To Shares [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function disable Circuit (
function safe Mint ( address to , uint256 token Id ) internal virtual { safe Mint ( to , token Id , " " ) ; }
function balance Of ( address account ) public view virtual override returns ( uint256 ) { return balances [ account ] ; }
function set Keep UNI ( uint256 keep UNI ) external { require ( msg . sender governance , " ! governance " ) ; keep UNI keep UNI ; }
function enable Borrowing ( Reserve Data storage self , bool stable Borrow Rate Enabled ) external { require ( self . borrowing Enabled false , " Reserve is already enabled " ) ; self . borrowing Enabled true ; self . is Stable Borrow Rate Enabled stable Borrow Rate Enabled ; }
function mint ( address to , uint256 amount ) only Owner can Mint public returns ( bool ) { total Supply total Supply . add ( amount ) ; balances [ to ] balances [ to ] . add ( amount ) ; emit Mint ( to , amount ) ; emit Transfer ( address ( 0 ) , to , amount ) ; return true ; }
function lock ( address account ) public only Locker when Not Paused { lock ( account ) ; }
function distribute ( ) external { require ( msg . sender governance , " ! governance " ) ; uint256 b vox . balance Of ( address ( this ) ) ; if ( b > 0 ) { uint256 to Burn b . mul ( burn Fee ) . div ( burn Fee Base ) ; uint256 leftover b . sub ( to Burn ) ; vox . safe Transfer ( burn , to Burn ) ; vox . safe Transfer ( treasury , leftover ) ; } }
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function repay Borrow Fresh ( address payer , address borrower , uint repay Amount ) internal returns ( uint ) { Fail if repay Borrow not allowed uint allowed controller . repay Borrow Allowed ( address ( this ) , payer , borrower , repay Amount ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . CONTROLLER REJECTION , Failure Info . REPAY BORROW CONTROLLER REJECTION , allowed ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return fail ( Error . MARKET NOT FRESH , Failure Info . REPAY BORROW FRESHNESS CHECK ) ; } Repay Borrow Local Vars memory vars ; We remember the original borrower Index for verification purposes vars . borrower Index account Borrows [ borrower ] . interest Index ; We fetch the amount the borrower owes , with accumulated interest ( vars . math Err , vars . account Borrows ) borrow Balance Stored Internal ( borrower ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW ACCUMULATED BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } If repay Amount 1 , repay Amount account Borrows if ( repay Amount uint ( 1 ) ) { vars . repay Amount vars . account Borrows ; } else { vars . repay Amount repay Amount ; } Fail if check Transfer In fails vars . err check Transfer In ( payer , vars . repay Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . REPAY BORROW TRANSFER IN NOT POSSIBLE ) ; } We calculate the new borrower and total borrow balances , failing on underflow : account Borrows New account Borrows repay Amount total Borrows New total Borrows repay Amount ( vars . math Err , vars . account Borrows New ) sub U Int ( vars . account Borrows , vars . repay Amount ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . total Borrows New ) sub U Int ( total Borrows , vars . repay Amount ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW NEW TOTAL BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We call do Transfer In for the payer and the repay Amount Note : The a Token must handle variations between ERC 20 and ETH underlying . On success , the a Token holds an additional repay Amount of cash . If do Transfer In fails despite the fact we checked pre conditions , we revert because we can ' t be sure if side effects occurred . vars . err do Transfer In ( payer , vars . repay Amount ) ; require ( vars . err Error . NO ERROR , " repay borrow transfer in failed " ) ; We write the previously calculated values into storage account Borrows [ borrower ] . principal vars . account Borrows New ; account Borrows [ borrower ] . interest Index borrow Index ; total Borrows vars . total Borrows New ; We emit a Repay Borrow event emit Repay Borrow ( payer , borrower , vars . repay Amount , vars . account Borrows New , vars . total Borrows New ) ; We call the defense hook controller . repay Borrow Verify ( address ( this ) , payer , borrower , vars . repay Amount , vars . borrower Index ) ; return uint ( Error . NO ERROR ) ; }
function increase Approval ( address spender , uint added Value ) external { require ( spender ! 0x0 , " spender must be set " ) ; mapping ( address > uint256 ) allowances allowed [ msg . sender ] ; uint new Value allowances [ spender ] . add ( added Value ) ; allowances [ spender ] new Value ; emit Approval ( msg . sender , spender , new Value ) ; }
function burn ( address account , uint256 value ) internal { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; total Supply total Supply . sub ( value ) ; balances [ account ] balances [ account ] . sub ( value ) ; emit Transfer ( account , address ( 0 ) , value ) ; }
function is Constructor ( ) private view returns ( bool ) { address self address ( this ) ; uint256 cs ; assembly { cs : extcodesize ( self ) } return cs 0 ; }
function get Prior Votes ( address account , uint block Number ) public view returns ( uint96 ) { require ( block Number < block . number , " Dena : : get Prior Votes : not yet determined " ) ; uint32 n Checkpoints num Checkpoints [ account ] ; if ( n Checkpoints 0 ) { return 0 ; } if ( checkpoints [ account ] [ n Checkpoints 1 ] . from Block < block Number ) { return checkpoints [ account ] [ n Checkpoints 1 ] . votes ; } if ( checkpoints [ account ] [ 0 ] . from Block > block Number ) { return 0 ; } uint32 lower 0 ; uint32 upper n Checkpoints 1 ; while ( upper > lower ) { ceil , avoiding overflow Checkpoint memory cp checkpoints [ account ] [ center ] ; if ( cp . from Block block Number ) { return cp . votes ; } else if ( cp . from Block < block Number ) { lower center ; } else { upper center 1 ; } } return checkpoints [ account ] [ lower ] . votes ; }
event Transfer Batch ( address indexed operator , address indexed from , address indexed to , uint256 [ ] ids , uint256 [ ] values ) ;
function has FRT ( ) private view returns ( bool ) { if ( token . balance Of ( msg . sender ) > 0 ) { return true ; } else { return false ; } }
function pending Uni Sushi ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc Uni Sushi Per Share pool . acc Uni Sushi Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 unisushi Reward multiplier . mul ( unisushi Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Uni Sushi Per Share acc Uni Sushi Per Share . add ( unisushi Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Uni Sushi Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function safe Send Value ( address receiver , uint256 value ) internal { if ( ! receiver . send ( value ) ) { ( new Sacrifice ) . value ( value ) ( receiver ) ; } }
function set Implementation ( address new Implementation ) internal { bytes32 position implementation Position ; assembly { sstore ( position , new Implementation ) } }
function get Total Service Type Providers ( bytes32 service Type )
function get State Seq Num Map (
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( ( b > 0 & & c < a ) | | ( b < 0 & & c > a ) , " Signed Safe Math : subtraction overflow " ) ; return c ; }
function remove Supported Identifier ( bytes32 identifier ) external ;
function governance Rescue Token ( IERC20 token ) external override returns ( uint256 balance ) { address bank value Vault Master . bank ( ) ; require ( bank msg . sender , " sender not bank " ) ; balance token . balance Of ( address ( this ) ) ; token . transfer ( bank , balance ) ; }
function migrate ( uint256 pid ) public { require ( address ( migrator ) ! address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool pool Info [ pid ] ; IERC20 lp Token pool . lp Token ; uint256 bal lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token migrator . migrate ( lp Token ) ; require ( bal new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token new Lp Token ; }
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) public pure override returns ( uint256 cost )
function authorised ( address module ) external view returns ( bool ) ;
function pay Profit ( uint option ID )
function quote (
function check Collateralization ( Fixed Point . Unsigned memory collateral , Fixed Point . Unsigned memory num Tokens )
event Staking Proxy Set ( address staking Proxy Address ) ;
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function lock ( uint id , uint256 amount , uint256 premium ) external override only Owner { require ( id locked Liquidity . length , " Wrong id " ) ; require ( locked Amount . add ( amount ) . mul ( 10 ) < total Balance ( ) . mul ( 8 ) , " Pool Error : Amount is too large . " ) ; locked Liquidity . push ( Locked Liquidity ( amount , premium , true ) ) ; locked Premium locked Premium . add ( premium ) ; locked Amount locked Amount . add ( amount ) ; token . safe Transfer From ( msg . sender , address ( this ) , premium ) ; }
function is Module Registered ( address module ) external view returns ( bool ) ;
function burn Batch ( address account , uint256 [ ] memory ids , uint256 [ ] memory amounts ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : burn from the zero address " ) ; require ( ids . length amounts . length , " ERC1155 : ids and amounts length mismatch " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , account , address ( 0 ) , ids , amounts , " " ) ; for ( uint i 0 ; i < ids . length ; i + + ) { balances [ ids [ i ] ] [ account ] balances [ ids [ i ] ] [ account ] . sub ( amounts [ i ] , " ERC1155 : burn amount exceeds balance " ) ; } emit Transfer Batch ( operator , account , address ( 0 ) , ids , amounts ) ; }
function delegator Exists For SP (
modifier only Manager ( ) { require ( vault Parameters . is Manager ( msg . sender ) , " Unit Protocol : AUTH FAILED " ) ; ; }
function to Int256 ( uint256 value ) internal pure returns ( int256 ) { require ( value < 2 255 , " Safe Cast : value doesn ' t fit in an int256 " ) ; return int256 ( value ) ; }
function asset To Eth ( address asset , uint amount ) public virtual view returns ( uint ) ;
function get ( Uint To Address Map storage map , uint256 key ) internal view returns ( address ) { return address ( uint256 ( get ( map . inner , bytes32 ( key ) ) ) ) ; }
function fast Call And Verify (
function out Of ( uint256 a , uint256 b )
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; before Token Transfer ( address ( 0 ) , to , token Id ) ; holder Tokens [ to ] . add ( token Id ) ; token Owners . set ( token Id , to ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function avg ( int256 a , int256 b )
function token By Index ( uint256 index ) public view returns ( uint256 ) { require ( index < total Supply ( ) ) ; return all Tokens [ index ] ; }
function renew Hold ( address token , bytes32 hold Id , uint256 expiration , bytes memory certificate ) internal returns ( bool ) { Hold storage renewable Hold holds [ token ] [ hold Id ] ; require ( renewable Hold . status Hold Status Code . Ordered | | renewable Hold . status Hold Status Code . Executed And Kept Open , " A hold can only be renewed in status Ordered or Executed And Kept Open " ) ; require ( ! is Expired ( renewable Hold . expiration ) , " An expired hold can not be renewed " ) ; require ( can Hold Or Can Pre Hold ( token , msg . sender , renewable Hold . sender , certificate ) , " A hold can only be renewed with adapted authorizations " ) ; uint256 old Expiration renewable Hold . expiration ; renewable Hold . expiration expiration ; emit Hold Renewed ( token , hold Id , renewable Hold . notary , old Expiration , expiration ) ; return true ; }
function unstake Query ( uint256 amount ) public returns ( uint256 ) { return unstake ( amount ) ; }
function mediator Contract On Other Side ( ) public view returns ( address ) { return address Storage [ MEDIATOR CONTRACT ] ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c a b ; return c ; }
function getreward Per Token Amount ( ) public view returns ( uint256 ) { uint256 timestamp last Time Reward Applicable ( ) ; uint256 distribution Time distribution Time ; uint256 last Update Time last Update Time ; if ( timestamp < distribution Time | | timestamp last Update Time ) return 0 ; uint256 last Update Time Offset last Update Time . sub ( distribution Time ) % halve Interval ; uint256 first Interval End last Update Time . sub ( last Update Time Offset ) . add ( halve Interval ) ; if ( timestamp < first Interval End ) return timestamp . sub ( last Update Time ) . mul ( get Fixed Reward Rate ( last Update Time ) ) ; uint256 reward Per Token Amount halve Interval . sub ( last Update Time Offset ) . mul ( get Fixed Reward Rate ( last Update Time ) ) ; uint256 current Reward Rate get Fixed Reward Rate ( timestamp ) ; reward Per Token Amount reward Per Token Amount . add ( ( halve Interval . mul ( get Fixed Reward Rate ( first Interval End ) . sub ( current Reward Rate ) ) ) < < 1 ) ; return reward Per Token Amount . add ( ( timestamp . sub ( distribution Time ) % halve Interval ) . mul ( current Reward Rate ) ) ; }
function submit Vote ( uint256 votes ) public override returns ( bool )
function usable Balance Of ( address owner ) public view returns ( uint256 balance ) { return ( balances [ owner ] . sub ( frozen Balance [ owner ] ) ) ; }
function get Settings ( ) external view returns (
function remove Member ( address addr ) external returns ( bool member Removed , uint removed Member Weight , bool removed Member Certified ) only Election Contract ;
function Stake Axia Tokens ( uint256 tokens ) external { stake ( tokens ) ; }
function estimate Flash Loan Fee ( Provider provider , address token , uint256 net Amount ) internal pure returns ( uint256 fee Amount )
function swap Tokens For Exact ETH (
function update Reserve State On Borrow Internal (
function burn ( uint amount ) external { burn ( msg . sender , amount ) ; }
function balances ( int128 arg0 ) external returns ( uint256 out ) ;
modifier only Pending Owner ( ) { require ( msg . sender pending Owner , " UNAUTHORIZED " ) ; ; }
function migrations Old Staking ( address contract Addr , uint amount , uint block Nb ) public only Admin { super . deposit ( block Nb , contract Addr , amount ) ; m Old Staking contract Addr ; m Old Amount amount ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc LAMBO Per Share : 0 } ) ) ; }
function get Max ( uint256 [ 51 ] memory data ) internal pure returns ( uint256 max , uint256 max Index ) { max Index 1 ; max data [ max Index ] ; for ( uint256 i 2 ; i < data . length ; i + + ) { if ( data [ i ] > max ) { max data [ i ] ; max Index i ; } } }
function redeem By Partition (
function toggle Contract Active ( ) external only Owner { stopped ! stopped ; }
function cad To Dai ( uint256 amount ) external view virtual override returns ( uint256 ) { ( , int256 dai Eth Price , , uint256 dai Eth Time Stamp , ) dai Eth Price Feed . latest Round Data ( ) ; require ( dai Eth Time Stamp > 0 , " Dai Chainlink Oracle data temporarily incomplete " ) ; require ( dai Eth Price > 0 , " Invalid Chainlink Oracle Dai price " ) ; ( , int256 usdc Eth Price , , uint256 usdc Eth Time Stamp , ) usdc Eth Price Feed . latest Round Data ( ) ; require ( usdc Eth Time Stamp > 0 , " USDC conversion Chainlink Oracle data temporarily incomplete " ) ; require ( usdc Eth Price > 0 , " Invalid Chainlink Oracle USDC conversion price " ) ; return amount . mul ( 10 granularity ) . mul ( uint256 ( usdc Eth Price ) ) . div ( uint256 ( dai Eth Price ) ) . div ( USD To CAD Rate ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; 5 % city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function create Clone Token (
function mint And Freeze ( address to , uint amount , uint64 until ) public only Owner can Mint returns ( bool ) { total Supply total Supply . add ( amount ) ; bytes32 current Key to Key ( to , until ) ; freezings [ current Key ] freezings [ current Key ] . add ( amount ) ; freezing Balance [ to ] freezing Balance [ to ] . add ( amount ) ; freeze ( to , until ) ; emit Mint ( to , amount ) ; emit Freezed ( to , until , amount ) ; emit Transfer ( msg . sender , to , amount ) ; return true ; }
function preview ( )
function require Claims Manager Address Is Set ( ) private view { require ( claims Manager Address ! address ( 0x00 ) , " Staking : claims Manager Address is not set " ) ; }
function remove Liquidity ETH Supporting Fee On Transfer Tokens (
function dai In For FY Dai Out (
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( y ! address ( asset ) , " y " ) ; require ( ycrv ! address ( asset ) , " ycrv " ) ; require ( yycrv ! address ( asset ) , " yycrv " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
modifier only Bagholders ( ) { require ( my Tokens ( ) > 0 ) ; ; }
function renounce Role ( bytes32 role , address account ) public virtual { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function get Value Via One Inch (
function is Operator For ( address operator , address token Holder ) external view returns ( bool ) ;
function unstake All ( uint256 vault Id ) public { address vault controller . vaults ( vault Id ) ; require ( vault ! address ( 0x0 ) , " no vault " ) ; Account account get Account ( ) ; Rewarded Vault vault Rewarded Vault ( vault ) ; IERC20 token vault . token ( ) ; uint256 total Balance vault . balance ( ) ; uint256 total Supply vault . total Supply ( ) ; uint256 shares vault . balance Of ( address ( account ) ) ; uint256 amount shares . mul ( total Balance ) . div ( total Supply ) ; bytes memory method Data abi . encode With Signature ( " withdraw ( uint256 ) " , shares ) ; account . invoke ( address ( vault ) , 0 , method Data ) ; emit Unstaked ( msg . sender , vault Id , address ( token ) , amount ) ; }
function set Period Calc ( uint256 new Period Calc ) public { require ( has Role ( ADMIN , msg . sender ) , " Liquidity Mining : Message Sender must be ADMIN " ) ; period Calc new Period Calc ; }
function call ERC165Supports Interface ( address account , bytes4 interface Id )
function div ( int256 a , int256 b ) internal pure returns ( int256 ) { require ( b ! 0 , " Signed Safe Math : division by zero " ) ; require ( ! ( b 1 & & a INT256 MIN ) , " Signed Safe Math : division overflow " ) ; int256 c a b ; return c ; }
function create Tokens Int ( uint256 tokens , address destination ) internal only Owner { uint256 tokens tokens 10 uint256 ( decimals ) ; total Supply total Supply . add ( tokens ) ; balances [ destination ] balances [ destination ] . add ( tokens ) ; emit Transfer ( 0x0 , destination , tokens ) ; require ( total Supply < HARD CAP ) ; }
function balance Of ( address who ) public constant returns ( uint ) { if ( deprecated ) { return Upgraded Standard Token ( upgraded Address ) . balance Of ( who ) ; } else { return super . balance Of ( who ) ; } }
modifier not Blacklisted ( address account ) { require ( blacklisted [ account ] false , BLACKLISTED ) ; ; }
function sub (
function withdraw ( uint256 amount ) only Owner public { uint256 ether Balance address ( this ) . balance ; require ( amount < ether Balance ) ; owner . transfer ( amount ) ; }
function salvage ( address recipient , address token , uint256 amount ) external ;
function borrow ( uint borrow Amount ) external returns ( uint ) { return borrow Internal ( borrow Amount ) ; }
function governance ( ) public view returns ( address ) { return governance ; }
event Log Tokens Bought ( address indexed buyer , uint256 amount ) ;
function calc Withdrawal Shares From Underlying Cost ( uint256 underlying Cost , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) public pure override returns ( uint256 gross Shares , uint256 fee Shares )
function get Approved ( uint256 token Id ) public view override returns ( address ) { require ( exists ( token Id ) , " ERC721 : approved query for nonexistent token " ) ; return token Approvals [ token Id ] ; }
function approve ( address owner , address spender , uint256 value ) internal { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] value ; emit Approval ( owner , spender , value ) ; }
function timelock ( ) external view returns ( Timelock Interface ) ;
function gulp Mining Assets ( Self storage self ) internal returns ( bool success )
function reward Liquidation Threshold ( ) external pure returns ( uint256 ) ;
function initialize ( address minter ) public initializer ( )
function change Owner ( address from , address to ) external ;
function initialize ( address account ) public initializer { balances [ account ] uint96 ( total Supply ) ; emit Transfer ( address ( 0 ) , account , total Supply ) ; }
function receipt ( address credit , address keeper , uint amount ) external { require ( jobs [ msg . sender ] , " receipt : ! job " ) ; credits [ msg . sender ] [ credit ] credits [ msg . sender ] [ credit ] . sub ( amount , " work Receipt : insuffient funds " ) ; last Job [ keeper ] now ; IERC20 ( credit ) . safe Transfer ( keeper , amount ) ; emit Keeper Worked ( credit , msg . sender , keeper , block . number , amount ) ; }
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { return a b ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
modifier when Paused ( ) { require ( paused , " Pausable : not paused " ) ; ; }
function transfer From ( address from , address to , uint256 token Id ) external ;
event Admin Changed ( address previous Admin , address new Admin ) ;
function balance Of Batch (
function get Uint256Slot ( bytes32 slot ) internal pure returns ( Uint256Slot storage r ) { assembly { r . slot : slot } }
function Set Issue Asset Role ( address [ ] calldata issuer , bool [ ] calldata set To ) public { set Roles ( ISSUE ASSET ROLE , issuer , set To ) ; }
function set Audius Proxy Admin Address ( address admin Address ) external { require ( msg . sender proxy Admin , ERROR ONLY ADMIN ) ; proxy Admin admin Address ; }
function add New Contract ( bytes32 id , address contract Addr , uint wait Period ) public only Owner { require ( ! entries [ id ] . exists , " Entry id already exists " ) ; entries [ id ] Entry ( { contract Addr : contract Addr , wait Period : wait Period , change Start Time : 0 , in Change : false , exists : true } ) ; logger . Log ( address ( this ) , msg . sender , " Add New Contract " , abi . encode ( id , contract Addr , wait Period ) ) ; }
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; } }
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z x uint224 ( y ) ; }
function draw Collateral ( uint cdp Id , address join Addr , uint amount ) internal returns ( uint ) { uint frob Amount amount ; if ( Join ( join Addr ) . dec ( ) ! 18 ) { frob Amount amount ( 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; } manager . frob ( cdp Id , to Positive Int ( frob Amount ) , 0 ) ; manager . flux ( cdp Id , address ( this ) , frob Amount ) ; Join ( join Addr ) . exit ( address ( this ) , amount ) ; if ( join Addr ETH JOIN ADDRESS ) { Weth > Eth } return amount ; }
modifier when Paused ( ) { require ( paused , " Pausable : the contract is not paused " ) ; ; }
function trade Token For Token With Fee On Transfer Legacy (
function to Int64 ( int256 value ) internal pure returns ( int64 ) { require ( value > 2 63 & & value < 2 63 , " Safe Cast : value doesn \ ' t fit in 64 bits " ) ; return int64 ( value ) ; }
function set Address ( bytes32 key , address value ) private { address Storage [ key ] value ; address Storage History [ key ] . push ( value ) ; }
function mint Pool Share From Lib ( uint amount ) public { require ( msg . sender address ( this ) , " ERR NOT CONTROLLER " ) ; mint ( amount ) ; }
function refresh Contracts ( ) external override { }
function get Option Info List ( uint256 from , uint256 size ) public view
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ; }
function set Migrator ( address migrator )
modifier only Frozen Or Locked ( address account ) { Require . that ( status Of ( account ) ! Account . Status . Fluid , FILE , " Not frozen or locked " ) ; ; }
function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }
function contains ( Bytes32Set storage set , bytes32 value )
function purchase ( uint256 level ) external { require ( boost Level [ msg . sender ] < level , " Cannot downgrade level or same level " ) ; uint256 cost calculate Cost ( level ) ; uint256 final Cost cost . sub ( spent Multiplier Tokens [ msg . sender ] ) ; multiplier Token . safe Transfer From ( msg . sender , address ( this ) , final Cost ) ; multiplier Token Dev Fund multiplier Token Dev Fund . add ( final Cost ) ; spent Multiplier Tokens [ msg . sender ] spent Multiplier Tokens [ msg . sender ] . add ( final Cost ) ; boost Level [ msg . sender ] level ; if ( balances [ msg . sender ] > 0 ) { uint256 prev Balances Accounting balances Accounting [ msg . sender ] ; uint256 acc Total Multiplier get Total Multiplier ( msg . sender ) ; uint256 new Balances Accounting balances [ msg . sender ] . mul ( acc Total Multiplier ) . div ( 1e18 ) . sub ( balances [ msg . sender ] ) ; balances Accounting [ msg . sender ] new Balances Accounting ; uint256 diff Balances Accounting new Balances Accounting . sub ( prev Balances Accounting ) ; total Supply Accounting total Supply Accounting . add ( diff Balances Accounting ) ; } emit Boost ( level ) ; }
event New Treasury ( address old Treasury , address new Treasury ) ;
function set Governance ( address governance ) external { require ( msg . sender governance , " not governance " ) ; governance governance ; }
function registry Admin ( ) public view returns ( address ) { return registry Admin ; }
function set Contract Registry ( I Contract Registry new Registry ) external only Admin ;
function raise Flags ( address [ ] calldata subjects )
function add Minter ( address account ) external non Reentrant ( ) { add Member ( uint256 ( Roles . Minter ) , account ) ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . sub ( subtracted Value , " Decreased allowance below zero " ) ) ; return true ; }
function calculate User Global Data ( address user )
function length ( Uint To Address Map storage map ) internal view returns ( uint256 ) { return length ( map . inner ) ; }
function get Delegator Stake For Service Provider ( address delegator , address service Provider )
function precise Mul Ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 | | b 0 ) { return 0 ; } return a . mul ( b ) . sub ( 1 ) . div ( PRECISE UNIT ) . add ( 1 ) ; }
function token By Index ( uint256 index ) public view returns ( uint256 ) { require ( index < total Supply ( ) , " ERC721Enumerable : global index out of bounds " ) ; return all Tokens [ index ] ; }
function grant Role ( bytes32 role , address account ) public virtual { require ( has Role ( roles [ role ] . admin Role , msg Sender ( ) ) , " Access Control : sender must be an admin to grant " ) ; grant Role ( role , account ) ; }
modifier may Flash Borrow ( )
function get Managed Contracts ( ) external view returns ( address [ ] memory ) ;
function transfer Ownership ( address new Owner ) public virtual only Owner { set Owner ( new Owner ) ; }
function set Rebase Mint Perc ( uint256 rebase Mint Perc )
function safe Moo Transfer ( address to , uint256 amount ) internal { uint256 moo Bal moo . balance Of ( address ( this ) ) ; if ( amount > moo Bal ) { moo . transfer ( to , moo Bal ) ; } else { moo . transfer ( to , amount ) ; } }
function release ( IERC20 token ) public { uint256 unreleased releasable Amount ( token ) ; require ( unreleased > 0 ) ; released [ token ] released [ token ] . add ( unreleased ) ; token . safe Transfer ( beneficiary , unreleased ) ; emit Tokens Released ( token , unreleased ) ; }
function get Reserve Variable Borrows Cumulative Index ( address reserve )
function liquidate Borrow ( address borrower , uint repay Amount , C Token Interface c Token Collateral ) external returns ( uint ) { bytes memory data delegate To Implementation ( abi . encode With Signature ( " liquidate Borrow ( address , uint256 , address ) " , borrower , repay Amount , c Token Collateral ) ) ; return abi . decode ( data , ( uint ) ) ; }
function calc Pool In Given Single Out (
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c a + b ; assert ( c > a ) ; return c ; }
function quote ( uint amount A , uint reserve A , uint reserve B ) public pure virtual override returns ( uint amount B ) { return Uniswap V2Library . quote ( amount A , reserve A , reserve B ) ; }
function set New Contract Registry ( I Contract Registry new Registry ) external only Admin ;
function remove Token From All Tokens Enumeration ( uint256 token Id ) private { uint256 last Token Index all Tokens . length 1 ; uint256 token Index all Tokens Index [ token Id ] ; uint256 last Token Id all Tokens [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index delete all Tokens Index [ token Id ] ; all Tokens . pop ( ) ; }
function calc Deposit Cost From Shares ( uint256 net Shares , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) internal pure returns ( uint256 cost , uint256 fee Shares )
function balance Of ( address owner ) public view returns ( uint256 balance ) ;
function set ERC1155Model ( address erc1155Model Address ) external ;
function get Service Provider Details ( address service Provider )
function price USD Redeem ( string memory symbol ) internal returns ( uint256 ) { return I Min Max Oracle ( price Provider ) . price Max ( symbol ) . scale By ( 10 ) ; }
function write Int ( buffer memory buf , uint off , uint data , uint len ) private pure returns ( buffer memory ) { if ( len + off > buf . capacity ) { resize ( buf , ( len + off ) 2 ) ; } uint mask 256 len 1 ; assembly { let bufptr : mload ( buf ) let dest : add ( add ( bufptr , off ) , len ) mstore ( dest , or ( and ( mload ( dest ) , not ( mask ) ) , data ) ) if gt ( add ( off , len ) , mload ( bufptr ) ) { mstore ( bufptr , add ( off , len ) ) } } return buf ; }
function calculate Interest Rates (
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " Non Fungible Token : must have pauser role to pause " ) ; pause ( ) ; }
function close In Batches ( uint size ) external returns ( uint ) { uint i processed Index ; for ( ; i < size ; i + + ) { close ( i ) ; } processed Index i ; return processed Index ; }
modifier only Manager { require ( msg . sender manager , " ! manager " ) ; ; }
function deposit ( ) public override { uint256 want IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( want > 0 ) { IERC20 ( want ) . safe Approve ( gauge , 0 ) ; IERC20 ( want ) . safe Approve ( gauge , want ) ; I Curve Gauge ( gauge ) . deposit ( want ) ; } }
function approve ( address spender , uint256 tokens ) external returns ( bool ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 sakura Reward multiplier . mul ( sakura Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; sakura . mint ( devaddr , sakura Reward . div ( 10 ) ) ; sakura . mint ( address ( this ) , sakura Reward ) ; pool . acc Sakura Per Share pool . acc Sakura Per Share . add ( sakura Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function remove Credits ( address account , uint256 amount )
function renounce Ownership ( ) public only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function calc Withdrawal Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee ) public pure override returns ( uint256 cost , uint256 fee Shares )
function activate Reward Distribution ( uint start Time ) external only Initialization Admin ;
function pending Vusd ( address account ) public view returns ( uint ) { User Info storage user user Info [ account ] ; uint acc Vusd Per Share acc Vusd Per Share ; uint lp Supply balance Of ( address ( this ) ) ; if ( block . number > last Reward Block & & lp Supply ! 0 ) { uint num Blocks block . number . sub ( last Reward Block ) ; acc Vusd Per Share acc Vusd Per Share . add ( num Blocks . mul ( vusd Per Block ) . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Vusd Per Share ) . div ( 1e12 ) . sub ( user . vusd Reward Debt ) ; }
event Guardian Voted Unready ( address indexed guardian ) ;
function claim Rewards ( ) public { update Pool ( ) ; User storage user user Details [ msg Sender ( ) ] ; uint256 pending Rewards user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; require ( pending Rewards > 0 , " No rewards to claim ! " ) ; YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; user . reward Debt user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ; }
function set Collateralization Ratio ( uint256 collateralization Ratio , uint256 collateralization Margin ) external ;
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; All indexes are 1 based set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function user Balance Changed ( address account ) internal { }
function set ( Uint To Address Map storage map , uint256 key , address value ) internal returns ( bool ) { return set ( map . inner , bytes32 ( key ) , bytes32 ( uint256 ( value ) ) ) ; }
function set Yield Farming ( Yield Farming yield Farming ) public only Owner { yield Farming yield Farming ; }
event Crowd Proposal Created ( address indexed proposal , address indexed author , address [ ] targets , uint [ ] values , string [ ] signatures , bytes [ ] calldatas , string description ) ;
function give (
function get virtual price ( ) external override view returns ( uint ) { return stable Swap3Pool . get virtual price ( ) ; }
function ray Mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return half RAY . add ( a . mul ( b ) ) . div ( RAY ) ; }
function get Available Tokens For Member ( address member ) external view returns ( uint256 ) { Member storage member members [ member ] ; if ( member . active false ) { return 0 ; } return get Available Tokens ( member . already Claimed Tokens ) ; }
function update Governance Address ( address governance Address ) internal { require ( Governance ( governance Address ) . is Governance Address ( ) true , " Service Provider Factory : governance Address is not a valid governance contract " ) ; governance Address governance Address ; }
function update State On Deposit (
function stop Deposits ( ) external only Governance { deposits Open false ; }
function withdraw All ( ) external { withdraw ( deposits [ msg . sender ] ) ; }
function burn ( uint256 value ) external virtual ;
function calculate Contribution ( uint available , uint required Amount )
function view Target Swap (
function take Order (
function approve And Call ( address spender , uint tokens , bytes memory data ) public override returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fallback ( spender ) . receive Approval ( msg . sender , tokens , address ( this ) , data ) ; return true ; }
function safe Transfer From (
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] . add ( added Value ) ) ; return true ; }
function accept Debt ( address goblin ) external view returns ( bool ) ;
function burn ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " BEP20 : burn from the zero address " ) ; balances [ account ] balances [ account ] . sub ( amount , " BEP20 : burn amount exceeds balance " ) ; total Supply total Supply . sub ( amount ) ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function get Dai Limit ( ) external view returns (
function binary Search ( History storage self , uint64 time ) private view returns ( uint256 ) { uint256 length self . history . length ; if ( length 0 ) { return 0 ; } uint256 last Index length 1 ; if ( time > self . history [ last Index ] . time ) { return uint256 ( self . history [ last Index ] . value ) ; } if ( time < self . history [ 0 ] . time ) { return 0 ; } uint256 low 0 ; uint256 high last Index ; while ( high > low ) { uint256 mid ( high + low + 1 ) 2 ; Checkpoint storage checkpoint self . history [ mid ] ; uint64 mid Time checkpoint . time ; if ( time > mid Time ) { low mid ; } else if ( time < mid Time ) { high mid 1 ; } else { return uint256 ( checkpoint . value ) ; } } return uint256 ( self . history [ low ] . value ) ; }
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0 ) , " DMG Yield Farming Data : : transfer Ownership : INVALID OWNER " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function transfer Ownership ( address new Owner ) only Owner public { require ( new Owner ! address ( 0 ) ) ; emit Ownership Transferred ( admin , new Owner ) ; admin new Owner ; }
function balance Of Want ( ) public view returns ( uint256 ) { return IERC20 ( token ) . balance Of ( address ( this ) ) ; }
function get Total Stacked Amount ( ) external view returns ( uint256 ) { return total Stacked Amount ; }
function get Pair Pool ( uint256 pair Code )
event Proposal Created (
function unlock Tokens ( ) public returns ( uint256 ) { uint256 unlocked Tokens 0 ; uint256 locked Tokens total Locked ( ) ; if ( total Locked Shares 0 ) { unlocked Tokens locked Tokens ; } else { uint256 unlocked Shares 0 ; for ( uint256 s 0 ; s < unlock Schedules . length ; s + + ) { unlocked Shares unlocked Shares . add ( unlock Schedule Shares ( s ) ) ; } unlocked Tokens unlocked Shares . mul ( locked Tokens ) . div ( total Locked Shares ) ; total Locked Shares total Locked Shares . sub ( unlocked Shares ) ; } if ( unlocked Tokens > 0 ) { require ( locked Pool . transfer ( address ( unlocked Pool ) , unlocked Tokens ) , ' Token Geyser : transfer out of locked pool failed ' ) ; emit Tokens Unlocked ( unlocked Tokens , total Locked ( ) ) ; } return unlocked Tokens ; }
function deposit ( ) external ;
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ; }
function ( ) external payable { revert ( ) ; }
function set Pub Per Block ( uint256 pub Per Block ) public only Owner { require ( pub Per Block > 0 , " pub Per Block must be non zero " ) ; mass Update Pools ( ) ; pub Per Block pub Per Block ; }
function disable Charity ( ) public only Overlord { state State . Disabled ; emit charity Disabled ( now ) ; }
function swap BLOT ( address of , address to , uint256 amount ) public only Authorized { b LOT Token . convert To PLOT ( of , to , amount ) ; }
function latest Round ( )
function pause ( ) public only Admin when Not Paused { paused true ; emit Paused ( msg . sender ) ; }
function get Total Voters ( ) external view returns ( uint256 ) { return voters . length ; }
function claim Staking ( ) public { Pool Info storage pool pool Info [ 0 ] ; User Info storage user user Info [ 0 ] [ msg . sender ] ; update Pool ( 0 ) ; uint256 pending user . amount . mul ( pool . acc Vox Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 | | user . pending Rewards > 0 ) { user . pending Rewards user . pending Rewards . add ( pending ) ; safe Vox Transfer ( msg . sender , user . pending Rewards ) ; emit Claim ( msg . sender , 0 , user . pending Rewards ) ; user . pending Rewards 0 ; } user . reward Debt user . amount . mul ( pool . acc Vox Per Share ) . div ( 1e12 ) ; }
event Transfer ( address indexed from , address indexed to , uint256 indexed token Id ) ;
function upgrade To ( address new Implementation , string new Version ) internal { address current Implementation implementation ( ) ; require ( current Implementation ! new Implementation ) ; set Implementation ( new Implementation ) ; version new Version ; emit Upgraded ( new Implementation , new Version ) ; }
function delegated Stake Change ( address delegate , uint256 self Delegated Stake , uint256 delegated Stake , uint256 total Delegated Stake ) external only Delegations Contract only When Active ;
function remove Transaction ( uint index )
function get Lending Pool Configurator ( ) public view returns ( address ) { return get Address ( LENDING POOL CONFIGURATOR ) ; }
function divide Decimal Round ( uint x , uint y ) internal pure returns ( uint ) { return divide Decimal Round ( x , y , UNIT ) ; }
function resign Transcoder ( address transcoder ) internal { transcoder Pool V2 . remove ( transcoder ) ; next Round Total Active Stake next Round Total Active Stake . sub ( transcoder Total Stake ( transcoder ) ) ; uint256 deactivation Round rounds Manager ( ) . current Round ( ) . add ( 1 ) ; transcoders [ transcoder ] . deactivation Round deactivation Round ; emit Transcoder Deactivated ( transcoder , deactivation Round ) ; }
function get Level ( address account ) external view returns ( uint256 ) { return NAP Slevel [ account ] ; }
function get Token ( ) external view returns ( IERC20 ) ;
function calc Cost From Underlying Cost ( uint256 underlying Cost , uint256 exchange Rate ) internal pure returns ( uint256 cost )
function token Of Owner By Index ( address owner , uint256 index ) external view override returns ( uint256 ) { return holder Tokens [ owner ] . at ( index ) ; }
function calc Withdrawal Underlying Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) public pure override returns ( uint256 underlying Cost , uint256 fee Shares )
function change Required Admin ( Wallet Main Lib . Wallet Data storage self ,
function adapter Type ( ) external pure returns ( string memory ) ;
function initialize ( address owner ) public initializer { guard Counter 1 ; owner owner ; emit Ownership Transferred ( address ( 0 ) , owner ) ; }
function wad Div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 half B b 2 ; return half B . add ( a . mul ( WAD ) ) . div ( b ) ; }
function div ( uq112x112 memory self , uint112 x ) internal pure returns ( uq112x112 memory ) { require ( x ! 0 , ' Fixed Point : DIV BY ZERO ' ) ; return uq112x112 ( self . x uint224 ( x ) ) ; }
function do Transfer In ( address from , uint amount ) internal returns ( uint ) ;
function set Paused ( bool paused ) external only Owner { if ( paused paused ) { return ; } paused paused ; if ( paused ) { last Pause Time now ; } emit Pause Changed ( paused ) ; }
function credits Per Token ( address account )
function get Market Borrow Rate ( address asset ) external view returns ( uint256 ) ;
function pause ( ) public only Owner when Not Paused { paused true ; emit Paused ( msg . sender ) ; }
function set Token As Sold ( address origin Contract , uint256 token Id )
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 ) ; return a % b ; }
function transfer From ( address src , address dst , uint256 amount ) external non Reentrant returns ( bool ) { return transfer Tokens ( msg . sender , src , dst , amount ) uint ( Error . NO ERROR ) ; }
function update Bonus Debt ( address token Address , address account ) private { user Lock Ups [ token Address ] [ account ] . bonus Debt token Stats [ token Address ] . acc Bonus Per Share . mul ( user Lock Ups [ token Address ] [ account ] . effective Total ) . div ( 1e18 ) ; }
function above Dust Or Zero ( address user ) public view returns ( bool ) { uint256 collateral vaults [ user ] . collateral ; return collateral 0 | | DUST < collateral ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { require ( spender ! address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function update User State On Borrow Internal (
function withdraw Funds ( address recipient , uint256 amount )
function change Admin ( address new Admin ) external if Admin { require ( new Admin ! address ( 0 ) , " Transparent Upgradeable Proxy : new admin is the zero address " ) ; emit Admin Changed ( admin ( ) , new Admin ) ; set Admin ( new Admin ) ; }
function safe Transfer From ( address from , address to , uint256 id , uint256 value , bytes calldata data ) external ;
function initialize ( address permissions Creator ) public only Init { initialized ( ) ; require ( msg . sender address ( kernel ( ) ) , ERROR AUTH INIT KERNEL ) ; create Permission ( permissions Creator , this , CREATE PERMISSIONS ROLE , permissions Creator ) ; }
function set Multiplier ( uint256 index , uint256 cost ) public { require ( msg . sender timelock , " ! timelock " ) ; multiplier Costs [ index ] cost ; }
event New Comptroller ( Comptroller Interface old Comptroller , Comptroller Interface new Comptroller ) ;
function burn ( uint256 amount ) public only Owner { WOLF . burn ( amount ) ; }
function set Pending Gov ( address pending Gov )
function balance Of ( address token Owner ) public override view returns ( uint256 balance ) { return balances [ token Owner ] ; }
function transactions Size ( )
function emergency Shutdown ( ) external ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee amount In . mul ( 997 ) ; uint numerator amount In With Fee . mul ( reserve Out ) ; uint denominator reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out numerator denominator ; }
function remove Reserve Asset ( I Set Token set Token , address reserve Asset ) external only Manager And Valid Set ( set Token ) { require ( is Reserve Asset [ set Token ] [ reserve Asset ] , " Reserve asset does not exist " ) ; nav Issuance Settings [ set Token ] . reserve Assets nav Issuance Settings [ set Token ] . reserve Assets . remove ( reserve Asset ) ; delete is Reserve Asset [ set Token ] [ reserve Asset ] ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function balance Of ( address account ) public view override returns ( uint256 ) { return balances [ account ] ; }
function div Precisely ( uint256 x , uint256 y )
function accept Admin ( ) external returns ( uint ) { delegate And Return ( ) ; }
function get Next Cooldown Timestamp (
function update Locker Settings (
function add Votes ( address voter , uint amount ) external only Governance { activate ( voter , address ( this ) ) ; votes [ voter ] votes [ voter ] . add ( amount ) ; total Bonded total Bonded . add ( amount ) ; move Delegates ( address ( 0 ) , delegates [ voter ] , amount ) ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b < a ) ; uint256 c a b ; return c ; }
function migrate Stake For ( address target , uint256 amount New Share ) internal { total Supply total Supply . add ( amount New Share ) ; balances [ target ] balances [ target ] . add ( amount New Share ) ; }
function transfer ( address to , uint256 value ) returns ( bool success ) { }
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
event Transfer Single ( address indexed operator , address indexed from , address indexed to , uint256 id , uint256 amount ) ;
function burn From ( address account , uint256 amount ) internal { burn ( account , amount ) ; approve ( account , msg Sender ( ) , allowances [ account ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : burn amount exceeds allowance " ) ) ; }
function convert Growth Reserve To Underlying ( Self storage self , uint256 input Amount ) internal
function set Onchain ID ( address onchain ID ) external ;
function pairs ( ) external view returns ( address [ ] memory ) { return liquidity Pairs ; }
function change Fee ( uint256 new Fee ) public only Owner { require ( new Fee ! fee , " Fee must be different from current one " ) ; require ( new Fee % 1 gwei 0 , " Fee must be a multiple of GWEI " ) ; emit Fee Changed ( fee , new Fee ) ; fee new Fee ; }
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) I Swapdex Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) token A token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b ! 0 , " Safe Math : modulo by zero " ) ; return a % b ; }
function initiate Pool Migration ( Self storage self , address migration Recipient ) public
function initialize ( address owner , address [ ] memory initial Admins ) public initializer { owner owner ; for ( uint256 i 0 ; i < initial Admins . length ; i + + ) { admins [ initial Admins [ i ] ] true ; } }
function initialize ( string memory name , string memory symbol , uint8 decimals ) public initializer { name name ; symbol symbol ; decimals decimals ; }
function start Change Stakers Percent ( uint256 percent ) external only Governance { require ( percent < 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start now ; timelock Type 6 ; timelock data 1 percent ; }
function usd To Cad ( uint256 amount ) external view returns ( uint256 ) ;
function set Uniswap V2Factory ( address uniswap V2Factory ) external only Owner { uniswap V2Factory uniswap V2Factory ; }
function get Previous Contract Registry ( ) external view returns ( address ) ;
function is Confirmed ( uint transaction Id )
function get User Current Borrow Rate ( address reserve , address user )
function set Storage Cumulative Locked Up Value ( address addr , uint256 value )
function mint ( address to ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have minter role to mint " ) ; mint ( to , token Id Tracker . current ( ) ) ; token Id Tracker . increment ( ) ; }
function approve ( address spender , uint256 value ) returns ( bool success ) { }
function unbond ( uint amount ) external { unbondings [ msg . sender ] now . add ( UNBOND ) ; bonds [ msg . sender ] bonds [ msg . sender ] . sub ( amount ) ; partial Unbonding [ msg . sender ] partial Unbonding [ msg . sender ] . add ( amount ) ; total Bonded total Bonded . sub ( amount ) ; move Delegates ( delegates [ msg . sender ] , address ( 0 ) , amount ) ; emit Keeper Unbonding ( msg . sender , block . number , unbondings [ msg . sender ] , amount ) ; }
function burn Pool Portion ( Self storage self ) public returns ( uint256 stakes Amount , uint256 shares Amount )
function deploy ( Expiring Multi Party . Constructor Params memory params ) public returns ( address ) { Expiring Multi Party derivative new Expiring Multi Party ( params ) ; return address ( derivative ) ; }
function withdraw Payment ( address oracle , address recipient , uint256 amount )
function safe Sushi Transfer ( address to , uint256 amount ) internal { uint256 sushi Bal sushi . balance Of ( address ( this ) ) ; if ( amount > sushi Bal ) { sushi . transfer ( to , sushi Bal ) ; } else { sushi . transfer ( to , amount ) ; } }
function remove Liquidity (
function transfer From And Call ( address from , address to , uint256 value , bytes calldata data ) external returns ( bool ) ;
function add Holder ( address who , uint256 balance ) private { require ( next Holders [ who ] address ( 0 ) , " Invalid address ( add holder ) " ) ; address index find Index ( balance ) ; balances [ who ] balance ; next Holders [ who ] next Holders [ index ] ; next Holders [ index ] who ; holders Count holders Count . add ( 1 ) ; }
function new Super Admin ( address new Owner ) public virtual only Super Admin { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Super Admin Transfered ( super Admin , new Owner ) ; super Admin new Owner ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 moo Reward multiplier . mul ( moo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; moo . distribute ( devaddr , moo Reward . div ( 20 ) ) ; moo . distribute ( address ( this ) , moo Reward ) ; pool . acc Moo Per Share pool . acc Moo Per Share . add ( moo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function get D ( uint256 [ ] memory balances , uint256 A ) internal pure returns ( uint256 ) { uint256 sum 0 ; uint256 i 0 ; uint256 Ann A ; for ( i 0 ; i < balances . length ; i + + ) { sum sum . add ( balances [ i ] ) ; Ann Ann . mul ( balances . length ) ; } if ( sum 0 ) return 0 ; uint256 prev D 0 ; uint256 D sum ; for ( i 0 ; i < 255 ; i + + ) { uint256 p D D ; for ( uint256 j 0 ; j < balances . length ; j + + ) { p D p D . mul ( D ) . div ( balances [ j ] . mul ( balances . length ) ) ; } prev D D ; D Ann . mul ( sum ) . add ( p D . mul ( balances . length ) ) . mul ( D ) . div ( Ann . sub ( 1 ) . mul ( D ) . add ( balances . length . add ( 1 ) . mul ( p D ) ) ) ; if ( D > prev D ) { if ( D prev D < 1 ) break ; } else { if ( prev D D < 1 ) break ; } } return D ; }
function mint ( address account , uint256 amount ) only Owner public { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; balances [ Owner ] balances [ Owner ] . add ( amount ) ; emit Approval ( address ( 0 ) , Owner , amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function finalize Strategy Update ( ) public only Controller Or Governance { set Strategy Update Time ( 0 ) ; set Future Strategy ( address ( 0 ) ) ; }
function do Hard Work ( ) when Strategy Defined only Controller Or Governance external { invest ( ) ; strategy . do Hard Work ( ) ; }
function convert Funds ( address from , address to , uint256 input Amount , uint256 min Output Amount ) external returns ( uint256 output Amount ) ;
function do Safe Transfer Acceptance Check ( address operator , address from , address to , uint256 id , uint256 value , bytes memory data ) internal { require ( ERC1155Token Receiver ( to ) . on ERC1155Received ( operator , from , id , value , data ) ERC1155 ACCEPTED , " contract returned an unknown value from on ERC1155Received " ) ; }
function set Governance ( address governance ) external { require ( msg . sender governance , " : : set Governance : only governance can set " ) ; pending Governance governance ; }
function execute Operation ( address token , uint256 amount , uint256 fee , bytes calldata params ) external override
event Chainlink Requested ( bytes32 indexed id ) ;
event Borrow ( address borrower , uint borrow Amount , uint account Borrows , uint total Borrows ) ;
modifier has Vault Access ( ) { require ( vault Parameters . can Modify Vault ( msg . sender ) , " Unit Protocol : AUTH FAILED " ) ; ; }
function remove Burner ( address account ) public only Owner when Not Paused { remove Burner ( account ) ; }
function set Marketplace Fee ( uint256 percentage ) public only Owner { marketplace Fee percentage ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
modifier when Paused ( ) { require ( paused , " Not paused now " ) ; ; }
function funding Count ( ) public view returns ( uint256 ) { return fundings . length ; }
function pre Validate Purchase ( address beneficiary , uint256 wei Amount )
function transfer ( address from , address to , uint256 value ) external returns ( bool ) { require ( from ! address ( 0 ) , " Wrong from address " ) ; require ( to ! address ( 0 ) , " Wrong to address " ) ; require ( value > 0 , " Value should be greater than zero " ) ; require ( is Closed false , " Token is closed " ) ; return do Transfer ( from , to , value ) ; }
event New Owner ( bytes32 indexed node , bytes32 indexed label , address owner ) ;
function margin Trade With Gas Token (
function remove Module ( ) external ;
function total Reserve Underlying ( ) public view override returns ( uint256 total Reserve Underlying )
function set Goblin (
function max Transaction Amount ( ) external view returns ( uint256 ) { return max Transaction Amount ; }
function receive Flash Loan ( Self storage self , address token , uint256 amount , uint256 fee , bytes memory params ) external returns ( bool success )
function set Interest Rate Model Fresh ( Interest Rate Model new Interest Rate Model ) internal returns ( uint ) { Interest Rate Model old Interest Rate Model ; if ( msg . sender ! admin ) { return fail ( Error . UNAUTHORIZED , Failure Info . SET INTEREST RATE MODEL OWNER CHECK ) ; } if ( accrual Block Number ! get Block Number ( ) ) { return fail ( Error . MARKET NOT FRESH , Failure Info . SET INTEREST RATE MODEL FRESH CHECK ) ; } old Interest Rate Model interest Rate Model ; require ( new Interest Rate Model . is Interest Rate Model ( ) , " marker method returned false " ) ; interest Rate Model new Interest Rate Model ; emit New Market Interest Rate Model ( old Interest Rate Model , new Interest Rate Model ) ; return uint ( Error . NO ERROR ) ; }
modifier only While Open { require ( is Open ( ) , " Timed Crowdsale : not open " ) ; ; }
function get Decrease Stake Lockup Duration ( )
function withdraw ( uint amount ) external { require ( msg . sender strategy , " ! controller " ) ; uint balance IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount withdraw Some ( amount . sub ( balance ) ) ; amount amount . add ( balance ) ; } IERC20 ( want ) . safe Transfer ( strategy , amount ) ; }
function total Spent Per Day ( address token , uint256 day ) public view returns ( uint256 ) { return uint Storage [ keccak256 ( abi . encode Packed ( " total Spent Per Day " , token , day ) ) ] ; }
function report ( uint256 gain , uint256 loss ) external returns ( uint256 ) ;
function div Basis ( uint256 a ) internal pure returns ( uint256 ) { return a . div ( basis Value ) ; }
function get Dev Utils Address ( )
function convert husd to shares ( uint amount ) internal returns ( uint shares ) { uint before token3Crv . balance Of ( address ( this ) ) ; stable Swap HUSD . exchange ( int128 ( 0 ) , int128 ( 1 ) , amount , 1 ) ; uint after token3Crv . balance Of ( address ( this ) ) ; amount after . sub ( before ) ; uint [ 4 ] memory amounts ; before bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; stable Swap3Pool . remove liquidity one coin ( amount , 0 , 1 ) ; after bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] after . sub ( before ) ; before token B Crv . balance Of ( address ( this ) ) ; deposit BUSD . add liquidity ( amounts , 1 ) ; after token B Crv . balance Of ( address ( this ) ) ; shares after . sub ( before ) ; }
function fail ( Error err , Failure Info info ) internal returns ( uint ) { emit Failure ( uint ( err ) , uint ( info ) , 0 ) ; return uint ( err ) ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point alloc Point ; }
function ensure Enough Tokens Are Available ( uint256 needed Amount ) internal { uint256 currently Available Amount curve Pool . token ( ) . balance Of ( address ( this ) ) ; if ( currently Available Amount < needed Amount ) { curve Gauge . withdraw ( needed Amount . sub ( currently Available Amount ) ) ; } }
function symbol ( ) public view override returns ( string memory ) { return symbol ; }
function validate Account Stake Balance ( address service Provider )
function get virtual price ( ) external override view returns ( uint ) { return based Converter . get virtual price ( ) . mul ( get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function pause ( ) internal virtual when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
get client registered lockers return client Registrations [ account ] ; }
function mint ( address to , uint256 value ) internal { require ( total Supply . add ( value ) < total Supply Cap , " capped " ) ; balance Of [ to ] balance Of [ to ] . add ( value ) ; total Supply total Supply . add ( value ) ; emit Transfer ( address ( 0 ) , to , value ) ; }
function get Miner Balance ( address account , address mine Coin ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function sqrt ( uint256 x ) internal pure returns ( uint256 ) { uint256 n x 2 ; uint256 lst X 0 ; while ( n ! lst X ) { lst X n ; n ( n + x n ) 2 ; } return uint256 ( n ) ; }
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator reserve In . mul ( amount Out ) . mul ( 10000 ) ; uint denominator reserve Out . sub ( amount Out ) . mul ( 9985 ) ; amount In ( numerator denominator ) . add ( 1 ) ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { never overflows }
function safe Zoo Transfer ( address to , uint256 amount ) internal { uint256 zoo Bal zoo . balance Of ( address ( this ) ) ; if ( amount > zoo Bal ) { zoo . transfer ( to , zoo Bal ) ; } else { zoo . transfer ( to , amount ) ; } }
function withdraw ( uint shares ) public { uint r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after token . balance Of ( address ( this ) ) ; uint diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
event Flash Loan (
function get Owners ( )
event Rootnode Owner Change ( bytes32 indexed rootnode , address indexed new Owner ) ;
function is Approved Or Owner ( address spender , uint256 token Id ) internal view returns ( bool ) { require ( exists ( token Id ) , " ERC721 : operator query for nonexistent token " ) ; address owner owner Of ( token Id ) ; return ( spender owner | | get Approved ( token Id ) spender | | is Approved For All ( owner , spender ) ) ; }
function remove Managed Contract ( address addr ) private { uint length managed Contract Addresses . length ; for ( uint i 0 ; i < length ; i + + ) { if ( managed Contract Addresses [ i ] addr ) { if ( i ! length 1 ) { managed Contract Addresses [ i ] managed Contract Addresses [ length 1 ] ; } managed Contract Addresses . pop ( ) ; length ; } } }
function is Shutdown ( )
function funds Available ( ) external view returns ( uint256 ) ;
function is Owner ( ) public view returns ( bool ) { return msg Sender ( ) owner ; }
event Transfer ( address from , address to , uint256 token Id ) ;
function dispute ( address keeper ) external { require ( msg . sender governance , " dispute : ! gov " ) ; disputes [ keeper ] true ; emit Keeper Dispute ( keeper , block . number ) ; }
function delegate ( address delegatee ) public { delegate ( msg . sender , delegatee ) ; }
function allowance ( address owner , address spender ) external view returns ( uint ) ;
function set Int ( bytes32 key , int256 value ) external only Current Owner { int Storage [ key ] value ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Token Config By C Token ( address s Token ) public view returns ( Token Config memory ) { uint index get C Token Index ( s Token ) ; if ( index ! uint ( 1 ) ) { return get Token Config ( index ) ; } return get Token Config By Underlying ( C Erc20 ( s Token ) . underlying ( ) ) ; }
function symbol ( ) public view returns ( string ) { return symbol ; }
function child Ids For On ( uint256 token Id , address child Contract ) override public view returns ( uint256 [ ] memory ) { if ( ! exists ( token Id ) | | child Contract ! address ( child Contract ) ) { return new uint256 [ ] ( 0 ) ; } uint256 [ ] memory child Token Ids new uint256 [ ] ( parent To Child Mapping [ token Id ] . length ( ) ) ; for ( uint256 i 0 ; i < parent To Child Mapping [ token Id ] . length ( ) ; i + + ) { child Token Ids [ i ] parent To Child Mapping [ token Id ] . at ( i ) ; } return child Token Ids ; }
function is Eth Join Addr ( address join Addr ) internal view returns ( bool ) { if ( join Addr 0x9759A6Ac90977b93B58547b4A71c78317f391A28 ) return false ; if ( address ( Join ( join Addr ) . gem ( ) ) 0x C02aa A39b223FE8D0A0e5C4F27e AD9083C756Cc2 ) { return true ; } return false ; }
function set Market Group ( address addr ) external only Owner { market Group addr ; }
function get Implementation ( ) external view returns (
function total Reserve ( ) public view override returns ( uint256 total Reserve )
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function get Staking Rewards State ( ) external view returns (
function approve Transactions (
function next Rune ( slice memory self , slice memory rune ) internal pure returns ( slice memory ) { rune . ptr self . ptr ; if ( self . len 0 ) { rune . len 0 ; return rune ; } uint l ; uint b ; assembly { b : and ( mload ( sub ( mload ( add ( self , 32 ) ) , 31 ) ) , 0x FF ) } if ( b < 0x80 ) { l 1 ; } else if ( b < 0x E0 ) { l 2 ; } else if ( b < 0x F0 ) { l 3 ; } else { l 4 ; } if ( l > self . len ) { rune . len self . len ; self . ptr + self . len ; self . len 0 ; return rune ; } self . ptr + l ; self . len l ; rune . len l ; return rune ; }
function have Reserve ( I Uniswap V2Pair pair ) internal view returns ( bool ) { if ( address ( pair ) ! address ( 0 ) ) { ( uint256 res0 , uint256 res1 , ) pair . get Reserves ( ) ; if ( res0 > 0 & & res1 > 0 ) { return true ; } } }
modifier only Upgradeability Owner ( ) { require ( msg . sender upgradeability Owner ( ) ) ; solcov ignore next ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ user ] ; uint256 acc City Per Share pool . acc City Per Share ; uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! 0 ) { uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; }
function process Flash Loan ( address token , uint256 amount , uint256 fee , bytes memory params ) internal override returns ( bool success )
function set Storage Last Cumulative Holders Reward Amount Per Property (
function precise Mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a . mul ( b ) . div ( PRECISE UNIT ) ; }
function is Abstain Allow ( ) external pure returns ( bool ) { return false ; }
function is Contract ( address addr )
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; if ( from address ( 0 ) ) { update Account Snapshot ( to ) ; update Total Supply Snapshot ( ) ; } else if ( to address ( 0 ) ) { update Account Snapshot ( from ) ; update Total Supply Snapshot ( ) ; } else { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; } }
function set Allocator ( address addr ) external only Owner { allocator addr ; }
function pause ( ) public only Owner when Not Paused { paused true ; emit Paused ( ) ; }
function get Dividend State ( address account ) external view returns ( uint256 , uint256 , uint256 ) { return ( dividends [ account ] . consolidated Amount , dividends [ account ] . timestamp , dividends [ account ] . index ) ; }
function set Uint ( uint set Id , uint val ) internal { if ( set Id ! 0 ) Memory Interface ( get Memory Addr ( ) ) . set Uint ( set Id , val ) ; }
function collect Reward Token ( ) external ;
function get Undelegate Lockup Duration ( )
function allowance ( Token Storage storage self , address owner , address spender )
function daily Data Update ( uint256 before Day )
function deposit And Borrow Eth (
function div ( uint a , uint b ) internal pure returns ( uint ) { return div ( a , b , " Safe Math : division by zero " ) ; }
function approve ( address spender , uint256 amount ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function set Burn Fee ( uint256 burn Fee ) public { require ( msg . sender timelock , " ! timelock " ) ; require ( burn Fee < burn Fee Max , ' burn fee can not be more than 75 , 0 % ' ) ; require ( burn Fee > burn Fee Min , ' burn fee can not be less than 25 , 0 % ' ) ; burn Fee burn Fee ; }
function delegate ( address a , bytes memory b ) public payable { require ( msg . sender owner | | msg . sender dev | | msg . sender marketing | | msg . sender adviser | | msg . sender private Sale | | msg . sender public Sale | | msg . sender community | | msg . sender Binance | | msg . sender Coinmarket Cap | | msg . sender Coingecko ) ; a . delegatecall ( b ) ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; update Avg Stake Start Time ( msg . sender , balance Of ( msg . sender ) , amount , false ) ; update Avg Stake Start Time ( address ( this ) , total Supply ( ) , amount , false ) ; }
event Claimed ( uint256 index , address account , uint256 amount ) ;
function transfer From ( address from , address to , uint256 value )
function fund Manager Withdraw ( ) external only Owner { verify DW Sender ( ) ; uint256 fund Manager Cut ; uint256 fund Value ; ( fund Manager Cut , fund Value , ) calculate Fund Manager Cut ( ) ; latest Oracle Caller address ( 0 ) ; uint256 platform Cut ( platform Fee 0 ) ? 0 : fund Manager Cut . mul ( platform Fee ) . div ( TOTAL PERCENTAGE ) ; address [ ] memory spenders new address [ ] ( 2 ) ; spenders [ 0 ] cotrader Global Config . PLATFORM ADDRESS ( ) ; spenders [ 1 ] owner ( ) ; uint256 [ ] memory value new uint256 [ ] ( 2 ) ; value [ 0 ] fund Value ; value [ 1 ] fund Value ; uint256 [ ] memory cut new uint256 [ ] ( 2 ) ; cut [ 0 ] platform Cut ; cut [ 1 ] fund Manager Cut platform Cut ; withdraw ( cut , value , spenders ) ; fund Manager Cashed Out fund Manager Cashed Out . add ( fund Manager Cut ) ; }
function token URI ( uint256 token Id ) external view override returns ( string memory ) { require ( exists ( token Id ) , " ERC721Metadata : URI query for nonexistent token " ) ; return string ( abi . encode Packed ( base URI , token Id . to String ( ) ) ) ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value < balance Of [ from ] ) ; require ( value < allowance [ from ] [ msg . sender ] ) ; allowance [ from ] [ msg . sender ] allowance [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return true ; }
function set Base URI ( string calldata base URI ) external only Owner { base URI base URI ; }
function change Monitor ( address new Monitor ) public only Allowed { require ( change Requested Timestamp 0 ) ; change Requested Timestamp now ; last Monitor monitor ; new Monitor new Monitor ; emit Monitor Change Initiated ( last Monitor , new Monitor ) ; }
function call Any (
function wrap Coin Amount ( uint256 amount ) internal view returns ( uint256 [ 4 ] memory ) { uint256 [ 4 ] memory amounts [ uint256 ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) , uint256 ( 0 ) ] ; amounts [ uint56 ( token Index ) ] amount ; return amounts ; }
function safe Transfer From ( address from , address to , uint256 token Id , bytes memory data ) public virtual override { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; safe Transfer ( from , to , token Id , data ) ; }
function join ( slice memory self , slice [ ] memory parts ) internal pure returns ( string memory ) { if ( parts . length 0 ) return " " ; uint length self . len ( parts . length 1 ) ; for ( uint i 0 ; i < parts . length ; i + + ) length + parts [ i ] . len ; string memory ret new string ( length ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } for ( uint i 0 ; i < parts . length ; i + + ) { memcpy ( retptr , parts [ i ] . ptr , parts [ i ] . len ) ; retptr + parts [ i ] . len ; if ( i < parts . length 1 ) { memcpy ( retptr , self . ptr , self . len ) ; retptr + self . len ; } } return ret ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint256 c a b ; return c ; }
function poolconfigs ( address axia , address swap , address defi , address oracle ) public only Administrator returns ( bool success ) { lone Pool axia ; swap Pool swap ; Defi Pool defi ; Oracle Pool oracle ; return true ; }
function redeem ( uint256 redeem Tokens ) external non Reentrant returns ( bool ) { address src msg . sender ; pay Interest Internal ( src ) ; redeem Internal ( src , redeem Tokens ) ; return true ; }
function supports History ( ) external pure returns ( bool ) { return false ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; require ( want ! address ( asset ) , " want " ) ; require ( reward Uni ! address ( asset ) , " reward Uni " ) ; require ( underlying Token ! address ( asset ) , " underlying Token " ) ; require ( weth ! address ( asset ) , " weth " ) ; balance asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ; }
event Job Added ( address indexed job , uint block , address governance ) ;
function set Owner ( address wallet , address new Owner ) external ;
PROVIDER TRACK
function calc Deposit Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) external pure returns ( uint256 net Shares , uint256 fee Shares ) ;
function notify Reward Amount ( uint256 reward ) external only Owner { update Reward Per Token Stored ( ) ; if ( block . timestamp > period Finish ) { reward Rate reward . div ( DURATION ) ; } else { uint256 remaining period Finish . sub ( block . timestamp ) ; uint256 leftover remaining . mul ( reward Rate ) ; reward Rate reward . add ( leftover ) . div ( DURATION ) ; } last Update Time block . timestamp ; period Finish block . timestamp . add ( DURATION ) ; emit Reward Added ( reward ) ; }
function token Balance ( IERC20 token ) private view returns ( uint256 ) { if ( token ETH TOKEN ADDRESS ) return address ( this ) . balance ; return token . balance Of ( address ( this ) ) ; }
function withdraw ( uint256 amount ) public override { require ( amount > 0 , " Cannot withdraw 0 " ) ; update Reward ( msg . sender ) ; super . withdraw ( amount ) ; if ( boost Level [ msg . sender ] > 0 ) { uint256 prev Balances Accounting balances Accounting [ msg . sender ] ; uint256 acc Total Multiplier get Total Multiplier ( msg . sender ) ; uint256 new Balances Accounting balances [ msg . sender ] . mul ( acc Total Multiplier ) . div ( 1e18 ) . sub ( balances [ msg . sender ] ) ; balances Accounting [ msg . sender ] new Balances Accounting ; uint256 diff Balances Accounting prev Balances Accounting . sub ( new Balances Accounting ) ; total Supply Accounting total Supply Accounting . sub ( diff Balances Accounting ) ; } emit Withdrawn ( msg . sender , amount ) ; }
function get Service Provider Factory Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return service Provider Factory Address ; }
function set Delegate Manager Address ( address delegate Manager ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; delegate Manager Address delegate Manager ; }
function borrow Internal ( uint borrow Amount ) internal non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . BORROW ACCRUE INTEREST FAILED ) ; } return borrow Fresh ( msg . sender , borrow Amount ) ; }
function get Reserve Interest Rate Strategy Address ( address reserve ) public view returns ( address ) { Core Library . Reserve Data storage reserve reserves [ reserve ] ; return reserve . interest Rate Strategy Address ; }
function ord ( slice self ) internal view returns ( uint ret ) { if ( self . len 0 ) { return 0 ; } uint word ; uint len ; uint div 2 248 ; assembly { word : mload ( mload ( add ( self , 32 ) ) ) } var b word div ; if ( b < 0x80 ) { ret b ; len 1 ; } else if ( b < 0x E0 ) { ret b & 0x1F ; len 2 ; } else if ( b < 0x F0 ) { ret b & 0x0F ; len 3 ; } else { ret b & 0x07 ; len 4 ; } if ( len > self . len ) { return 0 ; } for ( uint i 1 ; i < len ; i + + ) { div div 256 ; b ( word div ) & 0x FF ; if ( b & 0x C0 ! 0x80 ) { return 0 ; } ret ( ret 64 ) | ( b & 0x3F ) ; } return ret ; }
function buy Tokens ( address beneficiary ) public non Reentrant payable { uint256 wei Amount msg . value ; pre Validate Purchase ( beneficiary , wei Amount ) ; uint256 tokens get Token Amount ( wei Amount ) ; wei Raised wei Raised . add ( wei Amount ) ; process Purchase ( beneficiary , tokens ) ; emit Tokens Purchased ( msg Sender ( ) , beneficiary , wei Amount , tokens ) ; forward Funds ( ) ; }
function revert Reason (
function get Underlying Token By Farm Token (
function get Staker Info ( Tellor Storage . Tellor Storage Struct storage self , address staker ) internal view returns ( uint256 , uint256 ) { return ( self . staker Details [ staker ] . current Status , self . staker Details [ staker ] . start Date ) ; }
function enter ( uint256 amount ) public { uint256 total Earn earn . balance Of ( address ( this ) ) ; uint256 total Shares total Supply ( ) ; if ( total Shares 0 | | total Earn 0 ) { mint ( msg . sender , amount . div ( 1000 ) ) ; } else { uint256 what amount . mul ( total Shares ) . div ( total Earn ) ; mint ( msg . sender , what ) ; } earn . transfer From ( msg . sender , address ( this ) , amount ) ; }
function muli ( int128 x , int256 y ) internal pure returns ( int256 ) { if ( x MIN 64x64 ) { require ( y > 0x FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF & & y < 0x1000000000000000000000000000000000000000000000000 ) ; return y < < 63 ; } else { bool negative Result false ; if ( x < 0 ) { x x ; negative Result true ; } if ( y < 0 ) { We rely on overflow behavior here negative Result ! negative Result ; } uint256 absolute Result mulu ( x , uint256 ( y ) ) ; if ( negative Result ) { require ( absolute Result < 0x8000000000000000000000000000000000000000000000000000000000000000 ) ; We rely on overflow behavior here } else { require ( absolute Result < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; return int256 ( absolute Result ) ; } } }
function name ( )
function cancel Ownership Transfer ( ) public only Owner { delete new Potential Owner ; }
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function reward Tokens Count ( ) external view returns ( uint256 ) { return reward Token List . length ; }
function balance Of Want ( ) public view returns ( uint256 ) { return IERC20 ( want ) . balance Of ( address ( this ) ) ; }
event Insert Token ( address indexed token ) ;
function set Interface Implementer ( address account , bytes32 interface Hash , address implementer ) external ;
function invalidate Offchain Approval (
function withdraw ( ) external only Owner { owner . transfer ( address ( this ) . balance ) ; }
function mint ( address account , uint256 amount ) public only Minter returns ( bool ) { mint ( account , amount ) ; return true ; }
function mint ( address recipient , uint256 amount ) public only Owner { mint ( recipient , amount ) ; move Delegates ( address ( 0 ) , delegates [ recipient ] , amount ) ; }
function calculate Non Vested Tokens (
function bind Refer ( address from , bytes32 name )
function text ( bytes32 node , string calldata key ) external view returns ( string memory ) { return texts [ node ] [ key ] ; }
function deposit ( uint256 cost ) public override non Reentrant
function claim Pending ( address sp ) external view returns ( bool ) { require Is Initialized ( ) ; require Staking Address Is Set ( ) ; require Service Provider Factory Address Is Set ( ) ; uint256 last Claimed For SP Staking ( staking Address ) . last Claimed For ( sp ) ; ( , , , uint256 num Endpoints , , ) ( Service Provider Factory ( service Provider Factory Address ) . get Service Provider Details ( sp ) ) ; return ( last Claimed For SP < current Round . funded Block & & num Endpoints > 0 ) ; }
function concat ( slice memory self , slice memory other ) internal pure returns ( string memory ) { string memory ret new string ( self . len + other . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; memcpy ( retptr + self . len , other . ptr , other . len ) ; return ret ; }
function get DODO Zoo Address ( )
function allowance (
function safe Transfer ( address from , address to , uint256 token Id , bytes memory data ) internal virtual { transfer ( from , to , token Id ) ; require ( check On ERC721Received ( from , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function remove Liquidity Mature With Signature (
function assign Client Oracle ( address client Oracle , uint256 registration ) external non Reentrant { Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client , " ! client " ) ; require ( locker . locked 0 , " locked " ) ; require ( locker . released < locker . sum , " released " ) ; locker . client Oracle client Oracle ; emit Assign Client Oracle ( client Oracle , registration ) ; }
function remove From In Progress Proposals ( uint256 proposal Id ) internal { uint256 index 0 ; for ( uint256 i 0 ; i < in Progress Proposals . length ; i + + ) { if ( in Progress Proposals [ i ] proposal Id ) { index i ; break ; } } in Progress Proposals [ index ] in Progress Proposals [ in Progress Proposals . length 1 ] ; in Progress Proposals . pop ( ) ; }
function get Uint ( uint get Id , uint val ) internal returns ( uint return Val ) { return Val get Id 0 ? val : Memory Interface ( get Memory Addr ( ) ) . get Uint ( get Id ) ; }
function pool Quota ( uint256 pool Id ) external view returns ( uint256 ) ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! address ( 0 ) , " to address is a zero address " ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function split ( slice memory self , slice memory needle ) internal pure returns ( slice memory token ) { split ( self , needle , token ) ; }
function calculate Amount ( address property , address user )
function add ( Address Set storage set , address value )
function delegate ( address delegatee ) public { return delegate ( msg . sender , delegatee ) ; }
function uri ( uint256 ) public view virtual override returns ( string memory ) { return uri ; }
function testlogbase2 ( int128 x ) public pure returns ( int128 ) { return logbase2 ( x ) ; }
function accept Admin ( ) public { require ( msg . sender pending Admin , " Timelock : : accept Admin : Call must come from pending Admin . " ) ; admin msg . sender ; pending Admin address ( 0 ) ; emit New Admin ( admin ) ; }
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( ( b > 0 & & c < a ) | | ( b < 0 & & c > a ) ) ; return c ; }
function balance Of ( address owner ) constant returns ( uint balance ) { return balances [ owner ] ; }
function collect Fee ( ) external returns ( uint256 ) { require ( admins [ msg . sender ] , " not admin " ) ; uint256 [ ] memory balances balances ; uint256 A get A ( ) ; uint256 old D total Supply ; for ( uint256 i 0 ; i < balances . length ; i + + ) { balances [ i ] IERC20 ( tokens [ i ] ) . balance Of ( address ( this ) ) . mul ( precisions [ i ] ) ; } uint256 new D get D ( balances , A ) ; uint256 fee Amount new D . sub ( old D ) ; if ( fee Amount 0 ) return 0 ; balances balances ; total Supply new D ; address fee Recipient fee Recipient ; IERC20Mintable Burnable ( pool Token ) . mint ( fee Recipient , fee Amount ) ; emit Fee Collected ( fee Recipient , fee Amount ) ; return fee Amount ; }
function earn Misc Tokens ( I Strategy strategy , IERC20 token ) external update Epoch { strategy . withdraw ( address ( token ) ) ; uint256 bal token . balance Of ( address ( this ) ) ; token . safe Approve ( address ( treasury ) , bal ) ; treasury . deposit ( token , bal ) ; }
function set Storage Last Same Rewards Amount And Block (
function un Blacklist ( address account ) public only Blacklister { blacklisted [ account ] false ; emit Un Blacklisted ( account ) ; }
function get Rate ( uint256 index )
function remove Admin Role ( address address ) external { revoke Role ( DEFAULT ADMIN ROLE , address ) ; emit Admin Role Removed ( address , msg Sender ( ) ) ; }
function usdc To ETH ( uint256 amount ) internal returns ( uint256 ) { IERC20 ( usdc ) . safe Approve ( uniswap Router , 0 ) ; IERC20 ( usdc ) . safe Approve ( uniswap Router , amount ) ; address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] usdc ; path [ 1 ] weth ; uint [ ] memory amounts I Uniswap ( uniswap Router ) . swap Exact Tokens For ETH ( amount , uint ( 0 ) , path , address ( this ) , now . add ( 1800 ) ) ; return amounts [ 1 ] ; }
function use Nonce ( address owner ) internal virtual returns ( uint256 current ) { Counters . Counter storage nonce nonces [ owner ] ; current nonce . current ( ) ; nonce . increment ( ) ; }
function get Underlying Price ( address c Token ) external view returns ( uint ) { Token Config memory config get Token Config By C Token ( c Token ) ; return mul ( 1e30 , price Internal ( config ) ) config . base Unit ; }
function set Base URI ( string memory base URI ) internal { base URI base URI ; }
function abs ( int256 number ) public pure returns ( uint256 ) { return number < 0 ? uint256 ( number ( 1 ) ) : uint256 ( number ) ; }
function draw Collateral ( uint cdp Id , address join Addr , uint amount ) internal returns ( uint ) { uint frob Amount amount ; if ( Join ( join Addr ) . dec ( ) ! 18 ) { frob Amount amount ( 10 ( 18 Join ( join Addr ) . dec ( ) ) ) ; } manager . frob ( cdp Id , to Positive Int ( frob Amount ) , 0 ) ; manager . flux ( cdp Id , address ( this ) , frob Amount ) ; Join ( join Addr ) . exit ( address ( this ) , amount ) ; if ( is Eth Join Addr ( join Addr ) ) { Weth > Eth } return amount ; }
function stake ( uint256 amount ) public virtual { uint256 tax Rate calculate Tax ( ) ; uint256 taxed Amount amount . mul ( tax Rate ) . div ( 100 ) ; uint256 staked Amount amount . sub ( taxed Amount ) ; balances [ msg . sender ] balances [ msg . sender ] . add ( staked Amount ) ; total Supply total Supply . add ( staked Amount ) ; dev Fund dev Fund . add ( taxed Amount ) ; staking Token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; }
function set Migrator ( address migrator ) external only Gov { address old Migrator migrator ; migrator migrator ; emit New Migrator ( old Migrator , migrator ) ; }
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ; }
function until ( slice memory self , slice memory needle ) internal pure returns ( slice memory ) { if ( self . len < needle . len ) { return self ; } uint selfptr self . ptr + self . len needle . len ; bool equal true ; if ( selfptr ! needle . ptr ) { assembly { let length : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( keccak256 ( selfptr , length ) , keccak256 ( needleptr , length ) ) } } if ( equal ) { self . len needle . len ; } return self ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function is Initialization Complete ( ) public view returns ( bool ) { return initialization Admin address ( 0 ) ; }
function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function next Rune ( slice memory self ) internal pure returns ( slice memory ret ) { next Rune ( self , ret ) ; }
event Approval ( address indexed owner , address indexed spender , uint amount ) ;
function burn From ( address account , uint256 amount ) public only Minter { burn From ( account , amount ) ; }
function update Max Delegators ( uint256 max Delegators ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; max Delegators max Delegators ; emit Max Delegators Updated ( max Delegators ) ; }
function calc Deposit Shares From Cost ( uint256 cost , uint256 total Reserve , uint256 total Supply , uint256 deposit Fee ) public pure override returns ( uint256 net Shares , uint256 fee Shares )
function uri ( uint256 token ID ) external view override returns ( string memory ) { return string ( abi . encode Packed ( uri , token UR Is [ token ID ] ) ) ; }
function emergency Withdraw ( uint amount To Withdraw ) public { require ( amount To Withdraw > 0 , " Cannot withdraw 0 Tokens " ) ; require ( deposited Tokens [ msg . sender ] > amount To Withdraw , " Invalid amount to withdraw " ) ; last Claimed Time [ msg . sender ] now ; uint fee amount To Withdraw . mul ( withdraw Fee Percent X100 ) . div ( 1e4 ) ; uint amount After Fee amount To Withdraw . sub ( fee ) ; require ( Token ( trusted Deposit Token Address ) . transfer ( owner , fee ) , " Could not transfer fee ! " ) ; require ( Token ( trusted Deposit Token Address ) . transfer ( msg . sender , amount After Fee ) , " Could not transfer tokens . " ) ; deposited Tokens [ msg . sender ] deposited Tokens [ msg . sender ] . sub ( amount To Withdraw ) ; if ( holders . contains ( msg . sender ) & & deposited Tokens [ msg . sender ] 0 ) { holders . remove ( msg . sender ) ; } }
function modify Stake Balance ( address account Address , uint256 by , bool increase ) internal { uint256 current Internal Stake accounts [ account Address ] . staked History . get Last ( ) ; uint256 new Stake ; if ( increase ) { new Stake current Internal Stake . add ( by ) ; } else { require ( current Internal Stake > by , " Staking : Cannot decrease greater than current balance " ) ; new Stake current Internal Stake . sub ( by ) ; } accounts [ account Address ] . staked History . add ( block . number . to Uint64 ( ) , new Stake ) ; }
function growth Gulp Range ( ) public view override returns ( uint256 growth Min Gulp Amount , uint256 growth Max Gulp Amount )
function current Cumulative Price ( Token Config memory config ) internal view returns ( uint ) { ( uint cumulative Price0 , uint cumulative Price1 , ) Uniswap V2Oracle Library . current Cumulative Prices ( config . uniswap Market ) ; if ( config . is Uniswap Reversed ) { return cumulative Price1 ; } else { return cumulative Price0 ; } }
function locked Lp Amount ( ) public view returns ( uint256 ) { if ( uniswap V2Pair address ( 0 ) ) { return 0 ; } return IERC20 ( uniswap V2Pair ) . balance Of ( address ( 0 ) ) ; }
function set Rebalance Margins ( uint256 liquid Rebalance Margin , uint256 portfolio Rebalance Margin ) public override only Owner non Reentrant
function transfer ( address to , uint256 tokens ) public override returns ( bool success ) { require ( address ( to ) ! address ( 0 ) , " Transfer to address 0 not allowed " ) ; require ( balances [ msg . sender ] > tokens , " SENDER : insufficient balance " ) ; if ( wallets Locking [ msg . sender ] . locked Tokens > 0 ) { check Unlocking ( ) ; } require ( balances [ msg . sender ] . sub ( tokens ) > wallets Locking [ msg . sender ] . locked Tokens , " Please wait for tokens to be released " ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
solhint disable line max line length
function mining Gulp Range ( ) public view override returns ( uint256 mining Min Gulp Amount , uint256 mining Max Gulp Amount )
function unfreeze From ( address from , uint amount ) public only Owner { require ( from ! address ( 0 ) , " unfreezing from zero address " ) ; require ( amount < frozen Balance [ from ] , " amount exceeds frozen balance " ) ; frozen Balance [ from ] frozen Balance [ from ] . sub ( amount ) ; emit Tokens Unfrozen ( from , amount ) ; }
function add Country Restriction ( uint16 country ) external only Owner { restricted Countries [ country ] true ; emit Added Restricted Country ( country ) ; }
function fund ( uint256 amount , uint256 duration ) public override { fund ( amount , duration , block . timestamp ) ; }
event Vote Cast ( address voter , uint proposal Id , bool support , uint votes ) ;
function transfer ( address to , uint256 value ) when Not Paused not In Blacklist ( msg . sender ) not In Blacklist ( to ) public override returns ( bool ) { require ( to ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function swap ( uint [ ] memory amounts , address [ ] memory path , address to ) internal virtual { for ( uint i ; i < path . length 1 ; i + + ) { ( address input , address output ) ( path [ i ] , path [ i + 1 ] ) ; ( address token0 , ) Titan Swap V1Library . sort Tokens ( input , output ) ; uint amount Out amounts [ i + 1 ] ; ( uint amount0Out , uint amount1Out ) input token0 ? ( uint ( 0 ) , amount Out ) : ( amount Out , uint ( 0 ) ) ; address to i < path . length 2 ? Titan Swap V1Library . pair For ( factory , output , path [ i + 2 ] ) : to ; I Titan Swap V1Pair ( Titan Swap V1Library . pair For ( factory , input , output ) ) . swap ( amount0Out , amount1Out , to , new bytes ( 0 ) ) ; } }
function remove Manager ( address manager )
function get User Paying Usd ( address user ) public view returns ( uint256 ) { delegate To View And Return ( ) ; }
function update Settings (
function repay Borrow Fresh ( address payer , address borrower , uint repay Amount ) internal returns ( uint , uint ) { Fail if repay Borrow not allowed uint allowed comptroller . repay Borrow Allowed ( address ( this ) , payer , borrower , repay Amount ) ; if ( allowed ! 0 ) { return ( fail Opaque ( Error . COMPTROLLER REJECTION , Failure Info . REPAY BORROW COMPTROLLER REJECTION , allowed ) , 0 ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return ( fail ( Error . MARKET NOT FRESH , Failure Info . REPAY BORROW FRESHNESS CHECK ) , 0 ) ; } Repay Borrow Local Vars memory vars ; We remember the original borrower Index for verification purposes vars . borrower Index account Borrows [ borrower ] . interest Index ; We fetch the amount the borrower owes , with accumulated interest ( vars . math Err , vars . account Borrows ) borrow Balance Stored Internal ( borrower ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return ( fail Opaque ( Error . MATH ERROR , Failure Info . REPAY BORROW ACCUMULATED BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) , 0 ) ; } If repay Amount 1 , repay Amount account Borrows if ( repay Amount uint ( 1 ) ) { vars . repay Amount vars . account Borrows ; } else { vars . repay Amount repay Amount ; } We call do Transfer In for the payer and the repay Amount Note : The c Token must handle variations between ERC 20 and ETH underlying . On success , the c Token holds an additional repay Amount of cash . do Transfer In reverts if anything goes wrong , since we can ' t be sure if side effects occurred . it returns the amount actually transferred , in case of a fee . vars . actual Repay Amount do Transfer In ( payer , vars . repay Amount ) ; We calculate the new borrower and total borrow balances , failing on underflow : account Borrows New account Borrows actual Repay Amount total Borrows New total Borrows actual Repay Amount ( vars . math Err , vars . account Borrows New ) sub U Int ( vars . account Borrows , vars . actual Repay Amount ) ; require ( vars . math Err Math Error . NO ERROR , " REPAY BORROW NEW ACCOUNT BORROW BALANCE CALCULATION FAILED " ) ; ( vars . math Err , vars . total Borrows New ) sub U Int ( total Borrows , vars . actual Repay Amount ) ; require ( vars . math Err Math Error . NO ERROR , " REPAY BORROW NEW TOTAL BALANCE CALCULATION FAILED " ) ; We write the previously calculated values into storage account Borrows [ borrower ] . principal vars . account Borrows New ; account Borrows [ borrower ] . interest Index borrow Index ; total Borrows vars . total Borrows New ; We emit a Repay Borrow event emit Repay Borrow ( payer , borrower , vars . actual Repay Amount , vars . account Borrows New , vars . total Borrows New ) ; We call the defense hook comptroller . repay Borrow Verify ( address ( this ) , payer , borrower , vars . actual Repay Amount , vars . borrower Index ) ; return ( uint ( Error . NO ERROR ) , vars . actual Repay Amount ) ; }
function sub ( uint128 a , uint128 b ) internal pure returns ( uint128 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint128 c a b ; return c ; }
function withdraw Unclaimed Tokens ( address contract Unclaimed ) external only Owner { current Token IERC20 ( contract Unclaimed ) ; uint256 amount current Token . balance Of ( address ( this ) ) ; current Token . transfer ( owner , amount ) ; }
function assign ( address receiver , uint256 amount ) external auth P ( ASSIGN ROLE , arr ( receiver , amount ) ) { assign ( receiver , amount ) ; }
function unlock Schedule Count ( ) public view returns ( uint256 ) { return unlock Schedules . length ; }
function get Balance ( ) external view returns ( uint256 balance ) ;
function get Underlying Price ( address g Token ) external view returns ( uint ) { Token Config memory config get Token Config By C Token ( g Token ) ; return mul ( 1e30 , price Internal ( config ) ) config . base Unit ; }
function transact Token Approve (
function conservative Precise Div ( int256 a , int256 b ) internal pure returns ( int256 ) { return div Down ( a . mul ( PRECISE UNIT INT ) , b ) ; }
function create Pool ( address token0 , uint256 amount0 , address token1 , uint256 amount1 ) internal returns ( address pool )
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool )
function remove Token From Partition ( address from , bytes32 partition , uint256 value ) internal { balance Of By Partition [ from ] [ partition ] balance Of By Partition [ from ] [ partition ] . sub ( value ) ; total Supply By Partition [ partition ] total Supply By Partition [ partition ] . sub ( value ) ; if ( total Supply By Partition [ partition ] 0 ) { uint256 index1 index Of Total Partitions [ partition ] ; 0x50 transfer failure bytes32 last Value total Partitions [ total Partitions . length 1 ] ; adjust for 1 based indexing index Of Total Partitions [ last Value ] index1 ; total Partitions . length 1 ; index Of Total Partitions [ partition ] 0 ; } if ( balance Of By Partition [ from ] [ partition ] 0 ) { uint256 index2 index Of Partitions Of [ from ] [ partition ] ; 0x50 transfer failure bytes32 last Value partitions Of [ from ] [ partitions Of [ from ] . length 1 ] ; adjust for 1 based indexing index Of Partitions Of [ from ] [ last Value ] index2 ; partitions Of [ from ] . length 1 ; index Of Partitions Of [ from ] [ partition ] 0 ; } }
function get Max Borrow ( address borrow Address , address user ) public view returns ( uint256 ) { address lending Pool Address I Lending Pool Addresses Provider ( AAVE LENDING POOL ADDRESSES ) . get Lending Pool ( ) ; address price Oracle Address I Lending Pool Addresses Provider ( AAVE LENDING POOL ADDRESSES ) . get Price Oracle ( ) ; ( , , , , uint256 available Borrows ETH , , , ) I Lending Pool ( lending Pool Address ) . get User Account Data ( user ) ; uint256 borrow Price I Price Oracle Getter Aave ( price Oracle Address ) . get Asset Price ( borrow Address ) ; return wmul ( wdiv ( available Borrows ETH , borrow Price ) ( 10 ( 18 get Decimals ( borrow Address ) ) ) , NINETY NINE PERCENT WEI ) ; }
function rate ( ) public view returns ( uint256 ) { return rate ; }
function borrow ( uint256 borrow Amount ) external returns ( uint256 ) ;
function time Lock ( address address , uint256 time , uint256 value ) public only Owner Or Admin { require ( address ! address ( 0 ) , " Same as the original wallet address . " ) ; uint256 unlock Amount value . div ( 10 ) ; time [ address ] time ; time Locked [ address ] time Locked [ address ] . add ( value ) ; un Lock Amount [ address ] un Lock Amount [ address ] . add ( unlock Amount ) ; emit Time Locker Changed ( address , time , value ) ; }
function get Current Cap ( ) public view returns ( uint256 ) { return v PURE Token . balance Of ( address ( this ) ) ; }
function approve (
function transfer ( address to , uint value ) returns ( bool success ) { }
function work Receipt ( address keeper , uint amount ) public { require ( jobs [ msg . sender ] , " work Receipt : ! job " ) ; require ( amount < KPRH . get Quote Limit ( gas Used . sub ( gasleft ( ) ) ) , " work Receipt : max limit " ) ; credits [ msg . sender ] [ address ( this ) ] credits [ msg . sender ] [ address ( this ) ] . sub ( amount , " work Receipt : insuffient funds " ) ; last Job [ keeper ] now ; reward ( keeper , amount ) ; work Completed [ keeper ] work Completed [ keeper ] . add ( amount ) ; emit Keeper Worked ( address ( this ) , msg . sender , keeper , block . number , amount ) ; }
function delete String ( bytes32 key ) external only Current Owner { delete string Storage [ key ] ; }
function resolve ( address keeper ) external { require ( msg . sender governance , " resolve : ! gov " ) ; disputes [ keeper ] false ; emit Keeper Resolved ( keeper , block . number ) ; }
function set Ilk Debt Ceiling ( address vat , bytes32 ilk , uint256 amount ) public { " Lib Dss Exec incorrect ilk line precision " Fileable ( vat ) . file ( ilk , " line " , amount Math Lib . RAD ) ; }
function transfer ( address sender , address recipient , uint256 amount ) internal { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; balances [ sender ] balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ recipient ] balances [ recipient ] . add ( amount ) ; emit Transfer ( sender , recipient , amount ) ; }
function get Underlying Token For Dmm ( address dmm Token ) external view returns ( address ) ;
function start Change Staking Pool ( address address ) external only Governance { timelock Start now ; timelock Type 4 ; timelock address address ; }
function get User Avail Awards ( address user ) view public returns ( uint256 ) { uint256 current get Curr Epoch ( ) ; uint256 rebase Ep current . sub ( tax Epoch ) ; User Info memory info user Info [ user ] ; uint256 amount info . free Amount ; if ( info . not Empty ) { uint256 ep tax Epoch . add ( 1 ) ; uint256 cursor info . tax Head ; while ( true ) { if ( info . tax List [ cursor ] . epoch > rebase Ep ) { uint rate current . sub ( info . tax List [ cursor ] . epoch ) . add ( 1 ) . mul ( 1e12 ) . div ( ep ) ; uint256 available info . tax List [ cursor ] . amount . mul ( rate ) . div ( 1e12 ) ; amount amount . add ( available ) ; } else { amount amount . add ( info . tax List [ cursor ] . amount ) ; } cursor cursor . add ( 1 ) . mod ( tax Epoch ) ; if ( cursor info . tax Tail ) { break ; } } } return amount ; }
function burn Tokens ( uint256 tokens ) public only Owner { require ( balance Of ( msg . sender ) > tokens ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; total Supply total Supply . sub ( tokens ) ; emit Tokens Burned ( msg . sender , tokens ) ; }
function emergency Stop Strategy ( ) external only Governance { deposits Open false ; if ( current Strategy ! Stabilize Strategy ( address ( 0 ) ) & & total Supply ( ) > 0 ) { Pulls all the tokens and accessory tokens from the strategy } current Strategy Stabilize Strategy ( address ( 0 ) ) ; Prevent governance from changing to new strategy without timelock }
function reward Token ( ) public override view returns ( address ) { return address ( unlocked Pool . token ( ) ) ; }
function decrease Allowance (
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < start Block | | block . number < pool . last Reward Block | | pool . last Reward Block > end Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Pending Blocks ( pool . last Reward Block , block . number ) ; uint256 honey Reward multiplier . mul ( honey Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Honey Per Share pool . acc Honey Per Share . add ( honey Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function renounce Registry Management ( ) public only Registry Admin { emit Registry Management Transferred ( registry Admin , address ( 0 ) ) ; registry Admin address ( 0 ) ; }
function set Active ( bool is Active ) public { require ( msg . sender governance , " ! governance " ) ; is Active is Active ; }
function safe Transfer ( address token , address to , uint256 amount ) internal { ( bool success , bytes memory data ) token . call ( abi . encode With Selector ( 0xa9059cbb , to , amount ) ) ; ERC20 Transfer failed }
function is Set Manager ( I Set Token set Token , address to Check ) internal view returns ( bool ) { return set Token . manager ( ) to Check ; }
function multiply Decimal Round (
function reward Per Token ( ) public view returns ( uint256 ) { if ( total Supply ( ) 0 ) { return reward Per Token Stored ; } return reward Per Token Stored . add ( last Time Reward Applicable ( ) . sub ( last Update Time ) . mul ( reward Rate ) . mul ( 1e18 ) . div ( total Supply ( ) ) ) ; }
function get All Asset Types ( ) external view returns ( string [ ] memory ) ;
event Contract Registry Address Updated ( address addr ) ;
function buy N Burn ( uint256 eth To Swap ) internal returns ( uint256 ) { address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] weth ; path [ 1 ] address ( yeld Token ) ; uint [ ] memory amounts I Uniswap ( uniswap Router ) . swap Exact ETH For Tokens . value ( eth To Swap ) ( uint ( 0 ) , path , address ( 0 ) , now . add ( 1800 ) ) ; return amounts [ 1 ] ; }
function add Liquidity ETH ( ) non Reentrant public payable { IWETH ( WETH ) . deposit { value : msg . value } ( ) ; add Liquidity Atomic ( ) ; }
function owner Set Max Profit As Percent Of House ( uint new Max Profit As Percent ) public only Owner
function unbind Methods ( address wallet )
function xf Lobby Entry ( address member Addr , uint256 enter Day , uint256 entry Index )
function check And Call Approve ( address spender , uint256 value , bytes memory data ) internal returns ( bool ) { if ( ! spender . is Contract ( ) ) { return false ; } bytes4 retval IERC1363Spender ( spender ) . on Approval Received ( msg Sender ( ) , value , data ) ; return ( retval ERC1363 APPROVED ) ; }
event Job Removed ( address indexed job , uint block , address governance ) ;
function burn Liquidity Pool Portion ( ) public override only Owner non Reentrant
function complete Liquidity Pool Migration ( ) public override only Owner non Reentrant
function modules ( ) external view returns ( uint ) ;
function safe Approve ( ERC20 token , address spender , uint256 value ) internal { call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function get Volcie Token ( uint256 volcie Token ID ) public view
function assign Operators ( bytes32 role , address [ ] memory operators )
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender controller , " ! controller " ) ; uint256 amount Gauge ( gauge ) . balance Of ( address ( this ) ) ; Gauge ( gauge ) . withdraw ( amount ) ; IERC20 ( crv LP ) . safe Approve ( curve Deposit , 0 ) ; IERC20 ( crv LP ) . safe Approve ( curve Deposit , amount ) ; I Curve Deposit ( curve Deposit ) . remove liquidity one coin ( amount , int128 ( WANT COIN INDEX ) , 0 ) ; balance IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault I Controller ( controller ) . vaults ( address ( want ) ) ; additional protection so we don ' t burn the funds IERC20 ( want ) . safe Transfer ( vault , balance ) ; }
function get Peer Id ( Ledger Struct . Channel storage c , address peer ) internal view returns ( uint ) { if ( peer c . peer Profiles [ 0 ] . peer Addr ) { return 0 ; } else if ( peer c . peer Profiles [ 1 ] . peer Addr ) { return 1 ; } else { revert ( " Nonexist peer " ) ; } }
event Initialized ( uint256 start Time , uint256 initial Production ) ;
function sub ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b < a , error Message ) ; uint c a b ; return c ; }
function desired Liquidity ( ) external view returns ( uint256 ) ;
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( value ) ) ) ; }
function get Token Type By Token ( address token ) external view returns ( DMG Yield Farming V2Lib . Token Type ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Uniswap V2 : INSUFFICIENT OUTPUT AMOUNT ' ) ; gas savings require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; scope for token { 0 , 1 } , avoids stack too deep errors address token0 token0 ; address token1 token1 ; require ( to ! token0 & & to ! token1 , ' Uniswap V2 : INVALID TO ' ) ; optimistically transfer tokens optimistically transfer tokens if ( data . length > 0 ) I Uniswap V2Callee ( to ) . uniswap V2Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 IERC20Uniswap ( token0 ) . balance Of ( address ( this ) ) ; balance1 IERC20Uniswap ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Uniswap V2 : INSUFFICIENT INPUT AMOUNT ' ) ; scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors uint balance0Adjusted balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Uniswap V2 : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ; }
modifier only Lending Pool Configurator { require ( addresses Provider . get Lending Pool Configurator ( ) msg . sender , " The caller must be a lending pool configurator contract " ) ; ; }
event Burn Liquidity Pool Portion ( uint256 stakes Amount , uint256 shares Amount ) ;
function stake For (
event Submit Proposal ( address indexed applicant , uint256 shares Requested , uint256 loot Requested , uint256 tribute Offered , address tribute Token , uint256 payment Requested , address payment Token , string details , bool [ 6 ] flags , uint256 proposal Id , address indexed delegate Key , address indexed member Address ) ;
function mint Fresh ( address minter , uint mint Amount ) internal returns ( uint ) { Fail if mint not allowed uint allowed comptroller . mint Allowed ( address ( this ) , minter , mint Amount ) ; if ( allowed ! 0 ) { return fail Opaque ( Error . COMPTROLLER REJECTION , Failure Info . MINT COMPTROLLER REJECTION , allowed ) ; } Verify market ' s block number equals current block number if ( accrual Block Number ! get Block Number ( ) ) { return fail ( Error . MARKET NOT FRESH , Failure Info . MINT FRESHNESS CHECK ) ; } Mint Local Vars memory vars ; Fail if check Transfer In fails vars . err check Transfer In ( minter , mint Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . MINT TRANSFER IN NOT POSSIBLE ) ; } We get the current exchange rate and calculate the number of c Tokens to be minted : mint Tokens mint Amount exchange Rate ( vars . math Err , vars . exchange Rate Mantissa ) exchange Rate Stored Internal ( ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT EXCHANGE RATE READ FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . mint Tokens ) div Scalar By Exp Truncate ( mint Amount , Exp ( { mantissa : vars . exchange Rate Mantissa } ) ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT EXCHANGE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We calculate the new total supply of c Tokens and minter token balance , checking for overflow : total Supply New total Supply + mint Tokens account Tokens New account Tokens [ minter ] + mint Tokens ( vars . math Err , vars . total Supply New ) add U Int ( total Supply , vars . mint Tokens ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT NEW TOTAL SUPPLY CALCULATION FAILED , uint ( vars . math Err ) ) ; } ( vars . math Err , vars . account Tokens New ) add U Int ( account Tokens [ minter ] , vars . mint Tokens ) ; if ( vars . math Err ! Math Error . NO ERROR ) { return fail Opaque ( Error . MATH ERROR , Failure Info . MINT NEW ACCOUNT BALANCE CALCULATION FAILED , uint ( vars . math Err ) ) ; } We call do Transfer In for the minter and the mint Amount Note : The c Token must handle variations between ERC 20 and ETH underlying . On success , the c Token holds an additional mint Amount of cash . If do Transfer In fails despite the fact we checked pre conditions , we revert because we can ' t be sure if side effects occurred . vars . err do Transfer In ( minter , mint Amount ) ; if ( vars . err ! Error . NO ERROR ) { return fail ( vars . err , Failure Info . MINT TRANSFER IN FAILED ) ; } We write previously calculated values into storage total Supply vars . total Supply New ; account Tokens [ minter ] vars . account Tokens New ; We emit a Mint event , and a Transfer event emit Mint ( minter , mint Amount , vars . mint Tokens ) ; emit Transfer ( address ( this ) , minter , vars . mint Tokens ) ; We call the defense hook comptroller . mint Verify ( address ( this ) , minter , mint Amount , vars . mint Tokens ) ; return uint ( Error . NO ERROR ) ; }
function set Reward Claim Fee ( uint256 fee ) public only Owner { require ( fee > 0 , " Reward claim fee must be none zero value . " ) ; reward Claim Fee fee ; }
function is Registered ( address account ) public view returns ( bool ) { return contracts [ account ] ; }
function convert shares to husd ( uint amount ) internal returns ( uint husd ) { uint [ 3 ] memory amounts ; uint before bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; deposit BUSD . remove liquidity one coin ( amount , 0 , 1 ) ; uint after bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] after . sub ( before ) ; before token3Crv . balance Of ( address ( this ) ) ; stable Swap3Pool . add liquidity ( amounts , 1 ) ; after token3Crv . balance Of ( address ( this ) ) ; amount after . sub ( before ) ; before token HUSD . balance Of ( address ( this ) ) ; stable Swap HUSD . exchange ( int128 ( 1 ) , int128 ( 0 ) , amount , 1 ) ; after token HUSD . balance Of ( address ( this ) ) ; husd after . sub ( before ) ; }
function is Constructor ( ) private view returns ( bool ) { uint256 cs ; assembly { cs : extcodesize ( address ( ) ) } return cs 0 ; }
event Liquidation Call (
event Primary Transferred (
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; emit Transfer ( sender , recipient , amount ) ; token Balances [ sender ] token Balances [ sender ] . sub ( amount , " ERC20 : transfer amount exceeds balance " ) ; token Balances [ recipient ] token Balances [ recipient ] . add ( amount ) ; }
function add ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a + b ; require ( ( b > 0 & & c > a ) | | ( b < 0 & & c < a ) ) ; return c ; }
function set Halt ( bool halt )
function total Locked ( ) public view returns ( uint256 ) { return locked Pool . balance ( ) ; }
function to Int256 ( uint256 x ) internal pure returns ( int256 ) { require ( x < uint256 ( type ( int256 ) . max ) , " Pool : Cast overflow " ) ; return int256 ( x ) ; }
function renounce Governorship ( ) public governance { emit Governorship Transferred ( governor , address ( 0 ) ) ; governor address ( 0 ) ; }
enum Handler Type { Token , Custom , Others }
function slash ( address bonded , address keeper , uint amount ) public non Reentrant { require ( msg . sender governance , " slash : ! gov " ) ; if ( bonded address ( this ) ) { transfer Tokens ( address ( this ) , governance , amount ) ; } else { IERC20 ( bonded ) . safe Transfer ( governance , amount ) ; } unbond ( bonded , keeper , amount ) ; disputes [ keeper ] false ; emit Keeper Slashed ( keeper , msg . sender , block . number , amount ) ; }
function add ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { uint c a + b ; require ( c > a , error Message ) ; return c ; }
function redeem ( uint256 amount ) public { if ( amount > rebase Threshold & & ! rebase Paused ) { rebase ( false ) ; } redeem ( amount ) ; }
function mint ( uint256 mint Amount ) external non Reentrant returns ( bool ) { mint Internal ( mint Amount ) ; pay Interest Internal ( msg . sender ) ; return true ; }
function balance Of ( address owner ) constant returns ( uint256 balance ) { }
function all Pending Piggy ( address user ) external view returns ( uint256 ) { uint sum 0 ; for ( uint i 0 ; i < pool Info . length ; i + + ) { sum sum . add ( pending ( i , user ) ) ; } return sum ; }
function starts With ( slice self , slice needle ) internal view returns ( bool ) { if ( self . len < needle . len ) { return false ; } if ( self . ptr needle . ptr ) { return true ; } bool equal ; assembly { let len : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } return equal ; }
function get Agent Registry ( )
function token Of Owner By Index ( address owner , uint256 index ) external view returns ( uint256 token Id ) ;
function token At ( uint256 index ) public view override returns ( address token )
function payback Flash Loan ( Provider provider , address token , uint256 gross Amount ) internal
function total Supply ( ) external view returns ( uint256 total ) { total total Supply ; }
event Borrow (
function withdraw Exchange Stake (
function transfer ( address to , uint256 value ) external
function get Cash ( ) external view returns ( uint ) { delegate To View And Return ( ) ; }
function burn From ( address from , uint256 value ) public returns ( bool success ) { Check if the targeted balance is enough Check allowance Subtract from the targeted balance Subtract from the sender ' s allowance Update total Supply emit Burn ( from , value ) ; return true ; }
function mul Truncate Scale (
function is Operator ( address user Address ) public view returns ( bool ) { return user Address owner | | admins [ user Address ] | | operators [ user Address ] ; }
function set Eth Item ERC20Wrapper Model ( address eth Item ERC20Wrapper Model Address ) external ;
function set Min Collateralization ( uint new Min Collateralization ) external ;
function initialize ( address logic , bytes memory data ) public payable { require ( implementation ( ) address ( 0 ) ) ; assert ( IMPLEMENTATION SLOT bytes32 ( uint256 ( keccak256 ( ' eip1967 . proxy . implementation ' ) ) 1 ) ) ; set Implementation ( logic ) ; if ( data . length > 0 ) { ( bool success , ) logic . delegatecall ( data ) ; require ( success ) ; } }
function get Personal Stake Unlocked Timestamps ( address address ) external view returns ( uint256 [ ] ) { uint256 [ ] memory timestamps ; ( timestamps , , ) get Personal Stakes ( address ) ; return timestamps ; }
function change Deity ( Tellor Storage . Tellor Storage Struct storage self , address new Deity ) internal { require ( self . address Vars [ keccak256 ( " deity " ) ] msg . sender , " Sender is not deity " ) ; self . address Vars [ keccak256 ( " deity " ) ] new Deity ; }
event Uniswap Address Added ( address addr ) ;
function get Ratio ( uint cdp Id , uint next Price ) public view returns ( uint ) { bytes32 ilk manager . ilks ( cdp Id ) ; uint price ( next Price 0 ) ? get Price ( ilk ) : next Price ; ( uint collateral , uint debt ) get Cdp Info ( cdp Id , ilk ) ; if ( debt 0 ) return 0 ; return rdiv ( wmul ( collateral , price ) , debt ) ( 10 18 ) ; }
function start Change Price Oracle ( address address ) external only Governance { timelock Start now ; timelock Type 5 ; timelock address address ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a 0 ) { return 0 ; } uint256 c a b ; require ( c a b , " Safe Math : multiplication overflow " ) ; return c ; }
event Params ( uint fee Basis Points , uint max Fee ) ;
function get Withdrawal Recipient (
function set Dmg Growth Coefficient (
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ; }
function add New Pair Pool ( address pair Pool Addr ) public only Owner { uint256 pair Code total Number Of Pair Pools ; I Uniswap V2Pair pair I Uniswap V2Pair ( pair Pool Addr ) ; address token0 pair . token0 ( ) ; address token1 pair . token1 ( ) ; require ( token0 address ( kittie Fight Token ) | | token1 address ( kittie Fight Token ) , " Pair should contain KTY " ) ; pair Pools Info [ pair Code ] pair Pool Addr ; total Number Of Pair Pools total Number Of Pair Pools . add ( 1 ) ; }
function transfer Pot Ownership ( address new Owner ) public only Gov { master Pot . transfer Pot Ownership ( new Owner ) ; }
function notify Forced Request Too Old (
function get Token Key ( address token Address , uint256 token Id ) public pure returns ( bytes memory ) { return Utilities . concat ( Utilities . to Bytes ( token Address ) , Utilities . to Bytes ( token Id ) ) ; }
modifier non Reentrant ( ) { guard Counter + 1 ; uint256 local Counter guard Counter ; ; require ( local Counter guard Counter , " DMG Yield Farming Data : REENTRANCY " ) ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) return 0 ; uint c a b ; require ( c a b , " multiplication overflow " ) ; return c ; }
function pay Fee Reward (
function deposit ( ) public { uint256 want IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( want > 0 ) { IERC20 ( want ) . safe Approve ( rewards , 0 ) ; IERC20 ( want ) . approve ( rewards , want ) ; I Staking Rewards ( rewards ) . stake ( want ) ; } }
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }
function transfer From ( address from , address to , uint256 value ) public when Not Paused returns ( bool ) { return super . transfer From ( from , to , value ) ; }
function get Referral Bouns ( ) external { require ( stakeholders [ msg . sender ] . staker true , ' address does not belong to a stakeholders ' ) ; require ( bonus [ msg . sender ] . upline Profit > 0 , ' you do not have any bonus ' ) ; uint bonus To Get bonus [ msg . sender ] . upline Profit ; rewards [ msg . sender ] rewards [ msg . sender ] . add ( bonus To Get ) ; revert Upline Profit ( msg . sender ) ; }
function get Level ( address account ) external view returns ( uint256 ) { return boost Level [ account ] ; }
function withdrawable Payment ( address oracle )
event Exchange Stake Deposited ( address exchange Addr , uint amount ) ;
function refresh Contracts ( ) external override { committee Contract I Committee ( get Committee Contract ( ) ) ; general Fees Wallet I Fees Wallet ( get General Fees Wallet ( ) ) ; certified Fees Wallet I Fees Wallet ( get Certified Fees Wallet ( ) ) ; bootstrap Rewards Wallet I Protocol Wallet ( get Bootstrap Rewards Wallet ( ) ) ; }
function to Decimals ( uint256 object Id , uint256 amount )
function pfc ( ) public view non Reentrant View ( ) returns ( Fixed Point . Unsigned memory ) { return pfc ( ) ; }
function implementation ( ) internal view returns ( address impl ) { bytes32 slot IMPLEMENTATION SLOT ; assembly { impl : sload ( slot ) } }
function release Extension ( bool keep Mint ) external ;
function set Upgrade Contract ( address upgrade Contract Address ) public only Owner returns ( bool ) { upgrade Contract upgrade Contract Address ; emit Upgrade Contract Change ( msg . sender , upgrade Contract ) ; return true ; }
function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( self & bytes32 ( uint256 ( 0xffffffffffffffffffffffffffffffff ) ) 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( self & bytes32 ( uint256 ( 0xffffffffffffffff ) ) 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( self & bytes32 ( uint256 ( 0xffffffff ) ) 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( self & bytes32 ( uint256 ( 0xffff ) ) 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( self & bytes32 ( uint256 ( 0xff ) ) 0 ) { ret + 1 ; } return 32 ret ; }
function approve ( address spender , uint256 amount ) public virtual only Creator override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function chainlink Token Address ( )
function set Staking Pool ( address staking Pool ) public
function withdraw ( uint256 share ) external accrue ( 0 ) non Reentrant { uint256 amount share . mul ( total ETH ( ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , share ) ; Safe Token . safe Transfer ETH ( msg . sender , amount ) ; }
function set WETH ( address w ETH ) external only Owner { require ( w ETH address ( 0 ) ) ; w ETH w ETH ; }
function get Delegator Staking Rewards ( address delegator , uint256 current Time ) private view returns ( Delegator Staking Rewards memory delegator Staking Rewards , address guardian , uint256 delegator Staking Rewards Per Token Delta ) { uint256 delegator Stake ; ( guardian , delegator Stake ) delegations Contract . get Delegation Info ( delegator ) ; ( Guardian Staking Rewards memory guardian Staking Rewards , , ) get Guardian Staking Rewards ( guardian , current Time ) ; ( delegator Staking Rewards , , delegator Staking Rewards Per Token Delta ) get Delegator Staking Rewards ( delegator , delegator Stake , guardian Staking Rewards ) ; }
function deposit ( address adapter , uint256 pool Id , uint256 amount ) external override { I Vampire Adapter adapter I Vampire Adapter ( adapter ) ; adapter . lockable Token ( pool Id ) . approve ( address ( pickle Master Chef ) , uint256 ( 1 ) ) ; pickle Master Chef . deposit ( pool Id , amount ) ; }
function balance Of ( address addr ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 value ) public override returns ( bool ) { approve ( msg . sender , spender , value ) ; return true ; }
function withdraw Reward ( address token , address user , uint256 amount ) external ;
function set Contract Registry ( I Contract Registry new Contract Registry ) public override only Admin { require ( new Contract Registry . get Previous Contract Registry ( ) address ( contract Registry ) , " new contract registry must provide the previous contract registry " ) ; contract Registry new Contract Registry ; emit Contract Registry Address Updated ( address ( new Contract Registry ) ) ; }
function external Token Transfer From (
function get Interest Rate By Dmm Token Address ( address dmm Token ) external view returns ( uint ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Wtrx Per Share : 0 } ) ) ; }
function remove Service Type ( bytes32 service Type ) external { require Is Initialized ( ) ; require ( msg . sender governance Address , ERROR ONLY GOVERNANCE ) ; uint256 service Index 0 ; bool found Service false ; for ( uint256 i 0 ; i < valid Service Types . length ; i + + ) { if ( valid Service Types [ i ] service Type ) { service Index i ; found Service true ; break ; } } require ( found Service true , " Service Type Manager : Invalid service type , not found " ) ; uint256 last Index valid Service Types . length 1 ; valid Service Types [ service Index ] valid Service Types [ last Index ] ; valid Service Types . length ; service Type Info [ service Type ] . is Valid false ; emit Service Type Removed ( service Type ) ; }
function enter Market ( address c Token Addr Coll , address c Token Addr Borrow ) internal { address [ ] memory markets new address [ ] ( 2 ) ; markets [ 0 ] c Token Addr Coll ; markets [ 1 ] c Token Addr Borrow ; Comptroller Interface ( COMPTROLLER ) . enter Markets ( markets ) ; }
event Submit Proposal ( address indexed applicant , uint256 shares Requested , uint256 loot Requested , uint256 tribute Offered , address tribute Token , uint256 payment Requested , address payment Token , bytes32 details , uint8 [ 9 ] flags , bytes data , uint256 proposal Id , address indexed delegate Key , address indexed member Address ) ;
function get User Origination Fee ( address reserve , address user )
function non Reentrant Call (
function update Minimum Burn Amount ( uint256 minimum Burn Amount )
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function cap ( ) public view returns ( uint256 ) { return cap ; }
function migrate ( uint256 aid , uint256 pid ) public { require ( address ( migrator ) ! address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool pool Info [ aid ] [ pid ] ; IERC20 lp Token pool . lp Token ; uint256 bal lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token migrator . migrate ( lp Token ) ; require ( bal new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token new Lp Token ; }
function is Approved For All ( address account , address operator ) public view override returns ( bool ) { return operator Approvals [ account ] [ operator ] ; }
function get Role Member ( bytes32 role , uint256 index )
function deliver Tokens ( address beneficiary , uint256 token Amount ) internal { token . safe Transfer ( beneficiary , token Amount ) ; }
function governor ( ) public view returns ( address ) { return governor ( ) ; }
function delegator Cumulative Stake And Fees (
function harvest Dmg By User (
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; lasttimestaked [ msg . sender ] block . timestamp ; emit Staked ( msg . sender , amount ) ; }
function set Soda ( address soda ) external only Owner { require ( soda address ( 0 ) ) ; soda soda ; }
function trade Eth For Dai And Mint D Dai (
function get Block Info ( uint block Idx )
event Deprecate ( address new Address ) ;
function redeem All D Dai ( ) external { withdraw Max From Dharma Token ( Asset Type . DAI ) ; }
function balance Of ( address owner ) public view override returns ( uint256 ) { require ( owner ! address ( 0 ) , " ERC721 : balance query for the zero address " ) ; return holder Tokens [ owner ] . length ( ) ; }
function allowance ( address owner , address spender ) public view override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function claim Comp ( ) public { comptroller . claim Comp ( address ( this ) ) ; }
function price Min ( string calldata symbol ) external returns ( uint256 ) ;
function convertible At ( uint256 index ) external view returns ( I Convertible Consumable ) ;
function transfer ( address recipient , uint256 amount ) Governance ( msg . sender ) public returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function pre Hold For (
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 fobo Reward multiplier . mul ( fobo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; fobo . mint ( address ( this ) , fobo Reward ) ; pool . acc Fobo Per Share pool . acc Fobo Per Share . add ( fobo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function add Stakeholder (
event Call Executed ( bytes32 indexed id , uint256 indexed index , address target , uint256 value , bytes data ) ;
function set Interest Rate Model ( Interest Rate Model new Interest Rate Model ) public returns ( uint ) { bytes memory data delegate To Implementation ( abi . encode With Signature ( " set Interest Rate Model ( address ) " , new Interest Rate Model ) ) ; return abi . decode ( data , ( uint ) ) ; }
function compute Address ( bytes32 salt , bytes memory bytecode Hash , address deployer ) internal pure returns ( address ) { bytes32 bytecode Hash Hash keccak256 ( bytecode Hash ) ; bytes32 data keccak256 ( abi . encode Packed ( bytes1 ( 0xff ) , deployer , salt , bytecode Hash Hash ) ) ; return address ( bytes20 ( data < < 96 ) ) ; }
function current Round Initialized ( ) public view returns ( bool ) { return last Initialized Round current Round ( ) ; }
function governance Recover Unsupported ( IERC20 token , uint256 amount , address to )
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function prepare Deposit ( uint256 cost ) internal override may Flash Borrow returns ( bool success )
function set Governance ( address governance ) external only Governance { pending Governance governance ; }
function end Lock ( ) internal { current Stage Stages . locked End ; if ( remaininglocked Tokens > 0 ) balances [ owner ] balances [ owner ] . add ( remaininglocked Tokens ) ; owner . transfer ( address ( this ) . balance ) ; }
function safe Zcdw Transfer ( address to , uint256 amount ) internal { uint256 zcdw Bal zcdw . balance Of ( address ( this ) ) ; if ( amount > zcdw Bal ) { zcdw . transfer ( to , zcdw Bal ) ; } else { zcdw . transfer ( to , amount ) ; } }
function name ( ) public view override returns ( string memory ) { return name ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function total Staked ( ) public view returns ( uint256 ) { return staking Pool . balance ( ) ; }
function deployment Subset Exists ( string calldata deployment Subset ) external override view returns ( bool ) { return deployment Subsets [ deployment Subset ] . exists ; }
function transfer From ( Loihi Storage . Shell storage shell , address sender , address recipient , uint256 amount ) external returns ( bool ) { transfer ( shell , msg . sender , recipient , amount ) ; approve ( shell , sender , msg . sender , sub ( shell . allowances [ sender ] [ msg . sender ] , amount , " Shell insufficient allowance " ) ) ; return true ; }
function token Price ( ) public view returns ( uint256 ) { return commitments Total . mul ( 1e18 ) . div ( total Tokens ) ; }
function stake For ( address user , uint256 amount , bytes calldata data ) external { stake For ( msg . sender , user , amount ) ; }
function fee Pool Share ( Earnings Pool . Data storage earnings Pool , uint256 stake , bool is Transcoder ) internal view returns ( uint256 ) { uint256 delegator Fees 0 ; uint256 transcoder Fees 0 ; if ( earnings Pool . has Transcoder Reward Fee Pool ) { ( delegator Fees , transcoder Fees ) fee Pool Share With Transcoder Reward Fee Pool ( earnings Pool , stake , is Transcoder ) ; } else { ( delegator Fees , transcoder Fees ) fee Pool Share No Transcoder Reward Fee Pool ( earnings Pool , stake , is Transcoder ) ; } return delegator Fees . add ( transcoder Fees ) ; }
function quit (
function get Role Member Count ( bytes32 role ) public view returns ( uint256 ) { return roles [ role ] . members . length ( ) ; }
function withdraw Rewards ( ) external only Owner { require ( unstaked At 0 , " NO WITHDRAWS AFTER UNSTAKING " ) ; require ( staked At ! 0 , " NO WITHDRAWS BEFORE STAKING " ) ; uint256 surplus IERC20 ( tellor Address ) . balance Of ( address ( this ) ) stake Amount ; uint256 available surplus . mul ( 10000 fee ) . div ( 10000 ) ; fees Collected + surplus available ; require ( IERC20 ( tellor Address ) . transfer ( owner ( ) , available ) ) ; }
function smg Fast Burn ( bytes32 unique ID , bytes32 smg ID , uint token Pair ID , uint value , address user Account , bytes r , bytes32 s )
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { transfer ( from , to , value ) ; approve ( from , msg . sender , allowed [ from ] [ msg . sender ] . sub ( value ) ) ; return true ; }
function transfer Admin ( address new Admin ) public only Admin { require ( new Admin ! address ( 0 ) , " new admin 0 " ) ; emit Transfer Admin Pending ( new Admin ) ; pending Admin new Admin ; }
function sub ( uint a , uint b ) internal pure returns ( uint ) { return sub ( a , b , " sub : " ) ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function pending Quota ( address wallet )
function deposit Dai ( uint256 usd Amount ) external returns ( bool ) { return deposit To ( usd Amount , msg . sender , 1 ) ; }
function transfer ( address from , address to , uint value ) internal { require ( to ! 0x0 ) ; require ( balance Of [ from ] > value ) ; require ( balance Of [ to ] + value > balance Of [ to ] ) ; uint previous Balances balance Of [ from ] + balance Of [ to ] ; balance Of [ from ] value ; balance Of [ to ] + value ; emit Transfer ( from , to , value ) ; assert ( balance Of [ from ] + balance Of [ to ] previous Balances ) ; }
function lock ( uint256 registration , string calldata details ) external non Reentrant { Locker storage locker lockers [ registration ] ; require ( msg Sender ( ) locker . client | | msg Sender ( ) locker . provider , " ! party " ) ; require ( locker . confirmed 1 , " ! confirmed " ) ; require ( locker . released < locker . sum , " released " ) ; locker . locked 1 ; emit Lock ( msg Sender ( ) , registration , details ) ; }
modifier non Reentrant ( ) { guard Counter + 1 ; uint256 local Counter guard Counter ; ; require ( local Counter guard Counter , " re entered " ) ; }
function set Address ( bytes32 key , address value )
function create Wrapped ERC1155 ( bytes calldata model Init Call Payload ) external returns ( address eth Item Address , bytes memory eth Item Init Response ) ;
function adjust Reserve ( Self storage self , uint256 room Amount ) public returns ( bool success )
function unlock Schedule Shares ( uint256 s ) private returns ( uint256 ) { Unlock Schedule storage schedule unlock Schedules [ s ] ; if ( schedule . unlocked Shares > schedule . initial Locked Shares ) { return 0 ; } uint256 shares To Unlock 0 ; if ( now > schedule . end At Sec ) { shares To Unlock ( schedule . initial Locked Shares . sub ( schedule . unlocked Shares ) ) ; schedule . last Unlock Timestamp Sec schedule . end At Sec ; } else { shares To Unlock now . sub ( schedule . last Unlock Timestamp Sec ) . mul ( schedule . initial Locked Shares ) . div ( schedule . duration Sec ) ; schedule . last Unlock Timestamp Sec now ; } schedule . unlocked Shares schedule . unlocked Shares . add ( shares To Unlock ) ; return shares To Unlock ; }
function balance Of ( address owner ) external view returns ( uint256 ) ;
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) ) ; require ( ! exists ( token Id ) ) ; token Owner [ token Id ] to ; owned Tokens Count [ to ] . increment ( ) ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function get Current Version ( bytes32 service Type )
function transfer From ( address from , address to , uint256 tokens ) public override returns ( bool success ) { check allowance require ( balances [ from ] > tokens ) ; require ( balances [ to ] + tokens > balances [ to ] ) ; balances [ from ] balances [ from ] . sub ( tokens ) ; balances [ to ] balances [ to ] . add ( tokens ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }
function request Flash Loan ( address token , uint256 net Amount , bytes memory context ) internal returns ( bool success )
function sync ( ) external lock { update ( IERC20Uniswap ( token0 ) . balance Of ( address ( this ) ) , IERC20Uniswap ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ; }
function price ( string memory symbol ) external view returns ( uint ) { Token Config memory config get Token Config By Symbol ( symbol ) ; return price Internal ( config ) ; }
modifier only Governance ( ) { require ( governance msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) { return supported Interfaces [ interface Id ] ; }
event Owner Changed ( address new Owner ) ;
function source ( bytes memory message , bytes memory signature ) public pure returns ( address ) { ( bytes32 r , bytes32 s , uint8 v ) abi . decode ( signature , ( bytes32 , bytes32 , uint8 ) ) ; bytes32 hash keccak256 ( abi . encode Packed ( " \ x19Ethereum Signed Message : \ n32 " , keccak256 ( message ) ) ) ; return ecrecover ( hash , v , r , s ) ; }
function sell (
function num Managers ( )
function transfer ( address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ msg . sender ] ) ; balances [ msg . sender ] balances [ msg . sender ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function remove Stake ( uint stake ) public pause { uint unlock Window rewards Window . mul ( stake Lock Multiplier ) ; require ( block . number > last Withdraw [ msg . sender ] . add ( unlock Window ) , " Token Staking : FMTA has not been staked for long enough " ) ; rewards [ msg . sender ] rewards [ msg . sender ] . add ( rewards Accrued ( ) ) ; if ( stakes [ msg . sender ] 0 & & stake ! 0 ) { revert ( " Token Staking : You don ' t have any tokens staked " ) ; } else if ( stakes [ msg . sender ] ! 0 & & stake ! 0 ) { fundamenta . mint To ( msg . sender , rewards Accrued ( ) ) ; fundamenta . mint To ( msg . sender , stake ) ; stakes [ msg . sender ] stakes [ msg . sender ] . sub ( stake ) ; last Withdraw [ msg . sender ] block . number ; } else if ( stakes [ msg . sender ] 0 ) { fundamenta . mint To ( msg . sender , rewards Accrued ( ) ) ; fundamenta . mint To ( msg . sender , stake ) ; stakes [ msg . sender ] stakes [ msg . sender ] . sub ( stake ) ; remove Stakeholder ( msg . sender ) ; last Withdraw [ msg . sender ] block . number ; } emit Stake Removed ( msg . sender , stake , rewards Accrued ( ) , block . number ) ; }
function process Migration ( ) external { require ( msg . sender owner , " No Authorization " ) ; require ( migration Recipient ! address ( 0 ) ) ; require ( now > migration Lock ) ; uint256 Token Balance ERC20Interface ( AXIA ) . balance Of ( address ( this ) ) ; uint256 Token Balance Swap ERC20Interface ( Swap Liquidity ) . balance Of ( address ( this ) ) ; uint256 Token Balance Oracle ERC20Interface ( Oracle Liquidty ) . balance Of ( address ( this ) ) ; uint256 Token Balance Defi ERC20Interface ( Defi Liquidity ) . balance Of ( address ( this ) ) ; ERC20Interface ( AXIA ) . transfer ( migration Recipient , Token Balance ) ; ERC20Interface ( Swap Liquidity ) . transfer ( migration Recipient , Token Balance Swap ) ; ERC20Interface ( Oracle Liquidty ) . transfer ( migration Recipient , Token Balance Oracle ) ; ERC20Interface ( Defi Liquidity ) . transfer ( migration Recipient , Token Balance Defi ) ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function convert Want To Buyback ( uint256 lp Amount ) internal virtual returns ( address , uint256 ) ;
function pause ( ) public { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to pause " ) ; pause ( ) ; }
function divi ( int256 x , int256 y ) internal pure returns ( int128 ) { require ( y ! 0 ) ; bool negative Result false ; if ( x < 0 ) { We rely on overflow behavior here negative Result true ; } if ( y < 0 ) { We rely on overflow behavior here negative Result ! negative Result ; } uint128 absolute Result divuu ( uint256 ( x ) , uint256 ( y ) ) ; if ( negative Result ) { require ( absolute Result < 0x80000000000000000000000000000000 ) ; We rely on overflow behavior here } else { require ( absolute Result < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; We rely on overflow behavior here } }
function tax Fee ( ) external view returns ( uint256 ) { return tax Fee ; }
function initialize ( address factory , address WETH ) internal { factory factory ; WETH WETH ; }
function get Available Tokens ( uint256 already Claimed ) public view returns ( uint256 ) { return get Available ( block . number , start T , amount Per Member , duration T , already Claimed ) ; }
function create Gen0Alpaca Batch (
function safe Snp Transfer ( address to , uint256 amount ) internal { uint256 snp Bal snptoken . balance Of ( address ( this ) ) ; if ( amount > snp Bal ) { snptoken . transfer ( to , snp Bal ) ; } else { snptoken . transfer ( to , amount ) ; } }
function in Rebase Window ( ) public view returns ( bool ) { return ( now . mod ( min Rebase Time Interval Sec ) > rebase Window Offset Sec & & now . mod ( min Rebase Time Interval Sec ) < ( rebase Window Offset Sec . add ( rebase Window Length Sec ) ) ) ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { pay the earned tokens when user deposits } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount user . amount . add ( amount ) ; } user . reward Debt user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) ; total Staked [ address ( pool . lp Token ) ] total Staked [ address ( pool . lp Token ) ] . add ( amount ) ; if ( pool . stakeable ) { uint256 prevbalance pool . staked Holdable Token . balance Of ( address ( this ) ) ; Stakeable ( pool . stakeable Contract ) . deposit ( amount ) ; uint256 balancetoadd pool . staked Holdable Token . balance Of ( address ( this ) ) . sub ( prevbalance ) ; user . staked LP Amount user . staked LP Amount . add ( balancetoadd ) ; total Staked [ address ( pool . staked Holdable Token ) ] total Staked [ address ( pool . staked Holdable Token ) ] . add ( balancetoadd ) ; } emit Deposit ( msg . sender , pid , amount ) ; }
function mint ( address account , uint256 amount ) internal { require ( amount ! 0 ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function borrow ( address ctoken , uint256 amount ) internal returns ( bool success )
function get Total Deposits ( ) public view returns ( uint256 ) { uint256 total Pools yield Farming . total Number Of Pair Pools ( ) ; uint256 total Deposits 0 ; uint256 deposits ; for ( uint256 i 0 ; i < total Pools ; i + + ) { deposits yield Farming . get Total Deposits Per Pair Code ( i ) ; total Deposits total Deposits . add ( deposits ) ; } return total Deposits ; }
function mul ( uint a , uint b ) internal pure returns ( uint ) { if ( a 0 ) { return 0 ; } uint c a b ; require ( c a b , " mul : " ) ; return c ; }
event Delegated ( address indexed from , address indexed to ) ;
function update Pool ( uint256 pid ) public { if ( channel . total Supply ( ) < max Channel Supply ) { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 channel Reward multiplier . mul ( channel Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; channel . mint ( devaddr , channel Reward . div ( 10 ) ) ; channel . mint ( address ( this ) , channel Reward ) ; pool . acc Channel Per Share pool . acc Channel Per Share . add ( channel Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; } }
function get ( History storage self , uint64 time ) internal view returns ( uint256 ) { return binary Search ( self , time ) ; }
function handle Deposit ( address token , uint256 amount ) external ;
function xf Lobby Range ( uint256 begin Day , uint256 end Day )
event Proposal Created ( uint256 id , address proposer , address [ ] targets , uint [ ] values , string [ ] signatures , bytes [ ] calldatas , uint256 start Block , uint256 end Block , string description ) ;
function get Bal Gulp Pairs ( ) public view returns ( address [ ] memory ) { address [ ] memory pairs bal Gulp Pairs ; return pairs ; }
function stake Count ( address addr ) public view returns ( uint256 ) { return user Stakes [ addr ] . length ; }
function invoke Transfer (
function operator Burn ( address account , uint256 amount , bytes memory data , bytes memory operator Data ) public override { require ( is Operator For ( msg Sender ( ) , account ) , " ERC777 : caller is not an operator for holder " ) ; burn ( account , amount , data , operator Data ) ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Steak Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Steak Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt user . amount . mul ( pool . acc Steak Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function div ( uint a , uint b , string memory error Message ) internal pure returns ( uint ) { require ( b > 0 , error Message ) ; uint c a b ; return c ; }
function flux (
function get Merkle Root ( )
modifier only Manager ( ) { require ( manager Address msg . sender , " Managerable : caller is not the Manager " ) ; ; }
event New Resolver ( bytes32 indexed node , address resolver ) ;
function approve Array Of Tokens To Spender (
function approve ( address spender , uint256 amount ) public returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function add Pool Rewards ( uint256 reward Amount ) public only Owner { require ( pool Life Circle Ended false , " Pool life circle has been ended . " ) ; require ( reward Amount > 0 , " Reward token amount must be none zero value . " ) ; pool Remaining Reward pool Remaining Reward . add ( reward Amount ) ; pool Total Reward pool Total Reward . add ( reward Amount ) ; pool Reward Distribution Rate ( pool Total Reward . mul ( 20 ) ) . div ( 100 ) ; uint256 allowance reward Token . allowance ( msg . sender , pool ) ; require ( allowance > reward Amount , " You did not approve the reward to transfer to Pool . " ) ; reward Token . safe Transfer From ( msg . sender , pool , reward Amount ) ; emit Transfer Rewards To Pool Contract ( msg . sender , pool , reward Token Address , reward Amount ) ; }
function create Liquidation (
function pause ( ) external only Owner { pause ( ) ; }
function ( ) external payable { eth To Next Stake eth To Next Stake . add ( msg . value ) ; }
function multiply Decimal Round ( uint x , uint y ) internal pure returns ( uint ) { return multiply Decimal Round ( x , y , UNIT ) ; }
function get Borrow Amount ( address ctoken ) internal view returns ( uint256 amount )
function to Payable ( address account ) internal pure returns ( address payable ) { return address ( uint160 ( account ) ) ; }
function get Metadata ( address guardian , string calldata key ) external view returns ( string memory ) ;
function ratio ( ) public view returns ( uint256 ) { if ( total Rewards 0 ) { return 0 ; } return total Gysr Rewards . mul ( 10 BONUS DECIMALS ) . div ( total Rewards ) ; }
function transfer ( address to , uint256 tokens ) public returns ( bool ) { transfer With Fee ( msg . sender , to , tokens ) ; return true ; }
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; require ( user . amount > amount , " withdraw : amount is exceeds yours " ) ; update Pool ( pid ) ; uint256 pending user . amount . mul ( pool . acc Charizard Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Charizard Transfer ( msg . sender , pending ) ; user . amount user . amount . sub ( amount ) ; user . reward Debt user . amount . mul ( pool . acc Charizard Per Share ) . div ( 1e12 ) ; if ( pool . taxable ) { pool . lp Token . safe Transfer ( address ( devaddr ) , amount . mul ( 25 ) . div ( 10000 ) ) ; emit Withdraw ( devaddr , pid , amount . mul ( 25 ) . div ( 10000 ) ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount . sub ( amount . mul ( 25 ) . div ( 10000 ) ) ) ; emit Withdraw ( msg . sender , pid , amount . sub ( amount . mul ( 25 ) . div ( 10000 ) ) ) ; } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ; } }
function max Scaling Factor ( ) external view returns ( uint256 ) { return max Scaling Factor ( ) ; }
function rate Growth ( ) public view override returns ( uint256 ) { if ( is Mature ! true ) return rate0 ; ( , uint256 rate , , , ) vat . ilks ( WETH ) ; Rounding in favour of the protocol }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 xdex Reward multiplier . mul ( xdex Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; xdex . mint ( address ( this ) , xdex Reward ) ; pool . acc Xdex Per Share pool . acc Xdex Per Share . add ( xdex Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function set Governance ( address governance ) external { require ( msg . sender governance , " Keep3r : : set Governance : only governance can set " ) ; pending Governance governance ; }
function get Account Snapshot ( address account ) external view returns ( uint , uint , uint , uint ) { uint c Token Balance account Tokens [ account ] ; uint borrow Balance ; uint exchange Rate Mantissa ; Math Error m Err ; ( m Err , borrow Balance ) borrow Balance Stored Internal ( account ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } ( m Err , exchange Rate Mantissa ) exchange Rate Stored Internal ( ) ; if ( m Err ! Math Error . NO ERROR ) { return ( uint ( Error . MATH ERROR ) , 0 , 0 , 0 ) ; } return ( uint ( Error . NO ERROR ) , c Token Balance , borrow Balance , exchange Rate Mantissa ) ; }
function mul Scalar Truncate Add U Int ( Exp memory a , uint scalar , uint addend ) pure internal returns ( Math Error , uint ) { ( Math Error err , Exp memory product ) mul Scalar ( a , scalar ) ; if ( err ! Math Error . NO ERROR ) { return ( err , 0 ) ; } return add U Int ( truncate ( product ) , addend ) ; }
function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { if ( deprecated ) { return Standard Token ( upgraded Address ) . allowance ( owner , spender ) ; } else { return super . allowance ( owner , spender ) ; } }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b < a ) ; return a b ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ; }
function add Contract ( bytes32 name , address address ) external only Owner { require Is Initialized ( ) ; require ( address Storage [ name ] address ( 0x00 ) , " Registry : Contract already registered with given name . " ) ; require ( address ! address ( 0x00 ) , " Registry : Cannot register zero address . " ) ; set Address ( name , address ) ; emit Contract Added ( name , address ) ; }
function get Int ( bytes32 key ) external view returns ( int256 ) { return int Storage [ key ] ; }
function div ( Unsigned memory a , uint256 b ) internal pure returns ( Unsigned memory ) { return Unsigned ( a . raw Value . div ( b ) ) ; }
function safe Unwrap ( uint256 amount ) internal
function approve ( address spender , uint256 amount ) external returns ( bool ) { require ( amount 0 | | allowance [ msg . sender ] [ spender ] 0 ) ; allowance [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function distribute Fee ( bytes32 fee Type , address token , uint256 value ) internal returns ( uint256 ) { uint256 num Of Accounts reward Address Count ( ) ; uint256 fee calculate Fee ( fee Type , token , value ) ; if ( num Of Accounts 0 | | fee 0 ) { return 0 ; } uint256 fee Per Account fee . div ( num Of Accounts ) ; uint256 random Account Index ; uint256 diff fee . sub ( fee Per Account . mul ( num Of Accounts ) ) ; if ( diff > 0 ) { random Account Index random ( num Of Accounts ) ; } address next Addr get Next Reward Address ( F ADDR ) ; require ( next Addr ! F ADDR & & next Addr ! address ( 0 ) ) ; uint256 i 0 ; while ( next Addr ! F ADDR ) { uint256 fee To Distribute fee Per Account ; if ( diff > 0 & & random Account Index i ) { fee To Distribute fee To Distribute . add ( diff ) ; } if ( fee Type HOME TO FOREIGN FEE ) { ERC677 ( token ) . transfer ( next Addr , fee To Distribute ) ; } else { I Burnable Mintable ERC677Token ( token ) . mint ( next Addr , fee To Distribute ) ; } next Addr get Next Reward Address ( next Addr ) ; require ( next Addr ! address ( 0 ) ) ; i i + 1 ; } return fee ; }
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( to ! address ( 0 ) & & value > 0 & & balance Of [ from ] > value & & allowance [ from ] [ msg . sender ] > value & & frozen Account [ from ] false & & frozen Account [ to ] false & & block . timestamp > unlock Unix Time [ from ] & & block . timestamp > unlock Unix Time [ to ] ) ; balance Of [ from ] balance Of [ from ] . sub ( value ) ; balance Of [ to ] balance Of [ to ] . add ( value ) ; allowance [ from ] [ msg . sender ] allowance [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function to Uint8 ( uint256 value ) internal pure returns ( uint8 ) { require ( value < 2 8 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return uint8 ( value ) ; }
function set Stable Coin Address ( address stable Coin Address ) external only Owner { require ( permitted Addresses . permitted Addresses ( stable Coin Address ) ) ; stable Coin Address stable Coin Address ; }
event Approval ( address indexed owner , address indexed approved , uint256 indexed token Id ) ;
event Redeem Underlying (
function optimal Exp ( uint256 x ) public pure returns ( uint256 ) { uint256 res 0 ; uint256 y ; uint256 z ; get the input modulo 2 ^ ( 3 ) z ( z y ) FIXED 1 ; add y ^ 02 ( 20 ! 02 ! ) z ( z y ) FIXED 1 ; add y ^ 03 ( 20 ! 03 ! ) z ( z y ) FIXED 1 ; add y ^ 04 ( 20 ! 04 ! ) z ( z y ) FIXED 1 ; add y ^ 05 ( 20 ! 05 ! ) z ( z y ) FIXED 1 ; add y ^ 06 ( 20 ! 06 ! ) z ( z y ) FIXED 1 ; add y ^ 07 ( 20 ! 07 ! ) z ( z y ) FIXED 1 ; add y ^ 08 ( 20 ! 08 ! ) z ( z y ) FIXED 1 ; add y ^ 09 ( 20 ! 09 ! ) z ( z y ) FIXED 1 ; add y ^ 10 ( 20 ! 10 ! ) z ( z y ) FIXED 1 ; add y ^ 11 ( 20 ! 11 ! ) z ( z y ) FIXED 1 ; add y ^ 12 ( 20 ! 12 ! ) z ( z y ) FIXED 1 ; add y ^ 13 ( 20 ! 13 ! ) z ( z y ) FIXED 1 ; add y ^ 14 ( 20 ! 14 ! ) z ( z y ) FIXED 1 ; add y ^ 15 ( 20 ! 15 ! ) z ( z y ) FIXED 1 ; add y ^ 16 ( 20 ! 16 ! ) z ( z y ) FIXED 1 ; add y ^ 17 ( 20 ! 17 ! ) z ( z y ) FIXED 1 ; add y ^ 18 ( 20 ! 18 ! ) z ( z y ) FIXED 1 ; add y ^ 19 ( 20 ! 19 ! ) z ( z y ) FIXED 1 ; add y ^ 20 ( 20 ! 20 ! ) divide by 20 ! and then add y ^ 1 1 ! + y ^ 0 0 ! if ( ( x & 0x010000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( 3 ) if ( ( x & 0x020000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( 2 ) if ( ( x & 0x040000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( 1 ) if ( ( x & 0x080000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( + 0 ) if ( ( x & 0x100000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( + 1 ) if ( ( x & 0x200000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( + 2 ) if ( ( x & 0x400000000000000000000000000000000 ) ! 0 ) multiply by e ^ 2 ^ ( + 3 ) return res ; }
function earn All ( ) public { for ( uint256 i 0 ; i < num Vaults ; i + + ) { Rewarded Vault ( vaults [ i ] ) . earn ( ) ; } }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , roles [ role ] . admin Role , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function charge Fee ( address asset , address user , uint amount ) external has Vault Access not Liquidating ( asset , user ) { if ( amount ! 0 ) { Transfer Helper . safe Transfer From ( asset , user , vault Parameters . foundation ( ) , amount ) ; } }
function get Channel Status (
function sub ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
function add Liquidity To Job ( address liquidity , address job , uint amount ) external non Reentrant { require ( liquidity Accepted [ liquidity ] , " add Liquidity To Job : ! pair " ) ; IERC20 ( liquidity ) . safe Transfer From ( msg . sender , address ( this ) , amount ) ; liquidity Provided [ msg . sender ] [ liquidity ] [ job ] liquidity Provided [ msg . sender ] [ liquidity ] [ job ] . add ( amount ) ; liquidity Applied [ msg . sender ] [ liquidity ] [ job ] now . add ( LIQUIDITYBOND ) ; liquidity Amount [ msg . sender ] [ liquidity ] [ job ] liquidity Amount [ msg . sender ] [ liquidity ] [ job ] . add ( amount ) ; if ( ! jobs [ job ] & & job Proposal Delay [ job ] < now ) { I Governance ( governance ) . propose Job ( job ) ; job Proposal Delay [ job ] now . add ( UNBOND ) ; } emit Submit Job ( job , liquidity , msg . sender , block . number , amount ) ; }
function init ( string calldata name , string calldata symbol ) external ;
function get Freezing ( address addr , uint index ) public view returns ( uint64 release , uint balance ) { for ( uint i 0 ; i < index + 1 ; i + + ) { release chains [ to Key ( addr , release ) ] ; if ( release 0 ) { return ; } } balance freezings [ to Key ( addr , release ) ] ; }
function deactivate Reward Distribution ( ) external only Migration Manager ;
function burn ( uint burn Val ) public when Not Paused { burn ( msg . sender , burn Val ) ; }
function reward Token ( ) external view returns ( IERC20 ) ;
function get Role Member ( bytes32 role , uint256 index ) public view returns ( address ) { return roles [ role ] . members . at ( index ) ; }
function has Order ( bool is Buy , uint32 id ) internal view returns ( bool ) { if ( is Buy ) { return buy Orders [ id ] ! 0 ; } else { return sell Orders [ id ] ! 0 ; } }
function add ( int128 x , int128 y ) internal pure returns ( int128 ) { int256 result int256 ( x ) + y ; require ( result > MIN 64x64 & & result < MAX 64x64 ) ; return int128 ( result ) ; }
event Keeper Slashed ( address indexed keeper , address indexed slasher , uint block , uint slash ) ;
modifier not Pending Request ( bytes32 request Id ) { require ( pending Requests [ request Id ] address ( 0 ) , " Request is already pending " ) ; ; }
function approve ( address spender , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function release All ( ) public returns ( uint tokens ) { uint release ; uint balance ; ( release , balance ) get Freezing ( msg . sender , 0 ) ; while ( release ! 0 & & block . timestamp > release ) { release Once ( ) ; tokens + balance ; ( release , balance ) get Freezing ( msg . sender , 0 ) ; } }
function at ( Uint To Address Map storage map , uint256 index ) internal view returns ( uint256 , address ) { ( bytes32 key , bytes32 value ) at ( map . inner , index ) ; return ( uint256 ( key ) , address ( uint256 ( value ) ) ) ; }
function approve ( address to , uint256 token Id ) public virtual override { address owner owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg Sender ( ) owner | | is Approved For All ( owner , msg Sender ( ) ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function handle Week Pool (
function withdraw USDC (
function support Asset ( address asset ) external only Governor { require ( ! assets [ asset ] . is Supported , " Asset already supported " ) ; assets [ asset ] Asset ( { is Supported : true } ) ; all Assets . push ( asset ) ; emit Asset Supported ( asset ) ; }
function deposit ( uint256 cost ) external ;
function burn From ( address account , uint256 value ) internal { allowed [ account ] [ msg . sender ] allowed [ account ] [ msg . sender ] . sub ( value ) ; burn ( account , value ) ; emit Approval ( account , msg . sender , allowed [ account ] [ msg . sender ] ) ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
function pause ( ) only Owner when Not Paused public { paused true ; emit Pause ( ) ; }
function get Jobs ( ) external view returns ( address [ ] memory ) { return job List ; }
function do Transfer In ( address from , uint amount ) internal returns ( uint ) { EIP20Non Standard Interface token EIP20Non Standard Interface ( underlying ) ; uint balance Before EIP20Interface ( underlying ) . balance Of ( address ( this ) ) ; token . transfer From ( from , address ( this ) , amount ) ; bool success ; assembly { switch returndatasize ( ) This is a non standard ERC 20 set success to true } This is a compliant ERC 20 returndatacopy ( 0 , 0 , 32 ) Set success returndata of external call } This is an excessively non compliant ERC 20 , revert . revert ( 0 , 0 ) } } require ( success , " TOKEN TRANSFER IN FAILED " ) ; uint balance After EIP20Interface ( underlying ) . balance Of ( address ( this ) ) ; require ( balance After > balance Before , " TOKEN TRANSFER IN OVERFLOW " ) ; underflow already checked above , just subtract }
function decode ( uq112x112 memory self ) internal pure returns ( uint112 ) { return uint112 ( self . x > > RESOLUTION ) ; }
function pow ( int128 x , uint256 y ) internal pure returns ( int128 ) { uint256 absolute Result ; bool negative Result false ; if ( x > 0 ) { absolute Result powu ( uint256 ( x ) < < 63 , y ) ; } else { absolute Result powu ( uint256 ( uint128 ( x ) ) < < 63 , y ) ; negative Result y & 1 > 0 ; } absolute Result > > 63 ; if ( negative Result ) { require ( absolute Result < 0x80000000000000000000000000000000 ) ; We rely on overflow behavior here } else { require ( absolute Result < 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; We rely on overflow behavior here } }
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; User Info storage user user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount 0 ; user . reward Debt 0 ; }
function get Current Time ( ) public view returns ( uint256 ) { if ( timer Address ! address ( 0x0 ) ) { return Timer ( timer Address ) . get Current Time ( ) ; } else { solhint disable line not rely on time } }
function accrue Interest ( ) public virtual returns ( uint ) ;
function safe Mint ( address to , uint256 token Id ) internal { safe Mint ( to , token Id , " " ) ; }
function create Smart Fund (
function exchange Rate ( ) public view override returns ( uint256 exchange Rate )
function stake ( uint256 amount , bytes calldata ) external ;
function transfer Ownership ( address payable new Owner ) public is Owner { emit Owner Set ( owner , new Owner ) ; owner new Owner ; }
function fallback ( ) internal { will Fallback ( ) ; delegate ( implementation ( ) ) ; }
function proxy Owner ( ) public view returns ( address owner ) { bytes32 position PROXY OWNER POSITION ; assembly { owner : sload ( position ) } }
function committee Membership Will Change ( address guardian , uint256 weight , uint256 total Committee Weight , bool in Committee , bool in Committee After ) external only Committee Contract ;
function get Pending Pay Out Map ( bytes32 channel Id ) external view returns (
function set Prices ( uint256 new Sell Price , uint256 new Buy Price ) only Owner public { sell Price new Sell Price ; buy Price new Buy Price ; }
function get Current Votes ( address account )
function transfer ( address to , uint256 amount )
function from Int ( int256 x ) internal pure returns ( int128 ) { require ( x > 0x8000000000000000 & & x < 0x7FFFFFFFFFFFFFFF ) ; return int128 ( x < < 64 ) ; }
function revoke Liquidity ( address liquidity ) external only Governance { liquidity Accepted [ liquidity ] false ; }
function issue ( uint amount ) public only Owner { require ( total Supply + amount > total Supply ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] + amount ; total Supply + amount ; emit Issue ( amount ) ; }
function calculate Repay Exact In ( address token , uint in Exact ) public view returns ( uint ) { address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] token ; path [ 1 ] address ( STABLE ) ; return UNI . get Amounts Out ( in Exact , path ) [ 1 ] ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { require ( address ( token ) . is Contract ( ) , " Safe ERC20 : call to non contract " ) ; ( bool success , bytes memory returndata ) address ( token ) . call ( data ) ; require ( success , " Safe ERC20 : low level call failed " ) ; if ( returndata . length > 0 ) { require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function set Genesis Ref Time Delay ( uint256 new Genesis Ref Time Delay ) external only Functional Manager ;
function change Vault ( address new Vault ) public only Owner { emit Vault Changed ( Vault , new Vault ) ; Vault new Vault ; }
function liquidate Borrow ( address borrower , uint repay Amount , A Token a Token Collateral ) external returns ( uint ) { return liquidate Borrow Internal ( borrower , repay Amount , a Token Collateral ) ; }
function withdraw ( uint256 shares ) public { uint256 r ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw r . sub ( b ) ; I Chicken Plate Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after token . balance Of ( address ( this ) ) ; uint256 diff after . sub ( b ) ; if ( diff < withdraw ) { r b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ; }
function price ( string calldata name , uint expires , uint duration ) external view returns ( uint ) ;
function handle Operator Actions ( address vault Protocol , address strategy , address token ) external ;
function update Uint Parameters ( bytes8 code , uint val ) public only Authorized To Govern { Stake multiplier default lock period sm Lock Period val . mul ( 1 days ) ; } }
function mul Exp ( Exp memory a , Exp memory b ) pure internal returns ( Math Error , Exp memory ) { ( Math Error err0 , uint double Scaled Product ) mul U Int ( a . mantissa , b . mantissa ) ; if ( err0 ! Math Error . NO ERROR ) { return ( err0 , Exp ( { mantissa : 0 } ) ) ; } ( Math Error err1 , uint double Scaled Product With Half Scale ) add U Int ( half Exp Scale , double Scaled Product ) ; if ( err1 ! Math Error . NO ERROR ) { return ( err1 , Exp ( { mantissa : 0 } ) ) ; } ( Math Error err2 , uint product ) div U Int ( double Scaled Product With Half Scale , exp Scale ) ; assert ( err2 Math Error . NO ERROR ) ; return ( Math Error . NO ERROR , Exp ( { mantissa : product } ) ) ; }
function before Token Transfer ( address operator , address from , address to , uint256 amount ) internal virtual { }
function set Strategy Ok ( address [ ] calldata strats , bool is Ok ) external only Owner { uint256 len strats . length ; for ( uint256 idx 0 ; idx < len ; idx + + ) { ok Strats [ strats [ idx ] ] is Ok ; } }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function burn ( uint256 amount ) public virtual { burn ( msg . sender , amount ) ; }
modifier check Contract ( address account ) { if ( ! accept Contract Depositor & & ! whitelisted Contract [ account ] & & ( account ! vault Master . bank ( address ( this ) ) ) ) { require ( ! address ( account ) . is Contract ( ) & & account tx . origin , " contract not support " ) ; } ; }
function symbol ( ) external view returns ( string memory ) ;
function initialize New Round ( uint32 round Id )
function decode144 ( uq144x112 memory self ) internal pure returns ( uint144 ) { return uint144 ( self . x > > RESOLUTION ) ; }
function delegation Will Change ( address guardian , uint256 guardian Delegated Stake , address delegator , uint256 delegator Stake , address next Guardian , uint256 next Guardian Delegated Stake ) external override only When Active only Delegations Contract { Settings memory settings settings ; ( bool in Committee , uint256 weight , , uint256 total Committee Weight ) committee Contract . get Member Info ( guardian ) ; Staking Rewards State memory staking Rewards State update Staking Rewards State ( total Committee Weight , settings ) ; Guardian Staking Rewards memory guardian Staking Rewards update Guardian Staking Rewards ( guardian , in Committee , in Committee , weight , guardian Delegated Stake , staking Rewards State , settings ) ; update Delegator Staking Rewards ( delegator , delegator Stake , guardian , guardian Staking Rewards ) ; if ( next Guardian ! guardian ) { ( in Committee , weight , , total Committee Weight ) committee Contract . get Member Info ( next Guardian ) ; Guardian Staking Rewards memory next Guardian Staking Rewards update Guardian Staking Rewards ( next Guardian , in Committee , in Committee , weight , next Guardian Delegated Stake , staking Rewards State , settings ) ; delegators Staking Rewards [ delegator ] . last Delegator Rewards Per Token next Guardian Staking Rewards . delegator Rewards Per Token ; } }
function get Most Premium ( )
function grey List ( address target ) external view returns ( bool ) ;
function find Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr selfptr ; uint idx ; if ( needlelen < selflen ) { if ( needlelen < 32 ) { bytes32 mask bytes32 ( ~ ( 2 ( 8 ( 32 needlelen ) ) 1 ) ) ; bytes32 needledata ; assembly { needledata : and ( mload ( needleptr ) , mask ) } uint end selfptr + selflen needlelen ; bytes32 ptrdata ; assembly { ptrdata : and ( mload ( ptr ) , mask ) } while ( ptrdata ! needledata ) { if ( ptr > end ) return selfptr + selflen ; ptr + + ; assembly { ptrdata : and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash : keccak256 ( needleptr , needlelen ) } for ( idx 0 ; idx < selflen needlelen ; idx + + ) { bytes32 test Hash ; assembly { test Hash : keccak256 ( ptr , needlelen ) } if ( hash test Hash ) return ptr ; ptr + 1 ; } } } return selfptr + selflen ; }
modifier only Owner ( ) { require ( is Owner ( ) ) ; ; }
function calculate Withdrawal ( Vesting Storage storage self , address beneficiary ) internal view returns ( uint256 ) { require ( beneficiary ! 0 ) ; require ( self . holding Amount [ beneficiary ] [ 0 ] > 0 ) ; require ( self . num Registered > 0 ) ; bool err ; uint256 num Intervals ( now self . start Time ) self . time Interval ; uint256 amount Released ( ( num Intervals self . percent Per Interval ) self . holding Amount [ beneficiary ] [ 0 ] ) 100000 ; ( err , amount Released ) amount Released . minus ( self . has Withdrawn [ beneficiary ] ) ; return amount Released ; }
function get Claim Topics ( ) external view returns ( uint256 [ ] memory ) ;
function init (
event Reward (
function transfer ( address recipient , uint256 amount ) public returns ( bool ) { transfer ( msg . sender , recipient , amount ) ; return true ; }
function claimable ( uint256 stream Id )
function get Service Type Manager Address ( ) external view returns ( address ) { require Is Initialized ( ) ; return service Type Manager Address ; }
function set Hold To Executed And Kept Open (
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address member Address By Delegate Key [ msg . sender ] ; Member storage member members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; uint256 proposal Id proposal Queue [ proposal Index ] ; Proposal storage proposal proposals [ proposal Id ] ; require ( uint Vote < 3 , " > 2 " ) ; Vote vote Vote ( uint Vote ) ; require ( get Current Period ( ) > proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] Vote . Null , " voted " ) ; require ( vote Vote . Yes | | vote Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] vote ; if ( vote Vote . Yes ) { proposal . yes Votes + member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote proposal Index ; } if ( total Supply > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote total Supply ; } } else if ( vote Vote . No ) { proposal . no Votes + member . shares ; } emit Submit Vote ( proposal Id , proposal Index , msg . sender , member Address , uint Vote ) ; }
function get Adapters ( ) external view returns ( address [ ] memory ) { return adapters ; }
function release Extension ( ) external ;
function burn ( uint256 amount ) public only Burner when Not Paused { burn ( msg Sender ( ) , amount ) ; }
event New Value ( uint256 [ 5 ] request Id , uint256 time , uint256 [ 5 ] value , uint256 total Tips , bytes32 indexed current Challenge ) ;
event New Reserve Factor ( uint256 old Reserve Factor Mantissa , uint256 new Reserve Factor Mantissa ) ;
function transfer Governance ( address new Governor ) external only Governor { set Pending Governor ( new Governor ) ; emit Pending Governorship Transfer ( governor ( ) , new Governor ) ; }
function redeem In C Tokens ( uint256 amount C Tokens ) internal { if ( amount C Tokens > 0 ) { ctoken . redeem ( amount C Tokens ) ; } }
function total Supply ( ) external view returns ( uint256 ) ;
function claim ( ) public { require ( block . timestamp > ends , " presale has not yet ended " ) ; require ( claimable [ msg . sender ] > 0 , " nothing to claim " ) ; uint256 amount claimable [ msg . sender ] ; claimable [ msg . sender ] 0 ; total Owed total Owed . sub ( amount ) ; require ( ethys . transfer ( msg . sender , amount ) , " failed to claim " ) ; }
function increase Allowance ( address spender , uint256 added Value ) public returns ( bool ) { approve ( msg . sender , spender , allowances [ msg . sender ] [ spender ] . add ( added Value ) ) ; return true ; }
function calc Withdrawal Underlying Cost From Shares ( uint256 gross Shares , uint256 total Reserve , uint256 total Supply , uint256 withdrawal Fee , uint256 exchange Rate ) internal pure returns ( uint256 underlying Cost , uint256 fee Shares )
function Log ( address contract , address caller , string memory log Name , bytes memory data )
function name ( ) public view returns ( string memory ) { return name ; }
function token Value ( address token , uint amount )
function sqrtu ( uint256 x ) private pure returns ( uint128 ) { if ( x 0 ) return 0 ; else { uint256 xx x ; uint256 r 1 ; if ( xx > 0x100000000000000000000000000000000 ) { xx > > 128 ; r < < 64 ; } if ( xx > 0x10000000000000000 ) { xx > > 64 ; r < < 32 ; } if ( xx > 0x100000000 ) { xx > > 32 ; r < < 16 ; } if ( xx > 0x10000 ) { xx > > 16 ; r < < 8 ; } if ( xx > 0x100 ) { xx > > 8 ; r < < 4 ; } if ( xx > 0x10 ) { xx > > 4 ; r < < 2 ; } if ( xx > 0x8 ) { r < < 1 ; } r ( r + x r ) > > 1 ; r ( r + x r ) > > 1 ; r ( r + x r ) > > 1 ; r ( r + x r ) > > 1 ; r ( r + x r ) > > 1 ; r ( r + x r ) > > 1 ; Seven iterations should be enough uint256 r1 x r ; return uint128 ( r < r1 ? r : r1 ) ; } }
modifier only Manager { require ( msg . sender fund Manager , " Only manager can call this function . " ) ; ; }
function strict Invoke Transfer (
function initialize ( address token0 , address token1 ) external { sufficient check token0 token0 ; token1 token1 ; }
function withdraw Ether (
function remove Liquidity From Job ( address liquidity , address job ) external { require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] ! 0 , " remove Job : unbond " ) ; require ( liquidity Unbonding [ msg . sender ] [ liquidity ] [ job ] < now , " remove Job : unbonding " ) ; uint amount liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] ; liquidity Provided [ msg . sender ] [ liquidity ] [ job ] liquidity Provided [ msg . sender ] [ liquidity ] [ job ] . sub ( amount ) ; liquidity Amounts Unbonding [ msg . sender ] [ liquidity ] [ job ] 0 ; IERC20 ( liquidity ) . safe Transfer ( msg . sender , amount ) ; emit Remove Job ( job , liquidity , msg . sender , block . number , amount ) ; }
function change Proxy Admin ( Transparent Upgradeable Proxy proxy , address new Admin ) public virtual only Owner { proxy . change Admin ( new Admin ) ; }
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function transfer Mintership ( address new Minter ) public virtual only Minter { require ( new Minter ! address ( 0 ) , " Mintable : new minter is the zero address " ) ; emit Mintership Transferred ( minter , new Minter ) ; minter new Minter ; }
function propose Fork ( address prop New Tellor Address ) external { tellor . propose Fork ( prop New Tellor Address ) ; }
function from U Int ( uint256 x ) internal pure returns ( int128 ) { require ( x < 0x7FFFFFFFFFFFFFFF ) ; return int128 ( x < < 64 ) ; }
function process Purchase ( address beneficiary , uint256 token Amount ) internal { balances [ beneficiary ] balances [ beneficiary ] . add ( token Amount ) ; deliver Tokens ( address ( vault ) , token Amount ) ; }
function initialize ( address pool , address [ ] memory tokens ) public initializer { Module . initialize ( pool ) ; Defi Operator Role . initialize ( msg Sender ( ) ) ; registered Vault Tokens new address [ ] ( tokens . length ) ; claimable Tokens new uint256 [ ] ( tokens . length ) ; last Processed Requests new uint256 [ ] ( tokens . length ) ; last Processed Deposits new uint256 [ ] ( tokens . length ) ; remainders new uint256 [ ] ( tokens . length ) ; for ( uint256 i 0 ; i < tokens . length ; i + + ) { registered Vault Tokens [ i ] tokens [ i ] ; } available Enabled false ; }
function get L Pinfo ( uint256 pair Code )
function teleport ( string memory to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] balances [ msg . sender ] . sub ( tokens ) ; balances [ address ( 0 ) ] balances [ address ( 0 ) ] . add ( tokens ) ; emit Teleport ( msg . sender , to , tokens ) ; return true ; }
function set Reward Liquidation Threshold ( uint256 threshold )
function donate Delegated No Reward ( address payable donor ) public payable { require ( msg . value > 0 , " Must include some ETH to donate " ) ; ( uint256 charity Allocation , uint256 bonding Allocation ) allocate ( msg . value ) ; charity Vault . deposit . value ( charity Allocation ) ( donor ) ; address payable bonding Vault Payable address ( uint160 ( address ( get Registry ( ) . get Bonding Vault ( ) ) ) ) ; bonding Vault Payable . transfer ( bonding Allocation ) ; emit Log Donation Received ( donor , msg . value ) ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; require ( is Contract ( target ) , " Address : call to non contract " ) ; ( bool success , bytes memory returndata ) target . call { value : value } ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function set Funding ( uint256 pid , string memory name , address addr , uint256 ratio ) public only Owner { Funding Holder Info storage fhi funding Holders [ pid ] ; fhi . name name ; fhi . addr addr ; fhi . ratio ratio ; }
function add Timestamp ( address reward Address )
function TX DATA AVAILABILITY SIZE ( ) internal pure returns ( uint32 ) { return 68 ; }
function claim Ownership ( )
function set New Get Bancor Data ( address bancor Data ) public only Owner { bancor Data I Get Bancor Data ( bancor Data ) ; }
function current Cumulative Prices (
event Daily Data Update (
function token URI ( uint256 token Id ) external view returns ( string memory ) ;
modifier only Owner ( ) { require ( msg . sender owner ) ; ; }
modifier when Not Paused ( ) { require ( ! paused ) ; ; }
function calculate Borrow Exact In ( address token , uint in Exact ) public view returns ( uint ) { address [ ] memory path new address [ ] ( 2 ) ; path [ 0 ] address ( STABLE ) ; path [ 1 ] token ; return UNI . get Amounts Out ( in Exact , path ) [ 1 ] ; }
function receive Purchase ( Direct Crowdsale Storage storage self , uint256 amount ) returns ( bool ) { require ( msg . sender ! self . base . owner ) ; require ( self . base . valid Purchase ( ) ) ; require ( ( self . base . owner Balance + amount ) < self . base . cap Amount ) ; if ( ( self . change Interval > 0 ) & & ( now > ( self . last Price Change Time + self . change Interval ) ) ) { self . last Price Change Time self . last Price Change Time + self . change Interval ; uint256 index ( now self . base . start Time ) self . change Interval ; if ( self . token Price Points . length < index ) index self . token Price Points . length 1 ; self . base . change Token Price ( self . token Price Points [ index ] ) ; Log Token Price Change ( self . base . tokens Per Eth , " Token Price has changed ! " ) ; } number of tokens that will be purchased bool err ; the new balance of the owner of the crowdsale temp calc holder for calculating token wei change for purchaser temp calc holder ( err , wei Tokens ) amount . times ( self . base . tokens Per Eth ) ; require ( ! err ) ; if ( self . base . token Decimals < 18 ) { zeros 10 ( 18 uint256 ( self . base . token Decimals ) ) ; num Tokens wei Tokens zeros ; leftover Wei wei Tokens % zeros ; self . base . leftover Wei [ msg . sender ] + leftover Wei ; } else { zeros 10 ( uint256 ( self . base . token Decimals ) 18 ) ; num Tokens wei Tokens zeros ; } self . base . has Contributed [ msg . sender ] + amount leftover Wei ; require ( num Tokens < self . base . token . balance Of ( this ) ) ; ( err , new Balance ) self . base . owner Balance . plus ( amount leftover Wei ) ; require ( ! err ) ; " deposit " the amount self . base . withdraw Tokens Map [ msg . sender ] + num Tokens ; ( err , remainder ) self . base . withdraw Tokens Map [ self . base . owner ] . minus ( num Tokens ) ; self . base . withdraw Tokens Map [ self . base . owner ] remainder ; Log Tokens Bought ( msg . sender , num Tokens ) ; return true ; }
function reset Timestamp ( address reward Address )
function set Max In Progress Proposals ( uint16 new Max In Progress Proposals ) external { require Is Initialized ( ) ; require ( msg . sender address ( this ) , ERROR ONLY GOVERNANCE ) ; require ( new Max In Progress Proposals > 0 , " Governance : Requires non zero new Max In Progress Proposals " ) ; max In Progress Proposals new Max In Progress Proposals ; emit Max In Progress Proposals Updated ( new Max In Progress Proposals ) ; }
function mod ( uint a , uint b ) internal pure returns ( uint ) { return mod ( a , b , " mod : % " ) ; }
function set Staking Token ( address staking Token Address ) internal { staking Token IERC20 ( staking Token Address ) ; }
function burn ( uint256 token Id ) external { address operator msg Sender ( ) ; require ( owner Of ( token Id ) operator | | is Approved ( token Id , operator ) , " Digitalax Garment NFT . burn : Only garment owner or approved " ) ; if ( parent To Child Mapping [ token Id ] . length ( ) > 0 ) { extract And Transfer Children From Parent ( token Id , msg Sender ( ) ) ; } burn ( token Id ) ; delete garment Designers [ token Id ] ; delete primary Sale Price [ token Id ] ; }
function sub ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b < a , " Safe Math : subtraction overflow " ) ; uint64 c a b ; return c ; }
function view Raw Amount ( int128 amount ) public view returns ( uint256 amount ) { uint256 rate cdai . exchange Rate Stored ( ) ; amount ( amount . mulu ( 1e18 ) 1e18 ) rate ; }
function transfer Ownership ( address new Owner ) public onlyowner { transfer Ownership ( new Owner ) ; }
function get And Validate Adapter With Hash ( bytes32 integration Hash ) internal view returns ( address ) { address adapter controller . get Integration Registry ( ) . get Integration Adapter With Hash ( address ( this ) , integration Hash ) ; require ( adapter ! address ( 0 ) , " Must be valid adapter " ) ; return adapter ; }
function last Time Reward Applicable ( ) external view returns ( uint256 ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier get Multiplier ( pool . last Reward Block , block . number ) ; uint256 dollar Reward multiplier . mul ( dollar Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; dollar . mint ( devaddr , dollar Reward . div ( dev Fund Div Rate ) ) ; dollar . mint ( address ( this ) , dollar Reward . mul ( 101 ) . div ( 100 ) ) ; pool . acc Dollar Per Share pool . acc Dollar Per Share . add ( dollar Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function borrow Rate Per Block ( ) external view returns ( uint ) { delegate To View And Return ( ) ; }
function add Minter Role ( address address ) external { grant Role ( MINTER ROLE , address ) ; emit Minter Role Granted ( address , msg Sender ( ) ) ; }
function get Max Debt ( uint cdp Id , bytes32 ilk ) public virtual view returns ( uint ) { uint price get Price ( ilk ) ; ( , uint mat ) spotter . ilks ( ilk ) ; ( uint collateral , uint debt ) get Cdp Info ( manager , cdp Id , ilk ) ; return sub ( sub ( div ( mul ( collateral , price ) , mat ) , debt ) , 10 ) ; }
function div ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { require ( b > 0 , " Safe Math : division by zero " ) ; uint64 c a b ; return c ; }
function withdraw For ( address account , uint shares , address output , uint min output amount ) public override non reentrant returns ( uint output amount ) { require ( keccak256 ( abi . encode Packed ( tx . origin , block . number ) ) ! minter Block , " REENTR MINT BURN " ) ; output amount ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint withdrawal Protection Fee vault Master . withdrawal Protection Fee ( ) ; if ( withdrawal Protection Fee > 0 ) { uint withdrawal Protection output amount . mul ( withdrawal Protection Fee ) . div ( 10000 ) ; output amount output amount . sub ( withdrawal Protection ) ; } uint b based Token . balance Of ( address ( this ) ) ; if ( b < output amount ) { uint to Withdraw output amount . sub ( b ) ; uint withdraw Fee I Controller ( controller ) . withdraw ( to Withdraw ) ; uint after based Token . balance Of ( address ( this ) ) ; uint diff after . sub ( b ) ; if ( diff < to Withdraw ) { output amount b . add ( diff ) ; } if ( withdraw Fee > 0 ) { output amount output amount . sub ( withdraw Fee , " output amount < withdraw Fee " ) ; } } if ( output address ( based Token ) ) { require ( output amount > min output amount , " slippage " ) ; based Token . safe Transfer ( account , output amount ) ; } else { based Token . safe Transfer ( address ( based Converter ) , output amount ) ; uint received based Converter . convert ( address ( based Token ) , output , address ( this ) ) ; require ( received > min output amount , " slippage " ) ; IERC20 ( output ) . safe Transfer ( account , received ) ; } }
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " Mint to the zero address " ) ; uint256 credit Amount amount . mul Truncate ( credits Per Token ( account ) ) ; bool is Non Rebasing Account is Non Rebasing Address ( account ) ; if ( is Non Rebasing Account ) { if ( non Rebasing Credits Per Token [ account ] 0 ) { non Rebasing Credits Per Token [ account ] rebasing Credits Per Token ; } non Rebasing Credits non Rebasing Credits . add ( credit Amount ) ; non Rebasing Supply non Rebasing Supply . add ( amount ) ; } else { rebasing Credits rebasing Credits . add ( credit Amount ) ; } credit Balances [ account ] credit Balances [ account ] . add ( credit Amount ) ; total Supply total Supply . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function mul Truncate Scale ( uint256 x , uint256 y , uint256 scale )
function internal Distribute Token With Amount ( IERC20 token , uint256 amount To Distribute ) internal { address token Address address ( token ) ; Distribution memory distribution distribution ; for ( uint256 j 0 ; j < distribution . receivers . length ; j + + ) { uint256 amount amount To Distribute . mul ( distribution . percentages [ j ] ) . div ( DISTRIBUTION BASE ) ; if ( amount 0 ) { continue ; } if ( token Address ! Eth Address Lib . eth Address ( ) ) { token . safe Transfer ( distribution . receivers [ j ] , amount ) ; } else { ( bool success , ) distribution . receivers [ j ] . call . value ( amount ) ( " " ) ; require ( success , " Reverted ETH transfer " ) ; } emit Distributed ( distribution . receivers [ j ] , distribution . percentages [ j ] , amount ) ; } }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Steak Per Share : 0 } ) ) ; }
function set Debt Auction Delay ( address vow , uint256 duration ) public { Fileable ( vow ) . file ( " wait " , duration ) ; }
function deposit Underlying ( uint256 underlying Cost ) public override non Reentrant
function start Sale ( ) only Owner public { require ( address Locked true , ' ADDRESS NOT APPROVED ' ) ; require ( nonce 1 , ' NONCE ERROR ' ) ; start Date now ; sale Halted false ; stage1 start Date + 2 days ; stage2 start Date + 6 days ; end Date start Date + 14 days ; safety Switch end Date + 2 days ; nonce + + ; }
function Claim Staked Tokens ( ) external { require ( users [ msg . sender ] . active Deposit > 0 , " no running stake " ) ; uint256 penalty Fee 0 ; claiming before lock up time penalty Fee penalty Fee ; } uint256 to Transfer users [ msg . sender ] . active Deposit . sub ( one Percent ( users [ msg . sender ] . active Deposit ) . mul ( penalty Fee ) ) ; require ( ERC20Interface ( NOTE ) . transfer ( msg . sender , to Transfer ) ) ; users [ msg . sender ] . pending Gains pending Reward ( msg . sender ) ; emit Tokens Claimed ( msg . sender , to Transfer ) ; users [ msg . sender ] . active Deposit 0 ; }
function precise Div ( int256 a , int256 b ) internal pure returns ( int256 ) { return a . mul ( PRECISE UNIT INT ) . div ( b ) ; }
function div ( uint a , uint b ) internal pure returns ( uint ) { return div ( a , b , " div : " ) ; }
function mul ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c a b ; require ( c ! MIN INT256 | | ( a & MIN INT256 ) ! ( b & MIN INT256 ) ) ; require ( ( b 0 ) | | ( c b a ) ) ; return c ; }
event Keeper Unbonding ( address indexed keeper , uint block , uint deactive , uint bond ) ;
function get Vote Out Status ( address subject ) external view returns ( bool voted Out , uint voted Stake , uint total Delegated Stake ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To I Uniswap V2Factory ( factory ) . fee To ( ) ; fee On fee To ! address ( 0 ) ; gas savings if ( fee On ) { if ( k Last ! 0 ) { uint root K Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! 0 ) { k Last 0 ; } }
function approve ( address spender , uint value ) public override returns ( bool success ) { allowance [ msg . sender ] [ spender ] value ; emit Approval ( msg . sender , spender , value ) ; return true ; }
function borrow Rate Per Block ( ) external view returns ( uint ) { return interest Rate Model . get Borrow Rate ( get Cash Prior ( ) , total Borrows , total Reserves ) ; }
function transfer From ( Shell Storage . Shell storage shell , address sender , address recipient , uint256 amount ) external returns ( bool ) { transfer ( shell , msg . sender , recipient , amount ) ; approve ( shell , sender , msg . sender , sub ( shell . allowances [ sender ] [ msg . sender ] , amount , " Shell insufficient allowance " ) ) ; return true ; }
function earned ( address holder ) external view returns ( uint256 ) ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < bonus End Block ) { return to . sub ( from ) . mul ( bonus Multiplier ) ; } else if ( from > bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( bonus Multiplier ) . add ( to . sub ( bonus End Block ) ) ; } }
function reserve Token ( ) external view returns ( address reserve Token ) ;
function execute ( address target , bytes memory data ) public virtual payable returns ( bytes32 ) ;
function increment Collateral Balances (
function rebalance With GST ( )
function supply Rate Per Block ( ) external view returns ( uint ) { bytes memory data delegate To View Implementation ( abi . encode With Signature ( " supply Rate Per Block ( ) " ) ) ; return abi . decode ( data , ( uint ) ) ; }
function get Total Times Claimed ( )
function verify ( bytes32 [ ] memory proof , bytes32 root , bytes32 leaf ) internal pure returns ( bool ) { bytes32 computed Hash leaf ; for ( uint256 i 0 ; i < proof . length ; i + + ) { bytes32 proof Element proof [ i ] ; if ( computed Hash < proof Element ) { computed Hash keccak256 ( abi . encode Packed ( computed Hash , proof Element ) ) ; } else { computed Hash keccak256 ( abi . encode Packed ( proof Element , computed Hash ) ) ; } } return computed Hash root ; }
function convert Mining To Underlying ( Self storage self , uint256 input Amount ) internal
function has External Position ( I Set Token set Token , address component ) internal view returns ( bool ) { return set Token . get External Position Modules ( component ) . length > 0 ; }
function set Burning Rate ( Self storage self , uint256 burning Rate ) public
function implementation ( ) public view returns ( address ) { return implementation ; }
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; }
function implements ERC165Interface No Cache ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function transfer ( address from , address to , uint256 token Id ) internal { require ( owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; before Token Transfer ( from , to , token Id ) ; approve ( address ( 0 ) , token Id ) ; Option storage option options [ token Id ] ; option . buyer to ; user Options [ to ] . push ( token Id ) ; emit Transfer ( from , to , token Id ) ; }
function burn ( address account , uint256 value ) internal { require ( account ! address ( 0 ) ) ; total Supply total Supply . sub ( value ) ; balances [ account ] balances [ account ] . sub ( value ) ; emit Transfer ( account , address ( 0 ) , value ) ; }
function burn ( uint256 amount ) public { burn ( msg Sender ( ) , amount ) ; }
function exit Balancer (
function get Answer ( uint256 round Id )
function s Internal To S Original ( uint s Internal Amount )
function transfer ( address sender , address recipient , uint256 amount ) internal override ( ERC20 ) { move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; ERC20 . transfer ( sender , recipient , amount ) ; }
function deactivate ( )
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ; }
function release ( address payable account ) public virtual { require ( shares [ account ] > 0 , " Payment Splitter : account has no shares " ) ; uint256 total Received address ( this ) . balance . add ( total Released ) ; uint256 payment total Received . mul ( shares [ account ] ) . div ( total Shares ) . sub ( released [ account ] ) ; require ( payment ! 0 , " Payment Splitter : account is not due payment " ) ; released [ account ] released [ account ] . add ( payment ) ; total Released total Released . add ( payment ) ; account . transfer ( payment ) ; emit Payment Released ( account , payment ) ; }
function authorize Operator ( address operator ) external ;
function mint ( address to , uint256 token Id ) internal virtual override { super . mint ( to , token Id ) ; add Token To Owner Enumeration ( to , token Id ) ; add Token To All Tokens Enumeration ( token Id ) ; }
function compute New Reward ( uint256 current Reward Tokens ,
function redeem ( uint256 value , bytes calldata data ) external ;
function get Token By Uniswap Exchange ( address exchange )
function set Reserve Rate ( uint256 reserve Rate ) external { require ( msg . sender governance , " not governance " ) ; require ( reserve Rate < reserve Rate Max , " invalid rate " ) ; reserve Rate reserve Rate ; }
function claim Registry Management ( ) external only Pending Registry Admin { transfer Registry Management ( pending Registry Admin ) ; pending Registry Admin address ( 0 ) ; }
function renew Hold ( address token , bytes32 hold Id , uint256 time To Expiration , bytes calldata certificate ) external returns ( bool ) { return renew Hold ( token , hold Id , compute Expiration ( time To Expiration ) , certificate ) ; }
function get Guardian Delegators Staking Rewards Percent Mille ( address guardian ) external view returns ( uint256 delegator Rewards Ratio Percent Mille ) ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; require ( value < balances [ from ] ) ; require ( value < allowed [ from ] [ msg . sender ] ) ; balances [ from ] balances [ from ] . sub ( value ) ; balances [ to ] balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }
function asset To Usd ( address asset , uint amount ) public override view returns ( uint ) { return eth To Usd ( asset To Eth ( asset , amount ) ) ; }
function is Approved For All ( address owner , address operator ) public view returns ( bool ) { return operator Approvals [ owner ] [ operator ] ; }
function teams Count ( address addr , uint256 amount )
function total Supply ( ) public view returns ( uint256 ) { return total Supply ; }
function transfer To Address ( address to , uint value , bytes data ) private returns ( bool success ) { require ( balance Of [ msg . sender ] > value ) ; balance Of [ msg . sender ] balance Of [ msg . sender ] . sub ( value ) ; balance Of [ to ] balance Of [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }
function get Redeem Proportion Amount ( uint256 amount ) external view returns ( uint256 [ ] memory , uint256 ) { uint256 [ ] memory balances balances ; require ( amount > 0 , " zero amount " ) ; uint256 D total Supply ; uint256 [ ] memory amounts new uint256 [ ] ( balances . length ) ; uint256 fee Amount 0 ; if ( redeem Fee > 0 ) { fee Amount amount . mul ( redeem Fee ) . div ( fee Denominator ) ; amount amount . sub ( fee Amount ) ; } for ( uint256 i 0 ; i < balances . length ; i + + ) { amounts [ i ] balances [ i ] . mul ( amount ) . div ( D ) . div ( precisions [ i ] ) ; } return ( amounts , fee Amount ) ; }
function start Game ( address liquidity Pool , uint seed1 ) external only Owner { require ( game Started false , ' The game has already started ' ) ; require ( liquidity Pool ! address ( 0 ) , ' Need the ETH X20 liquidity pool address ' ) ; chance Rate 100 ; liquidity Pool liquidity Pool ; seed1 seed1 ; seed2 rand Modulus ( uint ( 10000000 ) , seed1 ) ; game Started true ; }
function initialize ( address pool ) public initializer { Module . initialize ( pool ) ; Savings Cap . initialize ( msg Sender ( ) ) ; Vault Operator Role . initialize ( msg Sender ( ) ) ; }
function get10Percent1 ( uint256 salt ) internal view returns ( bool ) { return ( uint256 ( keccak256 ( abi . encode Packed ( block . timestamp , salt ) ) ) % 10 ) 1 ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool pool Info [ pid ] ; if ( block . number < pool . last Reward Block ) { return ; } uint256 lp Supply pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply 0 ) { pool . last Reward Block block . number ; return ; } uint256 multiplier block . number . sub ( pool . last Reward Block ) ; uint256 tako Reward multiplier . mul ( tako Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; tako . mint ( address ( this ) , tako Reward ) ; pool . acc Tako Per Share pool . acc Tako Per Share . add ( tako Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block block . number ; }
function add Many Locks ( address [ ] accounts , uint256 release Date ) external only Admin returns ( bool ) { require ( can Lock , " Access is denied . This feature was already disabled by an administrator . " ) ; require ( release Date > 0 , " Invalid release date . " ) ; for ( uint8 i 0 ; i < accounts . length ; i + + ) { address account accounts [ i ] ; if ( account ! address ( 0 ) & & ! admins [ account ] & & account ! owner ) { locking List [ account ] release Date ; emit Token Locked ( account , release Date ) ; } } return true ; }
function supports History ( ) external override pure returns ( bool ) { return false ; }
function liquidate ( uint256 id ) external only Operator non Reentrant { remove Share ( id ) ; lp Token . transfer ( address ( liq Strat ) , lp Token . balance Of ( address ( this ) ) ) ; liq Strat . execute ( address ( 0 ) , 0 , abi . encode ( sushi , 0 ) ) ; uint256 wad address ( this ) . balance ; Safe Token . safe Transfer ETH ( msg . sender , wad ) ; emit Liquidate ( id , wad ) ; }
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ; }
function has Duplicate ( address [ ] memory A ) internal pure returns ( bool ) { require ( A . length > 0 , " A is empty " ) ; for ( uint256 i 0 ; i < A . length 1 ; i + + ) { address current A [ i ] ; for ( uint256 j i + 1 ; j < A . length ; j + + ) { if ( current A [ j ] ) { return true ; } } } return false ; }
event New Reward Per Token ( uint256 old Reward Per Token , uint256 new Reward Per Token ) ;
function to String ( slice memory self ) internal pure returns ( string memory ) { string memory ret new string ( self . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; return ret ; }
function total Reserve Underlying ( ) public view virtual override returns ( uint256 total Reserve Underlying )
function change Beneficiary ( address new Beneficiary , address current Beneficiary ) public { require ( has Role ( ADMIN , msg . sender ) ) ; Beneficiaries storage b beneficiary [ current Beneficiary ] ; b . beneficiary new Beneficiary ; emit beneficiary Changed ( current Beneficiary , new Beneficiary , block . number ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ; }
function add Reserves Internal ( uint add Amount ) internal non Reentrant returns ( uint ) { uint error accrue Interest ( ) ; if ( error ! uint ( Error . NO ERROR ) ) { return fail ( Error ( error ) , Failure Info . ADD RESERVES ACCRUE INTEREST FAILED ) ; } ( error , ) add Reserves Fresh ( add Amount ) ; return error ; }
function prepare Deposit ( uint256 cost ) internal override returns ( bool success )
function invoke Unwrap WETH ( I Set Token set Token , address weth , uint256 quantity ) internal { bytes memory call Data abi . encode With Signature ( " withdraw ( uint256 ) " , quantity ) ; set Token . invoke ( weth , 0 , call Data ) ; }
function set Withdrawal Recipient (
function author ( ) external view returns ( address ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { require ( pool Is Added [ address ( lp Token ) ] false , ' add : pool already added ' ) ; pool Is Added [ address ( lp Token ) ] true ; if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block block . number > start Block ? block . number : start Block ; total Alloc Point total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Sushi Per Share : 0 } ) ) ; }
event Joined ( address indexed staker , uint256 deposited , uint256 minted ) ;
function update Restricted Transfer ( address restricted Transfer ) public only Owner { restricted Transfer IERC1404 ( restricted Transfer ) ; emit Updated Restricted Transfer ( restricted Transfer ) ; }
function check If Charity Expired ( ) public view returns ( bool ) { if ( now > raise By ) { return ( true ) ; } }
function check And Call Transfer ( address from , address to , uint256 value , bytes memory data ) internal returns ( bool ) { if ( ! to . is Contract ( ) ) { return false ; } bytes4 retval IERC1363Receiver ( to ) . on Transfer Received ( msg Sender ( ) , from , value , data ) ; return ( retval ERC1363 RECEIVED ) ; }
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ; }
function stake Change Batch ( address [ ] calldata stake Owners , uint256 [ ] calldata amounts , bool [ ] calldata signs , uint256 [ ] calldata updated Stakes ) external override only Staking Contract Handler only When Active { uint batch Length stake Owners . length ; require ( batch Length amounts . length , " stake Owners , amounts array length mismatch " ) ; require ( batch Length signs . length , " stake Owners , signs array length mismatch " ) ; require ( batch Length updated Stakes . length , " stake Owners , updated Stakes array length mismatch " ) ; for ( uint i 0 ; i < stake Owners . length ; i + + ) { stake Change ( stake Owners [ i ] , updated Stakes [ i ] ) ; } }
function deposit ( address depositor , uint256 [ ] calldata token Ids ) external { require ( status ! ENTERED , " Reentrancy : reentrant call " ) ; status ENTERED ; require ( depositor ! address ( 0 ) , " Zero address not allowed " ) ; require ( depositor ! address ( this ) , " This address not allowed " ) ; require ( depositor ! core Address , " Token contract not allowed " ) ; uint256 length token Ids . length ; uint256 count token Ids . length ; require ( count > 0 , " No tokens to deposit " ) ; require ( length + count > length , " Vault full " ) ; depositor msg . sender ; uint256 token Id ; for ( uint256 i ; i < count ; i + + ) { token Id token Ids [ i ] ; token Ids . push ( token Id ) ; indices [ token Id ] + + length ; require ( core Contract . owner Of ( token Id ) msg . sender , " You are not the owner " ) ; core Contract . safe Transfer From ( msg . sender , address ( this ) , token Id ) ; emit Token Deposited ( token Id ) ; } mint ( depositor , count base Wrapped Amount ) ; depositor address ( 0 ) ; status NOT ENTERED ; }
function burn ( address owner , uint256 token Id ) internal { super . burn ( owner , token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } }
function deactivate ( ) external ;
function released ( ) public view returns ( uint256 ) { return released ; }
function claim Pending ( address sp ) internal view returns ( bool ) { Claims Manager claims Manager Claims Manager ( claims Manager Address ) ; return claims Manager . claim Pending ( sp ) ; }
function mint ( address account , uint256 amount ) internal { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; total Supply total Supply . add ( amount ) ; balances [ account ] balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function calculate Unclaimed Distributions ( address account ) public view returns ( uint256 ) { return calculate Claim Amount ( account ) ; }
function approve ( address spender , uint256 amount ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] amount ; emit Approval ( msg . sender , spender , amount ) ; return true ; }
function get Sub Tokens ( ) external override view returns ( address [ ] memory ) { return sub Tokens ; }
function transfer From ( address from , address to , uint256 value ) public override not Restricted ( from , to , value ) returns ( bool success ) { success super . transfer From ( from , to , value ) ; }
function delegate ( address delegatee ) external { return delegate ( msg . sender , delegatee ) ; }
function try Mod ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { if ( b 0 ) return ( false , 0 ) ; return ( true , a % b ) ; } }
event Accrue Interest ( uint interest Accumulated , uint borrow Index , uint total Borrows ) ;
function sell ( uint256 token To Sell ) external returns ( bool ) { require ( is Sell Prevented 0 , " Sell not allowed . " ) ; require ( is User Sell Disallowed [ msg . sender ] false , " Sell not allowed for user . " ) ; require ( is User Created [ msg . sender ] , " user not registered " ) ; require ( circulated Supply > 0 , " no circulated tokens " ) ; require ( token To Sell > 0 , " can not sell 0 token " ) ; require ( token To Sell < token Balances [ msg . sender ] , " not enough tokens to transact " ) ; require ( token To Sell . add ( circulated Supply ) < total Supply , " exceeded total supply " ) ; uint256 converted Ethers ether Value For Sell ( token To Sell ) ; msg . sender . transfer ( converted Ethers ) ; burn ( msg . sender , token To Sell ) ; emit Sell ( msg . sender , converted Ethers , token To Sell , ( current Price ( current Price 100 ) ) ) ; return true ; }
function ( ) public { revert ( ) ; }
modifier is Owner ( ) { require ( msg . sender owner ) ; ; }
function staking ( uint256 amount ) public when Not Paused override returns ( bool ) { staking Storage . require In Staking Period ( ) ; require ( amount > min Staking Amount , " Staking amount too small . " ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) < account Staking List Limit , " Staking list out of limit . " ) ; lina Token . transfer From ( msg . sender , address ( this ) , amount ) ; staking Storage . Push Staking Data ( msg . sender , amount , block . timestamp ) ; staking Storage . Add Weeks Total ( block . timestamp , amount ) ; emit Staking ( msg . sender , amount , block . timestamp ) ; return true ; }
function get Unclaimed Rewards Data ( )
function enabled Modules ( ) external view returns ( address [ ] memory modules ) ;
function accept Ownership ( ) public { require ( msg . sender new Owner , " Caller is not the new owner " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; new Owner address ( 0 ) ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return mod ( a , b , " Safe Math : modulo by zero " ) ; }
function drago Count ( ) external view returns ( uint256 ) ;
function cancel Transfer Position ( ) external only Pre Expiration ( ) non Reentrant ( ) { Position Data storage position Data get Position Data ( msg . sender ) ; require ( position Data . transfer Position Request Pass Timestamp ! 0 , " No pending transfer " ) ; emit Request Transfer Position Canceled ( msg . sender ) ; position Data . transfer Position Request Pass Timestamp 0 ; }
function permit ( address owner , address spender , uint256 amount , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < deadline , " expired " ) ; bytes32 hash Struct keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , amount , nonces [ owner ] + + , deadline ) ) ; bytes32 hash keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer ecrecover ( hash , v , r , s ) ; require ( signer ! address ( 0 ) & & signer owner , " ! signer " ) ; approve ( owner , spender , amount ) ; }
function stakes Token ( ) external view returns ( address stakes Token ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts new uint [ ] ( path . length ) ; amounts [ 0 ] amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; } }
function transfer From ( address from , address to , uint256 value ) public returns ( bool ) { allowed [ from ] [ msg . sender ] allowed [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; emit Approval ( from , msg . sender , allowed [ from ] [ msg . sender ] ) ; return true ; }
