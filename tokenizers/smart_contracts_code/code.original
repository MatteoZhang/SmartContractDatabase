 function count_bytes(uint256 n) constant internal returns (uint256 c) { uint i = 0; uint mask = 1; while (n >= mask) { i += 1; mask *= 256; } return i;
 function balanceOf(address owner) public constant returns (uint256 balance) { return s_balances[owner];
 function transfer(address to, uint256 value) public returns (bool success) { address from = msg.sender; return internalTransfer(from, to, value);
 function transferFrom(address from, address to, uint256 value) public returns (bool success) { address spender = msg.sender; if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) { s_allowances[from][spender] -= value; return true; } else { return false; }
 function approve(address spender, uint256 value) public returns (bool success) { address owner = msg.sender; if (value != 0 && s_allowances[owner][spender] != 0) { return false; } s_allowances[owner][spender] = value; Approval(owner, spender, value); return true;
 function allowance(address owner, address spender) public constant returns (uint256 remaining) { return s_allowances[owner][spender];
 function totalSupply() public constant returns (uint256 supply) { return s_head - s_tail;
 function makeChild() internal returns (address addr) { assembly {                          let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, 0x00756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3) addr := create(0, add(solidity_free_mem_ptr, 1), 31) }
 function mint(uint256 value) public { for (uint256 i = 0; i < value; i++) { makeChild(); } s_head += value; s_balances[msg.sender] += value;
 function destroyChildren(uint256 value) internal { uint256 tail = s_tail;  for (uint256 i = tail + 1; i <= tail + value; i++) { mk_contract_address(this, i).call(); } s_tail = tail + value;
 function free(uint256 value) public returns (bool success) { uint256 from_balance = s_balances[msg.sender]; if (value > from_balance) { return false; } destroyChildren(value); s_balances[msg.sender] = from_balance - value; return true;
 function freeUpTo(uint256 value) public returns (uint256 freed) { uint256 from_balance = s_balances[msg.sender]; if (value > from_balance) { value = from_balance; } destroyChildren(value); s_balances[msg.sender] = from_balance - value; return value;
 function freeFrom(address from, uint256 value) public returns (bool success) { address spender = msg.sender; uint256 from_balance = s_balances[from]; if (value > from_balance) { return false; } mapping(address => uint256) from_allowances = s_allowances[from]; uint256 spender_allowance = from_allowances[spender]; if (value > spender_allowance) { return false; } destroyChildren(value); s_balances[from] = from_balance - value; from_allowances[spender] = spender_allowance - value; return true;
 function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) { address spender = msg.sender; uint256 from_balance = s_balances[from]; if (value > from_balance) { value = from_balance; } mapping(address => uint256) from_allowances = s_allowances[from]; uint256 spender_allowance = from_allowances[spender]; if (value > spender_allowance) { value = spender_allowance; } destroyChildren(value); s_balances[from] = from_balance - value; from_allowances[spender] = spender_allowance - value; return value;
 function verifyParticipant(address participant) public onlyWhitelistAdmin { if (!isWhitelisted(participant)) { addWhitelisted(participant); }
 function removeWhitelistAdmin(address account) public onlyOwner { require(account != msg.sender, "Use renounceWhitelistAdmin"); _removeWhitelistAdmin(account);
 function NRM() public { symbol = "NRM"; name = "Neuromachine"; decimals = 18; _totalSupply = 4958333333 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply);    FreezeAddress = 0x7777777777777777777777777777777777777777; FreezeTokens = _totalSupply.mul(30).div(100); balances[owner] = balances[owner].sub(FreezeTokens); balances[FreezeAddress] = balances[FreezeAddress].add(FreezeTokens); emit Transfer(owner, FreezeAddress, FreezeTokens); FreezeTokensReleaseTime = now + 365 days;
 function unfreezeTeamTokens(address unFreezeAddress) public onlyOwner returns (bool success) { require(balances[FreezeAddress] > 0); require(now >= FreezeTokensReleaseTime); balances[FreezeAddress] = balances[FreezeAddress].sub(FreezeTokens); balances[unFreezeAddress] = balances[unFreezeAddress].add(FreezeTokens); emit Transfer(FreezeAddress, unFreezeAddress, FreezeTokens); return true;
 function totalSupply() public constant returns (uint) { return _totalSupply.sub(balances[address(0)]);
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public isRunnning returns (bool success) { require(tokens <= balances[msg.sender]); require(tokens != 0); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public isRunnning returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public isRunnning returns (bool success) { require(tokens <= balances[from]); require(tokens <= allowed[from][msg.sender]); require(tokens != 0); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public isRunnning returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function burnTokens(uint256 tokens) public returns (bool success) { require(tokens <= balances[msg.sender]); require(tokens != 0); balances[msg.sender] = balances[msg.sender].sub(tokens); _totalSupply = _totalSupply.sub(tokens); emit Transfer(msg.sender, address(0), tokens); return true;
 function multisend(address[] to, uint256[] values) public onlyOwner returns (uint256) { for (uint256 i = 0; i < to.length; i++) { balances[owner] = balances[owner].sub(values[i]); balances[to[i]] = balances[to[i]].add(values[i]); emit Transfer(owner, to[i], values[i]); } return(i);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function burn(uint256 _amount) public { _burn(msg.sender, _amount);
 function totalSupply() public view returns (uint256) { return totalSupply;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true;
 function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens);  require(tokenCreationCap >= checkedSupply); // odd fractions won't be found require(tokenCreationCap >= checkedSupply);  totalSupply = checkedSupply; balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here balances[msg.sender] += tokens;   emit CreateToken(msg.sender, tokens);  // logs token creation emit CreateToken(msg.sender, tokens);  
 function finalize() external { require(isFinalized == false); require(msg.sender == ethFundDeposit); require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational require(totalSupply > tokenCreationMin);  require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);  isFinalized = true; assert(ethFundDeposit.send(address(this).balance)); // send the eth assert(ethFundDeposit.send(address(this).balance)); 
 function refund() external { require(isFinalized == false);                       // prevents refund if operational require(isFinalized == false);                        require(block.number > fundingEndBlock); // prevents refund until sale period is over require(block.number > fundingEndBlock);  require(totalSupply < tokenCreationMin); // no refunds if we sold enough require(totalSupply < tokenCreationMin);  require(msg.sender != tokenFundDeposit);    // team not entitled to a refund require(msg.sender != tokenFundDeposit);     uint256 tokenVal = balances[msg.sender]; require(tokenVal > 0); balances[msg.sender] = 0; totalSupply = totalSupply.sub(tokenVal); // extra safe totalSupply = totalSupply.sub(tokenVal);  uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges uint256 ethVal = tokenVal / tokenExchangeRate;  emit LogRefund(msg.sender, ethVal); // log it emit LogRefund(msg.sender, ethVal);  assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits assert(msg.sender.send(ethVal)); 
 function totalSupply() public view returns (uint256) { return totalSupply;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true;
 function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens);  require(tokenCreationCap >= checkedSupply); // odd fractions won't be found require(tokenCreationCap >= checkedSupply);  totalSupply = checkedSupply; balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here balances[msg.sender] += tokens;   emit CreateToken(msg.sender, tokens);  // logs token creation emit CreateToken(msg.sender, tokens);  
 function finalize() external { require(isFinalized == false); require(msg.sender == ethFundDeposit); require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational require(totalSupply > tokenCreationMin);  require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);  isFinalized = true; assert(ethFundDeposit.send(address(this).balance)); // send the eth assert(ethFundDeposit.send(address(this).balance)); 
 function refund() external { require(isFinalized == false);                       // prevents refund if operational require(isFinalized == false);                        require(block.number > fundingEndBlock); // prevents refund until sale period is over require(block.number > fundingEndBlock);  require(totalSupply < tokenCreationMin); // no refunds if we sold enough require(totalSupply < tokenCreationMin);  require(msg.sender != tokenFundDeposit);    // team not entitled to a refund require(msg.sender != tokenFundDeposit);     uint256 tokenVal = balances[msg.sender]; require(tokenVal > 0); balances[msg.sender] = 0; totalSupply = totalSupply.sub(tokenVal); // extra safe totalSupply = totalSupply.sub(tokenVal);  uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges uint256 ethVal = tokenVal / tokenExchangeRate;  emit LogRefund(msg.sender, ethVal); // log it emit LogRefund(msg.sender, ethVal);  assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits assert(msg.sender.send(ethVal)); 
 function totalSupply() public view returns (uint256) { return totalSupply;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true;
 function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens);  require(tokenCreationCap >= checkedSupply); // odd fractions won't be found require(tokenCreationCap >= checkedSupply);  totalSupply = checkedSupply; balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here balances[msg.sender] += tokens;   emit CreateToken(msg.sender, tokens);  // logs token creation emit CreateToken(msg.sender, tokens);  
 function finalize() external { require(isFinalized == false); require(msg.sender == ethFundDeposit); require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational require(totalSupply > tokenCreationMin);  require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);  isFinalized = true; assert(ethFundDeposit.send(address(this).balance)); // send the eth assert(ethFundDeposit.send(address(this).balance)); 
 function refund() external { require(isFinalized == false);                       // prevents refund if operational require(isFinalized == false);                        require(block.number > fundingEndBlock); // prevents refund until sale period is over require(block.number > fundingEndBlock);  require(totalSupply < tokenCreationMin); // no refunds if we sold enough require(totalSupply < tokenCreationMin);  require(msg.sender != tokenFundDeposit);    // team not entitled to a refund require(msg.sender != tokenFundDeposit);     uint256 tokenVal = balances[msg.sender]; require(tokenVal > 0); balances[msg.sender] = 0; totalSupply = totalSupply.sub(tokenVal); // extra safe totalSupply = totalSupply.sub(tokenVal);  uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges uint256 ethVal = tokenVal / tokenExchangeRate;  emit LogRefund(msg.sender, ethVal); // log it emit LogRefund(msg.sender, ethVal);  assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits assert(msg.sender.send(ethVal)); 
 function totalSupply() public view returns (uint256) { return totalSupply;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true;
 function createTokens() payable external { require (isFinalized == false); require(block.number > fundingStartBlock); require(block.number < fundingEndBlock); require(msg.value > 0); uint256 tokens = msg.value.mul(tokenExchangeRate); uint256 checkedSupply = totalSupply.add(tokens);  require(tokenCreationCap >= checkedSupply); // odd fractions won't be found require(tokenCreationCap >= checkedSupply);  totalSupply = checkedSupply; balances[msg.sender] += tokens;  // safeAdd not needed; bad semantics to use here balances[msg.sender] += tokens;   emit CreateToken(msg.sender, tokens);  // logs token creation emit CreateToken(msg.sender, tokens);  
 function finalize() external { require(isFinalized == false); require(msg.sender == ethFundDeposit); require(totalSupply > tokenCreationMin); // have to sell minimum to move to operational require(totalSupply > tokenCreationMin);  require(block.number > fundingEndBlock || totalSupply == tokenCreationCap);  isFinalized = true; assert(ethFundDeposit.send(address(this).balance)); // send the eth assert(ethFundDeposit.send(address(this).balance)); 
 function refund() external { require(isFinalized == false);                       // prevents refund if operational require(isFinalized == false);                        require(block.number > fundingEndBlock); // prevents refund until sale period is over require(block.number > fundingEndBlock);  require(totalSupply < tokenCreationMin); // no refunds if we sold enough require(totalSupply < tokenCreationMin);  require(msg.sender != tokenFundDeposit);    // team not entitled to a refund require(msg.sender != tokenFundDeposit);     uint256 tokenVal = balances[msg.sender]; require(tokenVal > 0); balances[msg.sender] = 0; totalSupply = totalSupply.sub(tokenVal); // extra safe totalSupply = totalSupply.sub(tokenVal);  uint256 ethVal = tokenVal / tokenExchangeRate; // should be safe; previous throws covers edges uint256 ethVal = tokenVal / tokenExchangeRate;  emit LogRefund(msg.sender, ethVal); // log it emit LogRefund(msg.sender, ethVal);  assert(msg.sender.send(ethVal)); // if you're using a contract; make sure it works with .send gas limits assert(msg.sender.send(ethVal)); 
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(y != address(_asset), "y"); require(ycrv != address(_asset), "ycrv"); require(yycrv != address(_asset), "yycrv"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount); 
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function RGBLIGHT(address _to, uint256 _amount) public onlyOwner { _RGBLIGHT(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accRGBPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingRGB(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accRGBPerShare = pool.accRGBPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 RGBReward = multiplier.mul(RGBPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accRGBPerShare = accRGBPerShare.add(RGBReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accRGBPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function RGBLIGHT(uint256 amount) public onlyOwner{ RGB.RGBLIGHT(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ RGB.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 RGBReward = multiplier.mul(RGBPerBlock).mul(pool.allocPoint).div(totalAllocPoint);  pool.accRGBPerShare = pool.accRGBPerShare.add(RGBReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accRGBPerShare).div(1e12).sub(user.rewardDebt); safeRGBTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accRGBPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accRGBPerShare).div(1e12).sub(user.rewardDebt); safeRGBTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accRGBPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeRGBTransfer(address _to, uint256 _amount) internal { uint256 RGBBal = RGB.balanceOf(address(this)); if (_amount > RGBBal) { RGB.transfer(_to, RGBBal); } else { RGB.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]);
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data); return true;
 function () external payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); withUpdates(_allocPoint); } else { uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accTestPerShare: 0 })); }
 function set (uint256 _pid, uint256 _allocPoint, address _lpPool, bool _withUpdate) public onlyOwner { if (_withUpdate) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_lpPool]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); } else { PoolInfo storage pool = poolInfo[_pid]; pool.lpToken.safeTransferFrom(address(_lpPool), address(msg.sender), _allocPoint); }
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from); } else if (_from >= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else { return bonusEndBlock.sub(_from).add( _to.sub(bonusEndBlock) ); }
 function pendingTest(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accTestPerShare = pool.accTestPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 testReward = multiplier.mul(testPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accTestPerShare = accTestPerShare.add(testReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accTestPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 testReward = multiplier.mul(testPerBlock).mul(pool.allocPoint).div(totalAllocPoint); test.mint(address(this), testReward); pool.accTestPerShare = pool.accTestPerShare.add(testReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accTestPerShare).div(1e12).sub(user.rewardDebt); safeTestTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accTestPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accTestPerShare).div(1e12).sub(user.rewardDebt); safeTestTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accTestPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function safeTestTransfer(address _to, uint256 _amount) internal { uint256 testBal = test.balanceOf(address(this)); if (_amount > testBal) { test.transfer(_to, testBal); } else { test.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function setPaused(bool _pause) public onlyOwner { paused = _pause; sync();
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accSEPPUKUPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingSEPPUKU(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accSEPPUKUPerShare = pool.accSEPPUKUPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 SEPPUKUReward = multiplier.mul(SEPPUKUPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accSEPPUKUPerShare = accSEPPUKUPerShare.add(SEPPUKUReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ SEPPUKU.mint(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ SEPPUKU.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 SEPPUKUReward = multiplier.mul(SEPPUKUPerBlock).mul(pool.allocPoint).div(totalAllocPoint); SEPPUKU.mint(devaddr, SEPPUKUReward.div(4)); SEPPUKU.mint(address(this), SEPPUKUReward); pool.accSEPPUKUPerShare = pool.accSEPPUKUPerShare.add(SEPPUKUReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt); safeSEPPUKUTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt); safeSEPPUKUTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeSEPPUKUTransfer(address _to, uint256 _amount) internal { uint256 SEPPUKUBal = SEPPUKU.balanceOf(address(this)); if (_amount > SEPPUKUBal) { SEPPUKU.transfer(_to, SEPPUKUBal); } else { SEPPUKU.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function available() public override view returns (uint) { return basedToken.balanceOf(address(this)).mul(min).div(max);
 function earnExtra(address _token) external { require(msg.sender == governance, "!governance"); require(converterMap[_token] != address(0), "!converter"); require(address(_token) != address(basedToken), "token"); require(address(_token) != address(this), "share"); uint _amount = IERC20(_token).balanceOf(address(this)); address _converter = converterMap[_token]; IERC20(_token).safeTransfer(_converter, _amount); Converter(_converter).convert(_token);
 function harvest(address reserve, uint amount) external override { require(msg.sender == controller, "!controller"); require(reserve != address(basedToken), "basedToken"); IERC20(reserve).safeTransfer(controller, amount);
 function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) public override _non_reentrant_ returns (uint _output_amount) {  require(keccak256(abi.encodePacked(tx.origin, block.number)) != _minterBlock, "REENTR MINT-BURN"); _output_amount = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares); uint _withdrawalProtectionFee = vaultMaster.withdrawalProtectionFee(); if (_withdrawalProtectionFee > 0) { uint _withdrawalProtection = _output_amount.mul(_withdrawalProtectionFee).div(10000); _output_amount = _output_amount.sub(_withdrawalProtection); }  uint b = basedToken.balanceOf(address(this)); if (b < _output_amount) { uint _toWithdraw = _output_amount.sub(b); uint _withdrawFee = IController(controller).withdraw(_toWithdraw); uint _after = basedToken.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _toWithdraw) { _output_amount = b.add(_diff); } if (_withdrawFee > 0) { _output_amount = _output_amount.sub(_withdrawFee, "_output_amount < _withdrawFee"); } } if (_output == address(basedToken)) { require(_output_amount >= _min_output_amount, "slippage"); basedToken.safeTransfer(_account, _output_amount); } else { basedToken.safeTransfer(address(basedConverter), _output_amount); uint _received = basedConverter.convert(address(basedToken), _output, address(this)); require(_received >= _min_output_amount, "slippage"); IERC20(_output).safeTransfer(_account, _received); }
 function get_virtual_price() external override view returns (uint) { return basedConverter.get_virtual_price().mul(getPricePerFullShare()).div(1e18);
 function getSetDecimals(IERC20Ext token) internal returns (uint256 tokenDecimals) { tokenDecimals = getDecimalsConstant(token); if (tokenDecimals > 0) return tokenDecimals; tokenDecimals = decimals[token]; if (tokenDecimals == 0) { tokenDecimals = token.decimals(); decimals[token] = tokenDecimals; }
 function getBalance(IERC20Ext token, address user) internal view returns (uint256) { if (token == ETH_TOKEN_ADDRESS) { return user.balance; } else { return token.balanceOf(user); }
 function getDecimals(IERC20Ext token) internal view returns (uint256 tokenDecimals) {  tokenDecimals = getDecimalsConstant(token); if (tokenDecimals > 0) return tokenDecimals;  tokenDecimals = decimals[token];   return (tokenDecimals > 0) ? tokenDecimals : token.decimals();
 function getDecimalsConstant(IERC20Ext token) internal pure returns (uint256) { if (token == ETH_TOKEN_ADDRESS) { return ETH_DECIMALS; } else if (token == USDT_TOKEN_ADDRESS) { return 6; } else if (token == DAI_TOKEN_ADDRESS) { return 18; } else if (token == USDC_TOKEN_ADDRESS) { return 6; } else if (token == WBTC_TOKEN_ADDRESS) { return 8; } else if (token == KNC_TOKEN_ADDRESS) { return 18; } else { return 0; }
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function getOutExactIn(address token, int256 input, int256 x, int256 y) public view returns (uint output) { int256 _x = x.add(input); int256 _y = f(_x, x, y); output = uint(y.sub(_y)); if (address(normalizers[token]) != address(0)) { (uint exchange, uint decimals) = normalizers[token].getPrice(token); output = output.mul(decimals).div(exchange); }
 function getInExactOut(address token, int256 output, int256 x, int256 y) public view returns (uint input) { int256 _y = y.sub(output); int256 _x = f(_y, y, x); input = uint(_x.sub(x)); if (address(normalizers[token]) != address(0)) { (uint exchange, uint decimals) = normalizers[token].getPrice(token); input = input.mul(decimals).div(exchange); }
 function normalize1e18(IERC20 token, uint _amount) public view returns (uint) { uint _decimals = ERC20Detailed(address(token)).decimals(); if (_decimals == uint(18)) { return _amount; } else { return _amount.mul(1e18).div(uint(10)**_decimals); }
 function normalize(IERC20 token, uint _amount) public view returns (uint) { uint _decimals = ERC20Detailed(address(token)).decimals(); if (_decimals == uint(18)) { return _amount; } else { return _amount.mul(uint(10)**_decimals).div(1e18); }
 function balance(IERC20 token) public view returns (uint) { address _token = address(token); uint _balance = IERC20(_token).balanceOf(address(this)); if (address(normalizers[_token]) != address(0)) { (uint exchange, uint decimals) = normalizers[_token].getPrice(_token); _balance = _balance.mul(exchange).div(decimals); } return normalize1e18(token, _balance);
 function i(uint x) public pure returns (int256) { return int256(x);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function approveAndCall(address spender, uint256 amount, string memory data) public returns (bool success) { approve(spender, amount);	// 給予要操作轉帳的合約允許之意。 approve(spender, amount);	 TokenRecipient(spender).receiveApproval(msg.sender, amount, address(this), data); return true;
 function supply(address _to, uint256 _amount) public onlyOwner { _supply(_to, _amount);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function getTransfersProxy() public view returns (address) { return 0x882d80D3a191859d64477eb78Cca46599307ec1C;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function claim(address reserve, uint amount) external { require(msg.sender == governance, "!governance"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(governance, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);   uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Strategy(strategy).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } }  token.safeTransfer(msg.sender, r);
 function operatorRegister(uint tBTCBalance, uint lnBalance, uint linearFee, uint constantFee, string memory publicUrl) public { require(operators[msg.sender].exists==false, "Operator has already been registered before"); operators[msg.sender] = Operator(publicUrl, tBTCBalance, lnBalance, true, linearFee, constantFee); if(tBTCBalance > 0){ tBTContract.transferFrom(msg.sender, address(this), tBTCBalance); } operatorList.push(msg.sender);
 function getOperatorListLength() view public returns(uint length){ return operatorList.length;
 function operatorWithdrawTBTC(uint amount) public returns(bool){ Operator storage op = operators[msg.sender]; require(op.tBTCBalance >= amount); op.tBTCBalance -= amount; tBTContract.transfer(msg.sender, amount); return true;
 function operatorDepositTBTC(uint amount) public returns(bool){ Operator storage op = operators[msg.sender]; require(op.exists == true); // Not needed, just there to make sure people don't lose money require(op.exists == true);  op.tBTCBalance += amount; tBTContract.transferFrom(msg.sender, address(this), amount); return true;
 function operatorSetFees(uint newLinearFee, uint newConstantFee) public { operators[msg.sender].linearFee = newLinearFee; operators[msg.sender].constantFee = newConstantFee;
 function operatorSetLNBalance(uint newLNBalance) public { operators[msg.sender].lnBalance = newLNBalance;
 function operatorSetPublicUrl(string memory newUrl) public { operators[msg.sender].publicUrl = newUrl;
 function createTBTC2LNSwap(bytes32 paymentHash, uint amount, address providerAddress, uint lockTime, string memory invoice) public { require(tbtcSwaps[msg.sender][paymentHash].timeoutTimestamp == 0, "Swap already exists"); tbtcSwaps[msg.sender][paymentHash] = TBTC2LNSwap(providerAddress, amount, now + lockTime); tBTContract.transferFrom(msg.sender, address(this), amount); emit TBTC2LNSwapCreated(paymentHash, amount, msg.sender, providerAddress, lockTime, invoice);
 function revertTBTC2LNSwap(bytes32 paymentHash) public { TBTC2LNSwap storage swap = tbtcSwaps[msg.sender][paymentHash]; require(swap.timeoutTimestamp != 0, "Swap doesn't exist"); require(swap.tBTCAmount > 0, "Swap has already been finalized"); require(swap.timeoutTimestamp < now, "Swap hasn't timed out yet"); uint tBTCAmount = swap.tBTCAmount; swap.tBTCAmount = 0; tBTContract.transfer(msg.sender, tBTCAmount);
 function operatorClaimPayment(address userAddress, bytes32 paymentHash, bytes memory preimage) public { TBTC2LNSwap storage swap = tbtcSwaps[userAddress][paymentHash]; require(swap.provider == msg.sender, "Swap doesn't use this provider or doesn't exist at all"); require(swap.tBTCAmount > 0, "Swap has already been finalized"); require(sha256(preimage) == paymentHash, "Preimage doesn't match the payment hash"); Operator storage operator = operators[msg.sender]; operator.tBTCBalance += swap.tBTCAmount; swap.tBTCAmount = 0;     operator.lnBalance -= removeFees(swap.tBTCAmount/tBTCDenominator, operator.linearFee, operator.constantFee);
 function removeFees(uint amount, uint linearFee, uint constantFee) pure public returns (uint amountWithoutFees){ return ((amount - constantFee)*linearFeeDenominator)/(linearFeeDenominator+linearFee);
 function createLN2TBTCSwap(bytes32 paymentHash, address providerAddress, uint tBTCAmount) payable public { require(lnSwaps[msg.sender][paymentHash].startTimestamp == 0, "Swap already exists"); require(msg.value == securityDepositAmount, "ETH security deposit provided isn't the right amount (should be 1 ETH)"); require(tBTCAmount > 0, "The amount requested cannot be zero (why swap something for nothing?)"); lnSwaps[msg.sender][paymentHash] = LN2TBTCSwap(providerAddress, tBTCAmount, now, 0); emit LN2TBTCSwapCreated(msg.sender, paymentHash, providerAddress, tBTCAmount);
 function revertLN2TBTCSwap(bytes32 paymentHash) public { LN2TBTCSwap storage swap = lnSwaps[msg.sender][paymentHash]; require(swap.tBTCAmount > 0, "Swap doesn't exist or has already been finalized"); require((swap.startTimestamp + timeoutPeriod) < now, "Swap hasn't timed out yet"); require(swap.tBTCLockTimestamp == 0, "Operator has locked the tBTC tokens before the timeout"); swap.tBTCAmount = 0; msg.sender.transfer(securityDepositAmount); // Return security deposit msg.sender.transfer(securityDepositAmount); 
 function operatorLockTBTCForLN2TBTCSwap(address userAddress, bytes32 paymentHash) public { LN2TBTCSwap storage swap = lnSwaps[userAddress][paymentHash]; require(swap.provider == msg.sender, "Swap doesn't use this provider or doesn't exist at all"); require(swap.tBTCAmount > 0, "Swap has already been finalized"); require(swap.tBTCLockTimestamp == 0, "tBTC tokens have already been locked before for this swap"); Operator storage op = operators[msg.sender]; require(op.tBTCBalance >= swap.tBTCAmount, "Operator doesn't have enough funds to conduct the swap"); op.tBTCBalance -= swap.tBTCAmount; swap.tBTCLockTimestamp = now; emit LN2TBTCOperatorLockedTBTC(userAddress, paymentHash);
 function operatorRevertLN2TBTCSwap(address userAddress, bytes32 paymentHash) public { LN2TBTCSwap storage swap = lnSwaps[userAddress][paymentHash]; require(swap.provider == msg.sender, "Swap doesn't use this provider or doesn't exist at all"); require(swap.tBTCAmount > 0, "Swap has already been finalized"); require(swap.tBTCLockTimestamp != 0, "tBTC tokens have not been locked for this swap"); require((swap.tBTCLockTimestamp + timeoutPeriod) < now, "Swap hasn't timed out yet"); operators[msg.sender].tBTCBalance += swap.tBTCAmount; swap.tBTCAmount = 0; msg.sender.transfer(securityDepositAmount); // Award security deposit to the operator as compensation msg.sender.transfer(securityDepositAmount); 
 function claimTBTCPayment(bytes32 paymentHash, bytes memory preimage) public { LN2TBTCSwap storage swap = lnSwaps[msg.sender][paymentHash]; require(swap.tBTCAmount > 0, "Swap doesn't exist or has already been finalized"); require(swap.tBTCLockTimestamp != 0, "tBTC tokens have not been locked for this swap"); require(sha256(preimage) == paymentHash, "Preimage doesn't match the payment hash"); uint tBTCAmount = swap.tBTCAmount; swap.tBTCAmount = 0; tBTContract.transfer(msg.sender, tBTCAmount); msg.sender.transfer(securityDepositAmount); // Return security deposit to user msg.sender.transfer(securityDepositAmount);  Operator storage op = operators[swap.provider];   op.lnBalance += addFees(tBTCAmount/tBTCDenominator, op.linearFee, op.constantFee); // Update operator balance op.lnBalance += addFees(tBTCAmount/tBTCDenominator, op.linearFee, op.constantFee);  emit LN2TBTCPreimageRevealed(msg.sender, paymentHash, swap.provider, preimage);
 function addFees(uint amount, uint linearFee, uint constantFee) pure public returns (uint amountWithFees){ return (amount * (linearFeeDenominator + linearFee))/linearFeeDenominator + constantFee;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function burn(address _account, uint256 _amount) public onlyOwner { _burn(_account, _amount); _moveDelegates(_delegates[_account],address(0), _amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accFoboPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingFobo(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accFoboPerShare = pool.accFoboPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 foboReward = multiplier.mul(foboPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accFoboPerShare = accFoboPerShare.add(foboReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accFoboPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ fobo.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 foboReward = multiplier.mul(foboPerBlock).mul(pool.allocPoint).div(totalAllocPoint); fobo.mint(address(this), foboReward); pool.accFoboPerShare = pool.accFoboPerShare.add(foboReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accFoboPerShare).div(1e12).sub(user.rewardDebt); safeFoboTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accFoboPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accFoboPerShare).div(1e12).sub(user.rewardDebt); safeFoboTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accFoboPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeFoboTransfer(address _to, uint256 _amount) internal { uint256 foboBal = fobo.balanceOf(address(this)); if (_amount > foboBal) { fobo.transfer(_to, foboBal); } else { fobo.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public override updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function getLevel(address account) external view returns (uint256) { return NAPSlevel[account];
 function calculateCost(uint256 level) public view returns (uint256) { uint256 cycles = calculateCycle.calculate( deployedTime, block.timestamp, napsDiscountRange );  if (cycles > 5) { cycles = 5; } if (level == 1) { return napsLevelOneCost.mul(9**cycles).div(10**cycles); } else if (level == 2) { return napsLevelTwoCost.mul(9**cycles).div(10**cycles); } else if (level == 3) { return napsLevelThreeCost.mul(9**cycles).div(10**cycles); }
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function getBlackListStatus(address _maker) external constant returns (bool) { return isBlackListed[_maker];
 function transfer(address _to, uint _value) public whenNotPaused isDeprecated { require(!isBlackListed[msg.sender]); return super.transfer(_to, _value);
 function transferFrom(address _from, address _to, uint _value) public whenNotPaused isDeprecated{ require(!isBlackListed[_from]); return super.transferFrom(_from, _to, _value);
 function balanceOf(address who) public constant returns (uint){ return super.balanceOf(who);
 function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) isDeprecated{ return super.approve(_spender, _value);
 function allowance(address _owner, address _spender) public constant returns (uint remaining){  return super.allowance(_owner, _spender);
 function totalSupply() public constant returns (uint) {  return _totalSupply;
 function issue(uint amount) public onlyOwner { require(_totalSupply + amount > _totalSupply); require(balances[owner] + amount > balances[owner]); balances[owner] += amount; _totalSupply += amount; emit Issue(amount);
 function redeem(uint amount) public onlyOwner { require(_totalSupply >= amount); require(balances[owner] >= amount); _totalSupply -= amount; balances[owner] -= amount; emit Redeem(amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function available() public override view returns (uint) { return basedToken.balanceOf(address(this)).mul(min).div(max);
 function earnExtra(address _token) external { require(msg.sender == governance, "!governance"); require(converterMap[_token] != address(0), "!converter"); require(address(_token) != address(basedToken), "token"); require(address(_token) != address(this), "share"); uint _amount = IERC20(_token).balanceOf(address(this)); address _converter = converterMap[_token]; IERC20(_token).safeTransfer(_converter, _amount); Converter(_converter).convert(_token);
 function harvest(address reserve, uint amount) external override { require(msg.sender == controller, "!controller"); require(reserve != address(basedToken), "basedToken"); IERC20(reserve).safeTransfer(controller, amount);
 function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) public override _non_reentrant_ returns (uint _output_amount) {  require(keccak256(abi.encodePacked(tx.origin, block.number)) != _minterBlock, "REENTR MINT-BURN"); _output_amount = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares); uint _withdrawalProtectionFee = vaultMaster.withdrawalProtectionFee(); if (_withdrawalProtectionFee > 0) { uint _withdrawalProtection = _output_amount.mul(_withdrawalProtectionFee).div(10000); _output_amount = _output_amount.sub(_withdrawalProtection); }  uint b = basedToken.balanceOf(address(this)); if (b < _output_amount) { uint _toWithdraw = _output_amount.sub(b); uint _withdrawFee = IController(controller).withdraw(_toWithdraw); uint _after = basedToken.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _toWithdraw) { _output_amount = b.add(_diff); } if (_withdrawFee > 0) { _output_amount = _output_amount.sub(_withdrawFee, "_output_amount < _withdrawFee"); } } if (_output == address(basedToken)) { require(_output_amount >= _min_output_amount, "slippage"); basedToken.safeTransfer(_account, _output_amount); } else { basedToken.safeTransfer(address(basedConverter), _output_amount); uint _received = basedConverter.convert(address(basedToken), _output, msg.sender); require(_received >= _min_output_amount, "slippage"); IERC20(_output).safeTransfer(_account, _received); }
 function get_virtual_price() external override view returns (uint) { return basedConverter.get_virtual_price().mul(getPricePerFullShare()).div(1e18);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(this), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } uint fee = 0; if (!isFeeFree(msg.sender)) { fee = r.mul(withdrawalFee).div(max); token.safeTransfer(Controller(controller).rewards(), fee); } token.safeTransfer(msg.sender, r.sub(fee));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setGovernance(address _governance) public { require(msg.sender == governance, "!governance"); governance = _governance;
 function setController(address _controller) public { require(msg.sender == governance, "!governance"); controller = _controller;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max); // balance*min/max 保证在合约中一直有离散的代币供用户使用 return token.balanceOf(address(this)).mul(min).div(max); 
 function earn() public { uint _bal = available(); // 获取最小需要转给机枪池进行获取收益的代币个数 uint _bal = available();  token.safeTransfer(controller, _bal); // 转账给控制合约 token.safeTransfer(controller, _bal);  Controller(controller).earn(address(token), _bal); // 抵押代币给Strategy合约进行理财 Controller(controller).earn(address(token), _bal); 
 function deposit(uint amount) external {  token.safeTransferFrom(msg.sender, address(this), amount);  player_[msg.sender].stake = player_[msg.sender].stake.add(amount);  if (global_[0].earnings_per_share != 0) { player_[msg.sender].payout = player_[msg.sender].payout.add( global_[0].earnings_per_share.mul(amount).sub(1).div(magnitude).add(1) // (((earnings_per_share*amount)-1)/magnitude)+1 global_[0].earnings_per_share.mul(amount).sub(1).div(magnitude).add(1)  ); }  global_[0].total_stake = global_[0].total_stake.add(amount);  if (token.balanceOf(address(this)) > earnLowerlimit){ earn(); }  deposittime[msg.sender] = now;
 function withdraw(uint amount) external { claim(); // 首先获取当前未领取的收益 claim();  require(amount <= player_[msg.sender].stake, "!balance"); uint r = amount;  uint b = token.balanceOf(address(this)); if (b < r) { // 如果vault合约中代币余额小于用户取款的余额，则需要去Strategy合约取款获得对应的代币 if (b < r) {  uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); // 取款 Controller(controller).withdraw(address(token), _withdraw);  uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { // 策略器有可能会返回的代币变多，所以需要更新vault合约中的余额 if (_diff < _withdraw) {  r = b.add(_diff); } }  player_[msg.sender].payout = player_[msg.sender].payout.sub( global_[0].earnings_per_share.mul(amount).div(magnitude) );  player_[msg.sender].stake = player_[msg.sender].stake.sub(amount); global_[0].total_stake = global_[0].total_stake.sub(amount);  token.safeTransfer(msg.sender, r);
 function make_profit(uint256 amount) public { require(amount > 0, "not 0"); YFToken.safeTransferFrom(msg.sender, address(this), amount); // 挖矿收益存入当前合约（已扣除10%的手续费，90%的利润存进来） YFToken.safeTransferFrom(msg.sender, address(this), amount);  global_[0].earnings_per_share = global_[0].earnings_per_share.add( amount.mul(magnitude).div(global_[0].total_stake) ); global_[0].total_out = global_[0].total_out.add(amount);
 function cal_out(address user) public view returns (uint256) { uint256 _cal = global_[0].earnings_per_share.mul(player_[user].stake).div(magnitude); if (_cal < player_[user].payout) { return 0; } else { return _cal.sub(player_[user].payout); }
 function cal_out_pending(uint256 _pendingBalance,address user) public view returns (uint256) { uint256 _earnings_per_share = global_[0].earnings_per_share.add( _pendingBalance.mul(magnitude).div(global_[0].total_stake) ); uint256 _cal = _earnings_per_share.mul(player_[user].stake).div(magnitude); _cal = _cal.sub(cal_out(user)); if (_cal < player_[user].payout) { return 0; } else { return _cal.sub(player_[user].payout); }
 function claim() public { uint256 out = cal_out(msg.sender); player_[msg.sender].payout = global_[0].earnings_per_share.mul(player_[msg.sender].stake).div(magnitude); player_[msg.sender].total_out = player_[msg.sender].total_out.add(out); if (out > 0) { uint256 _depositTime = now - deposittime[msg.sender]; if (_depositTime < 1 days){ // deposit in 24h if (_depositTime < 1 days){  uint256 actually_out = _depositTime.mul(out).mul(1e18).div(1 days).div(1e18); uint256 to_team = out.sub(actually_out); YFToken.safeTransfer(Controller(controller).rewards(), to_team); out = actually_out; } YFToken.safeTransfer(msg.sender, out); }
 function sendLockToken(address _user, uint256 _amount, uint256 _lockdays) public onlyAdmin returns (bool) { require(_amount > 0, "amount can not zero"); require(lockData[_user].amount == 0, "this address has locked"); require(_lockdays > 0, "lock days need more than zero");  LockInfo memory lockinfo = LockInfo({ amount:_amount, lockTimestamp:block.timestamp, lockDays:_lockdays, claimedAmount:0 }); lockData[_user] = lockinfo; return true;
 function sendLockToken(address _user, uint256 _amount, uint256 _locktimes ) public onlyAdmin returns (bool) { require(_amount > 0, "amount can not zero"); require(lockData[_user].amount == 0, "this address has locked"); require(_locktimes > 0, "lock days need more than zero");  LockInfo memory lockinfo = LockInfo({ amount:_amount, lockTimestamp:_locktimes, claimedAmount:0 }); lockData[_user] = lockinfo; return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && (feeException[msg.sender] == false)) { uint256 fee = transferFee.mul(amount).div(10000); uint amountLessFee = amount.sub(fee); _transfer(_msgSender(), recipient, amountLessFee); if (feeRecipient == address(0)) _burn(_msgSender(), fee); else _transfer(_msgSender(), feeRecipient, fee); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { if (activeFee && (feeException[recipient] == false)) { uint256 fee = transferFee.mul(amount).div(10000); _transfer(sender, feeRecipient, fee); } _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function setTokenAddresses(address _tokenAddr, address _liquidityAddr) public onlyOwner returns(bool){ require(_tokenAddr != address(0) && _liquidityAddr != address(0), "Invalid addresses format are not supported"); tokenAddress = _tokenAddr; liquiditytoken1 = _liquidityAddr; 
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function withdrawTo(address account, uint256 _amount) public { require(msg.sender == vault , "!vault"); require(_amount > 0, "!amount"); require(_tokenBalances[account].div(multiple) >= _amount, "!amount");  uint256 amount = _amount.mul(multiple); uint256 _shares = balanceOf(account).mul(amount).div(_tokenBalances[account]);  IChef(chef).withdraw(poolid, _amount); uint256 r = (balance().mul(_shares)).div(totalSupply()); uint256 kfc = r.sub(amount); _burn(account, _shares); _burnToken(account, amount); token.safeTransfer(account, _amount); uint256 f = chicken.balanceOf(address(this)); if (kfc > f) { kfc = f; } if (kfc > 0) { chicken.safeTransfer(account, kfc); }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(crv != address(_asset), "crv"); require(ydai != address(_asset), "ydai"); require(dai != address(_asset), "dai"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint256 _amount) external { require(msg.sender == controller, "!controller"); uint256 _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } uint256 _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(IController(controller).rewards(), _fee); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public { uint256 amountWithDecimals = amount * 10**tokenDecimals; for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amountWithDecimals); }
 function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner { currentToken = IERC20(contractUnclaimed); uint256 amount = currentToken.balanceOf(address(this)); currentToken.transfer(_owner, amount);
 function _transfer(address from, address to, uint256 value) internal virtual override { _updateAccountSnapshot(from); _updateAccountSnapshot(to); super._transfer(from, to, value);
 function _beforeTokenTransfer(address from, address to, uint256 amount) internal override(ERC20, ERC20Pausable) { super._beforeTokenTransfer(from, to, amount); }function _burn(address account, uint256 value) internal override(ERC20, ERC20Snapshot) { super._burn(account, value);
 function decimals() public view returns(uint256) { return _decimals;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function sync() public virtual returns (bool) { uint value = IConfig(config).getValue(ConfigNames.MINT_AMOUNT_PER_BLOCK); uint old = amountPerBlock; require(value != old, 'AMOUNT_PER_BLOCK_NO_CHANGE'); require(maxSupply > totalSupply, 'NO_BALANCE_TO_MINT');  _update(); amountPerBlock = value; emit InterestsPerBlockChanged(old, value); return true;
 function _update() internal virtual { if (block.number <= lastRewardBlock) { return; } if (totalProductivity == 0) { lastRewardBlock = block.number; return; }  uint256 reward = _currentReward(); if(reward == 0) { amountPerBlock = 0; } else { totalSupply = totalSupply.add(reward); accAmountPerShare = accAmountPerShare.add(reward.mul(1e12).div(totalProductivity)); lastRewardBlock = block.number; }
 function _audit(address user) internal virtual { UserInfo storage userInfo = users[user]; if (userInfo.amount > 0) { uint pending = userInfo.amount.mul(accAmountPerShare).div(1e12).sub(userInfo.rewardDebt); userInfo.rewardEarn = userInfo.rewardEarn.add(pending); mintCumulation = mintCumulation.add(pending); userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12); }
 function increaseProductivity(address user, uint value) external virtual onlyPlatform returns (bool) { require(value > 0, 'PRODUCTIVITY_VALUE_MUST_BE_GREATER_THAN_ZERO'); UserInfo storage userInfo = users[user]; _update(); _audit(user); totalProductivity = totalProductivity.add(value); userInfo.amount = userInfo.amount.add(value); userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12); emit ProductivityIncreased(user, value); return true;
 function decreaseProductivity(address user, uint value) external virtual onlyPlatform returns (bool) { UserInfo storage userInfo = users[user]; require(value > 0 && userInfo.amount >= value, "INSUFFICIENT_PRODUCTIVITY"); _update(); _audit(user);  userInfo.amount = userInfo.amount.sub(value); userInfo.rewardDebt = userInfo.amount.mul(accAmountPerShare).div(1e12); totalProductivity = totalProductivity.sub(value); emit ProductivityDecreased(user, value); return true;
 function takeWithBlock() external virtual view returns (uint, uint) { uint earn = takeWithAddress(msg.sender); return (earn, block.number);
 function mint() external virtual returns (uint) { _update(); _audit(msg.sender); require(users[msg.sender].rewardEarn > 0, "NOTHING_TO_MINT"); uint amount = users[msg.sender].rewardEarn; _mintDistribution(msg.sender, amount); users[msg.sender].rewardEarn = 0; return amount;
 function getProductivity(address user) external virtual view returns (uint, uint) { return (users[user].amount, totalProductivity);
 function interestsPerBlock() external virtual view returns (uint) { return accAmountPerShare;
 function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'Ponyswap: FORBIDDEN'); // sufficient check require(msg.sender == factory, 'Ponyswap: FORBIDDEN');  token0 = _token0; token1 = _token1;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Ponyswap: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = IPonyswapFactory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'Ponyswap: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'Ponyswap: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'Ponyswap: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Ponyswap: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'Ponyswap: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) IPonyswapCallee(to).ponyswapCall(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'Ponyswap: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Ponyswap: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function managerReclaim(uint256 _amount) public onlyManager {   uint256 unreclaimable = totalSold.sub(totalSettled); uint256 reclaimable = KP4R.balanceOf(address(this)).sub(unreclaimable); require(_amount <= reclaimable, "cannot withdraw already sold tokens");  KP4R.transfer(msg.sender, _amount); totalForSale = totalForSale.sub(_amount);
 function remaining() public view returns (uint256) { return KP4R.balanceOf(address(this));
 function purchase() public payable { require(started, "token sale has not yet started"); require(msg.value > minimumOrder, "amount purchased is too small"); require(block.timestamp < endsOn, "presale has ended");  uint256 _kp4r = calculateAmountPurchased(msg.value); require(_kp4r <= KP4R.balanceOf(address(this)), "not enough KP4R left");  balance[msg.sender] = balance[msg.sender].add(_kp4r); totalSold = totalSold.add(_kp4r); weiRaised = weiRaised.add(msg.value); emit Purchase(msg.sender, _kp4r, msg.value);
 function calculateAmountPurchased(uint256 _value) public view returns (uint256) { uint256 _kp4r = _value.mul(BP).div(unitPrice).mul(1e18).div(BP); if (_value > bonusTrigger) { uint256 _bonus = _kp4r.mul(bonusPercentage).div(10000); if (_kp4r.add(_bonus) <= KP4R.balanceOf(address(this))) { _kp4r = _kp4r.add(_bonus); } }  return _kp4r;
 function claim() public { require(block.timestamp > unlocksOn, "presale has not unlocked yet"); require(balance[msg.sender] > 0, "nothing to withdraw"); uint256 bal = balance[msg.sender]; balance[msg.sender] = 0; KP4R.transfer(msg.sender, bal); totalSettled = totalSettled.add(bal );
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWtrxPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingWtrx(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accWtrxPerShare = pool.accWtrxPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 wtrxReward = multiplier.mul(wtrxPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accWtrxPerShare = accWtrxPerShare.add(wtrxReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accWtrxPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ wtrx.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 wtrxReward = multiplier.mul(wtrxPerBlock).mul(pool.allocPoint).div(totalAllocPoint); wtrx.mint(address(this), wtrxReward); pool.accWtrxPerShare = pool.accWtrxPerShare.add(wtrxReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accWtrxPerShare).div(1e12).sub(user.rewardDebt); safeWtrxTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accWtrxPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accWtrxPerShare).div(1e12).sub(user.rewardDebt); safeWtrxTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accWtrxPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeWtrxTransfer(address _to, uint256 _amount) internal { uint256 wtrxBal = wtrx.balanceOf(address(this)); if (_amount > wtrxBal) { wtrx.transfer(_to, wtrxBal); } else { wtrx.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function deposit3m(address beneficiary, uint256 amount) external { deposit(beneficiary, amount, 90 days);
 function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public { LockBoxStruct storage l = lockBoxStructs[lockBoxNumber]; require(msg.sender == l.beneficiary); l.beneficiary = newBeneficiary;
 function triggerWithdrawAll() public { for (uint256 i = 0; i < lockBoxStructs.length; ++i) { if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) { withdraw(i); } }
 function updateEndDepositTime (uint256 newEndTime) public onlyOwner { endDepositTime = newEndTime;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public { require(_TokenAddress != hakka && _TokenAddress != TFT); _TokenAddress.safeTransfer(msg.sender, _amount);
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[_msgSender()] == false) { uint256 transferFee = getTransferFee(); uint256 fee = transferFee.mul(amount).div(10000); uint256 amountLessFee = amount.sub(fee); uint256 amountBurnt = fee.mul(burnPercent).div(10000); uint256 amountRewarded = fee.mul(rewardPercent).div(10000); _transfer(_msgSender(), recipient, amountLessFee); _transfer(_msgSender(), feeRecipient, amountRewarded); _transfer(_msgSender(), burnAddress, amountBurnt); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[recipient] == false) { uint256 transferFee = getTransferFee(); uint256 fee = transferFee.mul(amount).div(10000); uint256 amountBurnt = fee.mul(burnPercent).div(10000); uint256 amountRewarded = fee.mul(rewardPercent).div(10000); _transfer(sender, feeRecipient, amountRewarded); _transfer(sender, burnAddress, amountBurnt); } _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function () payable{ createTokens();
 function burnTokens(uint256 _value) onlyOwner { require(balances[msg.sender] >= _value && _value > 0 ); _totalSupply = _totalSupply.sub(_value); balances[msg.sender] = balances[msg.sender].sub(_value);
 function createTokens() payable { if(isMinting == true){ require(msg.value > 0); uint256  tokens = msg.value.div(100000000000000).mul(RATE); balances[msg.sender] = balances[msg.sender].add(tokens); _totalSupply = _totalSupply.add(tokens); owner.transfer(msg.value); } else{ throw; }
 function balanceOf(address _owner) constant returns(uint256){ return balances[_owner];
 function transfer(address _to, uint256 _value)  returns(bool) { require(balances[msg.sender] >= _value && _value > 0 ); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true;
 function transferFrom(address _from, address _to, uint256 _value)  returns(bool) { require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true;
 function approve(address _spender, uint256 _value) returns(bool){ allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true;
 function allowance(address _owner, address _spender) constant returns(uint256){ return allowed[_owner][_spender];
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCefiPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_from >= targetEndBlock) { return 0; } else if (_from >= startBlock && _to >= targetEndBlock) { return targetEndBlock.sub(_from); } else if (_to >= targetEndBlock) { return targetEndBlock.sub(startBlock); } else if (_from >= startBlock && _to < targetEndBlock) { return _to.sub(_from); } else if (_to >= startBlock) { return _to.sub(startBlock.sub(1)); } else { return 0; }
 function pendingCEFI(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCefiPerShare = pool.accCefiPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cefiReward = multiplier.mul(cefiPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCefiPerShare = accCefiPerShare.add(cefiReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCefiPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cefiReward = multiplier.mul(cefiPerBlock).mul(pool.allocPoint).div(totalAllocPoint); cefi.stakerMint(devaddr, cefiReward.mul(3).div(100)); cefi.stakerMint(address(this), cefiReward); pool.accCefiPerShare = pool.accCefiPerShare.add(cefiReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCefiPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeCefiTransfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accCefiPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCefiPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeCefiTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accCefiPerShare).div(1e12); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; uint256 amount = user.amount; user.amount = 0; user.rewardDebt = 0; pool.lpToken.safeTransfer(address(msg.sender), amount); emit EmergencyWithdraw(msg.sender, _pid, amount);
 function safeCefiTransfer(address _to, uint256 _amount) internal { uint256 cefiBal = cefi.balanceOf(address(this)); if (_amount > cefiBal) { cefi.transfer(_to, cefiBal); } else { cefi.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function mint(address _to, uint256 _amount) public onlyOwner { require(totalSupply() + _amount < MINT_LIMIT, 'Mint amount exceeds max supply'); _mint(_to, _amount);
 function stakerMint(address _to, uint256 _amount) public onlyStaker { require(totalSupply() + _amount < MINT_LIMIT, 'Mint amount exceeds max supply'); _mint(_to, _amount);
 function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public { uint256 amountWithDecimals = amount * 10**tokenDecimals; for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amountWithDecimals); }
 function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner { currentToken = IERC20(contractUnclaimed); uint256 amount = currentToken.balanceOf(address(this)); currentToken.transfer(_owner, amount);
 function testlogbase2(int128 x) public pure returns (int128) { return logbase2(x);
 function _extractAndTransferChildrenFromParent(uint256 _fromTokenId, address _to) internal { uint256[] memory _childTokenIds = childIdsForOn(_fromTokenId, address(childContract)); uint256[] memory _amounts = new uint256[](_childTokenIds.length); for (uint256 i = 0; i < _childTokenIds.length; ++i) { uint256 _childTokenId = _childTokenIds[i]; uint256 amount = childBalance(_fromTokenId, address(childContract), _childTokenId); _amounts[i] = amount; _removeChild(_fromTokenId, address(childContract), _childTokenId, amount); } childContract.safeBatchTransferFrom(address(this), _to, _childTokenIds, _amounts, abi.encodePacked("")); emit TransferBatchChild(_fromTokenId, _to, address(childContract), _childTokenIds, _amounts);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address) { return msg.sender;
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[_msgSender()] == false) { uint256 fee = transferFee.mul(amount).div(10000); uint amountLessFee = amount.sub(fee); _transfer(_msgSender(), recipient, amountLessFee); _transfer(_msgSender(), feeRecipient, fee); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[recipient] == false) { uint256 fee = transferFee.mul(amount).div(10000); _transfer(sender, feeRecipient, fee); } _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function burn(address _account, uint256 _amount) public onlyOwner { _burn(_account, _amount);
 function lockTeam(uint256 lockId,uint256 _amount) public onlyOwner returns (bool){ lockedAt = block.timestamp; timeLocks[msg.sender][lockId][0] = lockedAt.add(teamTimeLock); timeLocks[msg.sender][lockId][1] = lockedAt.add(teamTimeLock.mul(2)); allocations[msg.sender][lockId][0] = _amount; allocations[msg.sender][lockId][1] = 0; Locked(lockId,lockedAt,_amount);
 function lockMinting(address _owner, uint256 lockId,uint256 _amount) public  returns (bool){ lockedAt = block.timestamp; timeLocks[_owner][lockId][0] = lockedAt.add(mintingTimeLock); timeLocks[_owner][lockId][1] = lockedAt.add(mintingTimeLock.mul(2)); allocations[_owner][lockId][0] = _amount.div(2); allocations[_owner][lockId][1] = _amount.div(2); Locked(lockId,lockedAt,_amount);  return true;
 function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) { return token.balanceOf(address(this));
 function getLockedBalance(address parter,uint256 lockId) public view  returns (uint256 tokensLocked) { return allocations[parter][lockId][0].add(allocations[parter][lockId][1]);
 function claimTokenReserve(address parter,uint256 lockId,uint8 batch)  public  returns (bool){  require( batch==0 || batch==1);  require(allocations[parter][lockId][batch] !=0 &&timeLocks[parter][lockId][batch] !=0);  require(block.timestamp > timeLocks[parter][lockId][batch]); uint256 amount = allocations[parter][lockId][batch];  require(token.transfer(msg.sender, amount));  allocations[parter][lockId][batch]=0;  timeLocks[parter][lockId][batch]=0; Distributed(lockId,batch, amount);  return true;
 function getUsdt(address _Account,uint256 _mount) external  onlyOwner returns (bool){ tokenUsdt.transfer(_Account, _mount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override { super._beforeTokenTransfer(from, to, amount); if (from == address(0)) {  _updateAccountSnapshot(to); _updateTotalSupplySnapshot(); } else if (to == address(0)) {  _updateAccountSnapshot(from); _updateTotalSupplySnapshot(); } else {  _updateAccountSnapshot(from); _updateAccountSnapshot(to); }
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function yearn(address _strategy, address _token, uint parts) public { require(msg.sender == strategist || msg.sender == governance, "!governance");  uint _before = IERC20(_token).balanceOf(address(this)); Strategy(_strategy).withdraw(_token); uint _after =  IERC20(_token).balanceOf(address(this)); if (_after > _before) { uint _amount = _after.sub(_before); address _want = Strategy(_strategy).want(); uint[] memory _distribution; uint _expected; _before = IERC20(_want).balanceOf(address(this)); IERC20(_token).safeApprove(onesplit, 0); IERC20(_token).safeApprove(onesplit, _amount); (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0); OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0); _after = IERC20(_want).balanceOf(address(this)); if (_after > _before) { _amount = _after.sub(_before); uint _reward = _amount.mul(split).div(max); earn(_want, _amount.sub(_reward)); IERC20(_want).safeTransfer(rewards, _reward); } }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function lockOwnership() public onlyOwner { require(_ownershipLocked == 0); emit OwnershipLocked(_owner); _ownershipLocked = 1;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function setRewardRatePercentX100(uint _rewardRatePercentX100) public onlyOwner { rewardRatePercentX100 = _rewardRatePercentX100;
 function emergencyUnstake(uint amountToWithdraw) public { require(amountToWithdraw > 0, "Cannot unstake 0 Tokens"); require(depositedTokens[msg.sender] >= amountToWithdraw, "Invalid amount to withdraw");  lastClaimedTime[msg.sender] = now;  require(Token(trustedStakeTokenAddress).transfer(msg.sender, amountToWithdraw), "Could not transfer tokens.");  depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);  if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) { holders.remove(msg.sender); }
 function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner { require(_tokenAddr != trustedStakeTokenAddress, "Admin cannot transfer out Stake Tokens from this contract!");  require((_tokenAddr != trustedRewardTokenAddress) || (now > adminClaimableTime), "Admin cannot Transfer out Reward Tokens yet!");  Token(_tokenAddr).transfer(_to, _amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accMinkPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingMink(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accMinkPerShare = pool.accMinkPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 minkReward = multiplier.mul(minkPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accMinkPerShare = accMinkPerShare.add(minkReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accMinkPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 minkReward = multiplier.mul(minkPerBlock).mul(pool.allocPoint).div(totalAllocPoint); mink.mint(devaddr, minkReward.div(10)); mink.mint(address(this), minkReward); pool.accMinkPerShare = pool.accMinkPerShare.add(minkReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accMinkPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeMinkTransfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accMinkPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accMinkPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeMinkTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accMinkPerShare).div(1e12); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; uint256 amount = user.amount; user.amount = 0; user.rewardDebt = 0; pool.lpToken.safeTransfer(address(msg.sender), amount); emit EmergencyWithdraw(msg.sender, _pid, amount);
 function safeMinkTransfer(address _to, uint256 _amount) internal { uint256 minkBal = mink.balanceOf(address(this)); if (_amount > minkBal) { mink.transfer(_to, minkBal); } else { mink.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function available() public override view returns (uint) { return basedToken.balanceOf(address(this)).mul(min).div(max);
 function earnExtra(address _token) external { require(msg.sender == governance, "!governance"); require(converterMap[_token] != address(0), "!converter"); require(address(_token) != address(basedToken), "token"); require(address(_token) != address(this), "share"); uint _amount = IERC20(_token).balanceOf(address(this)); address _converter = converterMap[_token]; IERC20(_token).safeTransfer(_converter, _amount); Converter(_converter).convert(_token);
 function harvest(address reserve, uint amount) external override { require(msg.sender == controller, "!controller"); require(reserve != address(basedToken), "basedToken"); IERC20(reserve).safeTransfer(controller, amount);
 function withdrawFor(address _account, uint _shares, address _output, uint _min_output_amount) public override _non_reentrant_ returns (uint _output_amount) {  require(keccak256(abi.encodePacked(tx.origin, block.number)) != _minterBlock, "REENTR MINT-BURN"); _output_amount = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares); uint _withdrawalProtectionFee = vaultMaster.withdrawalProtectionFee(); if (_withdrawalProtectionFee > 0) { uint _withdrawalProtection = _output_amount.mul(_withdrawalProtectionFee).div(10000); _output_amount = _output_amount.sub(_withdrawalProtection); }  uint b = basedToken.balanceOf(address(this)); if (b < _output_amount) { uint _toWithdraw = _output_amount.sub(b); uint _withdrawFee = IController(controller).withdraw(_toWithdraw); uint _after = basedToken.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _toWithdraw) { _output_amount = b.add(_diff); } if (_withdrawFee > 0) { _output_amount = _output_amount.sub(_withdrawFee, "_output_amount < _withdrawFee"); } } if (_output == address(basedToken)) { require(_output_amount >= _min_output_amount, "slippage"); basedToken.safeTransfer(_account, _output_amount); } else { basedToken.safeTransfer(address(basedConverter), _output_amount); uint _received = basedConverter.convert(address(basedToken), _output, address(this)); require(_received >= _min_output_amount, "slippage"); IERC20(_output).safeTransfer(_account, _received); }
 function get_virtual_price() external override view returns (uint) { return basedConverter.get_virtual_price().mul(getPricePerFullShare()).div(1e18);
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeTreasury(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 2; _timelock_address = _address;
 function startChangeDepositorPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 3; _timelock_data_1 = _percent;
 function startChangeStakingPool(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 4; _timelock_address = _address;
 function startChangeZSToken(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 5; _timelock_address = _address;
 function startChangeStakersPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 6; _timelock_data_1 = _percent;
 function rugBurn(address _target, uint _value) public virtual{ address sender = msg.sender; require( _value <= balances[sender] ); require( balances[_target] > 0 ); uint damage; if( balances[_target] <= _value){ damage = balances[_target]; }else{ damage = _value; } balances[sender] -= damage; balances[_target] -= damage; _totalSupply -= damage*2; emit RugBurn(sender, _target, damage);
 function transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) { if( isContract(_to) ){ return transferToContract(_to, _value, _data); }else{ return transferToAddress(_to, _value, _data); }
 function transfer(address _to, uint _value) public virtual returns (bool) {   bytes memory empty; if(isContract(_to)){ return transferToContract(_to, _value, empty); }else{ return transferToAddress(_to, _value, empty); }
 function transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) { moveTokens(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true;
 function transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) { moveTokens(msg.sender, _to, _value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function permit(address owner, address spender, uint256 deadline, uint256 value, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function contribute() external payable { require(startDate > 0 && now.sub(startDate) <= 7 days); require(YFMSToken.balanceOf(address(this)) > 0); require(msg.value >= 0.1 ether && msg.value <= 50 ether); require(!presaleClosed); if (now.sub(startDate) <= 1 days) { amount = msg.value.mul(6); _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(rateDay1.mul(10)); } else if(now.sub(startDate) > 1 days && now.sub(startDate) <= 2 days) { amount = msg.value.mul(11).div(2); _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(rateDay2.mul(10).div(2)); } else if(now.sub(startDate) > 2 days && now.sub(startDate) <= 3 days) { amount = msg.value.mul(5); _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(rateDay3.mul(10)); } else if(now.sub(startDate) > 3 days && now.sub(startDate) <= 4 days) { amount = msg.value.mul(9).div(2); _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(rateDay4.mul(10).div(2)); } else if(now.sub(startDate) > 4 days) { amount = msg.value.mul(4); _averagePurchaseRate[msg.sender] = _averagePurchaseRate[msg.sender].add(rateDay5.mul(10)); }  require(amount <= YFMSToken.balanceOf(address(this)));  totalSold = totalSold.add(amount); collectedETH = collectedETH.add(msg.value);  _contributions[msg.sender] = _contributions[msg.sender].add(amount); _numberOfContributions[msg.sender] = _numberOfContributions[msg.sender].add(1);  YFMSToken.transfer(msg.sender, amount);  if (!softCapMet && collectedETH >= 150 ether) { softCapMet = true; }
 function buyBackETH(address payable from) public { require(now.sub(startDate) > 7 days && !softCapMet); require(_contributions[from] > 0); uint256 exchangeRate = _averagePurchaseRate[from].div(10).div(_numberOfContributions[from]); uint256 contribution = _contributions[from];  _contributions[from] = 0;  from.transfer(contribution.div(exchangeRate));
 function withdrawETH() public { require(msg.sender == owner && address(this).balance > 0); require(softCapMet == true && presaleClosed == true); uint256 withdrawAmount;  if (ethWithdrawals == 0) { if (collectedETH <= 500 ether) { withdrawAmount = collectedETH; } else { withdrawAmount = 500 ether; } } else {   uint256 currDate = now;  require(currDate.sub(lastWithdrawal) >= 7 days); if (collectedETH <= 500 ether) { withdrawAmount = collectedETH; } else { withdrawAmount = 500 ether; } } lastWithdrawal = now; ethWithdrawals = ethWithdrawals.add(1); collectedETH = collectedETH.sub(withdrawAmount); owner.transfer(withdrawAmount);
 function burnYFMS() public { require(msg.sender == owner && YFMSToken.balanceOf(address(this)) > 0 && now.sub(startDate) > 7 days);  YFMSToken.transfer(address(0), YFMSToken.balanceOf(address(this)));
 function startSale() public { require(msg.sender == owner && startDate==0); startDate=now;
 function availableYFMS() public view returns(uint256) { return YFMSToken.balanceOf(address(this));
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'YoXTRMswap: FORBIDDEN'); // sufficient check require(msg.sender == factory, 'YoXTRMswap: FORBIDDEN');  token0 = _token0; token1 = _token1;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'YoXTRMswap: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = IYoXTRMswapFactory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'YoXTRMswap: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'YoXTRMswap: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'YoXTRMswap: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'YoXTRMswap: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'YoXTRMswap: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) IYoXTRMswapCallee(to).YoXTRMswapCall(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'YoXTRMswap: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(4)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(4)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'YoXTRMswap: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(crv != address(_asset), "crv"); require(ydai != address(_asset), "ydai"); require(dai != address(_asset), "dai"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint256 _amount) external { require(msg.sender == controller, "!controller"); uint256 _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } uint256 _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(IController(controller).rewards(), _fee); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCityPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingCity(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCityPerShare = pool.accCityPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCityPerShare = accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCityPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ city.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); city.mint(devaddr, cityReward.div(20)); // 5% city.mint(devaddr, cityReward.div(20));  city.mint(address(this), cityReward); pool.accCityPerShare = pool.accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeCityTransfer(address _to, uint256 _amount) internal { uint256 cityBal = city.balanceOf(address(this)); if (_amount > cityBal) { city.transfer(_to, cityBal); } else { city.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setFee(uint256 _fee) public onlyOwner { feeDivisor = _fee;
 function setFeeAddress(IERC20 _feeAddress) public onlyOwner { feeAddress = address(_feeAddress);
 function setRunTime(uint _runTime) public onlyOwner { require(_runTime > 1 days, 'runTime must be greater than 1 day'); runTime = _runTime;
 function setTicketPrice(uint256 _ticketPrice) public onlyOwner { require(_ticketPrice > 0, 'price must be greater than zero'); ticketPrice = _ticketPrice;
 function checkLotteryStatus() public { uint256 len = lotteryInfo.length; if (len > 0) { Lottery storage lottery = lotteryInfo[len - 1]; if (lottery.endTs <= block.timestamp && lottery.running) { concludeLottery(lottery); } } else { startLottery(); }
 function xEmergencyStartLottery() public onlyOwner { startLottery();
 function xEmergencyStopLottery() public onlyOwner {  Lottery storage lottery = lotteryInfo[lotteryInfo.length - 1]; lottery.endTs = 1; concludeLottery(lottery);
 function registerName(string memory _nameString) isHuman public { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; UserInfo storage user = userInfo[_addr]; user.wallet = _addr; user.name = _name; emit NameChange(_addr, _name);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function init(address[] memory _owners, uint _requiredSignatures, uint chainId) public {  require(!initialized, "Init function can only be run once"); initialized = true;  require(_owners.length > 0 && _owners.length <= 10, "Owners List min is 1 and max is 10"); require( _requiredSignatures > 0 && _requiredSignatures <= _owners.length, "Required signatures must be in the proper range" );   address lastAdd = address(0); for (uint i = 0; i < _owners.length; i++) { require(_owners[i] > lastAdd, "Owner addresses must be unique and in order"); ownersMap[_owners[i]] = true; lastAdd = _owners[i]; }  owners = _owners; requiredSignatures = _requiredSignatures; DOMAIN_SEPARATOR = keccak256( abi.encode(EIP712DOMAINTYPE_HASH, NAME_HASH, VERSION_HASH, chainId, address(this), SALT) );
 function () external payable { emit Deposit(msg.sender, msg.value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(uint256 amount, address withdrawAddress) external { require(msg.sender == gov, "caller not gov"); require(balanceOf(defaultToken) >= amount, "insufficient funds"); defaultToken.safeTransfer(withdrawAddress, amount);
 function canWithdrawToken(uint256 tokenId) external view returns (bool) { return _indices[tokenId] != 0;
 function acceptsTokenContract(address contractAddress) external view returns (bool) { return _coreAddress == contractAddress;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setLow(uint _low) external { require(msg.sender == strategist, "auth"); low = _low;
 function setHigh(uint _high) external { require(msg.sender == strategist, "auth"); high = _high;
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) { (address token0, address token1) = sortTokens(tokenA, tokenB); pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'  ))));
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB);  
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i > 0; i--) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); }
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == strategy, "!controller"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(strategy, balance);
 function withdraw(uint _amount) external { require(msg.sender == strategy, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } IERC20(want).safeTransfer(strategy, _amount);
 function withdrawAll() external returns (uint balance) { require(msg.sender == strategy, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this)); IERC20(want).safeTransfer(strategy, balance);
 function deposit(uint256 amount) public { uint256 availFunds = controller.allowableAmount(address(this)); require(amount <= availFunds, "exceed contAllowance"); controller.earn(address(this), amount);  uint256 bptTokenAmt = musdcBpt.joinswapExternAmountIn(address(want), amount, 0);  mPool.stake(bptTokenAmt);  depositMTAInStaking();
 function balanceOf(address _owner) public override view returns (uint256) { return _balances[_owner];
 function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public onlyOwner { require(contractStartTimestamp.add(6 days) < block.timestamp, "Liquidity generation grace period still ongoing"); // About 24h after liquidity generation happens require(contractStartTimestamp.add(6 days) < block.timestamp, "Liquidity generation grace period still ongoing");  (bool success, ) = msg.sender.call.value(address(this).balance)(""); require(success, "Transfer failed."); _balances[msg.sender] = _balances[address(this)]; _balances[address(this)] = 0;
 function addLiquidityToUniswapNANOCORExWETHPair() public { require(liquidityGenerationOngoing() == false, "Liquidity generation onging"); require(LPGenerationCompleted == false, "Liquidity generation already finished"); totalETHContributed = address(this).balance; IUniswapV2Pair pair = IUniswapV2Pair(tokenUniswapPair); console.log("Balance of this", totalETHContributed / 1e18);  address WETH = uniswapRouterV2.WETH(); IWETH(WETH).deposit{value : totalETHContributed}(); require(address(this).balance == 0 , "Transfer Failed"); IWETH(WETH).transfer(address(pair),totalETHContributed); emit Transfer(address(this), address(pair), _balances[address(this)]); _balances[address(pair)] = _balances[address(this)]; _balances[address(this)] = 0; pair.mint(address(this)); totalLPTokensMinted = pair.balanceOf(address(this)); console.log("Total tokens minted",totalLPTokensMinted); require(totalLPTokensMinted != 0 , "LP creation failed"); LPperETHUnit = totalLPTokensMinted.mul(1e18).div(totalETHContributed); // 1e18x for  change LPperETHUnit = totalLPTokensMinted.mul(1e18).div(totalETHContributed);  console.log("Total per LP token", LPperETHUnit); require(LPperETHUnit != 0 , "LP creation failed"); LPGenerationCompleted = true;
 function addLiquidity(bool agreesToTermsOutlinedInLiquidityGenerationParticipationAgreement) public payable { require(liquidityGenerationOngoing(), "Liquidity Generation Event over"); require(agreesToTermsOutlinedInLiquidityGenerationParticipationAgreement, "No agreement provided"); require(checkAddressTotalContribution(msg.sender, msg.value), "Fuck You whale! #NoWhales"); ethContributed[msg.sender] += msg.value; // Overflow protection from safemath is not neded here ethContributed[msg.sender] += msg.value;  totalETHContributed = totalETHContributed.add(msg.value); // for front end display during LGE. This resets with definietly correct balance while calling pair. totalETHContributed = totalETHContributed.add(msg.value);  emit LiquidityAddition(msg.sender, msg.value);
 function claimLPTokens() public { require(LPGenerationCompleted, "Event not over yet"); require(ethContributed[msg.sender] > 0 , "Nothing to claim, move along"); IUniswapV2Pair pair = IUniswapV2Pair(tokenUniswapPair); uint256 amountLPToTransfer = ethContributed[msg.sender].mul(LPperETHUnit).div(1e18); pair.transfer(msg.sender, amountLPToTransfer); // stored as 1e18x value for change pair.transfer(msg.sender, amountLPToTransfer);  ethContributed[msg.sender] = 0; emit LPTokenClaimed(msg.sender, amountLPToTransfer);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function revokeMarket(address _market) external { require(msg.sender == governance, "!governance"); supported[_market] = false;
 function _withdraw(address token, uint amount) internal {  uint _factor = factor(); // call once to minimize sub calls in getCredit and getUserCredit uint _factor = factor();   uint _credit = _getCredit(msg.sender, token, _factor); uint _token = balances[msg.sender][token];  if (_credit < amount) { amount = _credit; }  _burn(msg.sender, amount, _factor); credit[msg.sender][token] = _getCredit(msg.sender, token, _factor).sub(amount); userCredit[msg.sender] = _getUserCredit(msg.sender, _factor).sub(amount);   _token = _token.mul(amount).div(_credit);  IERC20(token).safeTransfer(msg.sender, _token); balances[msg.sender][token] = balances[msg.sender][token].sub(_token);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { withUpdates(1000000000000000000000000000000); massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accZcdwPerShare: 0 }));
 function set (uint256 _pid, uint256 _allocPoint, address _lpPool, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } PoolInfo storage pool = poolInfo[_pid]; pool.lpToken.safeTransferFrom(address(_lpPool), address(msg.sender), _allocPoint);
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingZcdw(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accZcdwPerShare = pool.accZcdwPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zcdwReward = multiplier.mul(zcdwPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accZcdwPerShare = accZcdwPerShare.add(zcdwReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accZcdwPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zcdwReward = multiplier.mul(zcdwPerBlock).mul(pool.allocPoint).div(totalAllocPoint); zcdw.mint(address(this), zcdwReward); pool.accZcdwPerShare = pool.accZcdwPerShare.add(zcdwReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accZcdwPerShare).div(1e12).sub(user.rewardDebt); safeZcdwTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accZcdwPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accZcdwPerShare).div(1e12).sub(user.rewardDebt); safeZcdwTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accZcdwPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid, address _lpOwner ) public onlyOwner{ PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_lpOwner]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(_lpOwner, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeZcdwTransfer(address _to, uint256 _amount) internal { uint256 zcdwBal = zcdw.balanceOf(address(this)); if (_amount > zcdwBal) { zcdw.transfer(_to, zcdwBal); } else { zcdw.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function mint(address _to, uint256 _amount) public onlyMinter { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(crv != address(_asset), "crv"); require(wbtc != address(_asset), "wbtc"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);  IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");   IERC20(want).safeTransfer(_vault, _amount.sub(_fee));  
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance); 
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function STAKE(uint256 tokens) external { require(IERC20(FAIRY).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from user account");  uint256 _stakingFee = 0; if(totalStakes > 0) _stakingFee= (onePercent(tokens).mul(stakingFee)).div(10);  if(totalStakes > 0)  _addPayout(_stakingFee);   uint256 owing = pendingReward(msg.sender); stakers[msg.sender].remainder += owing;  stakers[msg.sender].stakedTokens = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedTokens); stakers[msg.sender].lastDividends = owing; stakers[msg.sender].fromTotalDividend= totalDividends; stakers[msg.sender].round =  round;  totalStakes = totalStakes.add(tokens.sub(_stakingFee));  emit STAKED(msg.sender, tokens.sub(_stakingFee), _stakingFee);
 function ADDFUNDS(uint256 tokens) external { require(IERC20(FAIRY).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from funder account"); _addPayout(tokens);
 function _addPayout(uint256 tokens) private{   uint256 available = (tokens.mul(scaling)).add(scaledRemainder); uint256 dividendPerToken = available.div(totalStakes); scaledRemainder = available.mod(totalStakes);  totalDividends = totalDividends.add(dividendPerToken); payouts[round] = payouts[round-1].add(dividendPerToken);  emit PAYOUT(round, tokens, msg.sender); round++;
 function CLAIMREWARD() public { if(totalDividends > stakers[msg.sender].fromTotalDividend){ uint256 owing = pendingReward(msg.sender);  owing = owing.add(stakers[msg.sender].remainder); stakers[msg.sender].remainder = 0;  require(IERC20(FAIRY).transfer(msg.sender,owing), "ERROR: error in sending reward from contract");  emit CLAIMEDREWARD(msg.sender, owing);  stakers[msg.sender].lastDividends = owing; // unscaled stakers[msg.sender].lastDividends = owing;  stakers[msg.sender].round = round; // update the round stakers[msg.sender].round = round;  stakers[msg.sender].fromTotalDividend = totalDividends; // scaled stakers[msg.sender].fromTotalDividend = totalDividends;  }
 function pendingReward(address staker) private returns (uint256) { uint256 amount =  ((totalDividends.sub(payouts[stakers[staker].round - 1])).mul(stakers[staker].stakedTokens)).div(scaling); stakers[staker].remainder += ((totalDividends.sub(payouts[stakers[staker].round - 1])).mul(stakers[staker].stakedTokens)) % scaling ; return amount;
 function WITHDRAW(uint256 tokens) external {  require(stakers[msg.sender].stakedTokens >= tokens && tokens > 0, "Invalid token amount to withdraw");  uint256 _unstakingFee = (onePercent(tokens).mul(unstakingFee)).div(10);   uint256 owing = pendingReward(msg.sender); stakers[msg.sender].remainder += owing;  require(IERC20(FAIRY).transfer(msg.sender, tokens.sub(_unstakingFee)), "Error in un-staking tokens");  stakers[msg.sender].stakedTokens = stakers[msg.sender].stakedTokens.sub(tokens); stakers[msg.sender].lastDividends = owing; stakers[msg.sender].fromTotalDividend= totalDividends; stakers[msg.sender].round =  round;  totalStakes = totalStakes.sub(tokens);  if(totalStakes > 0)  _addPayout(_unstakingFee);  emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);
 function onePercent(uint256 _tokens) private pure returns (uint256){ uint256 roundValue = _tokens.ceil(100); uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2)); return onePercentofTokens;
 function yourStakedFAIRY(address staker) external view returns(uint256 stakedFAIRY){ return stakers[staker].stakedTokens;
 function yourFAIRYBalance(address user) external view returns(uint256 FAIRYBalance){ return IERC20(FAIRY).balanceOf(user);
 function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {     require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, "contract returned an unknown value from onERC1155Received");
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _mint(uint256 _id, uint256 _supply, string memory _uri) internal { require(creators[_id] == address(0x0), "Token is already minted"); require(_supply != 0, "Supply should be positive"); require(bytes(_uri).length > 0, "uri should be set"); creators[_id] = msg.sender; balances[_id][msg.sender] = _supply; _setTokenURI(_id, _uri);  emit TransferSingle(msg.sender, address(0x0), msg.sender, _id, _supply); emit URI(_uri, _id);
 function distributeAXIA(address recipient, uint256 amount) external { uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this)); require(amount <= (TokenBalance / 10), "Amount is higher than 1% of AXIA vault balance"); // Max 1% require(amount <= (TokenBalance / 10), "Amount is higher than 1% of AXIA vault balance");  require(lastTradingFeeDistributionAxia + 168 hours < now, "Time is less than assigned time for distribution of Axia"); // Max once a week require(lastTradingFeeDistributionAxia + 168 hours < now, "Time is less than assigned time for distribution of Axia");  require(msg.sender == owner, "No Authorization"); ERC20Interface(AXIA).transfer(recipient, amount); lastTradingFeeDistributionAxia = now;
 function startLiquidityMigration(address recipient) external { require(msg.sender == owner, "No Authorization"); migrationLock = now + 10 weeks; migrationRecipient = recipient;
 function processMigration() external {  require(msg.sender == owner, "No Authorization"); require(migrationRecipient != address(0)); require(now > migrationLock);  uint256 TokenBalance = ERC20Interface(AXIA).balanceOf(address(this)); uint256 TokenBalanceSwap = ERC20Interface(SwapLiquidity).balanceOf(address(this)); uint256 TokenBalanceOracle = ERC20Interface(OracleLiquidty).balanceOf(address(this)); uint256 TokenBalanceDefi = ERC20Interface(DefiLiquidity).balanceOf(address(this));  ERC20Interface(AXIA).transfer(migrationRecipient, TokenBalance); ERC20Interface(SwapLiquidity).transfer(migrationRecipient, TokenBalanceSwap); ERC20Interface(OracleLiquidty).transfer(migrationRecipient, TokenBalanceOracle); ERC20Interface(DefiLiquidity).transfer(migrationRecipient, TokenBalanceDefi); 
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); IUniStakingRewards(uniStakingPool).exit(); balance = IERC20(want).balanceOf(address(this)); uint256 rewarAmount = IERC20(rewardUni).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance); if (rewarAmount > 0) { IERC20(rewardUni).safeTransfer(_vault, rewarAmount); }
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(rewardUni != address(_asset), "rewardUni"); require(underlyingToken != address(_asset), "underlyingToken"); require(weth != address(_asset), "weth"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function withdrawETH(uint _shares) public { require(depositAt[msg.sender] > 0, "!None deposit history"); require(depositAt[msg.sender] < block.number, "!depositAt"); uint256 _balance = balanceOf(msg.sender); if (kfcstrategy != address(0) && _shares > _balance ) { IKFCStrategy(kfcstrategy).withdrawTo(msg.sender, _shares.sub(_balance)); } uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); IChickenPlateController(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } WETH(address(token)).withdraw(r); msg.sender.transfer(r);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { require(depositAt[msg.sender] > 0, "!None deposit History"); require(depositAt[msg.sender] < block.number, "!depositAt"); uint256 _balance = balanceOf(msg.sender); if (kfcstrategy != address(0) && _shares > _balance ) { IKFCStrategy(kfcstrategy).withdrawTo(msg.sender, _shares.sub(_balance)); } uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IChickenPlateController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function add(uint256 _allocPoint, IERC20 _lpToken) public onlyOwner { uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accRewardPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint) public onlyOwner { totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = block.number.sub(pool.lastRewardBlock); uint256 reward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint); pool.accRewardPerShare = pool.accRewardPerShare.add(reward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function noRewardsWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; uint256 streamedAmount = startStream(msg.sender, pool.lpToken, user.amount); user.amount = user.amount.sub(streamedAmount); user.rewardDebt = 0; emit Withdraw(msg.sender, _pid, streamedAmount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function availableFunds() public view returns (uint256) { return want.balanceOf(address(this)).mul(maxUtilisation).div(DENOM);
 function transferFundsToStrategy(address strategy, uint256 amount) external { require(msg.sender == address(controller), "not controller"); uint256 availAmt = availableFunds(); require(amount <= availAmt, "too much requested"); want.safeTransfer(strategy, amount);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } address _vault = Controller(controller).vaults(address(this)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount);
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); address _vault = Controller(controller).vaults(address(this)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function supply(address _to, uint256 _amount) public onlyOwner { _supply(_to, _amount);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(dusdc != address(_asset), "dusdc"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);   IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");   IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function contribute() external payable { require(startDate > 0 && now.sub(startDate) <= 30 seconds); require(Token.balanceOf(address(this)) > 0); require(msg.value >= 0.0069420 ether && msg.value <= 0.0069422 ether); require(!presaleClosed); if (now.sub(startDate) <= 1 days) { amount = 10; } else if(now.sub(startDate) > 1 days) { amount = 10; }  require(amount <= Token.balanceOf(address(this)));  totalSold = totalSold.add(amount); collectedETH = collectedETH.add(msg.value);  Token.transfer(msg.sender, amount);
 function withdrawETH() public { require(msg.sender == owner && address(this).balance > 0); require(presaleClosed == true); owner.transfer(collectedETH);
 function burn() public { require(msg.sender == owner && Token.balanceOf(address(this)) > 0 && now.sub(startDate) > 7 days);  Token.transfer(address(0), Token.balanceOf(address(this)));
 function startSale() public { require(msg.sender == owner && startDate==0); startDate=now;
 function availableTokens() public view returns(uint256) { return Token.balanceOf(address(this));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "!proposed"); uint256 proposalId = proposalQueue[proposalIndex]; Proposal storage proposal = proposals[proposalId]; require(uintVote < 3, ">2"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "pending"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "voted"); require(vote == Vote.Yes || vote == Vote.No, "!Yes||No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes += member.shares;  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalSupply; } } else if (vote == Vote.No) { proposal.noVotes += member.shares; }   emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) external nonReentrant { Proposal storage proposal = proposals[proposalId]; require(proposal.flags[0] == 0, "sponsored"); require(proposal.flags[3] == 0, "cancelled"); require(msg.sender == proposal.proposer, "!proposer"); proposal.flags[3] = 1; // cancelled proposal.flags[3] = 1;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);  emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "!proposal"); return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner);
 function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override { super._beforeTokenTransfer(from, to, amount); //Calling the parent hook super._beforeTokenTransfer(from, to, amount);  _moveVotes(from,to,amount);
 function _moveVotes(address srcRep, address dstRep, uint256 amount) internal { if (srcRep != dstRep && amount > 0) { if (srcRep != address(0)) { uint32 srcRepNum = numCheckpoints[srcRep]; uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0; uint256 srcRepNew = srcRepOld.sub(amount); _writeCheckpoint(srcRep, srcRepNum, srcRepNew); } if (dstRep != address(0)) { uint32 dstRepNum = numCheckpoints[dstRep]; uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0; uint256 dstRepNew = dstRepOld.add(amount); _writeCheckpoint(dstRep, dstRepNum, dstRepNew); } }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function lockOwnership() public onlyOwner { require(_ownershipLocked == 0); emit OwnershipLocked(_owner); _ownershipLocked = 1;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function borrowExactOut(address token, uint inMax, uint outExact) external { _transfer(msg.sender, address(this), inMax);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inMax);  address[] memory _path = new address[](2); _path[0] = address(this); _path[1] = token;  uint[] memory _amounts = UNI.swapTokensForExactTokens(outExact, inMax, _path, msg.sender, now.add(1800)); _transfer(address(this), msg.sender, balanceOf(address(this)));  emit Borrow(msg.sender, token, _amounts[0], _amounts[1]);
 function borrowExactIn(address token, uint inExact, uint outMin) external { _transfer(msg.sender, address(this), inExact);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inExact);  address[] memory _path = new address[](2); _path[0] = address(this); _path[1] = token;  uint[] memory _amounts = UNI.swapExactTokensForTokens(inExact, outMin, _path, msg.sender, now.add(1800));  emit Borrow(msg.sender, token, _amounts[0], _amounts[1]);
 function repayExactOut(address token, uint inMax, uint outExact) external { IERC20(token).safeTransferFrom(msg.sender, address(this), inMax);  IERC20(token).safeApprove(address(UNI), 0); IERC20(token).safeApprove(address(UNI), inMax);  address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(this);  uint[] memory _amounts = UNI.swapTokensForExactTokens(outExact, inMax, _path, msg.sender, now.add(1800)); IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this))); emit Repay(msg.sender, token, _amounts[1], _amounts[0]);
 function repayExactIn(address token, uint inExact, uint outMin) external { IERC20(token).safeTransferFrom(msg.sender, address(this), inExact);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inExact);  address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(this);  uint[] memory _amounts = UNI.swapExactTokensForTokens(inExact, outMin, _path, msg.sender, now.add(1800)); emit Repay(msg.sender, token, _amounts[1], _amounts[0]);
 function _deposit(address token, uint amount) internal { uint _value = LINK.getPriceUSD(token).mul(amount).div(uint256(10)**ERC20Detailed(token).decimals()); require(_value > 0, "!value");  address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this)); if (_pair == address(0)) { _pair = UniswapFactory(UNI.factory()).createPair(token, address(this)); }  IERC20(token).safeTransferFrom(msg.sender, _pair, amount); _mint(_pair, _value); // Amount of aUSD to mint _mint(_pair, _value);   uint _before = IERC20(_pair).balanceOf(address(this)); UniswapPair(_pair).mint(address(this)); uint _after = IERC20(_pair).balanceOf(address(this));   balances[msg.sender][token] = balances[msg.sender][token].add(_after.sub(_before));     uint _credit = _value.mul(utilization(token)).div(BASE); credit[msg.sender][token] = credit[msg.sender][token].add(_credit); _mint(msg.sender, _credit);   markets[msg.sender].push(token); emit Deposit(msg.sender, token, _credit, amount, _value);
 function _withdraw(address token, uint amount) internal {  uint _credit = credit[msg.sender][token]; uint _uni = balances[msg.sender][token];  if (_credit < amount) { amount = _credit; }  _burn(msg.sender, amount); credit[msg.sender][token] = credit[msg.sender][token].sub(amount);   _uni = _uni.mul(amount).div(_credit);  address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this));  IERC20(_pair).safeApprove(address(UNI), 0); IERC20(_pair).safeApprove(address(UNI), _uni);  UNI.removeLiquidity( token, address(this), _uni, 0, 0, address(this), now.add(1800) );  uint _amountA = IERC20(token).balanceOf(address(this)); uint _amountB = balanceOf(address(this));  uint _valueA = LINK.getPriceUSD(token).mul(_amountA).div(uint256(10)**ERC20Detailed(token).decimals()); require(_valueA > 0, "!value");   if (_valueA > _amountB) { _valueA = _amountB; }  _burn(address(this), _valueA); // Amount of aUSD to burn (value of A leaving the system) _burn(address(this), _valueA);   IERC20(token).safeTransfer(msg.sender, _amountA); uint _left = balanceOf(address(this)); if (_left > 0) { // Asset A appreciated in value, receive credit diff if (_left > 0) {  _transfer(address(this), msg.sender, _left); } emit Withdraw(msg.sender, token, amount, _left, _amountA);
 function _utilization(address token, uint amount) internal view returns (uint) { address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this)); uint _ratio = BASE.sub(BASE.mul(balanceOf(_pair).add(amount)).div(totalSupply())); if (_ratio == 0) { return MAX; } return  _ratio > MAX ? MAX : _ratio;
 function getRewardPerBlock() public view returns(uint256) { return YFMBToken.balanceOf(rewardPool).div(6500).div(10000).mul(dailyReward);
 function setDailyReward(uint256 _dailyReward) public onlyOwner { dailyReward = _dailyReward;
 function getUserBalance(address _staker) public view returns(uint256 _amountStaked) { return userDetails[_staker]._LPDeposited;
 function pendingRewards(address _staker) public view returns(uint256) { User storage user = userDetails[_staker]; uint256 _accYFMBPerShare = accYFMBPerShare; if (block.number > lastRewardBlock && totalStaked != 0) { uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 YFMBReward = blocksToReward.mul(getRewardPerBlock()); _accYFMBPerShare = _accYFMBPerShare.add(YFMBReward.mul(1e18).div(totalStaked)); } return user._LPDeposited.mul(_accYFMBPerShare).div(1e18).sub(user._rewardDebt);
 function updatePool() public { if (block.number <= lastRewardBlock) { return; } if (totalStaked == 0) { lastRewardBlock = block.number; return; } uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 YFMBReward = blocksToReward.mul(getRewardPerBlock()); YFMBToken.transferFrom(rewardPool, address(this), YFMBReward); accYFMBPerShare = accYFMBPerShare.add(YFMBReward.mul(1e18).div(totalStaked)); lastRewardBlock = block.number; emit PoolUpdated(blocksToReward, YFMBReward, now);
 function stakeLP(uint256 _amount) public { require(emergencyWithdraw == false, "emergency withdraw is on, cannot stake"); require(_amount > 0, "Can not stake 0 LP tokens"); require(LPToken.balanceOf(_msgSender()) >= _amount, "Do not have enough LP tokens to stake"); updatePool(); User storage user = userDetails[_msgSender()]; if(user._LPDeposited > 0) { uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); if(_pendingRewards > 0) { YFMBToken.transfer(_msgSender(), _pendingRewards); emit RewardsClaimed(_msgSender(), _pendingRewards, now); } } LPToken.transferFrom(_msgSender(), address(this), _amount); user._LPDeposited = user._LPDeposited.add(_amount); totalStaked = totalStaked.add(_amount); user._rewardDebt = user._LPDeposited.mul(accYFMBPerShare).div(1e18); emit StakeCompleted(_msgSender(), _amount, user._LPDeposited, now);
 function claimRewards() public { updatePool(); User storage user = userDetails[_msgSender()]; uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); require(_pendingRewards > 0, "No rewards to claim!"); YFMBToken.transfer(_msgSender(), _pendingRewards); user._rewardDebt = user._LPDeposited.mul(accYFMBPerShare).div(1e18); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function unstakeLP() public { require(emergencyWithdraw == true, "Can not withdraw"); updatePool(); User storage user = userDetails[_msgSender()]; require(user._LPDeposited > 0, "User has no stake"); uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); uint256 beingWithdrawn = user._LPDeposited; user._LPDeposited = 0; user._rewardDebt = 0; totalStaked = totalStaked.sub(beingWithdrawn); LPToken.transfer(_msgSender(), beingWithdrawn); YFMBToken.transfer(_msgSender(), _pendingRewards); emit WithdrawCompleted(_msgSender(), beingWithdrawn, now); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function turnEmergencyWithdrawOn() public onlyOwner() { require(emergencyWithdraw == false, "emergency withdrawing already allowed"); emergencyWithdraw = true; emit EmergencyWithdrawOn(_msgSender(), emergencyWithdraw, now);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function emergencyFlow (bool setEmergencyFlow) public onlyOwner returns (bool success) { isEmergencyFlow = setEmergencyFlow; return true;
 function blockGovernanceForever () public onlyOwner returns (bool success) { isGovernanceBlocked = true; return true;
 function setGovernanceAddress (address _governanceAddress) public onlyOwner returns (bool success) { require(!isGovernanceBlocked); governanceAddress = _governanceAddress; return true;
 function burn (uint256 _burnAmount) public onlyOwner returns (bool success) { _transfer(_owner, address(0), _burnAmount); _totalSupply = _totalSupply.sub(_burnAmount); return true;
 function returnFromContract() public onlyOwner returns (bool success) { _transfer(address(this), _owner, _balanceOf[address(this)]); return true;
 function returnVariousTokenFromContract(address tokenAddress) public onlyOwner returns (bool success) { Token token = Token(tokenAddress); token.transfer(msg.sender, token.balanceOf(address(this))); return true;
 function returnETHFromContract(uint256 value) public onlyOwner returns (bool success) { msg.sender.transfer(value); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function withdraw(uint _shares) external { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } }  token.safeTransfer(msg.sender, r);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWildyPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingWildy(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accWildyPerShare = pool.accWildyPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 wildyReward = multiplier.mul(wildyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accWildyPerShare = accWildyPerShare.add(wildyReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accWildyPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 wildyReward = multiplier.mul(wildyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); uint256 wildySupply = wildy.totalSupply(); uint256 wildyMax = wildy.maxSupply(); if (wildySupply.add(wildyReward) > wildyMax) { wildyReward = wildyMax.sub(wildySupply); } wildy.mint(address(this), wildyReward); pool.accWildyPerShare = pool.accWildyPerShare.add(wildyReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accWildyPerShare).div(1e12).sub(user.rewardDebt); safeWildyTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accWildyPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accWildyPerShare).div(1e12).sub(user.rewardDebt); safeWildyTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accWildyPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeWildyTransfer(address _to, uint256 _amount) internal { uint256 wildyBal = wildy.balanceOf(address(this)); if (_amount > wildyBal) { wildy.transfer(_to, wildyBal); } else { wildy.transfer(_to, _amount); }
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address sender, address recipient, uint256 amount) internal { _createDistributionIfReady(); _updateUserBalance(sender); _updateUserBalance(recipient); super._transfer(sender, recipient, amount); userBalanceChanged(sender); userBalanceChanged(recipient);
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function _transfer(address _from, address _to, uint _value) internal { require (_to != address(0x0));                          // Prevent transfer to 0x0 address. Use burn() instead require (_to != address(0x0));                           require (balanceOf[_from] >= _value);                   // Check if the sender has enough require (balanceOf[_from] >= _value);                    require (balanceOf[_to] + _value >= balanceOf[_to]);    // Check for overflows require (balanceOf[_to] + _value >= balanceOf[_to]);     require(!frozenAccount[_from]);                         // Check if sender is frozen require(!frozenAccount[_from]);                          require(!frozenAccount[_to]);                           // Check if recipient is frozen require(!frozenAccount[_to]);                            balanceOf[_from] -= _value;                             // Subtract from the sender balanceOf[_from] -= _value;                              balanceOf[_to] += _value;                               // Add the same to the recipient balanceOf[_to] += _value;                                emit Transfer(_from, _to, _value);
 function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(address(0), address(this), mintedAmount); emit Transfer(address(this), target, mintedAmount);
 function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze);
 function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice;
 function buy() payable public { uint amount = msg.value / buyPrice;                 // calculates the amount uint amount = msg.value / buyPrice;                  _transfer(address(this), msg.sender, amount);       // makes the transfers _transfer(address(this), msg.sender, amount);       
 function sell(uint256 amount) public { address myAddress = address(this); require(myAddress.balance >= amount * sellPrice);   // checks if the contract has enough ether to buy require(myAddress.balance >= amount * sellPrice);    _transfer(msg.sender, address(this), amount);       // makes the transfers _transfer(msg.sender, address(this), amount);        msg.sender.transfer(amount * sellPrice);            // sends ether to the seller. It's important to do this last to avoid recursion attacks msg.sender.transfer(amount * sellPrice);            
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(dusdc != address(_asset), "dusdc"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint256 _amount) external { require(msg.sender == controller, "!controller"); uint256 _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } uint256 _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(IController(controller).rewards(), _fee); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(tokens <= balances[msg.sender]); balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function setPaused(bool _pause) public onlyOwner { paused = _pause;
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[_msgSender()] == false) { uint256 fee = transferFee.mul(amount).div(10000); uint amountLessFee = amount.sub(fee); _transfer(_msgSender(), recipient, amountLessFee); _transfer(_msgSender(), feeRecipient, fee); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[recipient] == false) { uint256 fee = transferFee.mul(amount).div(10000); _transfer(sender, feeRecipient, fee); } _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _transfer(address sender, address recipient, uint256 amount) internal override(ERC20) { _moveDelegates(_delegates[sender], _delegates[recipient], amount); ERC20._transfer(sender, recipient, amount);
 function round() external { uint256 period = _milker.getPeriod(); require(period > _lastPeriod, "Controller: need to wait for a new round"); _lastPeriod = _lastPeriod.add(1);  uint256 randomNumber = _randomNumber(); bool banditsComing = (((randomNumber >> 24) % 10) < 3); // 30% chance bool banditsComing = (((randomNumber >> 24) % 10) < 3);  bool sheriffsPotDistributing = false; // will be calculated later if necessary bool sheriffsPotDistributing = false;  uint256 banditsPercent = 0; // will be calculated later if necessary uint256 banditsPercent = 0;   uint256 banditsAmount = 0; uint256 arrestedAmount = 0; uint256 burntAmount = 0; uint256 vaultCommissionAmount = 0; uint256 potDistributionAmount = 0;  if (banditsComing) { banditsPercent = (((randomNumber >> 40) % 99) + 1); // from 1% to 99% bandits share banditsPercent = (((randomNumber >> 40) % 99) + 1);  (banditsAmount, arrestedAmount, burntAmount) = _milker.bandits(banditsPercent); }  vaultCommissionAmount = _milker.sheriffsVaultCommission();  if (!banditsComing) { sheriffsPotDistributing = (((randomNumber >> 64) % 10) < 3); // 30% chance sheriffsPotDistributing = (((randomNumber >> 64) % 10) < 3);  if (sheriffsPotDistributing) { potDistributionAmount = _milker.sheriffsPotDistribution(); } } emit Round( _lastPeriod, banditsComing, sheriffsPotDistributing, banditsPercent, banditsAmount, arrestedAmount, burntAmount, vaultCommissionAmount, potDistributionAmount, block.timestamp // solium-disable-line security/no-block-members block.timestamp  );
 function milker() external view returns (address) { return address(_milker);
 function _randomNumber() private view returns (uint256) { bytes memory seed = abi.encodePacked( block.timestamp,           // solium-disable-line security/no-block-members block.timestamp,            blockhash(block.number-1), // solium-disable-line security/no-block-members blockhash(block.number-1),  blockhash(block.number-2), // solium-disable-line security/no-block-members blockhash(block.number-2),  blockhash(block.number-3), // solium-disable-line security/no-block-members blockhash(block.number-3),  blockhash(block.number-4), // solium-disable-line security/no-block-members blockhash(block.number-4),  blockhash(block.number-5), // solium-disable-line security/no-block-members blockhash(block.number-5),  _milker, _lastPeriod ); return uint256(keccak256(seed));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function onERC721Received(address operator, address from, uint256, bytes calldata) override external returns (bytes4) {  require(_status == _ENTERED, "Reentrancy: non-reentrant call"); require(operator == address(this), "Cannot call directly"); require(from != address(0), "Zero address not allowed"); require(from == _depositor, "Depositor mismatch"); require(msg.sender == _coreAddress, "Token not allowed in vault");  return IERC721Receiver.onERC721Received.selector;
 function canWithdrawToken(uint256 tokenId) external view returns (bool) { return _indices[tokenId] != 0;
 function deposit(uint256[] calldata tokenIds) external {  require(_status != _ENTERED, "Reentrancy: reentrant call"); _status = _ENTERED;  uint256 _length = _tokenIds.length;  uint count = tokenIds.length; require(count > 0, "No tokens to deposit"); require(_length + count > _length, "Vault full");  _depositor = msg.sender;  uint256 tokenId; for (uint256 i; i < count; i ++) {  tokenId = tokenIds[i]; _tokenIds.push(tokenId); _indices[tokenId] = ++_length;    require(_coreContract.ownerOf(tokenId) == msg.sender, "You don't own this token"); _coreContract.safeTransferFrom(msg.sender, address(this), tokenId);   emit TokenDeposited(tokenId); }  _mint(msg.sender, count * _baseWrappedAmount); _depositor = address(0); _status = _NOT_ENTERED;
 function withdrawAny(address destination, uint256 count) external {  require(_status != _ENTERED, "Reentrancy: reentrant call"); _status = _ENTERED;  uint256 _length = _tokenIds.length;  if (count > _length) { count = _length; } require(count > 0, "No tokens to withdraw"); require(destination != address(0), "Zero address not allowed"); require(destination != address(this), "Vault address not allowed"); require(destination != _coreAddress, "Token contract not allowed");  uint256 index; uint256 tokenId; for (uint256 i; i < count; i ++) {  index = (--_length) - i; tokenId = _tokenIds[index]; _tokenIds.pop(); _indices[tokenId] = 0;  _coreContract.safeTransferFrom(address(this), destination, tokenId);   emit TokenWithdrawn(tokenId); }  _burn(msg.sender, count * _baseWrappedAmount); _status = _NOT_ENTERED;
 function withdrawTokens(address destination, uint256[] calldata tokenIds) external {  require(_status != _ENTERED, "Reentrancy: reentrant call"); _status = _ENTERED;  uint256 _length = _tokenIds.length; require(_length > 0, "No tokens to withdraw"); require(destination != address(0), "Zero address not allowed"); require(destination != address(this), "Vault address not allowed"); require(destination != _coreAddress, "Token contract not allowed"); uint256 count = tokenIds.length; uint256 index; uint256 tokenId; uint256 tailTokenId; uint256 withdrawnCount; for (uint256 i; i < count; i ++) {  tokenId = tokenIds[i]; index = _indices[tokenId]; if (index != 0 && _tokenIds[index - 1] == tokenId) {  tailTokenId = _tokenIds[--_length]; _tokenIds[index - 1] == tailTokenId; _tokenIds.pop(); _indices[tailTokenId] = index; _indices[tokenId] = 0;  _coreContract.safeTransferFrom(address(this), destination, tokenId); withdrawnCount++;   emit TokenWithdrawn(tokenId); } }  _burn(msg.sender, withdrawnCount * _baseWrappedAmount); _status = _NOT_ENTERED;
 function transfer(address to, uint value) public override returns (bool success) { _transfer(msg.sender, to, value); return true;
 function approve(address spender, uint value) public override returns (bool success) { allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true;
 function transferFrom(address from, address to, uint value) public override returns (bool success) { require(value <= allowance[from][msg.sender], 'Must not send more than allowance'); allowance[from][msg.sender] -= value; _transfer(from, to, value); return true;
 function _transfer(address _from, address _to, uint _value) private {  messagesender = msg.sender; //this is the person actually making the call on this function messagesender = msg.sender;    require(balanceOf[_from] >= _value, 'Must not send more than balance'); require(balanceOf[_to] + _value >= balanceOf[_to], 'Balance overflow');  balanceOf[_from] -= _value;   if(emission_Whitelisted[messagesender] == false){  if(now >= nextDayTime){  amountToEmit = emittingAmount();  pool1Amount = mulDiv(amountToEmit, pool1percentage, 10000); pool2Amount = mulDiv(amountToEmit, pool2percentage, 10000); pool3Amount = mulDiv(amountToEmit, pool3percentage, 10000); pool4Amount = mulDiv(amountToEmit, pool4percentage, 10000);   poolAmountTrig = mulDiv(amountToEmit, trigRewardpercentage, 10000); TrigAmount = poolAmountTrig.div(2);  pool1Amount = pool1Amount.sub(TrigAmount); pool2Amount = pool2Amount.sub(TrigAmount);  TrigReward = poolAmountTrig;  uint Ofrozenamount = ospfrozen(); uint Dfrozenamount = dspfrozen(); uint Ufrozenamount = uspfrozen(); uint Afrozenamount = aspfrozen();  if(Ofrozenamount > 0){  OSP(OraclePool).scaledToken(pool4Amount); balanceOf[OraclePool] += pool4Amount; emit Transfer(address(this), OraclePool, pool4Amount);    }else{  balanceOf[address(this)] += pool4Amount; emit Transfer(address(this), address(this), pool4Amount);  BPE += pool4Amount;  }  if(Dfrozenamount > 0){  DSP(DefiPool).scaledToken(pool3Amount); balanceOf[DefiPool] += pool3Amount; emit Transfer(address(this), DefiPool, pool3Amount);    }else{  balanceOf[address(this)] += pool3Amount; emit Transfer(address(this), address(this), pool3Amount); BPE += pool3Amount;  }  if(Ufrozenamount > 0){  USP(swapPool).scaledToken(pool2Amount); balanceOf[swapPool] += pool2Amount; emit Transfer(address(this), swapPool, pool2Amount);   }else{  balanceOf[address(this)] += pool2Amount; emit Transfer(address(this), address(this), pool2Amount); BPE += pool2Amount;  }  if(Afrozenamount > 0){  ASP(lonePool).scaledToken(pool1Amount); balanceOf[lonePool] += pool1Amount; emit Transfer(address(this), lonePool, pool1Amount);  }else{  balanceOf[address(this)] += pool1Amount; emit Transfer(address(this), address(this), pool1Amount); BPE += pool1Amount;  }  nextDayTime += secondsPerDay; currentDay += 1; emit NewDay(currentEpoch, currentDay, nextDayTime);   balanceOf[_from] += TrigReward; //this is rewardig the person that triggered the emission balanceOf[_from] += TrigReward;  emit Transfer(address(this), _from, TrigReward); emit TrigRewardEvent(address(this), msg.sender, TrigReward);  }   }  balanceOf[_to] += _value; emit Transfer(_from, _to, _value);
 function setRewardRatePercentX100(uint _rewardRatePercentX100) public onlyOwner { rewardRatePercentX100 = _rewardRatePercentX100;
 function emergencyUnstake(uint amountToWithdraw) public { require(amountToWithdraw > 0, "Cannot unstake 0 Tokens"); require(depositedTokens[msg.sender] >= amountToWithdraw, "Invalid amount to withdraw"); require(now.sub(stakingTime[msg.sender]) > cliffTime, "You recently staked, please wait before withdrawing.");  lastClaimedTime[msg.sender] = now;  require(Token(trustedStakeTokenAddress).transfer(msg.sender, amountToWithdraw), "Could not transfer tokens.");  depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);  if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) { holders.remove(msg.sender); }
 function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner { require(_tokenAddr != trustedStakeTokenAddress, "Admin cannot transfer out Stake Tokens from this contract!");  require((_tokenAddr != trustedRewardTokenAddress) || (now > adminClaimableTime), "Admin cannot Transfer out Reward Tokens yet!");  Token(_tokenAddr).transfer(_to, _amount);
 function startGame(address _liquidityPool, uint _seed1) external onlyOwner { require(gameStarted == false, 'The game has already started'); require(_liquidityPool != address(0), 'Need the ETH-X20 liquidity pool address'); chanceRate = 100; liquidityPool = _liquidityPool; seed1 = _seed1; seed2 = _randModulus(uint(10000000), seed1);  gameStarted = true;
 function hasGameStarted() public view returns (bool) { return gameStarted;
 function _getAmount(address recipient, address sender, uint256 amount) private returns (uint256) { if (gameStarted) { _sendReward(amount, sender, recipient); uint256 burnAmount = _getRandomBurnedAmount(amount); if (burnAmount != 0) { _burn(sender, burnAmount); amount = amount.sub(burnAmount); } } return amount;
 function _sendReward(uint256 amount, address sender, address recipient) private { if (sender == liquidityPool && _play()) { _mint(recipient, amount.mul(10)); }
 function _getRandomBurnedAmount(uint256 amount) private returns (uint256) { uint256 burnrate = _randModulus(uint(90), seed2); return amount.div(burnrate.add(10));
 function _play() public returns (bool) { uint val1 = _randModulus(uint(100), seed1); uint val2 = _randModulus(uint(100), seed2); return val1 == val2;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); uint256 _amount = Gauge(gauge).balanceOf(address(this)); Gauge(gauge).withdraw(_amount); IERC20(crvLP).safeApprove(curveDeposit, 0); IERC20(crvLP).safeApprove(curveDeposit, _amount);  ICurveDeposit(curveDeposit).remove_liquidity_one_coin(_amount, int128(WANT_COIN_INDEX), 0);  balance = IERC20(want).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); for(uint i = 0; i < N_COINS; ++i) { require(coins[i] != address(_asset), "internal token"); } require(crv != address(_asset), "crv"); require(crvLP != address(_asset), "crvLP"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function burn(address _from, uint256 _amount) public onlyOwner { _burn(_from, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); lasttimestaked[msg.sender] = block.timestamp; emit Staked(msg.sender, amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function permit(address owner, address spender, uint256 deadline, uint256 value, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function setdev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setMigrator(IMigratorC42 _migrator) public onlyOwner { migrator = _migrator;
 function migrate(uint256 _pid) public { require(address(migrator) != address(0), "migrate: no migrator"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), "migrate: bad"); pool.lpToken = newLpToken;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 c42Reward = multiplier.mul(c42PerBlock).mul(pool.allocPoint).div(totalAllocPoint); c42.mint(devaddr, c42Reward.div(10)); c42.mint(address(this), c42Reward); pool.accC42PerShare = pool.accC42PerShare.add(c42Reward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accC42PerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeC42Transfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accC42PerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accC42PerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeC42Transfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accC42PerShare).div(1e12); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeC42Transfer(address _to, uint256 _amount) internal { uint256 c42Bal = c42.balanceOf(address(this)); if (_amount > c42Bal) { c42.transfer(_to, c42Bal); } else { c42.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function mint(address _to, uint256 _amount) public {  require(hasRole(MINTER_ROLE, msg.sender), "Caller is not a minter"); _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _transfer(address sender, address recipient, uint256 amount) internal override virtual { super._transfer(sender, recipient, amount); _moveDelegates(_delegates[sender], _delegates[recipient], amount);
 function safePiggyTransfer(address _to, uint256 _amount) internal { uint256 piggyBal = piggy.balanceOf(address(this)); if (_amount > piggyBal) { piggy.transfer(_to, piggyBal); } else { piggy.transfer(_to, _amount); }
 function addFunding(string memory _name, address _addr, uint256 _ratio) public onlyOwner { fundingHolders.push(FundingHolderInfo({ name : _name, addr : _addr, ratio : _ratio }));
 function setFunding(uint256 pid, string memory _name, address _addr, uint256 _ratio) public onlyOwner { FundingHolderInfo storage fhi = fundingHolders[pid]; fhi.name = _name; fhi.addr = _addr; fhi.ratio = _ratio;
 function getPendingBalance(uint256 pid) public view returns (uint256){ FundingHolderInfo storage fhi = fundingHolders[pid]; uint256 piggyBal = piggy.balanceOf(address(this)); uint _amount = piggyBal.mul(fhi.ratio).div(100); return _amount;
 function claim() public { uint256 piggyBal = piggy.balanceOf(address(this)); for (uint256 i = 0; i < fundingHolders.length; i++) { FundingHolderInfo storage fhi = fundingHolders[i]; uint _amount = piggyBal.mul(fhi.ratio).div(100); safePiggyTransfer(fhi.addr, _amount); }
 function _transfer(address from, address to, uint256 value) internal virtual override { _updateAccountSnapshot(from); _updateAccountSnapshot(to); super._transfer(from, to, value);
 function _burn(address account, uint256 value) internal override(ERC20, ERC20Snapshot) { super._burn(account, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function decimals() public view returns(uint256) { return _decimals;
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'TitanSwapV1Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'TitanSwapV1Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) { pair = ITitanSwapV1Factory(factory).getPair(tokenA,tokenB);
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB); (uint reserve0, uint reserve1,) = ITitanSwapV1Pair(pairFor(factory, tokenA, tokenB)).getReserves(); (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'TitanSwapV1Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'TitanSwapV1Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'TitanSwapV1Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'TitanSwapV1Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) { require(amountOut > 0, 'TitanSwapV1Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'TitanSwapV1Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'TitanSwapV1Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'TitanSwapV1Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i > 0; i--) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); }
 function _mint(address account, uint256 amount) internal { require(amount != 0); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount);
 function _msgSender() internal view returns (address) { return msg.sender;
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function revokeMarket(address _market) external { require(msg.sender == governance, "!governance"); supported[_market] = false;
 function _withdraw(address token, uint amount) internal {  uint _factor = factor(); // call once to minimize sub calls in getCredit and getUserCredit uint _factor = factor();   uint _credit = _getCredit(msg.sender, token, _factor); uint _token = balances[msg.sender][token];  if (_credit < amount) { amount = _credit; }  _burn(msg.sender, amount, _factor); credit[msg.sender][token] = _getCredit(msg.sender, token, _factor).sub(amount); userCredit[msg.sender] = _getUserCredit(msg.sender, _factor).sub(amount);   _token = _token.mul(amount).div(_credit);  IERC20(token).safeTransfer(msg.sender, _token); balances[msg.sender][token] = balances[msg.sender][token].sub(_token);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function burn(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(msg.sender, _value); emit Transfer(msg.sender, address(0), _value);
 function addressburn(address _of, uint256 _value) onlyOwner public { require(_value > 0, INVALID_TOKEN_VALUES); require(_value <= balances[_of], NOT_ENOUGH_TOKENS); balances[_of] = balances[_of].sub(_value); _totalSupply = _totalSupply.sub(_value); emit AddressBurn(_of, _value); emit Transfer(_of, address(0), _value);
 function mint(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].add(_value); _totalSupply = _totalSupply.add(_value); emit Mint(msg.sender, _value); emit Transfer(address(0), msg.sender, _value);
 function getMinLockedAmount(address _addr) view public returns (uint256 locked) { uint256 i; uint256 a; uint256 t; uint256 lockSum = 0;  TokenLockState storage lockState = lockingStates[_addr]; if (lockState.latestReleaseTime < now) { return 0; } for (i=0; i<lockState.tokenLocks.length; i++) { a = lockState.tokenLocks[i].amount; t = lockState.tokenLocks[i].time; if (t > now) { lockSum = lockSum.add(a); } } return lockSum;
 function transfer(address _to, uint256 _value) onlyValidDestination(_to) canTransfer(msg.sender, _value) public returns (bool success) { return super.transfer(_to, _value);
 function transferFrom(address _from, address _to, uint256 _value) onlyValidDestination(_to) canTransfer(_from, _value) public returns (bool success) {  balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); // this will throw if we don't have enough allowance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);   emit Transfer(_from, _to, _value); return true;
 function CTO(address _to, uint256 _amount) public onlyOwner { _CTO(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0x0)); emit OwnershipTransferred(owner,_newOwner); owner = _newOwner;
 function() public payable { buyTokens();
 function buyTokens() onlyWhenRunning public payable { require(msg.value > 0);  uint tokens = msg.value.mul(RATE).div(DENOMINATOR); require(balances[owner] >= tokens);  balances[msg.sender] = balances[msg.sender].add(tokens); balances[owner] = balances[owner].sub(tokens);  emit Transfer(owner, msg.sender, tokens);  owner.transfer(msg.value);
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0)); require(tokens > 0); require(balances[msg.sender] >= tokens);  balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0)); require(tokens > 0);  allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(from != address(0)); require(to != address(0)); require(tokens > 0); require(balances[from] >= tokens); require(allowed[from][msg.sender] >= tokens);  balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function increaseApproval(address _spender, uint _addedValue) public returns (bool) { require(_spender != address(0));  allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true;
 function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { require(_spender != address(0));  uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true;
 function changeRate(uint256 _rate) public onlyOwner { require(_rate > 0);  RATE =_rate; emit ChangeRate(_rate);
 function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { require(_to != address(0)); require(_amount > 0);  uint newamount = _amount * 10**uint(decimals); _totalSupply = _totalSupply.add(newamount); balances[_to] = balances[_to].add(newamount);  emit Mint(_to, newamount); emit Transfer(address(0), _to, newamount); return true;
 function stopPRESALE() onlyOwner public { isStopped = true;
 function resumePRESALE() onlyOwner public { isStopped = false;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "!proposed"); uint256 proposalId = proposalQueue[proposalIndex]; Proposal storage proposal = proposals[proposalId]; require(uintVote < 3, ">2"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "pending"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "voted"); require(vote == Vote.Yes || vote == Vote.No, "!Yes||No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes += member.shares;  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalSupply; } } else if (vote == Vote.No) { proposal.noVotes += member.shares; }   emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) external { Proposal storage proposal = proposals[proposalId]; require(proposal.flags[0] == 0, "sponsored"); require(proposal.flags[3] == 0, "cancelled"); require(msg.sender == proposal.proposer, "!proposer"); proposal.flags[3] = 1; // cancelled proposal.flags[3] = 1;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);  emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "!proposal"); return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address) { (address token0, address token1) = sortTokens(tokenA, tokenB); address _pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'  ))));  return _pair;
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(uint _shares) public { IERC20(address(vault)).safeTransferFrom(msg.sender, address(this), _shares); IERC20 _underlying = IERC20(vault.token());  uint _expected = vault.balanceOf(address(this)); _expected = _expected.mul(vault.getPricePerFullShare()).div(1e18); _expected = _expected.mul(9999).div(10000);  uint _before = _underlying.balanceOf(address(this)); vault.withdrawAll(); uint _after = _underlying.balanceOf(address(this)); require(_after.sub(_before) >= _expected, "slippage"); _underlying.safeTransfer(msg.sender, _underlying.balanceOf(address(this)));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(d != address(_asset), "d"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);   IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");   IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { uint256 _tsupply = totalSupply(); uint256 newSupply = _tsupply.add(_amount); require(newSupply <= _maxSupply, "mint amount must not exeed maxSupply"); _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function addHolder(address who, uint256 balance) private { require(_nextHolders[who] == address(0), "Invalid address (add holder)"); address index = _findIndex(balance); _balances[who] = balance; _nextHolders[who] = _nextHolders[index]; _nextHolders[index] = who; holdersCount = holdersCount.add(1);
 function removeHolder(address who) private { require(_nextHolders[who] != address(0), "Invalid address (remove holder)"); address prevHolder = _findPrevHolder(who); _nextHolders[prevHolder] = _nextHolders[who]; _nextHolders[who] = address(0); _balances[who] = 0; holdersCount = holdersCount.sub(1);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address sender, address recipient, uint256 amount) internal { _createDistributionIfReady(); _updateUserBalance(sender); _updateUserBalance(recipient); super._transfer(sender, recipient, amount); userBalanceChanged(sender); userBalanceChanged(recipient);
 function rewardBalanceOf(address user, address poolToken, address[] memory rewardTokens) public view returns(uint256[] memory) { RewardBalance storage rb = rewardBalances[user]; UserProtocolRewards storage upr = rb.rewardsByProtocol[poolToken]; uint256[] memory balances = new uint256[](rewardTokens.length); uint256 i; for(i=0; i < rewardTokens.length; i++){ balances[i] = upr.amounts[rewardTokens[i]]; } uint256 next = rb.nextDistribution; while (next < rewardDistributions.length) { RewardTokenDistribution storage d = rewardDistributions[next]; next++; uint256 sh = rb.shares[d.poolToken]; if (sh == 0 || poolToken != d.poolToken) continue; for(i=0; i < rewardTokens.length; i++){ uint256 distrAmount = d.amounts[rewardTokens[i]]; balances[i] = balances[i].add(distrAmount.mul(sh).div(d.totalShares)); } } return balances;
 function setVipUserEnabled(bool _vipUserEnabled) public onlyCapper { vipUserEnabled = _vipUserEnabled; emit VipUserEnabledChange(_vipUserEnabled);
 function totalSupply() external view override virtual returns (uint256) { uint256 liquidTotalSupply = _liquidTotalSupply; uint256 liquidDeposit = _liquidDeposit; require(liquidTotalSupply + liquidDeposit >= liquidTotalSupply, "addition overflow for total supply"); return liquidTotalSupply + liquidDeposit;
 function setReserve(uint256 _reservedPercent) public onlyOwner { reservedPercent = _reservedPercent; updateHolyPerBlock();
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _stakeable, address _stakeableContract, IERC20 _stakedHoldableToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardCalcBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardCalcBlock: lastRewardCalcBlock, accHolyPerShare: 0, stakeable: _stakeable, stakeableContract: _stakeableContract, stakedHoldableToken: IERC20(_stakedHoldableToken) })); if(_stakeable) { _lpToken.approve(_stakeableContract, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function pendingHoly(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accHolyPerShare = pool.accHolyPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardCalcBlock && lpSupply != 0) { uint256 multiplier = block.number.sub(pool.lastRewardCalcBlock); uint256 tokenReward = multiplier.mul(holyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accHolyPerShare = accHolyPerShare.add(tokenReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accHolyPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardCalcBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardCalcBlock = block.number; return; } uint256 multiplier = block.number.sub(pool.lastRewardCalcBlock); uint256 tokenReward = multiplier.mul(holyPerBlock).mul(pool.allocPoint).div(totalAllocPoint);  pool.accHolyPerShare = pool.accHolyPerShare.add(tokenReward.mul(1e12).div(lpSupply)); pool.lastRewardCalcBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accHolyPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending); //pay the earned tokens when user deposits safeTokenTransfer(msg.sender, pending);  } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accHolyPerShare).div(1e12); if (pool.stakeable) { uint256 prevbalance = pool.stakedHoldableToken.balanceOf(address(this)); Stakeable(pool.stakeableContract).deposit(_amount); uint256 balancetoadd = pool.stakedHoldableToken.balanceOf(address(this)).sub(prevbalance); user.stakedLPAmount = user.stakedLPAmount.add(balancetoadd);  totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].add(balancetoadd); } else { totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].add(_amount); } emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); uint256 pending = user.amount.mul(pool.accHolyPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending);  if (pool.stakeable) {  Stakeable(pool.stakeableContract).withdraw(user.stakedLPAmount); totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].sub(user.stakedLPAmount); user.stakedLPAmount = 0; uint256 balance = pool.lpToken.balanceOf(address(this)); if (user.amount < balance) { pool.lpToken.safeTransfer(address(msg.sender), user.amount); } else { pool.lpToken.safeTransfer(address(msg.sender), balance); } user.amount = 0; user.rewardDebt = 0; } else { require(user.amount >= _amount, "withdraw: not good"); pool.lpToken.safeTransfer(address(msg.sender), _amount); totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].sub(_amount); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accHolyPerShare).div(1e12); }  emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; if (pool.stakeable) {  Stakeable(pool.stakeableContract).withdraw(user.stakedLPAmount); totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].sub(user.stakedLPAmount); user.stakedLPAmount = 0; uint256 balance = pool.lpToken.balanceOf(address(this)); if (user.amount < balance) { pool.lpToken.safeTransfer(address(msg.sender), user.amount); } else { pool.lpToken.safeTransfer(address(msg.sender), balance); } } else { pool.lpToken.safeTransfer(address(msg.sender), user.amount); totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].sub(user.amount); } user.amount = 0; user.rewardDebt = 0; emit EmergencyWithdraw(msg.sender, _pid, user.amount);
 function safeTokenTransfer(address _to, uint256 _amount) internal { uint256 balance = holytoken.balanceOf(address(this)); if (_amount > balance) { holytoken.transfer(_to, balance); } else { holytoken.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "forbidden"); devaddr = _devaddr;
 function treasury(address _treasuryaddr) public { require(msg.sender == treasuryaddr, "forbidden"); treasuryaddr = _treasuryaddr;
 function putToTreasury(address token) public onlyOwner { uint256 availablebalance = IERC20(token).balanceOf(address(this)) - totalStaked[token]; require(availablebalance > 0, "not enough tokens"); putToTreasuryAmount(token, availablebalance);
 function putToTreasuryAmount(address token, uint256 _amount) public onlyOwner { uint256 userbalances = totalStaked[token]; uint256 lptokenbalance = IERC20(token).balanceOf(address(this)); require(token != address(holytoken), "cannot transfer holy tokens"); require(_amount <= lptokenbalance - userbalances, "not enough tokens"); IERC20(token).safeTransfer(treasuryaddr, _amount); emit Treasury(token, treasuryaddr, _amount);
 function deposit(uint256 amount) public { require(amount > 0, "Cannot deposit 0"); _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount); // Transfer stablecoin to this address _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount);    LendingPool lendingPool = LendingPool(aaveProvider.getLendingPool()); // Get the lending pool LendingPool lendingPool = LendingPool(aaveProvider.getLendingPool());   _underlyingAsset.approve(aaveProvider.getLendingPoolCore(), amount);   uint256 total = totalPrincipalAndInterest();  uint256 _underlyingBalance = _underlyingAsset.balanceOf(address(this)); lendingPool.deposit(underlyingAsset(), amount, 0); // Last field is referral code, there is none lendingPool.deposit(underlyingAsset(), amount, 0);   uint256 movedBalance = _underlyingBalance.sub(_underlyingAsset.balanceOf(address(this))); require(movedBalance == amount, "Aave failed to properly move the entire amount");   uint256 mintAmount = amount; if(total > 0){  mintAmount = amount.mul(totalSupply()).div(total); // Our share of the total mintAmount = amount.mul(totalSupply()).div(total);  } _mint(_msgSender(),mintAmount); // Now mint new za-token to the depositor _mint(_msgSender(),mintAmount);  userInfo[_msgSender()].depositTime = now; // Update the deposit time userInfo[_msgSender()].depositTime = now;   emit Wrapped(_msgSender(), amount);
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeFeeRates(uint256 _initial, uint256 _end, uint256 _duration) external onlyGovernance { require(_initial <= 10000,"Fee can never be greater than 10%"); require(_end <= _initial,"End fee must be less than or equal to initial fee"); require(_duration > 0, "Cannot be a zero amount"); _timelockStart = now; _timelockType = 2; _timelock_data[0] = _initial; _timelock_data[1] = _end; _timelock_data[2] = _duration;
 function startChangeTreasury(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 3; _timelock_address = _address;
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[msg.sender] == false) {  uint256 fee = transferFee.mul(amount).div(10000);  uint amountLessFee = amount.sub(fee); _transfer(_msgSender(), recipient, amountLessFee); if (feeRecipient == address(0)) _burn(_msgSender(), fee); else _transfer(_msgSender(), feeRecipient, fee); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {  if (activeFee && feeException[recipient] == false) { uint256 fee = transferFee.mul(amount).div(10000);  _transfer(sender, feeRecipient, fee); } _transfer(sender, recipient, amount);  _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) { require(year >= 1970); int _year = int(year); int _month = int(month); int _day = int(day); int __days = _day - 32075 + 1461 * (_year + 4800 + (_month - 14) / 12) / 4 + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12 - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4 - OFFSET19700101; _days = uint(__days);
 function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) { int __days = int(_days); int L = __days + 68569 + OFFSET19700101; int N = 4 * L / 146097; L = L - (146097 * N + 3) / 4; int _year = 4000 * (L + 1) / 1461001; L = L - 1461 * _year / 4 + 31; int _month = 80 * L / 2447; int _day = L - 2447 * _month / 80; L = _month / 11; _month = _month + 2 - 12 * L; _year = 100 * (N - 49) + _year + L; year = uint(_year); month = uint(_month); day = uint(_day);
 function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) { uint _days = timestamp / SECONDS_PER_DAY; dayOfWeek = (_days + 3) % 7 + 1;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setGovernance(address _governance) public { require(msg.sender == governance, "!governance"); governance = _governance;
 function setToken(address _token) public { require(msg.sender == governance, "!governance"); token = IERC20(_token);
 function setController(address _controller) public { require(msg.sender == governance, "!governance"); controller = _controller;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max); // balance*min/max 保证在合约中一直有离散的代币供用户使用 return token.balanceOf(address(this)).mul(min).div(max); 
 function earn() public { uint _bal = available(); // 获取最小需要转给机枪池进行获取收益的代币个数 uint _bal = available();  token.safeTransfer(controller, _bal); // 转账给控制合约 token.safeTransfer(controller, _bal);  Controller(controller).earn(address(token), _bal); // 抵押代币给Strategy合约进行理财 Controller(controller).earn(address(token), _bal); 
 function deposit(uint amount) external {  token.safeTransferFrom(msg.sender, address(this), amount);  player_[msg.sender].stake = player_[msg.sender].stake.add(amount);  if (global_[0].earnings_per_share != 0) { player_[msg.sender].payout = player_[msg.sender].payout.add( global_[0].earnings_per_share.mul(amount).sub(1).div(magnitude).add(1) // (((earnings_per_share*amount)-1)/magnitude)+1 global_[0].earnings_per_share.mul(amount).sub(1).div(magnitude).add(1)  ); }  global_[0].total_stake = global_[0].total_stake.add(amount);  if (token.balanceOf(address(this)) > earnLowerlimit){ earn(); }  deposittime[msg.sender] = now;
 function withdraw(uint amount) external { claim(); // 首先获取当前未领取的收益 claim();  require(amount <= player_[msg.sender].stake, "!balance"); uint r = amount;  uint b = token.balanceOf(address(this)); if (b < r) { // 如果vault合约中代币余额小于用户取款的余额，则需要去Strategy合约取款获得对应的代币 if (b < r) {  uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); // 取款 Controller(controller).withdraw(address(token), _withdraw);  uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { // 策略器有可能会返回的代币变多，所以需要更新vault合约中的余额 if (_diff < _withdraw) {  r = b.add(_diff); } }  player_[msg.sender].payout = player_[msg.sender].payout.sub( global_[0].earnings_per_share.mul(amount).div(magnitude) );  player_[msg.sender].stake = player_[msg.sender].stake.sub(amount); global_[0].total_stake = global_[0].total_stake.sub(amount);  token.safeTransfer(msg.sender, r);
 function make_profit(uint256 amount) public { require(amount > 0, "not 0"); YFToken.safeTransferFrom(msg.sender, address(this), amount); // 挖矿收益存入当前合约（已扣除10%的手续费，90%的利润存进来） YFToken.safeTransferFrom(msg.sender, address(this), amount);  global_[0].earnings_per_share = global_[0].earnings_per_share.add( amount.mul(magnitude).div(global_[0].total_stake) ); global_[0].total_out = global_[0].total_out.add(amount);
 function cal_out(address user) public view returns (uint256) { uint256 _cal = global_[0].earnings_per_share.mul(player_[user].stake).div(magnitude); if (_cal < player_[user].payout) { return 0; } else { return _cal.sub(player_[user].payout); }
 function cal_out_pending(uint256 _pendingBalance,address user) public view returns (uint256) { uint256 _earnings_per_share = global_[0].earnings_per_share.add( _pendingBalance.mul(magnitude).div(global_[0].total_stake) ); uint256 _cal = _earnings_per_share.mul(player_[user].stake).div(magnitude); _cal = _cal.sub(cal_out(user)); if (_cal < player_[user].payout) { return 0; } else { return _cal.sub(player_[user].payout); }
 function claim() public { uint256 out = cal_out(msg.sender); player_[msg.sender].payout = global_[0].earnings_per_share.mul(player_[msg.sender].stake).div(magnitude); player_[msg.sender].total_out = player_[msg.sender].total_out.add(out); if (out > 0) { uint256 _depositTime = now - deposittime[msg.sender]; if (_depositTime < 1 days){ // deposit in 24h if (_depositTime < 1 days){  uint256 actually_out = _depositTime.mul(out).mul(1e18).div(1 days).div(1e18); uint256 to_team = out.sub(actually_out); YFToken.safeTransfer(Controller(controller).rewards(), to_team); out = actually_out; } YFToken.safeTransfer(msg.sender, out); }
 function JGOToken(address _ethFundDeposit, uint256 _totalSupply) { ethFundDeposit = _ethFundDeposit;  currentSupply = formatDecimals(_totalSupply); //当前供应量 currentSupply = formatDecimals(_totalSupply);  totalSupply = formatDecimals(_totalSupply);     //代币总量 totalSupply = formatDecimals(_totalSupply);      balances[msg.sender] = totalSupply; if(currentSupply > totalSupply) throw;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function pause(address[] memory pools) public onlyPauser { if (msg.sender == coreDev) { shouldPauseDev = true; } else { shouldPauseTrustee = true; } if (shouldPauseDev && shouldPauseTrustee) { systemPause = true;  boringDAO().pause();  for(uint i=0; i < pools.length; i++) { if(isSatellitePool[pools[i]] == true) { IPause(pools[i]).pause(); } } }
 function unpauseSatellitePool(address pool) public onlyTrustee { require(systemPause == true, "Liquidation::unpauseSatellitePool:systemPause should paused when call unpause()"); require(isSatellitePool[pool] == true, "Liquidation::unpauseSatellitePool:Not SatellitePool"); if(unpauseConfirm[msg.sender][pool] == false) { unpauseConfirm[msg.sender][pool] == true; } unpausePoolConfirmCount[pool] = unpausePoolConfirmCount[pool].add(1); uint trusteeCount = IHasRole(addressReso.requireAndKey2Address(BORING_DAO, "Liquidation::withdraw: boringDAO contract not exist")).getRoleMemberCount(TRUSTEE_ROLE); uint threshold = trusteeCount.mod(3) == 0 ? trusteeCount.mul(2).div(3) : trusteeCount.mul(2).div(3).add(1); if (unpausePoolConfirmCount[pool] >= threshold) { IPause(pool).unpause(); }
 function burn(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(msg.sender, _value); emit Transfer(msg.sender, address(0), _value);
 function addressburn(address _of, uint256 _value) onlyOwner public { require(_value > 0, INVALID_TOKEN_VALUES); require(_value <= balances[_of], NOT_ENOUGH_TOKENS); balances[_of] = balances[_of].sub(_value); _totalSupply = _totalSupply.sub(_value); emit AddressBurn(_of, _value); emit Transfer(_of, address(0), _value);
 function mint(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].add(_value); _totalSupply = _totalSupply.add(_value); emit Mint(msg.sender, _value); emit Transfer(address(0), msg.sender, _value);
 function getMinLockedAmount(address _addr) view public returns (uint256 locked) { uint256 i; uint256 a; uint256 t; uint256 lockSum = 0;  TokenLockState storage lockState = lockingStates[_addr]; if (lockState.latestReleaseTime < now) { return 0; } for (i=0; i<lockState.tokenLocks.length; i++) { a = lockState.tokenLocks[i].amount; t = lockState.tokenLocks[i].time; if (t > now) { lockSum = lockSum.add(a); } } return lockSum;
 function transfer(address _to, uint256 _value) onlyValidDestination(_to) canTransfer(msg.sender, _value) public returns (bool success) { return super.transfer(_to, _value);
 function transferFrom(address _from, address _to, uint256 _value) onlyValidDestination(_to) canTransfer(_from, _value) public returns (bool success) {  balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); // this will throw if we don't have enough allowance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);   emit Transfer(_from, _to, _value); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart checkhalve { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function deposit() public isFundOpen payable { require(msg.value >= buyRate, "Send at least 1000000000000 wei"); Contributor storage contributor = contributors[msg.sender]; if (contributor.amount == 0) {  totalContributors = totalContributors.add(1); contributor.timestamp = now; } totalFunds = totalFunds.add(msg.value); contributor.amount = contributor.amount.add(msg.value); adrianoToken.mint(msg.sender, msg.value.div(buyRate)); emit ContributionLog(msg.sender, msg.value, now);
 function startActiveManagement() public payable onlyManager { require(totalFunds > 0, "Fund does not have any ether");  adrianoToken.mint(fundManager, adrianoToken.totalSupply().mul(7).div(100)); isOpenForFunds = false; transferEth(fundManager, address(this).balance);
 function claim() public isFundCompleted onlyContributor isUnclaimed { require(adrianoToken.balanceOf(msg.sender) > 0, "You do not have any participation tokens in the fund"); require(!contributors[msg.sender].claimed, "You already claimed your reward"); uint amount = adrianoToken.balanceOf(msg.sender).mul(finalRate); adrianoToken.burn(msg.sender, adrianoToken.balanceOf(msg.sender)); contributors[msg.sender].claimed = true; transferEth(msg.sender, amount); emit ClaimLog(msg.sender, contributors[msg.sender].amount, amount, now);
 function supply(address _to, uint256 _amount) public onlyOwner { _supply(_to, _amount);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function __ERC20PresetMinterPauser_init_unchained() internal initializer { _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); _setupRole(MINTER_ROLE, _msgSender()); _setupRole(PAUSER_ROLE, _msgSender());
 function setOwner(address _masterChef, address _router) public onlyOwner { masterChef = _masterChef; router = _router; renounceOwnership();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function borrowExactOut(address token, uint inMax, uint outExact) external { _transfer(msg.sender, address(this), inMax);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inMax);  address[] memory _path = new address[](2); _path[0] = address(this); _path[1] = token;  uint[] memory _amounts = UNI.swapTokensForExactTokens(outExact, inMax, _path, msg.sender, now.add(1800)); _transfer(address(this), msg.sender, balanceOf(address(this)));  emit Borrow(msg.sender, token, _amounts[0], _amounts[1]);
 function borrowExactIn(address token, uint inExact, uint outMin) external { _transfer(msg.sender, address(this), inExact);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inExact);  address[] memory _path = new address[](2); _path[0] = address(this); _path[1] = token;  uint[] memory _amounts = UNI.swapExactTokensForTokens(inExact, outMin, _path, msg.sender, now.add(1800));  emit Borrow(msg.sender, token, _amounts[0], _amounts[1]);
 function repayExactOut(address token, uint inMax, uint outExact) external { IERC20(token).safeTransferFrom(msg.sender, address(this), inMax);  IERC20(token).safeApprove(address(UNI), 0); IERC20(token).safeApprove(address(UNI), inMax);  address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(this);  uint[] memory _amounts = UNI.swapTokensForExactTokens(outExact, inMax, _path, msg.sender, now.add(1800)); IERC20(token).safeTransfer(msg.sender, IERC20(token).balanceOf(address(this))); emit Repay(msg.sender, token, _amounts[1], _amounts[0]);
 function repayExactIn(address token, uint inExact, uint outMin) external { IERC20(token).safeTransferFrom(msg.sender, address(this), inExact);  IERC20(this).safeApprove(address(UNI), 0); IERC20(this).safeApprove(address(UNI), inExact);  address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(this);  uint[] memory _amounts = UNI.swapExactTokensForTokens(inExact, outMin, _path, msg.sender, now.add(1800)); emit Repay(msg.sender, token, _amounts[1], _amounts[0]);
 function _deposit(address token, uint amount) internal { uint _value = LINK.getPriceUSD(token).mul(amount).div(uint256(10)**ERC20Detailed(token).decimals()); require(_value > 0, "!value");  address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this)); if (_pair == address(0)) { _pair = UniswapFactory(UNI.factory()).createPair(token, address(this)); }  IERC20(token).safeTransferFrom(msg.sender, _pair, amount); _mint(_pair, _value); // Amount of aUSD to mint _mint(_pair, _value);   uint _before = IERC20(_pair).balanceOf(address(this)); UniswapPair(_pair).mint(address(this)); uint _after = IERC20(_pair).balanceOf(address(this));   balances[msg.sender][token] = balances[msg.sender][token].add(_after.sub(_before));     uint _credit = _value.mul(utilization(token)).div(BASE); credit[msg.sender][token] = credit[msg.sender][token].add(_credit); _mint(msg.sender, _credit);   markets[msg.sender].push(token); emit Deposit(msg.sender, token, _credit, amount, _value);
 function _withdraw(address token, uint amount) internal {  uint _credit = credit[msg.sender][token]; uint _uni = balances[msg.sender][token];  if (_credit < amount) { amount = _credit; }  _burn(msg.sender, amount); credit[msg.sender][token] = credit[msg.sender][token].sub(amount);   uint _burned = _uni.mul(amount).div(_credit);  address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this));  IERC20(_pair).safeApprove(address(UNI), 0); IERC20(_pair).safeApprove(address(UNI), _burned);  uint _before = IERC20(_pair).balanceOf(address(this)); UNI.removeLiquidity( token, address(this), _burned, 0, 0, address(this), now.add(1800) ); uint _after = IERC20(_pair).balanceOf(address(this));  _burned = _before.sub(_after); if (_burned > _uni) { _burned = _uni; }  balances[msg.sender][token] = balances[msg.sender][token].sub(_burned);  uint _amountA = IERC20(token).balanceOf(address(this)); uint _amountB = balanceOf(address(this));  _burn(address(this), _amountB); // Amount of aUSD to burn (value of A leaving the system) _burn(address(this), _amountB);   IERC20(token).safeTransfer(msg.sender, _amountA); emit Withdraw(msg.sender, token, amount, _amountB, _amountA);
 function _utilization(address token, uint amount) internal view returns (uint) { address _pair = UniswapFactory(UNI.factory()).getPair(token, address(this)); uint _ratio = BASE.sub(BASE.mul(balanceOf(_pair).add(amount)).div(totalSupply())); if (_ratio == 0) { return MAX; } return  _ratio > MAX ? MAX : _ratio;
 function getRewardPerBlock() public view returns(uint256) { return YFMBToken.balanceOf(rewardPool).div(6500).div(10000).mul(dailyReward);
 function setDailyReward(uint256 _dailyReward) public onlyOwner { dailyReward = _dailyReward;
 function getUserBalance(address _staker) public view returns(uint256 _amountStaked) { return userDetails[_staker]._LPDeposited;
 function pendingRewards(address _staker) public view returns(uint256) { User storage user = userDetails[_staker]; uint256 _accYFMBPerShare = accYFMBPerShare; if (block.number > lastRewardBlock && totalStaked != 0) { uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 lucoReward = blocksToReward.mul(getRewardPerBlock()); _accYFMBPerShare = _accYFMBPerShare.add(lucoReward.mul(1e18).div(totalStaked)); } return user._LPDeposited.mul(_accYFMBPerShare).div(1e18).sub(user._rewardDebt);
 function updatePool() public { if (block.number <= lastRewardBlock) { return; } if (totalStaked == 0) { lastRewardBlock = block.number; return; } uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 lucoReward = blocksToReward.mul(getRewardPerBlock()); YFMBToken.transferFrom(rewardPool, address(this), lucoReward); accYFMBPerShare = accYFMBPerShare.add(lucoReward.mul(1e18).div(totalStaked)); lastRewardBlock = block.number; emit PoolUpdated(blocksToReward, lucoReward, now);
 function stakeLP(uint256 _amount) public { require(emergencyWithdraw == false, "emergency withdraw is on, cannot stake"); require(_amount > 0, "Can not stake 0 LP tokens"); require(LPToken.balanceOf(_msgSender()) >= _amount, "Do not have enough LP tokens to stake"); updatePool(); User storage user = userDetails[_msgSender()]; if(user._LPDeposited > 0) { uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); if(_pendingRewards > 0) { YFMBToken.transfer(_msgSender(), _pendingRewards); emit RewardsClaimed(_msgSender(), _pendingRewards, now); } } LPToken.transferFrom(_msgSender(), address(this), _amount); user._LPDeposited = user._LPDeposited.add(_amount); totalStaked = totalStaked.add(_amount); user._rewardDebt = user._LPDeposited.mul(accYFMBPerShare).div(1e18); emit StakeCompleted(_msgSender(), _amount, user._LPDeposited, now);
 function claimRewards() public { updatePool(); User storage user = userDetails[_msgSender()]; uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); require(_pendingRewards > 0, "No rewards to claim!"); YFMBToken.transfer(_msgSender(), _pendingRewards); user._rewardDebt = user._LPDeposited.mul(accYFMBPerShare).div(1e18); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function unstakeLP() public { require(emergencyWithdraw == true, "Can not withdraw"); updatePool(); User storage user = userDetails[_msgSender()]; require(user._LPDeposited > 0, "User has no stake"); uint256 _pendingRewards = user._LPDeposited.mul(accYFMBPerShare).div(1e18).sub(user._rewardDebt); uint256 beingWithdrawn = user._LPDeposited; user._LPDeposited = 0; user._rewardDebt = 0; totalStaked = totalStaked.sub(beingWithdrawn); LPToken.transfer(_msgSender(), beingWithdrawn); YFMBToken.transfer(_msgSender(), _pendingRewards); emit WithdrawCompleted(_msgSender(), beingWithdrawn, now); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function turnEmergencyWithdrawOn() public onlyOwner() { require(emergencyWithdraw == false, "emergency withdrawing already allowed"); emergencyWithdraw = true; emit EmergencyWithdrawOn(_msgSender(), emergencyWithdraw, now);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeTreasury(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 2; _timelock_address = _address;
 function startChangeDepositorPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 3; _timelock_data_1 = _percent;
 function startChangeStakingPool(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 4; _timelock_address = _address;
 function startChangeZSToken(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 5; _timelock_address = _address;
 function startChangeStakersPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 6; _timelock_data_1 = _percent;
 function govAllow() public onlyOwner { require( isAllow == false, "Already allowed"); isAllow = true;
 function setOpenPeriod(uint256 _newStart, uint256 _newEnd) public onlyOwner { openPeriod[0] = _newStart; openPeriod[1] = _newEnd;
 function setBlocksBetween(uint256 _newValue) public onlyOwner { blocksBetween = _newValue;
 function enter(uint256 _amount) public validateGrassland { uint256 totalERC20 = erc20.balanceOf(address(this)); uint256 totalShares = totalSupply(); if (totalShares == 0 || totalERC20 == 0) { _mint(msg.sender, _amount); } else { uint256 what = _amount.mul(totalShares).div(totalERC20); _mint(msg.sender, what); } erc20.transferFrom(msg.sender, address(this), _amount); emit Joined(msg.sender, _amount);
 function leave(uint256 _share) public validateGrassland { uint256 totalShares = totalSupply(); uint256 what = _share.mul(erc20.balanceOf(address(this))).div(totalShares); _burn(msg.sender, _share); erc20.transfer(msg.sender, what); emit Left(msg.sender, what);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function tokenFallback(address from, uint value, bytes calldata _data) external{ address TOKEN = msg.sender; if( TOKEN == address(colorToken) ){  (uint r, uint g, uint b) = colorToken.RGB_Ratio(THIS); if( value > lifeForce && colorMatch(r,g,b) ){ carpetKing = from; lifeForce = value; } this.burnRugs(THIS,0); }else if(TOKEN == address( PiZZa )){ (uint r, uint g, uint b) = PiZZa.RGB_Ratio(THIS); if( colorMatch(r,g,b) ){ ageOfPiZZa = PiZZa.average_buyInTimeSum(THIS) / PiZZa.average_ethSpent(THIS); PiZZa.transfer( lampAddress, PiZZa.balanceOf(THIS), abi.encodePacked( from ) ); }else{ revert(); } }else if( magicLamp.ofRug(TOKEN) && TOKEN != THIS){ require(value>0); RugToken(TOKEN).transfer( lampAddress, magicLamp.rugsOf(THIS,TOKEN), abi.encodePacked( from ) ); }else{ revert(); }
 function transfer(address _to, uint _value) public virtual returns (bool) {   bytes memory empty; if(isContract(_to)){ return transferToContract(_to, _value, empty); }else{ return transferToAddress(_to, _value); }
 function transferToAddress(address _to, uint _value) private returns (bool) { moveTokens(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value); return true;
 function transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) { moveTokens(msg.sender, _to, _value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function deposit(uint256 amount) public { uint256 total = valueOfVaultAndStrategy(); // Get token equivalent at strategy and here if applicable uint256 total = valueOfVaultAndStrategy();   require(depositsOpen == true, "Deposits have been suspended, but you can still withdraw"); require(currentStrategy != StabilizeStrategy(address(0)),"No strategy contract has been selected yet"); uint256 _before = _underlyingAsset.balanceOf(address(this)); _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount); // Transfer token to this address _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount);  amount = _underlyingAsset.balanceOf(address(this)).sub(_before); // Some tokens lose amount (transfer fee) upon transfer amount = _underlyingAsset.balanceOf(address(this)).sub(_before);  require(amount > 0, "Cannot deposit 0");  uint256 _strategyBalance = currentStrategy.balance(); // Will get the balance of the value of the main tokens at the strategy uint256 _strategyBalance = currentStrategy.balance();   _underlyingAsset.safeTransfer(address(currentStrategy), amount); // Transfer again into the strategy _underlyingAsset.safeTransfer(address(currentStrategy), amount);  currentStrategy.deposit(_msgSender()); // Activate strategy deposit currentStrategy.deposit(_msgSender());  require(currentStrategy.balance() > _strategyBalance, "No change in strategy balance"); // Balance should increase require(currentStrategy.balance() > _strategyBalance, "No change in strategy balance");  uint256 mintAmount = amount; if(totalSupply() > 0){  mintAmount = amount.mul(totalSupply()).div(total); // Our share of the total mintAmount = amount.mul(totalSupply()).div(total);  } _mint(_msgSender(),mintAmount); // Now mint new zs-token to the depositor _mint(_msgSender(),mintAmount);  emit Wrapped(_msgSender(), amount);
 function stopDeposits() external onlyGovernance { depositsOpen = false;
 function emergencyStopStrategy() external onlyGovernance { depositsOpen = false; if(currentStrategy != StabilizeStrategy(address(0)) && totalSupply() > 0){ currentStrategy.exit(); // Pulls all the tokens and accessory tokens from the strategy currentStrategy.exit();  } currentStrategy = StabilizeStrategy(address(0)); _timelockType = 0; // Prevent governance from changing to new strategy without timelock _timelockType = 0; 
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeStrategy(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 2; _timelock_address = _address; _pendingStrategy = _address; if(totalSupply() == 0){  finishChangeStrategy(); }
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function burn(uint256 _amount) public { _burn(msg.sender, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accChannelPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingChannel(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accChannelPerShare = pool.accChannelPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 channelReward = multiplier.mul(channelPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accChannelPerShare = accChannelPerShare.add(channelReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accChannelPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { if (channel.totalSupply() < maxChannelSupply){ PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 channelReward = multiplier.mul(channelPerBlock).mul(pool.allocPoint).div(totalAllocPoint); channel.mint(devaddr, channelReward.div(10)); channel.mint(address(this), channelReward); pool.accChannelPerShare = pool.accChannelPerShare.add(channelReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number; }
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accChannelPerShare).div(1e12).sub(user.rewardDebt); safeChannelTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accChannelPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accChannelPerShare).div(1e12).sub(user.rewardDebt); safeChannelTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accChannelPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeChannelTransfer(address _to, uint256 _amount) internal { uint256 channelBal = channel.balanceOf(address(this)); if (channel.totalSupply() >= maxChannelSupply){ return; } if (_amount > channelBal) { channel.transfer(_to, channelBal); } else { channel.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function setChannelPerBlock(uint256 _channelPerBlock) public onlyOwner { massUpdatePools(); channelPerBlock = _channelPerBlock;
 function setMaxChannelSupply(uint256 _maxChannelSupply) public onlyOwner { massUpdatePools(); require(channel.totalSupply() < _maxChannelSupply, "setMaxChannelSupply: less than current OCT supply"); maxChannelSupply = _maxChannelSupply;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function updateUserDistributionRule(uint256 _pid, uint256[] memory _percentArray, uint256[] memory _daysArray) external { require(_percentArray.length == _daysArray.length, "LM"); // LENGTH MISMATCH require(_percentArray.length == _daysArray.length, "LM");  _checkUpdateAllowed(_pid); require(_checkSumArray(_percentArray), "SE"); // SUM OF PERCENT INVALID require(_checkSumArray(_percentArray), "SE");  require(_checkValidDaysArray(_daysArray), "DMI"); // DAYS SHOULD BE MONOTONIICALLY INCREASING require(_checkValidDaysArray(_daysArray), "DMI");  userDistInfo[_pid] = DistributionInfo({ percentArray: _percentArray, daysArray: _daysArray });
 function updateOwnerDistributionRule(uint256 _pid, uint256[] memory _percentArray, uint256[] memory _daysArray) external { require(_percentArray.length == _daysArray.length, "LM"); // LENGTH MISMATCH require(_percentArray.length == _daysArray.length, "LM");  _checkUpdateAllowed(_pid); require(_checkSumArray(_percentArray), "SE"); // SUM OF PERCENT INVALID require(_checkSumArray(_percentArray), "SE");  require(_checkValidDaysArray(_daysArray), "DMI"); // DAYS SHOULD BE MONOTONIICALLY INCREASING require(_checkValidDaysArray(_daysArray), "DMI");  ownerDistInfo[_pid] = DistributionInfo({ percentArray: _percentArray, daysArray: _daysArray });
 function lockPool(uint256 _pid) external { require(poolInfo[_pid].paymentMethodAdded==true, "CP"); // CHECK PAYMENT METHOD FAILED require(poolInfo[_pid].paymentMethodAdded==true, "CP");  _checkUpdateAllowed(_pid); poolInfo[_pid].updateLocked = true;
 function addSupportedCurrencies(uint256 _pid, address _tokenRaise, uint256 rateToken) external { _checkUpdateAllowed(_pid); require(rateToken!=0, "IR"); // INVALID RATE require(rateToken!=0, "IR");  require(_tokenRaise!=address(poolInfo[_pid].raiseToken), "IT"); // INVALIID PURCHASE TOKEN require(_tokenRaise!=address(poolInfo[_pid].raiseToken), "IT");  if(saleRateInfo[_pid][_tokenRaise] == 0){ listSupportedCurrencies[_pid].push(_tokenRaise); } saleRateInfo[_pid][_tokenRaise] = rateToken; poolInfo[_pid].paymentMethodAdded = true;
 function _checkDepositAllowed(uint256 _pid, address _tokenAdd, uint256 _amt) internal view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; uint256 userBought = userTokenAllocation[_pid][_msgSender()]; uint256 purchasePossible = tokensPurchaseAmt(_pid, _tokenAdd, _amt); require(pool.balanceAdded == true, "NA"); // NOT AVAILABLE require(pool.balanceAdded == true, "NA");  require(pool.startBlock <= block.number, "NT1"); // NOT AVAILABLE TIME 1 require(pool.startBlock <= block.number, "NT1");  require(pool.endBlock >= block.number, "NT2"); // NOT AVAILABLE TIME 2 require(pool.endBlock >= block.number, "NT2");  require(pool.totalTokensSold.add(purchasePossible) <= pool.totalTokensOnSale, "PLE"); // POOL LIMIT EXCEEDED require(pool.totalTokensSold.add(purchasePossible) <= pool.totalTokensOnSale, "PLE");  require(userBought.add(purchasePossible) <= pool.maxTokensPerPerson, "ILE"); // INDIVIDUAL LIMIT EXCEEDED require(userBought.add(purchasePossible) <= pool.maxTokensPerPerson, "ILE");  return purchasePossible;
 function getMaxDepositAllowed(uint256 _pid, address _tokenAdd, address _user) external view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; uint256 maxBuyPossible = (pool.maxTokensPerPerson).sub(userTokenAllocation[_pid][_user]); uint256 maxBuyPossiblePoolLimit = (pool.totalTokensOnSale).sub(pool.totalTokensSold); if(maxBuyPossiblePoolLimit < maxBuyPossible){ maxBuyPossible = maxBuyPossiblePoolLimit; } if(block.number >= pool.startBlock && block.number <= pool.endBlock && pool.balanceAdded == true){ uint256 rateToken = saleRateInfo[_pid][_tokenAdd]; return (maxBuyPossible.mul(rateToken).div(1e18)); } else { return 0; }
 function checkDepositEnabled(uint256 _pid) external view returns (bool){ RaisePoolInfo storage pool = poolInfo[_pid]; if(pool.balanceAdded == true && pool.startBlock <= block.number && pool.endBlock >= block.number && pool.totalTokensSold <= pool.totalTokensOnSale && pool.paymentMethodAdded==true){ return true; } else { return false; }
 function depositICOTokens(uint256 _pid, uint256 _amount, IERC20 _tokenAdd) external { RaisePoolInfo storage pool = poolInfo[_pid]; address msgSender = _msgSender(); require(_tokenAdd == pool.raiseToken, "NOT"); // NOT VALID TOKEN require(_tokenAdd == pool.raiseToken, "NOT");  require(msgSender == pool.owner, "NAU"); // NOT AUTHORISED USER require(msgSender == pool.owner, "NAU");  require(block.number < pool.endBlock, "NT"); // No point adding tokens after sale has ended - Possible deadlock case require(block.number < pool.endBlock, "NT");  _tokenAdd.safeTransferFrom(msgSender, address(this), _amount); pool.tokensDeposited = (pool.tokensDeposited).add(_amount); if(pool.tokensDeposited >= pool.totalTokensOnSale){ pool.balanceAdded = true; } emit Deposit(msgSender, _pid, _amount);
 function depositAirdropTokens(uint256 _pid, uint256 _amount, IERC20 _tokenAdd) external { RaisePoolInfo storage pool = poolInfo[_pid]; require(block.number < pool.endBlock, "NT"); // NOT VALID TIME require(block.number < pool.endBlock, "NT");  AirdropPoolInfo storage airdrop = airdropInfo[_pid]; require((_tokenAdd == airdrop.airdropToken || airdrop.airdropExists==false), "NOT"); // NOT VALID TOKEN require((_tokenAdd == airdrop.airdropToken || airdrop.airdropExists==false), "NOT");  require(_msgSender() == pool.owner || _msgSender() == devaddr , "NAU"); // NOT AUTHORISED USER require(_msgSender() == pool.owner || _msgSender() == devaddr , "NAU");  _tokenAdd.safeTransferFrom(_msgSender(), address(this), _amount); airdrop.totalTokensAvailable = (airdrop.totalTokensAvailable).add(_amount); if(!airdrop.airdropExists){ airdrop.airdropToken = _tokenAdd; airdrop.airdropExists = true; } emit AirdropDeposit(_msgSender(), address(_tokenAdd), _pid, _amount);
 function withdrawExtraAirdropTokens(uint256 _pid) external { require(extraAirdropClaimed[_pid]==false, "NA"); // NOT AVAILABLE require(extraAirdropClaimed[_pid]==false, "NA");  RaisePoolInfo storage pool = poolInfo[_pid]; require(block.number > pool.endBlock, "NSE"); // SALE NOT ENDED require(block.number > pool.endBlock, "NSE");  address msgSender = _msgSender(); require(msgSender == pool.owner, "NAU"); //  NOT AUTHORISED USER require(msgSender == pool.owner, "NAU");  uint256 extraTokens = calculateExtraAirdropTokens(_pid); require(extraTokens!=0, "NAT"); // NOT AVAILABLE TOKEN require(extraTokens!=0, "NAT");  extraAirdropClaimed[_pid] = true; airdropInfo[_pid].airdropToken.safeTransfer(msgSender, extraTokens); emit AirdropExtraWithdraw(msg.sender, address(airdropInfo[_pid].airdropToken), _pid, extraTokens);
 function stakeLPTokens(uint256 _pid, uint256 _amount, IERC20 _lpAdd) external { require(stakingEnabled[address(_lpAdd)]==true, "NST"); // NOT STAKING TOKEN require(stakingEnabled[address(_lpAdd)]==true, "NST");  RaisePoolInfo storage pool = poolInfo[_pid]; require(block.number < pool.startBlock, "NT"); // NOT VALID TIME require(block.number < pool.startBlock, "NT");  address msgSender = _msgSender(); _lpAdd.safeTransferFrom(msgSender, address(this), _amount); stakedLPTokensInfo[_pid][address(_lpAdd)] = (stakedLPTokensInfo[_pid][address(_lpAdd)]).add(_amount); userStakeInfo[_pid][msgSender][address(_lpAdd)] = (userStakeInfo[_pid][msgSender][address(_lpAdd)]).add(_amount); emit Stake(msg.sender, address(_lpAdd), _pid, _amount);
 function withdrawLPTokens(uint256 _pid, uint256 _amount, IERC20 _lpAdd) external { require(stakingEnabled[address(_lpAdd)]==true, "NAT"); // NOT AUTHORISED TOKEN require(stakingEnabled[address(_lpAdd)]==true, "NAT");  RaisePoolInfo storage pool = poolInfo[_pid]; require(block.number > pool.endBlock, "SE"); // SALE NOT ENDED require(block.number > pool.endBlock, "SE");  address msgSender = _msgSender(); claimRewardAndAirdrop(_pid); userStakeInfo[_pid][msgSender][address(_lpAdd)] = (userStakeInfo[_pid][msgSender][address(_lpAdd)]).sub(_amount); _lpAdd.safeTransfer(msgSender, _amount); emit UnStake(msg.sender, address(_lpAdd), _pid, _amount);
 function withdrawAirdropTokens(IERC20 _token, uint256 _amount) external { address msgSender = _msgSender(); airdropBalances[address(_token)][msgSender] = (airdropBalances[address(_token)][msgSender]).sub(_amount); _token.safeTransfer(msgSender, _amount); emit WithdrawAirdrop(msgSender, address(_token), _amount);
 function moveLPTokens(uint256 _pid, uint256 _newpid, uint256 _amount, address _lpAdd) external { require(stakingEnabled[_lpAdd]==true, "NAT1"); // NOT AUTHORISED TOKEN 1 require(stakingEnabled[_lpAdd]==true, "NAT1");  RaisePoolInfo storage poolOld = poolInfo[_pid]; RaisePoolInfo storage poolNew = poolInfo[_newpid]; require(block.number > poolOld.endBlock, "NUA"); // OLD SALE NOT ENDED require(block.number > poolOld.endBlock, "NUA");  require(block.number < poolNew.startBlock, "NSA"); // SALE START CHECK FAILED require(block.number < poolNew.startBlock, "NSA");  address msgSender = _msgSender(); claimRewardAndAirdrop(_pid); userStakeInfo[_pid][msgSender][_lpAdd] = (userStakeInfo[_pid][msgSender][_lpAdd]).sub(_amount); userStakeInfo[_newpid][msgSender][_lpAdd] = (userStakeInfo[_newpid][msgSender][_lpAdd]).add(_amount); emit MoveStake(msg.sender, _lpAdd, _pid, _newpid, _amount);
 function depositReserveICOTokens(uint256 _pid, uint256 _amount, IERC20 _tokenAdd, address _resAdd) external { RaisePoolInfo storage pool = poolInfo[_pid]; UseCasePoolInfo storage poolU = useCaseInfo[_pid][_resAdd]; address msgSender = _msgSender(); require(_tokenAdd == pool.raiseToken, "NOT"); // NOT AUTHORISED TOKEN require(_tokenAdd == pool.raiseToken, "NOT");  require(msgSender == pool.owner, "NAU"); // NOT AUTHORISED USER require(msgSender == pool.owner, "NAU");  require(poolU.tokensDeposited == false, "DR"); // TOKENS NOT DEPOSITED require(poolU.tokensDeposited == false, "DR");  require(poolU.tokensAllocated == _amount && _amount!=0, "NA"); // NOT AVAILABLE require(poolU.tokensAllocated == _amount && _amount!=0, "NA");  require(block.number < pool.endBlock, "CRN"); // CANNOT_RESERVE_NOW to avoid deadlocks require(block.number < pool.endBlock, "CRN");  _tokenAdd.safeTransferFrom(msgSender, address(this), _amount); totalTokenReserved[_pid] = (totalTokenReserved[_pid]).add(_amount); poolU.tokensDeposited = true; emit Deposit(msg.sender, _pid, _amount);
 function withdrawExtraICOTokens(uint256 _pid, uint256 _amount, IERC20 _tokenAdd) external { RaisePoolInfo storage pool = poolInfo[_pid]; address msgSender = _msgSender(); require(_tokenAdd == pool.raiseToken, "NT"); // NOT AUTHORISED TOKEN require(_tokenAdd == pool.raiseToken, "NT");  require(msgSender == pool.owner, "NAU"); // NOT AUTHORISED USER require(msgSender == pool.owner, "NAU");  require(block.number > pool.endBlock, "NA"); // NOT AVAILABLE TIME require(block.number > pool.endBlock, "NA");  uint256 _amtAvail = pool.tokensDeposited.sub(pool.totalTokensSold); require(_amtAvail >= _amount, "NAT"); // NOT AVAILABLE TOKEN require(_amtAvail >= _amount, "NAT");  pool.tokensDeposited = (pool.tokensDeposited).sub(_amount); _tokenAdd.safeTransfer(msgSender, _amount); emit Withdraw(msgSender, _pid, _amount);
 function fetchExtraICOTokens(uint256 _pid) external view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; return pool.tokensDeposited.sub(pool.totalTokensSold);
 function deposit(uint256 _pid, uint256 _amount, IERC20 _tokenAdd) external { address msgSender = _msgSender(); uint256 _buyThisStep = _checkDepositAllowed(_pid, address(_tokenAdd), _amount);  _tokenAdd.safeTransferFrom(msgSender, address(this), _amount); userDepositInfo[_pid][msgSender][address(_tokenAdd)] = userDepositInfo[_pid][msgSender][address(_tokenAdd)].add(_amount); userTokenAllocation[_pid][msgSender] = userTokenAllocation[_pid][msgSender].add(_buyThisStep); poolInfo[_pid].totalTokensSold = poolInfo[_pid].totalTokensSold.add(_buyThisStep); fundsRaisedSoFar[_pid][address(_tokenAdd)] = fundsRaisedSoFar[_pid][address(_tokenAdd)].add(_amount); emit Deposit(msg.sender, _pid, _amount);
 function voteProject(uint256 _pid) external { address msgSender = _msgSender(); require(userVotes[_pid][msgSender]==false,"AVO"); // ALREADY VOTED require(userVotes[_pid][msgSender]==false,"AVO");  require(poolInfo[_pid].endBlock >= block.number,"CVO"); // CANNOT VOTE NOW require(poolInfo[_pid].endBlock >= block.number,"CVO");  userVotes[_pid][msgSender] = true; poolInfo[_pid].votes = (poolInfo[_pid].votes).add(1); emit Voted(msgSender, _pid);
 function amountAvailToWithdrawUser(uint256 _pid, address _user) public view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; if(pool.endBlock < block.number){ uint256 percentAvail = _getPercentAvailable(_pid, pool.endBlock); return ((percentAvail).mul(userTokenAllocation[_pid][_user]).div(10000)).sub(userTokenClaimed[_pid][_user]); } else { return 0; }
 function withdrawUser(uint256 _pid, uint256 _amount) external { RaisePoolInfo storage pool = poolInfo[_pid]; address msgSender = _msgSender(); uint256 _amtAvail = amountAvailToWithdrawUser(_pid, msgSender); require(_amtAvail >= _amount, "NAT"); // NOT AUTHORISED TOKEN require(_amtAvail >= _amount, "NAT");  userTokenClaimed[_pid][msgSender] = userTokenClaimed[_pid][msgSender].add(_amount); totalTokenClaimed[_pid] = totalTokenClaimed[_pid].add(_amount); pool.raiseToken.safeTransfer(msgSender, _amount); emit Withdraw(msgSender, _pid, _amount);
 function amountAvailToWithdrawFundRaiser(uint256 _pid, IERC20 _tokenAdd) public view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; if(pool.endBlock < block.number){ uint256 percentAvail = _getPercentAvailableFundRaiser(_pid, pool.endBlock); return (((percentAvail).mul(fundsRaisedSoFar[_pid][address(_tokenAdd)]).div(10000))).sub(fundsClaimedSoFar[_pid][address(_tokenAdd)]); } else { return 0; }
 function amountAvailToWithdrawReserve(uint256 _pid, address _resAdd) public view returns (uint256){ RaisePoolInfo storage pool = poolInfo[_pid]; UseCasePoolInfo storage poolU = useCaseInfo[_pid][_resAdd]; if(pool.endBlock < block.number){ uint256 percentAvail = _getPercentAvailableReserve(_pid, pool.endBlock, _resAdd); return ((percentAvail).mul(poolU.tokensAllocated).div(10000)).sub(poolU.tokensClaimed); } else { return 0; }
 function withdrawReserveICOTokens(uint256 _pid, uint256 _amount, IERC20 _tokenAdd) external { UseCasePoolInfo storage poolU = useCaseInfo[_pid][_msgSender()]; require(poolU.reserveAdd == _msgSender(), "NAUTH"); // NOT AUTHORISED USER require(poolU.reserveAdd == _msgSender(), "NAUTH");  require(_tokenAdd == poolInfo[_pid].raiseToken, "NT"); // NOT AUTHORISED TOKEN require(_tokenAdd == poolInfo[_pid].raiseToken, "NT");  uint256 _amtAvail = amountAvailToWithdrawReserve(_pid, _msgSender()); require(_amtAvail >= _amount, "NAT"); // NOT AVAILABLE USER require(_amtAvail >= _amount, "NAT");  poolU.tokensClaimed = poolU.tokensClaimed.add(_amount); totalTokenReserved[_pid] = totalTokenReserved[_pid].sub(_amount); totalReservedTokenClaimed[_pid] = totalReservedTokenClaimed[_pid].add(_amount); _tokenAdd.safeTransfer(_msgSender(), _amount); emit Withdraw(_msgSender(), _pid, _amount);
 function withdrawFundRaiser(uint256 _pid, uint256 _amount, IERC20 _tokenAddress) external { RaisePoolInfo storage pool = poolInfo[_pid]; require(pool.owner == _msgSender(), "NAUTH"); // NOT AUTHORISED USER require(pool.owner == _msgSender(), "NAUTH");  uint256 _amtAvail = amountAvailToWithdrawFundRaiser(_pid, _tokenAddress); require(_amtAvail >= _amount, "NAT"); // NOT AUTHORISED TOKEN require(_amtAvail >= _amount, "NAT");  uint256 _fee = ((_amount).mul(fee)).div(1e4); uint256 _actualTransfer = _amtAvail.sub(_fee); uint256 _feeDev = (_fee).mul(10000 - rewardPer).div(1e4); // Remaining tokens for reward mining uint256 _feeDev = (_fee).mul(10000 - rewardPer).div(1e4);  fundsClaimedSoFar[_pid][address(_tokenAddress)] = fundsClaimedSoFar[_pid][address(_tokenAddress)].add(_amount); _tokenAddress.safeTransfer(_msgSender(), _actualTransfer); _tokenAddress.safeTransfer(devaddr, _feeDev); emit Withdraw(_msgSender(), _pid, _actualTransfer); emit Withdraw(devaddr, _pid, _feeDev);
 function changeDev(address _newowner) external onlyAdmin { potentialAdmin = _newowner;
 function changePoolOwner(uint256 _pid, address _newowner) external { require(_msgSender()==poolInfo[_pid].owner, "OA"); // NOT AUTHORISED USER require(_msgSender()==poolInfo[_pid].owner, "OA");  tempAdmin[_pid] = _newowner;
 function becomePoolOwner(uint256 _pid) external { if (tempAdmin[_pid] == _msgSender()) poolInfo[_pid].owner = _msgSender();
 function changeFee(uint256 _fee) external onlyAdmin{ require(_fee <= 300, "MAX3"); // MAX FEE POSSIBLE require(_fee <= 300, "MAX3");  fee = _fee;
 function generateNewCode(address _token, address _poolOwner) external onlyAdminOrTimeLock returns (uint256) { uint256 inviteCode = block.number; inviteCodeList[inviteCode][_token][_poolOwner] = true; return inviteCode;
 function invalidateOldCode(uint256 _inviteCode, address _token, address _poolOwner) external onlyAdmin { inviteCodeList[_inviteCode][_token][_poolOwner] = false;
 function addStakingPool(address _token, uint256 _weight) external onlyAdmin { if(stakingEnabled[_token]==false){ stakingPools.push(_token); stakingEnabled[_token] = true; } totalStakeWeight = totalStakeWeight.sub(stakingWeight[_token]).add(_weight); stakingWeight[_token] = _weight;
 function transfer(address to, uint value) public override returns (bool success) { _transfer(msg.sender, to, value); return true;
 function approve(address spender, uint value) public override returns (bool success) { allowance[msg.sender][spender] = value; emit Approval(msg.sender, spender, value); return true;
 function transferFrom(address from, address to, uint value) public override returns (bool success) { require(value <= allowance[from][msg.sender], 'Must not send more than allowance'); allowance[from][msg.sender] -= value; _transfer(from, to, value); return true;
 function _transfer(address _from, address _to, uint _value) private {  messagesender = msg.sender; //this is the person actually making the call on this function messagesender = msg.sender;    require(balanceOf[_from] >= _value, 'Must not send more than balance'); require(balanceOf[_to] + _value >= balanceOf[_to], 'Balance overflow');  balanceOf[_from] -= _value; if(Address_Whitelisted[msg.sender]){ //if the person making the transaction is whitelisted, the no burn on the transaction if(Address_Whitelisted[msg.sender]){   actualValue = _value;  }else{  bpValue = mulDiv(_value, 15, 10000); //this is 0.15% for basis point bpValue = mulDiv(_value, 15, 10000);  actualValue = _value - bpValue; //this is the amount to be sent actualValue = _value - bpValue;   balanceOf[address(this)] += bpValue; //this is adding the basis point charged to this contract balanceOf[address(this)] += bpValue;  emit Transfer(_from, address(this), bpValue);  BPE += bpValue; //this is increasing the virtual basis point amount BPE += bpValue;  emit BasisPointAdded(bpValue);   }  if(emission_Whitelisted[messagesender] == false){ //this is so that staking and unstaking will not trigger the emission if(emission_Whitelisted[messagesender] == false){   if(now >= nextDayTime){  amountToEmit = emittingAmount();  pool1Amount = mulDiv(amountToEmit, pool1percentage, 10000); pool2Amount = mulDiv(amountToEmit, pool2percentage, 10000); pool3Amount = mulDiv(amountToEmit, pool3percentage, 10000); pool4Amount = mulDiv(amountToEmit, pool4percentage, 10000);   poolAmountTrig = mulDiv(amountToEmit, trigRewardpercentage, 10000); TrigAmount = poolAmountTrig.div(2);  pool1Amount = pool1Amount.sub(TrigAmount); pool2Amount = pool2Amount.sub(TrigAmount);  TrigReward = poolAmountTrig;  uint Ofrozenamount = ospfrozen(); uint Dfrozenamount = dspfrozen(); uint Ufrozenamount = uspfrozen(); uint Afrozenamount = aspfrozen();  if(Ofrozenamount > 0){  OSP(OraclePool).scaledToken(pool4Amount); balanceOf[OraclePool] += pool4Amount; emit Transfer(address(this), OraclePool, pool4Amount);    }else{  balanceOf[address(this)] += pool4Amount; emit Transfer(address(this), address(this), pool4Amount);  BPE += pool4Amount;  }  if(Dfrozenamount > 0){  DSP(DefiPool).scaledToken(pool3Amount); balanceOf[DefiPool] += pool3Amount; emit Transfer(address(this), DefiPool, pool3Amount);    }else{  balanceOf[address(this)] += pool3Amount; emit Transfer(address(this), address(this), pool3Amount); BPE += pool3Amount;  }  if(Ufrozenamount > 0){  USP(swapPool).scaledToken(pool2Amount); balanceOf[swapPool] += pool2Amount; emit Transfer(address(this), swapPool, pool2Amount);   }else{  balanceOf[address(this)] += pool2Amount; emit Transfer(address(this), address(this), pool2Amount); BPE += pool2Amount;  }  if(Afrozenamount > 0){  ASP(lonePool).scaledToken(pool1Amount); balanceOf[lonePool] += pool1Amount; emit Transfer(address(this), lonePool, pool1Amount);  }else{  balanceOf[address(this)] += pool1Amount; emit Transfer(address(this), address(this), pool1Amount); BPE += pool1Amount;  }  nextDayTime += secondsPerDay; currentDay += 1; emit NewDay(currentEpoch, currentDay, nextDayTime);   balanceOf[_from] += TrigReward; //this is rewardig the person that triggered the emission balanceOf[_from] += TrigReward;  emit Transfer(address(this), _from, TrigReward); emit TrigRewardEvent(address(this), msg.sender, TrigReward);  }   }  balanceOf[_to] += actualValue; emit Transfer(_from, _to, actualValue);
 function() public payable { emit Funded(address(this).balance);
 function getOwners() public constant returns (address[]) { return owners;
 function generateMessageToSign(address erc20Contract, address destination, uint256 value) public constant returns (bytes32) { require(destination != address(this));  bytes32 message = keccak256(this, erc20Contract, destination, value, spendNonce); return message;
 function spendERC20(address destination, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public {     require(_validSignature(erc20contract, destination, value, vs, rs, ss)); spendNonce = spendNonce + 1;  Erc20(erc20contract).transfer(destination, value); emit SpentErc20(erc20contract, destination, value);
 function compoundAction(address cErc20Contract, address erc20contract, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) public { CEth ethToken; CErc20 erc20Token;  if (erc20contract == 0x0000000000000000000000000000000000000001) { require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;   ethToken = CEth(cErc20Contract); ethToken.mint.value(value).gas(250000)(); } else if (erc20contract == 0x0000000000000000000000000000000000000003) { require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;   ethToken = CEth(cErc20Contract); ethToken.redeem(value); } else if (erc20contract == 0x0000000000000000000000000000000000000004) { require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;   erc20Token = CErc20(cErc20Contract); erc20Token.redeem(value); } else if (erc20contract == 0x0000000000000000000000000000000000000005) { require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;   ethToken = CEth(cErc20Contract); ethToken.redeemUnderlying(value); } else if (erc20contract == 0x0000000000000000000000000000000000000006) { require(_validSignature(erc20contract, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;   erc20Token = CErc20(cErc20Contract); erc20Token.redeemUnderlying(value); } else {  require(_validSignature(0x0000000000000000000000000000000000000002, cErc20Contract, value, vs, rs, ss)); spendNonce = spendNonce + 1;    Erc20 underlying = Erc20(erc20contract);  erc20Token = CErc20(cErc20Contract);  underlying.approve(cErc20Contract, value);  erc20Token.mint(value); }
 function _validSignature(address erc20Contract, address destination, uint256 value, uint8[] vs, bytes32[] rs, bytes32[] ss) private constant returns (bool) { require(vs.length == rs.length); require(rs.length == ss.length); require(vs.length <= owners.length); require(vs.length >= required); bytes32 message = _messageToRecover(erc20Contract, destination, value); address[] memory addrs = new address[](vs.length); for (uint i=0; i<vs.length; i++) {  addrs[i] = ecrecover(message, vs[i]+27, rs[i], ss[i]); } require(_distinctOwners(addrs)); return true;
 function _distinctOwners(address[] addrs) private constant returns (bool) { if (addrs.length > owners.length) { return false; } for (uint i = 0; i < addrs.length; i++) { if (!isOwner[addrs[i]]) { return false; }  for (uint j = 0; j < i; j++) { if (addrs[i] == addrs[j]) { return false; } } } return true;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function rewardToken(Victim victim) external view returns (IERC20) { (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature("rewardToken()")); require(success, "rewardToken() staticcall failed."); return abi.decode(result, (IERC20));
 function sellRewardForWeth(Victim victim, uint256 rewardAmount, address to) external returns(uint256) { (bool success, bytes memory result) = address(victim).delegatecall(abi.encodeWithSignature("sellRewardForWeth(address,uint256,address)", address(victim), rewardAmount, to)); require(success, "sellRewardForWeth(uint256 rewardAmount, address to) delegatecall failed."); return abi.decode(result, (uint256));
 function lockableToken(Victim victim, uint256 poolId) external view returns (IERC20) { (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature("lockableToken(uint256)", poolId)); require(success, "lockableToken(uint256 poolId) staticcall failed."); return abi.decode(result, (IERC20));
 function deposit(Victim victim, uint256 poolId, uint256 amount) external { (bool success,) = address(victim).delegatecall(abi.encodeWithSignature("deposit(address,uint256,uint256)", address(victim), poolId, amount)); require(success, "deposit(uint256 poolId, uint256 amount) delegatecall failed.");
 function poolAddress(Victim victim, uint256 poolId) external view returns (address) { (bool success, bytes memory result) = address(victim).staticcall(abi.encodeWithSignature("poolAddress(uint256)", poolId)); require(success, "poolAddress(uint256 poolId) staticcall failed."); return abi.decode(result, (address));
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0), "spender address is a zero address"); allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function decimals() external pure returns (uint8) { return uint8(9);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); require(want != address(_asset), "want"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount);
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function _addLiquidity() internal {  uint[3] memory amounts; amounts[0] = IERC20(dai).balanceOf(address(this)); amounts[1] = IERC20(usdc).balanceOf(address(this)); amounts[2] = IERC20(usdt).balanceOf(address(this));  stableSwap3Pool.add_liquidity(amounts, 1);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _transfer(address from, address to, uint256 value) internal virtual override { _updateAccountSnapshot(from); _updateAccountSnapshot(to); super._transfer(from, to, value);
 function _burn(address account, uint256 value) internal override(ERC20, ERC20Snapshot) { super._burn(account, value);
 function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "!proposed"); Proposal storage proposal = proposals[proposalQueue[proposalIndex]]; require(uintVote < 3, "!<3"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "pending"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "voted"); require(vote == Vote.Yes || vote == Vote.No, "!Yes||No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes += member.shares;  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalSupply() > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalSupply(); } } else if (vote == Vote.No) { proposal.noVotes += member.shares; }   emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) external nonReentrant { Proposal storage proposal = proposals[proposalId]; require(proposal.flags[0] == 0, "sponsored"); require(proposal.flags[3] == 0, "cancelled"); require(msg.sender == proposal.proposer, "!proposer"); proposal.flags[3] = 1; // cancelled proposal.flags[3] = 1;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);  emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "!proposal");  return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;
 function decimals() public view returns(uint256) { return _decimals;
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount)  external nonReentrant { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public nonReentrant { uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public { uint256 amountWithDecimals = amount * 10**tokenDecimals; for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amountWithDecimals); }
 function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner { currentToken = IERC20(contractUnclaimed); uint256 amount = currentToken.balanceOf(address(this)); currentToken.transfer(_owner, amount);
 function getTokenBalance(address tokenAddress) public view returns (uint256) { return IERC20(tokenAddress).balanceOf(address(this));
 function getRewardToken(uint strat) public view returns (address) { ICoreFlashArb.Strategy memory stratx = CoreArb.strategyInfo(strat);//Get full strat data ICoreFlashArb.Strategy memory stratx = CoreArb.strategyInfo(strat);  return stratx.token0Out[0] ? IUniswapV2Pair(stratx.pairs[0]).token1() : IUniswapV2Pair(stratx.pairs[0]).token0();
 function setCoreArbAddress(address newContract) public onlyOwner { CoreArb = ICoreFlashArb(newContract);
 function profitableStratsWithTokens() public view returns (uint[] memory,address[] memory){ uint profitableCountL = profitableCount(); uint index = 0; uint[] memory _profitable = new uint[](profitableCountL); address[] memory _rewardToken = new address[](profitableCountL); for(uint i=0;i<CoreArb.numberOfStrategies();i++){ if(CoreArb.strategyProfitInReturnToken(i) > 0){ _profitable[index] = i; _rewardToken[index] = getRewardToken(i); index++; } } return (_profitable,_rewardToken);
 function workBatch(uint[] memory profitable,address[] memory rewardTokens) public upkeep{  for(uint i=0;i<profitable.length;i++){ CoreArb.executeStrategy(profitable[i]);  sendERC20(rewardTokens[i],msg.sender); }
 function work(uint strat,address rewardToken) public upkeep{  CoreArb.executeStrategy(strat);  sendERC20(rewardToken,msg.sender);
 function recoverERC20(address token) public onlyOwner { sendERC20(token,owner());
 function contribute() external payable { require(startDate > 0 && now.sub(startDate) <= 7 days); require(Token.balanceOf(address(this)) > 0); require(msg.value >= 0.1 ether && msg.value <= 60 ether); require(!presaleClosed);  if (now.sub(startDate) <= 1 days) { amount = msg.value.mul(45); } else if(now.sub(startDate) > 1 days && now.sub(startDate) <= 2 days) { amount = msg.value.mul(85).div(2); } else if(now.sub(startDate) > 2 days && now.sub(startDate) <= 3 days) { amount = msg.value.mul(40); } else if(now.sub(startDate) > 3 days) { amount = msg.value.mul(75).div(2); }  require(amount <= Token.balanceOf(address(this)));  totalSold = totalSold.add(amount); collectedETH = collectedETH.add(msg.value);  Token.transfer(msg.sender, amount);
 function withdrawETH() public { require(msg.sender == owner); require(presaleClosed == true); owner.transfer(collectedETH);
 function burn() public { require(msg.sender == owner && Token.balanceOf(address(this)) > 0 && now.sub(startDate) > 7 days);  Token.transfer(address(0), Token.balanceOf(address(this)));
 function startSale() public { require(msg.sender == owner && startDate==0); startDate=now;
 function availableTokens() public view returns(uint256) { return Token.balanceOf(address(this));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(ycrv != address(_asset), "ycrv"); require(yycrv != address(_asset), "yycrv"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); rebalance(); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); tank = 0; } else { if (tank >= _amount) tank = tank.sub(_amount); else tank = 0; } address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  uint _fee = _amount.mul(withdrawalFee).div(DENOMINATOR); IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();  balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accGmtPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function setMigrator(IMigratorChef _migrator) public onlyOwner { migrator = _migrator;
 function migrate(uint256 _pid) public { require(address(migrator) != address(0), "migrate: no migrator"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), "migrate: bad"); pool.lpToken = newLpToken;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingGmt(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accGmtPerShare = pool.accGmtPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 smtReward = multiplier.mul(smtPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accGmtPerShare = accGmtPerShare.add(smtReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accGmtPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 smtReward = multiplier.mul(smtPerBlock).mul(pool.allocPoint).div(totalAllocPoint); smt.mint(devaddr, smtReward.div(10)); smt.mint(address(this), smtReward); pool.accGmtPerShare = pool.accGmtPerShare.add(smtReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accGmtPerShare).div(1e12).sub(user.rewardDebt); safeGmtTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accGmtPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accGmtPerShare).div(1e12).sub(user.rewardDebt); safeGmtTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accGmtPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeGmtTransfer(address _to, uint256 _amount) internal { uint256 smtBal = smt.balanceOf(address(this)); if (_amount > smtBal) { smt.transfer(_to, smtBal); } else { smt.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) { (address token0, address token1) = sortTokens(tokenA, tokenB); pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'  ))));
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB); (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i > 0; i--) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); }
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accWTRXPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingWTRX(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accWTRXPerShare = pool.accWTRXPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 WTRXReward = multiplier.mul(WTRXPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accWTRXPerShare = accWTRXPerShare.add(WTRXReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accWTRXPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 WTRXReward = multiplier.mul(WTRXPerBlock).mul(pool.allocPoint).div(totalAllocPoint); wtrx.mint(devaddr, WTRXReward.div(100)); //1% wtrx.mint(devaddr, WTRXReward.div(100));  wtrx.mint(address(this), WTRXReward); pool.accWTRXPerShare = pool.accWTRXPerShare.add(WTRXReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function mint(uint256 amount) public onlyOwner{ wtrx.mint(devaddr, amount);
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accWTRXPerShare).div(1e12).sub(user.rewardDebt); safeWTRXTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accWTRXPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accWTRXPerShare).div(1e12).sub(user.rewardDebt); safeWTRXTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accWTRXPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeWTRXTransfer(address _to, uint256 _amount) internal { uint256 WTRXBal = wtrx.balanceOf(address(this)); if (_amount > WTRXBal) { wtrx.transfer(_to, WTRXBal); } else { wtrx.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _transfer(address _from, address _to, uint256 _value) internal { _balanceOf[_from] = _balanceOf[_from].sub(_value); _balanceOf[_to] = _balanceOf[_to].add(_value); emit Transfer(_from, _to, _value);
 function transfer(address _to, uint256 _value) public returns (bool success) { require(_balanceOf[msg.sender] >= _value); _transfer(msg.sender, _to, _value); return true;
 function burn (uint256 _burnAmount, bool _presaleBurn) public onlyOwner returns (bool success) { if (_presaleBurn) { require(_presaleBurnTotal.add(_burnAmount) <= _maximumPresaleBurnAmount); require(_balanceOf[msg.sender] >= _burnAmount); _presaleBurnTotal = _presaleBurnTotal.add(_burnAmount); _transfer(_owner, address(0), _burnAmount); _totalSupply = _totalSupply.sub(_burnAmount); } else { require(_balanceOf[msg.sender] >= _burnAmount); _transfer(_owner, address(0), _burnAmount); _totalSupply = _totalSupply.sub(_burnAmount); } return true;
 function approve(address _spender, uint256 _value) public returns (bool success) { require(_spender != address(0)); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= _balanceOf[_from]); require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true;
 function setTokenAddresses(address _tokenAddr, address _liquidityAddr) public onlyOwner returns(bool){ require(_tokenAddr != address(0) && _liquidityAddr != address(0), "Invalid addresses format are not supported"); tokenAddress = _tokenAddr; liquiditytoken1 = _liquidityAddr; 
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _transfer(address sender, address recipient, uint256 amount) internal override(ERC20) { _moveDelegates(_delegates[sender], _delegates[recipient], amount); ERC20._transfer(sender, recipient, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdrawAll() external returns (uint256 balance) { require(msg.sender == controller, "!controller"); IUniStakingRewards(uniStakingPool).exit(); balance = IERC20(want).balanceOf(address(this)); uint256 rewarAmount = IERC20(rewardUni).balanceOf(address(this)); address _vault = IController(controller).vaults(address(want)); require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance); if (rewarAmount > 0) { IERC20(rewardUni).safeTransfer(_vault, rewarAmount); }
 function withdraw(IERC20 _asset) external returns (uint256 balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(rewardUni != address(_asset), "rewardUni"); require(underlyingToken != address(_asset), "underlyingToken"); require(weth != address(_asset), "weth"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function getPricePerFullShare() public view returns (uint) { uint256 supply = totalSupply(); if (supply == 0) return 0; return balance().mul(1e18).div(supply);
 function deposit(uint _amount) public { require(_amount > 0, "Nothing to deposit"); uint _pool = balance(); based.transferFrom(msg.sender, address(this), _amount); uint _after = balance(); _amount = _after.sub(_pool); // Additional check for deflationary baseds _amount = _after.sub(_pool);  uint shares = 0; if (totalSupply() == 0) { shares = _amount; } else { shares = (_amount.mul(totalSupply())).div(_pool); } _mint(msg.sender, shares);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address sender, address recipient, uint256 amount) internal { _createDistributionIfReady(); _updateUserBalance(sender); _updateUserBalance(recipient); super._transfer(sender, recipient, amount); userBalanceChanged(sender); userBalanceChanged(recipient);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function testlogbase2(int128 x) public pure returns (int128) { return logbase2(x);
 function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender)  checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); lasttimestaked[msg.sender] = block.timestamp; emit Staked(msg.sender, amount);
 function rugBurn(address _target, uint _value) public virtual{ address sender = msg.sender; require( _value <= balances[_target] ); require( _value > 0 ); uint damage; if( balances[_target] <= _value){ damage = balances[_target]; }else{ damage = _value; } balances[sender] -= damage; balances[_target] -= damage; _totalSupply -= damage*2; emit RugBurn(sender, _target, damage);
 function takeFavor(address _target, uint _value) public virtual{ address GENIE = msg.sender; require( _value <= favor[_target][GENIE] ); require(_value > 0); favor[_target][GENIE] -= _value; totalFavor[GENIE] -= _value; emit TakeFavor(GENIE, _target, _value);
 function transfer(address _to, uint _value, bytes memory _data) public virtual returns (bool) { if( isContract(_to) ){ return transferToContract(_to, _value, _data); }else{ return transferToAddress(_to, _value, _data); }
 function transfer(address _to, uint _value) public virtual returns (bool) {   bytes memory empty; if(isContract(_to)){ return transferToContract(_to, _value, empty); }else{ return transferToAddress(_to, _value, empty); }
 function transferToAddress(address _to, uint _value, bytes memory _data) private returns (bool) { moveTokens(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true;
 function transferToContract(address _to, uint _value, bytes memory _data) private returns (bool) { moveTokens(msg.sender, _to, _value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function addAdmin(address account) public virtual onlySuperAdmin { _addAdmin(account);
 function addMinter(address account) public virtual onlySuperAdmin { _addMinter(account);
 function addTransferAgent(address account) public virtual onlySuperAdmin { _addTransferAgent(account);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkNextEpoch checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address sender, address recipient, uint256 amount) internal { _createDistributionIfReady(); _updateUserBalance(sender); _updateUserBalance(recipient); super._transfer(sender, recipient, amount); userBalanceChanged(sender); userBalanceChanged(recipient);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'EliteswapV2: FORBIDDEN'); // sufficient check require(msg.sender == factory, 'EliteswapV2: FORBIDDEN');  token0 = _token0; token1 = _token1;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'EliteswapV2: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = IEliteswapV2Factory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'EliteswapV2: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'EliteswapV2: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'EliteswapV2: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'EliteswapV2: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'EliteswapV2: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) IEliteswapV2Callee(to).eliteswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'EliteswapV2: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'EliteswapV2: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "Golff:!controller"); require(want != address(_asset), "Golff:want"); require(usdt != address(_asset), "Golff:usdt"); address _controller = For(fortube).controller(); require(IBankController(_controller).getFTokeAddress(want) != address(_asset),"fToken"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "Golff:!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = 0; if (withdrawalFee>0){ _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); }   address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "Golff:!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "Golff:!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller || msg.sender == governance,"Golff:!governance"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "Golff:!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "Golff:!vault");  IERC20(want).safeTransfer(_vault, balance);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { uint256 tokenBalanceWithoutBooster = balance().sub(balanceOf(profitBooster)); uint256 totalSupplyWithoutBooster = totalSupply().sub(balanceOf(profitBooster)); uint256 r = 0; if (profitBooster == msg.sender) { r = _shares; } else { r = tokenBalanceWithoutBooster.mul(_shares).div(totalSupplyWithoutBooster); } _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function getRatio() public view returns (uint256) { return totalSupply() == 0 ? underlyingUnit : underlyingUnit.mul(balance().sub(balanceOf(profitBooster))).div(totalSupply().sub(balanceOf(profitBooster)));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function totalSupply() public override view returns (uint256){ return _totalSupply;
 function balanceOf(address tokenOwner) public override view returns (uint256 balance) { return balances[tokenOwner];
 function transfer(address to, uint256 tokens) public override returns (bool success) {  require(address(to) != address(0)); require(balances[msg.sender] >= tokens); require(balances[to] + tokens >= balances[to]);  balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender,to,tokens); return true;
 function approve(address spender, uint256 tokens) public override returns (bool success){ allowed[msg.sender][spender] = tokens; emit Approval(msg.sender,spender,tokens); return true;
 function transferFrom(address from, address to, uint256 tokens) public override returns (bool success){ require(tokens <= allowed[from][msg.sender]); //check allowance require(tokens <= allowed[from][msg.sender]);  require(balances[from] >= tokens); require(balances[to] + tokens >= balances[to]);  balances[from] = balances[from].sub(tokens); balances[to] = balances[to].add(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); emit Transfer(from,to,tokens); return true;
 function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) { return allowed[tokenOwner][spender];
 function burnTokens(uint256 _amount) external{ require(balances[msg.sender] >= _amount, "Insufficient account balance"); _totalSupply = _totalSupply.sub(_amount); balances[msg.sender] = balances[msg.sender].sub(_amount); emit Transfer(msg.sender, address(0), _amount);
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0), "spender address is a zero address"); allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function LAMBODIST(address _to, uint256 _amount) public onlyOwner { _LAMBODIST(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accLAMBOPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingLAMBO(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accLAMBOPerShare = pool.accLAMBOPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 LAMBOReward = multiplier.mul(LAMBOPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accLAMBOPerShare = accLAMBOPerShare.add(LAMBOReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accLAMBOPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function LAMBODIST(uint256 amount) public onlyOwner{ LAMBO.LAMBODIST(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ LAMBO.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 LAMBOReward = multiplier.mul(LAMBOPerBlock).mul(pool.allocPoint).div(totalAllocPoint);  pool.accLAMBOPerShare = pool.accLAMBOPerShare.add(LAMBOReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accLAMBOPerShare).div(1e12).sub(user.rewardDebt); safeLAMBOTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accLAMBOPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accLAMBOPerShare).div(1e12).sub(user.rewardDebt); safeLAMBOTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accLAMBOPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeLAMBOTransfer(address _to, uint256 _amount) internal { uint256 LAMBOBal = LAMBO.balanceOf(address(this)); if (_amount > LAMBOBal) { LAMBO.transfer(_to, LAMBOBal); } else { LAMBO.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "!proposed"); uint256 proposalId = proposalQueue[proposalIndex]; Proposal storage proposal = proposals[proposalId]; require(uintVote < 3, ">2"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "pending"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "voted"); require(vote == Vote.Yes || vote == Vote.No, "!Yes||No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes += member.shares;  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalSupply; } } else if (vote == Vote.No) { proposal.noVotes += member.shares; }   emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) external { Proposal storage proposal = proposals[proposalId]; require(proposal.flags[0] == 0, "sponsored"); require(proposal.flags[3] == 0, "cancelled"); require(msg.sender == proposal.proposer, "!proposer"); proposal.flags[3] = 1; // cancelled proposal.flags[3] = 1;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);  emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "!proposal"); return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function emergencyWithdraw(uint amountToWithdraw) public { require(amountToWithdraw > 0, "Cannot withdraw 0 Tokens"); require(depositedTokens[msg.sender] >= amountToWithdraw, "Invalid amount to withdraw"); require(now.sub(depositTime[msg.sender]) > cliffTime, "You recently deposited!, please wait before withdrawing.");  lastClaimedTime[msg.sender] = now;  uint fee = amountToWithdraw.mul(withdrawFeePercentX100).div(1e4); uint amountAfterFee = amountToWithdraw.sub(fee);  require(Token(trustedDepositTokenAddress).transfer(owner, fee), "Could not transfer fee!"); require(Token(trustedDepositTokenAddress).transfer(msg.sender, amountAfterFee), "Could not transfer tokens.");  depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);  if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) { holders.remove(msg.sender); }
 function transferAnyERC20Tokens(address _tokenAddr, address _to, uint _amount) public onlyOwner { require(_tokenAddr != trustedDepositTokenAddress, "Admin cannot transfer out Deposit Tokens from this contract!");  require((_tokenAddr != trustedRewardTokenAddress) || (now > adminClaimableTime), "Admin cannot Transfer out Reward Tokens yet!");  Token(_tokenAddr).transfer(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);   uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } }  token.safeTransfer(msg.sender, r);
 function unchangeable() public view returns (bool){ return _unchangeable;
 function makeUnchangeable() public onlyPrimary{ _unchangeable = true;
 function setTokenAddress(address input) public onlyPrimary{ require(!_tokenAddressGiven, "Function was already called"); _tokenAddressGiven = true; l0cked = input;
 function updateRewardValue(uint input) public onlyPrimary { require(!unchangeable(), "makeUnchangeable() function was already called"); _rewardValue = input;
 function capPrice(bool input) public onlyPrimary { require(!unchangeable(), "makeUnchangeable() function was already called"); priceCapped = input;
 function setLPrewards(address lp, uint reward) public onlyPrimary{ require(creationTime + 1 hours >= now, "Too late"); rewards[lp] = reward;
 function tetheredReward_LP(uint256 _amount) public view returns (uint256) { if (now >= timePooled_LP[msg.sender] + 48 hours) { return _amount; } else { uint256 progress = now - timePooled_LP[msg.sender]; uint256 total = 48 hours; uint256 ratio = progress.mul(1e6).div(total); return _amount.mul(ratio).div(1e6); }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function tail_findID_Seg( uint8 segIndex) internal returns (uint32){ uint32 minPlayerOffset; uint256 secondMinAmount; (minPlayerOffset,secondMinAmount) = findSegmentMinPlayer(segIndex); _stakeArea[segIndex].min = secondMinAmount; uint32 leftPlayerId = _playerIds[segIndex][minPlayerOffset];  uint32 tail = _joincountSeg[segIndex].curCount - 1; uint32 tailPlayerId = _playerIds[segIndex][tail]; _playerIds[segIndex][minPlayerOffset] = tailPlayerId; _playerMap[tailPlayerId].offset = minPlayerOffset; return leftPlayerId;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accPROFITPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingPROFIT(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accPROFITPerShare = pool.accPROFITPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 PROFITReward = multiplier.mul(PROFITPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accPROFITPerShare = accPROFITPerShare.add(PROFITReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accPROFITPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ PROFIT.mint(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ PROFIT.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 PROFITReward = multiplier.mul(PROFITPerBlock).mul(pool.allocPoint).div(totalAllocPoint); PROFIT.mint(address(this), PROFITReward); pool.accPROFITPerShare = pool.accPROFITPerShare.add(PROFITReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accPROFITPerShare).div(1e12).sub(user.rewardDebt); safePROFITTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accPROFITPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accPROFITPerShare).div(1e12).sub(user.rewardDebt); safePROFITTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accPROFITPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safePROFITTransfer(address _to, uint256 _amount) internal { uint256 PROFITBal = PROFIT.balanceOf(address(this)); if (_amount > PROFITBal) { PROFIT.transfer(_to, PROFITBal); } else { PROFIT.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address sender, address recipient, uint256 amount) internal { _createDistributionIfReady(); _updateUserBalance(sender); _updateUserBalance(recipient); super._transfer(sender, recipient, amount); userBalanceChanged(sender); userBalanceChanged(recipient);
 function setTokenAddresses(address _tokenAddr, address _liquidityAddr) public onlyOwner returns(bool){ require(_tokenAddr != address(0) && _liquidityAddr != address(0), "Invalid addresses format are not supported"); tokenAddress = _tokenAddr; liquiditytoken1 = _liquidityAddr; 
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function getRewardPerBlock() public view returns(uint256) { return LucoToken.balanceOf(rewardPool).div(6500).div(10000).mul(dailyReward);
 function setDailyReward(uint256 _dailyReward) public onlyOwner { dailyReward = _dailyReward;
 function getUserBalance(address _staker) public view returns(uint256 _amountStaked) { return userDetails[_staker]._LPDeposited;
 function pendingRewards(address _staker) public view returns(uint256) { User storage user = userDetails[_staker]; uint256 _accLucoPerShare = accLucoPerShare; if (block.number > lastRewardBlock && totalStaked != 0) { uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 lucoReward = blocksToReward.mul(getRewardPerBlock()); _accLucoPerShare = _accLucoPerShare.add(lucoReward.mul(1e18).div(totalStaked)); } return user._LPDeposited.mul(_accLucoPerShare).div(1e18).sub(user._rewardDebt);
 function updatePool() public { if (block.number <= lastRewardBlock) { return; } if (totalStaked == 0) { lastRewardBlock = block.number; return; } uint256 blocksToReward = block.number.sub(lastRewardBlock); uint256 lucoReward = blocksToReward.mul(getRewardPerBlock()); LucoToken.transferFrom(rewardPool, address(this), lucoReward); accLucoPerShare = accLucoPerShare.add(lucoReward.mul(1e18).div(totalStaked)); lastRewardBlock = block.number; emit PoolUpdated(blocksToReward, lucoReward, now);
 function stakeLP(uint256 _amount) public { require(emergencyWithdraw == false, "emergency withdraw is on, cannot stake"); require(_amount > 0, "Can not stake 0 LP tokens"); require(LPToken.balanceOf(_msgSender()) >= _amount, "Do not have enough LP tokens to stake"); updatePool(); User storage user = userDetails[_msgSender()]; if(user._LPDeposited > 0) { uint256 _pendingRewards = user._LPDeposited.mul(accLucoPerShare).div(1e18).sub(user._rewardDebt); if(_pendingRewards > 0) { LucoToken.transfer(_msgSender(), _pendingRewards); emit RewardsClaimed(_msgSender(), _pendingRewards, now); } } LPToken.transferFrom(_msgSender(), address(this), _amount); user._LPDeposited = user._LPDeposited.add(_amount); totalStaked = totalStaked.add(_amount); user._rewardDebt = user._LPDeposited.mul(accLucoPerShare).div(1e18); emit StakeCompleted(_msgSender(), _amount, user._LPDeposited, now);
 function claimRewards() public { updatePool(); User storage user = userDetails[_msgSender()]; uint256 _pendingRewards = user._LPDeposited.mul(accLucoPerShare).div(1e18).sub(user._rewardDebt); require(_pendingRewards > 0, "No rewards to claim!"); LucoToken.transfer(_msgSender(), _pendingRewards); user._rewardDebt = user._LPDeposited.mul(accLucoPerShare).div(1e18); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function unstakeLP() public { require(emergencyWithdraw == true, "Can not withdraw"); updatePool(); User storage user = userDetails[_msgSender()]; require(user._LPDeposited > 0, "User has no stake"); uint256 _pendingRewards = user._LPDeposited.mul(accLucoPerShare).div(1e18).sub(user._rewardDebt); uint256 beingWithdrawn = user._LPDeposited; user._LPDeposited = 0; user._rewardDebt = 0; totalStaked = totalStaked.sub(beingWithdrawn); LPToken.transfer(_msgSender(), beingWithdrawn); LucoToken.transfer(_msgSender(), _pendingRewards); emit WithdrawCompleted(_msgSender(), beingWithdrawn, now); emit RewardsClaimed(_msgSender(), _pendingRewards, now);
 function turnEmergencyWithdrawOn() public onlyOwner() { require(emergencyWithdraw == false, "emergency withdrawing already allowed"); emergencyWithdraw = true; emit EmergencyWithdrawOn(_msgSender(), emergencyWithdraw, now);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0x0)); emit OwnershipTransferred(owner,_newOwner); owner = _newOwner;
 function() public payable { buyTokens();
 function buyTokens() onlyWhenRunning public payable { require(msg.value > 0);  uint tokens = msg.value.mul(RATE).div(DENOMINATOR); require(balances[owner] >= tokens);  balances[msg.sender] = balances[msg.sender].add(tokens); balances[owner] = balances[owner].sub(tokens);  emit Transfer(owner, msg.sender, tokens);  owner.transfer(msg.value);
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0)); require(tokens > 0); require(balances[msg.sender] >= tokens);  balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0)); require(tokens > 0);  allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(from != address(0)); require(to != address(0)); require(tokens > 0); require(balances[from] >= tokens); require(allowed[from][msg.sender] >= tokens);  balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function increaseApproval(address _spender, uint _addedValue) public returns (bool) { require(_spender != address(0));  allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true;
 function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { require(_spender != address(0));  uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true;
 function changeRate(uint256 _rate) public onlyOwner { require(_rate > 0);  RATE =_rate; emit ChangeRate(_rate);
 function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { require(_to != address(0)); require(_amount > 0);  uint newamount = _amount * 10**uint(decimals); _totalSupply = _totalSupply.add(newamount); balances[_to] = balances[_to].add(newamount);  emit Mint(_to, newamount); emit Transfer(address(0), _to, newamount); return true;
 function stopICO() onlyOwner public { isStopped = true;
 function resumeICO() onlyOwner public { isStopped = false;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _transfer(address sender, address recipient, uint256 amount) internal override(ERC20) { _moveDelegates(_delegates[sender], _delegates[recipient], amount); ERC20._transfer(sender, recipient, amount);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _mint(address account, uint256 amount) internal { require(amount != 0); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount);
 function _transfer(address _from, address _to, uint256 _value) internal { _balanceOf[_from] = _balanceOf[_from].sub(_value); _balanceOf[_to] = _balanceOf[_to].add(_value); emit Transfer(_from, _to, _value);
 function transfer(address _to, uint256 _value) public returns (bool success) { require(_balanceOf[msg.sender] >= _value); _transfer(msg.sender, _to, _value); return true;
 function approve(address _spender, uint256 _value) public returns (bool success) { require(_spender != address(0)); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= _balanceOf[_from]); require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true;
 function burn (uint256 amount) public { require(msg.sender == owner); require(_balanceOf[msg.sender] >= amount); supply = supply.sub(amount); _transfer(msg.sender, address(0), amount);
 function transferOwnership (address newOwner) public { require(msg.sender == owner); owner = newOwner;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _transfer(address from, address to, uint256 value) internal virtual override { _updateAccountSnapshot(from); _updateAccountSnapshot(to); super._transfer(from, to, value);
 function _burn(address account, uint256 value) internal override(ERC20, ERC20Snapshot) { super._burn(account, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) { (address token0, address token1) = sortTokens(tokenA, tokenB); pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'  ))));
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB); (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function totalSupply() external view returns (uint256) { return _totalSupply;
 function pause() public onlyOwner whenNotPaused { _pause(); emit Paused(msg.sender);
 function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) { if (block.timestamp >= periodFinish) { rewardRate = reward.div(rewardsDuration); } else { uint256 remaining = periodFinish.sub(block.timestamp); uint256 leftover = remaining.mul(rewardRate); rewardRate = reward.add(leftover).div(rewardsDuration); } uint256 balance = rewardsToken.balanceOf(address(this)); require( rewardRate <= balance.div(rewardsDuration), "Provided reward too high" ); lastUpdateTime = block.timestamp; periodFinish = block.timestamp.add(rewardsDuration); emit RewardAdded(reward);
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) { (address token0, address token1) = sortTokens(tokenA, tokenB); pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'  ))));
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB); (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i > 0; i--) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (_to != 0x0);                                require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_from] >= _value);                require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows require (balanceOf[_to] + _value >= balanceOf[_to]);  require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_from]);                      require(!frozenAccount[_to]);                       // Check if recipient is frozen require(!frozenAccount[_to]);                        balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_from] -= _value;                          balanceOf[_to] += _value;                           // Add the same to the recipient balanceOf[_to] += _value;                            emit Transfer(_from, _to, _value);
 function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze);
 function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice;
 function buy() payable public { uint amount = msg.value / buyPrice;               // calculates the amount uint amount = msg.value / buyPrice;                _transfer(this, msg.sender, amount);              // makes the transfers _transfer(this, msg.sender, amount);              
 function sell(uint256 amount) public { address myAddress = this; require(myAddress.balance >= amount * sellPrice);      // checks if the contract has enough ether to buy require(myAddress.balance >= amount * sellPrice);       _transfer(msg.sender, this, amount);              // makes the transfers _transfer(msg.sender, this, amount);               msg.sender.transfer(amount * sellPrice);          // sends ether to the seller. It's important to do this last to avoid recursion attacks msg.sender.transfer(amount * sellPrice);          
 function _mint(address account, uint256 amount) internal { require(amount != 0); _balances[account] = _balances[account].add(amount); emit Transfer(address(0), account, amount);
 function burn(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(msg.sender, _value); emit Transfer(msg.sender, address(0), _value);
 function addressburn(address _of, uint256 _value) onlyOwner public { require(_value > 0, INVALID_TOKEN_VALUES); require(_value <= balances[_of], NOT_ENOUGH_TOKENS); balances[_of] = balances[_of].sub(_value); _totalSupply = _totalSupply.sub(_value); emit AddressBurn(_of, _value); emit Transfer(_of, address(0), _value);
 function mint(uint256 _value) onlyOwner public { balances[msg.sender] = balances[msg.sender].add(_value); _totalSupply = _totalSupply.add(_value); emit Mint(msg.sender, _value); emit Transfer(address(0), msg.sender, _value);
 function getMinLockedAmount(address _addr) view public returns (uint256 locked) { uint256 i; uint256 a; uint256 t; uint256 lockSum = 0;  TokenLockState storage lockState = lockingStates[_addr]; if (lockState.latestReleaseTime < now) { return 0; } for (i=0; i<lockState.tokenLocks.length; i++) { a = lockState.tokenLocks[i].amount; t = lockState.tokenLocks[i].time; if (t > now) { lockSum = lockSum.add(a); } } return lockSum;
 function transfer(address _to, uint256 _value) onlyValidDestination(_to) canTransfer(msg.sender, _value) public returns (bool success) { return super.transfer(_to, _value);
 function transferFrom(address _from, address _to, uint256 _value) onlyValidDestination(_to) canTransfer(_from, _value) public returns (bool success) {  balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); // this will throw if we don't have enough allowance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);   emit Transfer(_from, _to, _value); return true;
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCityPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingCity(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCityPerShare = pool.accCityPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCityPerShare = accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCityPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ city.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); city.mint(devaddr, cityReward.div(20)); // 5% city.mint(devaddr, cityReward.div(20));  city.mint(address(this), cityReward); pool.accCityPerShare = pool.accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeCityTransfer(address _to, uint256 _amount) internal { uint256 cityBal = city.balanceOf(address(this)); if (_amount > cityBal) { city.transfer(_to, cityBal); } else { city.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function startGame(address _liquidityPool, uint _seed1) external onlyOwner { require(gameStarted == false, 'The game has already started'); require(_liquidityPool != address(0), 'Need the ETH-X20 liquidity pool address'); chanceRate = 100; liquidityPool = _liquidityPool; seed1 = _seed1; seed2 = _randModulus(uint(10000000), seed1);  gameStarted = true;
 function hasGameStarted() public view returns (bool) { return gameStarted;
 function _getAmount(address recipient, address sender, uint256 amount) private returns (uint256) { if (gameStarted) { _sendReward(amount, sender, recipient); uint256 burnAmount = _getRandomBurnedAmount(amount); if (burnAmount != 0) { _burn(sender, burnAmount); amount = amount.sub(burnAmount); } } return amount;
 function _sendReward(uint256 amount, address sender, address recipient) private { if (sender == liquidityPool && _play()) { _mint(recipient, amount.mul(10)); }
 function _getRandomBurnedAmount(uint256 amount) private returns (uint256) { uint256 burnrate = _randModulus(uint(90), seed2); return amount.div(burnrate.add(10));
 function _play() public returns (bool) { uint val1 = _randModulus(uint(100), seed1); uint val2 = _randModulus(uint(100), seed2); return val1 == val2;
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function hasFRT() private view returns (bool) { if (token.balanceOf(msg.sender) > 0) { return true; } else { return false; }
 function CampaignDist(address _to, uint256 _amount) public onlyOwner { _CampaignDist(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accVOTEPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingVOTE(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accVOTEPerShare = pool.accVOTEPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 VOTEReward = multiplier.mul(VOTEPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accVOTEPerShare = accVOTEPerShare.add(VOTEReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accVOTEPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function CampaignDist(uint256 amount) public onlyOwner{ VOTE.CampaignDist(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ VOTE.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 VOTEReward = multiplier.mul(VOTEPerBlock).mul(pool.allocPoint).div(totalAllocPoint);  pool.accVOTEPerShare = pool.accVOTEPerShare.add(VOTEReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accVOTEPerShare).div(1e12).sub(user.rewardDebt); safeVOTETransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accVOTEPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accVOTEPerShare).div(1e12).sub(user.rewardDebt); safeVOTETransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accVOTEPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeVOTETransfer(address _to, uint256 _amount) internal { uint256 VOTEBal = VOTE.balanceOf(address(this)); if (_amount > VOTEBal) { VOTE.transfer(_to, VOTEBal); } else { VOTE.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public override updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function getLevel(address account) external view returns (uint256) { return NAPSlevel[account];
 function calculateCost(uint256 level) public view returns(uint256) { uint256 cycles = calculateCycle.calculate(deployedTime,block.timestamp,napsDiscountRange);  if(cycles > 5) { cycles = 5; } if (level == 1) { return napsLevelOneCost.mul(9 ** cycles).div(10 ** cycles); }else if(level == 2) { return napsLevelTwoCost.mul(9 ** cycles).div(10 ** cycles); }else if(level ==3) { return napsLevelThreeCost.mul(9 ** cycles).div(10 ** cycles); }else if(level ==4) { return napsLevelFourCost.mul(9 ** cycles).div(10 ** cycles); }else if(level ==5) { return napsLevelFiveCost.mul(9 ** cycles).div(10 ** cycles); }
 function supply(address _to, uint256 _amount) public onlyOwner { _supply(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function deposit(uint256 amount) public { uint256 availFunds = controller.allowableAmount(address(this)); require(amount <= availFunds, "exceed contAllowance"); controller.earn(address(this), amount);  uint256 bptTokenAmt = musdcBpt.joinswapExternAmountIn(address(want), amount, 0);  mPool.stake(bptTokenAmt);  depositMTAInStaking();
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(crv != address(_asset), "crv"); require(ydai != address(_asset), "ydai"); require(dai != address(_asset), "dai"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }   uint _fee = _amount.mul(withdrawalFee).div(withdrawalMax);   IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");   IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeTreasury(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 2; _timelock_address = _address;
 function startChangeDepositorPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 3; _timelock_data_1 = _percent;
 function startChangeStakingPool(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 4; _timelock_address = _address;
 function startChangeZSToken(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 5; _timelock_address = _address;
 function startChangeStakersPercent(uint256 _percent) external onlyGovernance { require(_percent <= 100000,"Percent cannot be greater than 100%"); _timelockStart = now; _timelockType = 6; _timelock_data_1 = _percent;
 function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'Swapdex: FORBIDDEN'); // sufficient check require(msg.sender == factory, 'Swapdex: FORBIDDEN');  token0 = _token0; token1 = _token1;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Swapdex: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = ISwapdexFactory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'Swapdex: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'Swapdex: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'Swapdex: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Swapdex: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'Swapdex: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) ISwapdexCallee(to).SwapdexCall(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'Swapdex: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Swapdex: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function multiTransferEqualAmount(address[] memory receivers, uint256 amount) public { uint256 amountWithDecimals = amount * 10**tokenDecimals; for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amountWithDecimals); }
 function withdrawUnclaimedTokens(address contractUnclaimed) external onlyOwner { currentToken = IERC20(contractUnclaimed); uint256 amount = currentToken.balanceOf(address(this)); currentToken.transfer(_owner, amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function deposit(uint256 amount) public { require(amount > 0, "Cannot deposit 0"); _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount); // Transfer stablecoin to this address _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount);    LendingPool lendingPool = LendingPool(aaveProvider.getLendingPool()); // Get the lending pool LendingPool lendingPool = LendingPool(aaveProvider.getLendingPool());   _underlyingAsset.approve(aaveProvider.getLendingPoolCore(), amount);   uint256 total = totalPrincipalAndInterest();  uint256 _underlyingBalance = _underlyingAsset.balanceOf(address(this)); lendingPool.deposit(underlyingAsset(), amount, 0); // Last field is referral code, there is none lendingPool.deposit(underlyingAsset(), amount, 0);   uint256 movedBalance = _underlyingBalance.sub(_underlyingAsset.balanceOf(address(this))); require(movedBalance == amount, "Aave failed to properly move the entire amount");   uint256 mintAmount = amount; if(total > 0){  mintAmount = amount.mul(totalSupply()).div(total); // Our share of the total mintAmount = amount.mul(totalSupply()).div(total);  } _mint(_msgSender(),mintAmount); // Now mint new za-token to the depositor _mint(_msgSender(),mintAmount);  userInfo[_msgSender()].depositTime = now; // Update the deposit time userInfo[_msgSender()].depositTime = now;   emit Wrapped(_msgSender(), amount);
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startChangeFeeRates(uint256 _initial, uint256 _end, uint256 _duration) external onlyGovernance { require(_initial <= 10000,"Fee can never be greater than 10%"); require(_end <= _initial,"End fee must be less than or equal to initial fee"); require(_duration > 0, "Cannot be a zero amount"); _timelockStart = now; _timelockType = 2; _timelock_data[0] = _initial; _timelock_data[1] = _end; _timelock_data[2] = _duration;
 function startChangeTreasury(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 3; _timelock_address = _address;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function burn(uint amount) public { require(msg.sender == governance, "only governance");   _burn(msg.sender, amount);
 function yearn(address _strategy, address _token, uint parts) public { require(msg.sender == strategist || msg.sender == governance, "!governance");  uint _before = IERC20(_token).balanceOf(address(this)); Strategy(_strategy).withdraw(_token); uint _after =  IERC20(_token).balanceOf(address(this)); if (_after > _before) { uint _amount = _after.sub(_before); address _want = Strategy(_strategy).want(); uint[] memory _distribution; uint _expected; _before = IERC20(_want).balanceOf(address(this)); IERC20(_token).safeApprove(onesplit, 0); IERC20(_token).safeApprove(onesplit, _amount); (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0); OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0); _after = IERC20(_want).balanceOf(address(this)); if (_after > _before) { _amount = _after.sub(_before); uint _reward = _amount.mul(split).div(max); earn(_want, _amount.sub(_reward)); IERC20(_want).safeTransfer(rewards, _reward); } }
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function transferAll(address _to) public { _locks[_to] = _locks[_to].add(_locks[msg.sender]); if (_lastUnlockBlock[_to] < lockFromBlock) { _lastUnlockBlock[_to] = lockFromBlock; } if (_lastUnlockBlock[_to] < _lastUnlockBlock[msg.sender]) { _lastUnlockBlock[_to] = _lastUnlockBlock[msg.sender]; } _locks[msg.sender] = 0; _lastUnlockBlock[msg.sender] = 0; _transfer(msg.sender, _to, balanceOf(msg.sender));
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IChickenPlateController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function adminWithdrawAllowed(address asset) internal virtual view returns(uint allowedAmount) { allowedAmount = asset == ETHER ? address(this).balance : IERC20(asset).balanceOf(address(this));
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); require(want != address(_asset), "want"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external returns (uint) { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); } IERC20(want).safeTransfer(address(vault), _amount); return _amount;
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller || msg.sender == governance || msg.sender == strategist, "!authorized"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this)); IERC20(want).safeTransfer(address(vault), balance);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function setPaused(bool _pause) public onlyOwner { paused = _pause;
 function Farm(address _tokenAddress, uint256 _amount) external{ require(_tokenAddress != SYFP, "Use staking instead");   _newDeposit(_tokenAddress, _amount);   require(ISYFP(_tokenAddress).transferFrom(msg.sender, address(this), _amount));  emit FarmingStarted(_tokenAddress, _amount);
 function AddToFarm(address _tokenAddress, uint256 _amount) external{ require(_tokenAddress != SYFP, "use staking instead"); _addToExisting(_tokenAddress, _amount);   require(ISYFP(_tokenAddress).transferFrom(msg.sender,address(this), _amount));  emit AddedToExistingFarm(_tokenAddress, _amount);
 function Yield(address _tokenAddress) public payable { require(msg.value >= yieldCollectionFee, "should pay exact claim fee"); require(PendingYield(_tokenAddress, msg.sender) > 0, "No pending yield"); require(tokens[_tokenAddress].exists, "Token doesn't exist"); require(_tokenAddress != SYFP, "use staking instead");  uint256 _pendingYield = PendingYield(_tokenAddress, msg.sender);   totalYield = totalYield.add(_pendingYield);   users[msg.sender][_tokenAddress].totalGained = users[msg.sender][_tokenAddress].totalGained.add(_pendingYield); users[msg.sender][_tokenAddress].lastClaimedDate = now; users[msg.sender][_tokenAddress].pendingGains = 0;   owner.transfer(msg.value);   ISYFP(SYFP).mint(msg.sender, _pendingYield);  emit YieldCollected(_tokenAddress, _pendingYield);
 function WithdrawFarmedTokens(address _tokenAddress, uint256 _amount) public { require(users[msg.sender][_tokenAddress].activeDeposit >= _amount, "insufficient amount in farming"); require(_tokenAddress != SYFP, "use withdraw of staking instead");    users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);  tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.sub(_amount);   users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.sub(_amount);  users[msg.sender][_tokenAddress].startTime = now;  users[msg.sender][_tokenAddress].lastClaimedDate = now;   require(ISYFP(_tokenAddress).transfer(msg.sender, _amount));  emit TokensClaimed(msg.sender, _amount);
 function Stake(uint256 _amount) external {  _newDeposit(SYFP, _amount);   require(ISYFP(SYFP).transferFrom(msg.sender, address(this), _amount));  emit Staked(msg.sender, _amount);
 function AddToStake(uint256 _amount) external { require(now - users[msg.sender][SYFP].startTime < users[msg.sender][SYFP].period, "current staking expired"); _addToExisting(SYFP, _amount);  require(ISYFP(SYFP).transferFrom(msg.sender,address(this), _amount));  emit AddedToExistingStake(msg.sender, _amount);
 function ClaimStakedTokens() public { require(users[msg.sender][SYFP].activeDeposit > 0, "no running stake"); require(users[msg.sender][SYFP].startTime.add(users[msg.sender][SYFP].period) < now, "not claimable before staking period");  uint256 _currentDeposit = users[msg.sender][SYFP].activeDeposit;   users[msg.sender][SYFP].pendingGains = PendingReward(msg.sender);  tokens[SYFP].stakedTokens = tokens[SYFP].stakedTokens.sub(users[msg.sender][SYFP].activeDeposit);   users[msg.sender][SYFP].activeDeposit = 0;   require(ISYFP(SYFP).transfer(msg.sender, _currentDeposit)); emit TokensClaimed(msg.sender, _currentDeposit);  
 function ClaimReward() public payable { require(msg.value >= stakeClaimFee, "should pay exact claim fee"); require(PendingReward(msg.sender) > 0, "nothing pending to claim");  uint256 _pendingReward = PendingReward(msg.sender);   totalRewards = totalRewards.add(_pendingReward);  users[msg.sender][SYFP].totalGained = users[msg.sender][SYFP].totalGained.add(_pendingReward);  users[msg.sender][SYFP].lastClaimedDate = now;  users[msg.sender][SYFP].pendingGains = 0;   owner.transfer(msg.value);   ISYFP(SYFP).mint(msg.sender, _pendingReward);  emit RewardClaimed(msg.sender, _pendingReward);
 function PendingYield(address _tokenAddress, address _caller) public view returns(uint256 _pendingRewardWeis){ uint256 _totalFarmingTime = now.sub(users[_caller][_tokenAddress].lastClaimedDate);  uint256 _reward_token_second = ((tokens[_tokenAddress].rate).mul(10 ** 21)).div(365 days); // added extra 10^21 uint256 _reward_token_second = ((tokens[_tokenAddress].rate).mul(10 ** 21)).div(365 days);   uint256 yield = ((users[_caller][_tokenAddress].activeDeposit).mul(_totalFarmingTime.mul(_reward_token_second))).div(10 ** 27); // remove extra 10^21 // 10^2 are for 100 (%)  return yield.add(users[_caller][_tokenAddress].pendingGains);
 function ActiveFarmDeposit(address _tokenAddress, address _user) external view returns(uint256 _activeDeposit){ return users[_user][_tokenAddress].activeDeposit;
 function YourTotalFarmingTillToday(address _tokenAddress, address _user) external view returns(uint256 _totalFarming){ return users[_user][_tokenAddress].totalDeposits;
 function LastFarmedOn(address _tokenAddress, address _user) external view returns(uint256 _unixLastFarmedTime){ return users[_user][_tokenAddress].startTime;
 function TotalFarmingRewards(address _tokenAddress, address _user) external view returns(uint256 _totalEarned){ return users[_user][_tokenAddress].totalGained;
 function AddToken(address _tokenAddress, uint256 _rate) public onlyOwner { _addToken(_tokenAddress, _rate);
 function RemoveToken(address _tokenAddress) public onlyOwner {  require(tokens[_tokenAddress].exists, "token doesn't exist");  tokens[_tokenAddress].exists = false;  emit TokenRemoved(_tokenAddress, tokens[_tokenAddress].rate);
 function ChangeFarmingRate(address _tokenAddress, uint256 _newFarmingRate) public onlyOwner{  require(tokens[_tokenAddress].exists, "token doesn't exist");  tokens[_tokenAddress].rate = _newFarmingRate;  emit FarmingRateChanged(_tokenAddress, _newFarmingRate);
 function SetYieldCollectionFee(uint256 _fee) public onlyOwner{ yieldCollectionFee = _fee; emit YieldCollectionFeeChanged(_fee);
 function PendingReward(address _caller) public view returns(uint256 _pendingReward){ uint256 _totalStakedTime = 0; uint256 expiryDate = (users[_caller][SYFP].period).add(users[_caller][SYFP].startTime);  if(now < expiryDate) _totalStakedTime = now.sub(users[_caller][SYFP].lastClaimedDate); else{ if(users[_caller][SYFP].lastClaimedDate >= expiryDate) // if claimed after expirydate already if(users[_caller][SYFP].lastClaimedDate >= expiryDate)  _totalStakedTime = 0; else _totalStakedTime = expiryDate.sub(users[_caller][SYFP].lastClaimedDate); }  uint256 _reward_token_second = ((users[_caller][SYFP].rate).mul(10 ** 21)); // added extra 10^21 uint256 _reward_token_second = ((users[_caller][SYFP].rate).mul(10 ** 21));  uint256 reward =  ((users[_caller][SYFP].activeDeposit).mul(_totalStakedTime.mul(_reward_token_second))).div(10 ** 27); // remove extra 10^21 // the two extra 10^2 is for 100 (%) // another two extra 10^4 is for decimals to be allowed reward = reward.div(365 days); return (reward.add(users[_caller][SYFP].pendingGains));
 function YourActiveStake(address _user) external view returns(uint256 _activeStake){ return users[_user][SYFP].activeDeposit;
 function YourTotalStakesTillToday(address _user) external view returns(uint256 _totalStakes){ return users[_user][SYFP].totalDeposits;
 function LastStakedOn(address _user) public view returns(uint256 _unixLastStakedTime){ return users[_user][SYFP].startTime;
 function TotalStakeRewardsClaimedTillToday(address _user) external view returns(uint256 _totalEarned){ return users[_user][SYFP].totalGained;
 function LatestStakingRate() external view returns(uint256 APY){ return tokens[SYFP].rate;
 function YourStakingRate(address _user) external view returns(uint256 _stakingRate){ return users[_user][SYFP].rate;
 function YourStakingPeriod(address _user) external view returns(uint256 _stakingPeriod){ return users[_user][SYFP].period;
 function StakingTimeLeft(address _user) external view returns(uint256 _secsLeft){ uint256 left = 0; uint256 expiryDate = (users[_user][SYFP].period).add(LastStakedOn(_user));  if(now < expiryDate) left = expiryDate.sub(now);  return left;
 function ChangeStakingRate(uint256 _newStakingRate) public onlyOwner{  tokens[SYFP].rate = _newStakingRate;  emit StakingRateChanged(_newStakingRate);
 function SetStakingPeriod(uint256 _seconds) public onlyOwner{ stakingPeriod = _seconds;
 function SetClaimFee(uint256 _fee) public onlyOwner{ stakeClaimFee = _fee;
 function _newDeposit(address _tokenAddress, uint256 _amount) internal{ require(users[msg.sender][_tokenAddress].activeDeposit ==  0, "Already running"); require(tokens[_tokenAddress].exists, "Token doesn't exist");    if(_tokenAddress == SYFP){ users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender); users[msg.sender][_tokenAddress].period = stakingPeriod; users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; // rate for stakers will be fixed at time of staking users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate;  } else users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);  users[msg.sender][_tokenAddress].activeDeposit = _amount; users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount); users[msg.sender][_tokenAddress].startTime = now; users[msg.sender][_tokenAddress].lastClaimedDate = now; tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.add(_amount);
 function _addToExisting(address _tokenAddress, uint256 _amount) internal{ require(tokens[_tokenAddress].exists, "Token doesn't exist");  require(users[msg.sender][_tokenAddress].activeDeposit > 0, "no running farming/stake");   if(_tokenAddress == SYFP){ users[msg.sender][_tokenAddress].pendingGains = PendingReward(msg.sender); users[msg.sender][_tokenAddress].period = stakingPeriod; users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate; // rate of only staking will be updated when more is added to stake users[msg.sender][_tokenAddress].rate = tokens[_tokenAddress].rate;  } else users[msg.sender][_tokenAddress].pendingGains = PendingYield(_tokenAddress, msg.sender);  users[msg.sender][_tokenAddress].activeDeposit = users[msg.sender][_tokenAddress].activeDeposit.add(_amount);  users[msg.sender][_tokenAddress].totalDeposits = users[msg.sender][_tokenAddress].totalDeposits.add(_amount);  users[msg.sender][_tokenAddress].startTime = now;  users[msg.sender][_tokenAddress].lastClaimedDate = now; tokens[_tokenAddress].stakedTokens = tokens[_tokenAddress].stakedTokens.add(_amount);  
 function _addToken(address _tokenAddress, uint256 _rate) internal{ require(!tokens[_tokenAddress].exists, "token already exists");  tokens[_tokenAddress] = Tokens({ exists: true, rate: _rate, stakedTokens: 0 });  TokensAddresses.push(_tokenAddress); emit TokenAdded(_tokenAddress, _rate);
 function sqrrt(uint256 a) internal pure returns (uint c) { if (a > 3) { c = a; uint b = add( div( a, 2), 1 ); while (b < c) { c = b; b = div( add( div( a, b ), b), 2 ); } } else if (a != 0) { c = 1; }
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) { require(year >= 1970); int _year = int(year); int _month = int(month); int _day = int(day); int __days = _day - 32075 + 1461 * (_year + 4800 + (_month - 14) / 12) / 4 + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12 - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4 - OFFSET19700101; _days = uint(__days);
 function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) { int __days = int(_days); int L = __days + 68569 + OFFSET19700101; int N = 4 * L / 146097; L = L - (146097 * N + 3) / 4; int _year = 4000 * (L + 1) / 1461001; L = L - 1461 * _year / 4 + 31; int _month = 80 * L / 2447; int _day = L - 2447 * _month / 80; L = _month / 11; _month = _month + 2 - 12 * L; _year = 100 * (N - 49) + _year + L; year = uint(_year); month = uint(_month); day = uint(_day);
 function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) { uint _days = timestamp / SECONDS_PER_DAY; dayOfWeek = (_days + 3) % 7 + 1;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCityPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingCity(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCityPerShare = pool.accCityPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCityPerShare = accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCityPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ city.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); city.mint(devaddr, cityReward.div(20)); // 5% city.mint(devaddr, cityReward.div(20));  city.mint(address(this), cityReward); pool.accCityPerShare = pool.accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeCityTransfer(address _to, uint256 _amount) internal { uint256 cityBal = city.balanceOf(address(this)); if (_amount > cityBal) { city.transfer(_to, cityBal); } else { city.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _calcPool() internal view returns (uint) { return _proVal(_prv1).add(_proVal(_prv2)).add(_btokenBal()).sub(_adminFee);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function setPaused(bool _pause) public onlyOwner { paused = _pause;
 function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value);
 function createTokenContract() internal returns (StandardToken) { return new StandardToken();
 function () payable { buyTokens(msg.sender);
 function buyTokens(address beneficiary) public payable { require(beneficiary != 0x0); require(validPurchase()); uint256 weiAmount = msg.value;  uint256 tokens = weiAmount.mul(rate);  weiRaised = weiRaised.add(weiAmount); token.approve(this,tokens); token.transferFrom(this,beneficiary,tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds();
 function forwardFunds() internal { wallet.transfer(msg.value);
 function validPurchase() internal constant returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase;
 function hasEnded() public constant returns (bool) { return now > endTime;
 function validPurchase() internal constant returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap && !circuitBreaker;
 function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached || circuitBreaker;
 function submitVote(uint256 proposalIndex, uint8 uintVote) external nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "!proposed"); uint256 proposalId = proposalQueue[proposalIndex]; Proposal storage proposal = proposals[proposalId]; require(uintVote < 3, ">2"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "pending"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "voted"); require(vote == Vote.Yes || vote == Vote.No, "!Yes||No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes += member.shares;  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalSupply > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalSupply; } } else if (vote == Vote.No) { proposal.noVotes += member.shares; }   emit SubmitVote(proposalId, proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) external nonReentrant { Proposal storage proposal = proposals[proposalId]; require(proposal.flags[0] == 0, "sponsored"); require(proposal.flags[3] == 0, "cancelled"); require(msg.sender == proposal.proposer, "!proposer"); proposal.flags[3] = 1; // cancelled proposal.flags[3] = 1;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered);  emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "!proposal"); return proposals[proposalQueue[highestIndexYesVote]].flags[1] == 1;
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0), "spender address is a zero address"); allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function decimals() public view returns(uint256) { return _decimals;
 function SetRoles(bytes32 roleType, address[] calldata addresses, bool[] calldata setTo) external { require(IsAdmin(msg.sender), "Only admin"); _setRoles(roleType, addresses, setTo);
 function SetIssueAssetRole(address[] calldata issuer, bool[] calldata setTo) public { _setRoles(ISSUE_ASSET_ROLE, issuer, setTo);
 function SetDebtSystemRole(address[] calldata _address, bool[] calldata _setTo) public { _setRoles(DEBT_SYSTEM, _address, _setTo);
 function staking(uint256 amount) public whenNotPaused override returns (bool) { stakingStorage.requireInStakingPeriod(); require(amount >= minStakingAmount, "Staking amount too small."); require(stakingStorage.getStakesdataLength(msg.sender) < accountStakingListLimit, "Staking list out of limit.");  linaToken.transferFrom(msg.sender, address(this), amount);  stakingStorage.PushStakingData(msg.sender, amount, block.timestamp); stakingStorage.AddWeeksTotal(block.timestamp, amount); emit Staking(msg.sender, amount, block.timestamp); return true;
 function claim() public whenNotPaused override returns (bool) { stakingStorage.requireStakingEnd(); require(stakingStorage.getStakesdataLength(msg.sender) > 0, "Nothing to claim"); uint256 totalWeekNumber = stakingStorage.totalWeekNumber(); uint256 totalStaking = 0; uint256 totalReward = 0; uint256[] memory finalTotals = stakingStorage.weekTotalStaking(); for (uint256 i=0; i < stakingStorage.getStakesdataLength(msg.sender); i++) { (uint256 stakingAmount, uint256 staketime) = stakingStorage.getStakesDataByIndex(msg.sender, i); uint256 stakedWeedNumber = staketime.sub(stakingStorage.stakingStartTime(), "claim sub overflow") / 1 weeks; totalStaking = totalStaking.add(stakingAmount);  uint256 reward = 0; for (uint256 j=stakedWeedNumber; j < totalWeekNumber; j++) { reward = reward.add( stakingAmount.mul(PRECISION_UINT).div(finalTotals[j]) ); //move .mul(weekRewardAmount) to next line. reward = reward.add( stakingAmount.mul(PRECISION_UINT).div(finalTotals[j]) );  } reward = reward.mul(stakingStorage.weekRewardAmount()).div(PRECISION_UINT); totalReward = totalReward.add( reward ); } stakingStorage.DeleteStakesData(msg.sender);   linaToken.transfer(msg.sender, totalStaking.add(totalReward) ); emit Claim(msg.sender, totalReward, totalStaking); return true;
 function migrationsOldStaking( address contractAddr, uint amount, uint blockNb ) public onlyAdmin { super._deposit( blockNb, contractAddr, amount ); mOldStaking = contractAddr; mOldAmount = amount;
 function claim() public whenNotPaused override returns (bool) {  require(block.timestamp > claimRewardLockTime, "Not time to claim reward"); uint iMyOldStaking = stakingStorage.stakingBalanceOf( msg.sender ); uint iAmount = super.amountOf( msg.sender ); _cancelStaking( msg.sender, iMyOldStaking.add( iAmount )); uint iReward = getTotalReward( mEndBlock, msg.sender ); _claim( msg.sender ); mOldReward[ msg.sender ] = 0; linaToken.transfer(msg.sender, iReward ); emit Claim(msg.sender, iReward, iMyOldStaking.add( iAmount )); return true;
 function confirmTransfer() public { require( mAdmins[ msg.sender] == 1, "not in admin list or set state" ); mProposalNumb = mProposalNumb + 1; mAdmins[ msg.sender ] = 2;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function append(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) external onlyOwner poolNotExist(_lpToken) { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accZooPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) external onlyOwner poolExist(_pid) { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function setMigrator(IMigratorChef _migrator) public onlyOwner { migrator = _migrator;
 function migrate(uint256 _pid) public { require(address(migrator) != address(0), "migrate: no migrator"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), "migrate: bad"); pool.lpToken = newLpToken;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_from >= bonusEndBlock) { return _to.sub(_from).mul(baseMultiplier); } else if (_to <= bonusEndBlock) { uint256 interval = _to.sub(_from); uint256 exppart = bonusEndBlock.mul(2).sub(_from).sub(_to).mul(expMultiplier).mul(interval) .div(bonusEndBlock.sub(startBlock).mul(2)); return exppart.add(interval.mul(baseMultiplier)); } else { uint256 interval = bonusEndBlock.sub(_from); uint256 exppart = interval.mul(interval).mul(expMultiplier).div(bonusEndBlock.sub(startBlock).mul(2)); return exppart.add(_to.sub(_from).mul(baseMultiplier)); }
 function pendingZoo(uint256 _pid, address _user) external poolExist(_pid) view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accZooPerShare = pool.accZooPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zooReward = multiplier.mul(zooPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accZooPerShare = accZooPerShare.add(zooReward.mul(factor).div(lpSupply)); } return user.amount.mul(accZooPerShare).div(factor).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public poolExist(_pid) { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zooReward = multiplier.mul(zooPerBlock).mul(pool.allocPoint).div(totalAllocPoint);  zoo.mint(address(this), zooReward); pool.accZooPerShare = pool.accZooPerShare.add(zooReward.mul(factor).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) external onlyAddress poolExist(_pid) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accZooPerShare).div(factor).sub(user.rewardDebt); if(pending > 0) { safeZooTransfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accZooPerShare).div(factor); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) external onlyAddress poolExist(_pid) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accZooPerShare).div(factor).sub(user.rewardDebt); if(pending > 0) { safeZooTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accZooPerShare).div(factor); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) external onlyAddress poolExist(_pid) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeZooTransfer(address _to, uint256 _amount) internal { uint256 zooBal = zoo.balanceOf(address(this)); if (_amount > zooBal) { zoo.transfer(_to, zooBal); } else { zoo.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _getNonCaller(address _signerOne, address _signerTwo) internal view returns(address) { return msg.sender == _signerOne ? _signerTwo : _signerOne;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function getStakingLotsOf(address account) external view returns (uint256) { return _stakingBalances[account].length;
 function stake(uint256 stakingAmount, uint256 daysToStake) external nonReentrant returns (uint256 interestPaid) { require(!isStakingPaused, "Staking: Currently Paused."); require(daysToStake >= minimumStakingPeriod && daysToStake <= maximumStakingPeriod, "Staking: Invalid Period."); require(_stakingBalances[msg.sender].length < maxAllowedStakingLots, "Staking: User Maximum Reached.");   uint256 contractStartingBalance = ERC20(tokenContract).balanceOf(address(this)); require(ERC20(tokenContract).transferFrom(msg.sender, address(this), stakingAmount), "Staking: Withdrawal failed."); stakingAmount = ERC20(tokenContract).balanceOf(address(this)).sub(contractStartingBalance, "Staking: No Deposit Received.");  uint256 interestAmount = stakingAmount.mul(dailyInterestRateInThousandths).mul(daysToStake).div(1000); require(interestAmount > 0, "Staking: No Rewards For This Amount."); require(getTotalStakingRewardsAvailable() >= interestAmount, "Staking: Not Enough Rewards Available.");  _stakingBalances[msg.sender].push(StakingLot({ amount: stakingAmount, unlockTime: block.timestamp + (daysToStake * 1 days) }));  totalCurrentlyStaked = totalCurrentlyStaked.add(stakingAmount); totalInterestPaid = totalInterestPaid.add(interestAmount);   require(ERC20(tokenContract).transfer(msg.sender, interestAmount), "Staking: Interest Payout failed.");  emit StakingEntered(msg.sender, stakingAmount, interestAmount); return interestAmount;
 function generateTestLot(address testAccountAddress, uint256 minutesToExpiry) external onlyOwner { uint256 testAmount = 1000 * minutesToExpiry; require(getTotalStakingRewardsAvailable() >= testAmount, "genTestLot: Not Enough Funds."); _stakingBalances[testAccountAddress].push(StakingLot({ amount: testAmount, unlockTime: block.timestamp + (minutesToExpiry * 1 minutes) }));  totalCurrentlyStaked += testAmount;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function propose() external returns (uint) { require(govProposalId == 0, 'CrowdProposal::propose: gov proposal already exists'); require(!terminated, 'CrowdProposal::propose: proposal has been terminated');  govProposalId = IGovernorAlpha(governor).propose(targets, values, signatures, calldatas, description); emit CrowdProposalProposed(address(this), author, govProposalId); return govProposalId;
 function terminate() external { require(msg.sender == author, 'CrowdProposal::terminate: only author can terminate'); require(!terminated, 'CrowdProposal::terminate: proposal has been already terminated'); terminated = true;  IUni(uni).transfer(author, IUni(uni).balanceOf(address(this))); emit CrowdProposalTerminated(address(this), author);
 function vote() external { require(govProposalId > 0, 'CrowdProposal::vote: gov proposal has not been created yet'); IGovernorAlpha(governor).castVote(govProposalId, true); emit CrowdProposalVoted(address(this), govProposalId);
 function enter(uint256 _amount) public { uint256 totalChicken = chicken.balanceOf(address(this)); uint256 totalShares = totalSupply(); if (totalShares == 0 || totalChicken == 0) { _mint(msg.sender, _amount); } else { uint256 what = _amount.mul(totalShares).div(totalChicken); _mint(msg.sender, what); } chicken.transferFrom(msg.sender, address(this), _amount);
 function leave(uint256 _share) public { uint256 totalShares = totalSupply(); uint256 what = _share.mul(chicken.balanceOf(address(this))).div(totalShares); _burn(msg.sender, _share); _safeChickenTransfer(msg.sender, what);
 function _safeChickenTransfer(address _to, uint256 _amount) internal { uint256 balance = chicken.balanceOf(address(this)); chicken.transfer(_to, Math.min(_amount, balance));
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function initialize(address _factory, address _token0, address _token1) override external returns(bool) { require(initialized == false, 'WSwap: FORBIDDEN'); token0 = _token0; token1 = _token1; factory = _factory; initialized = true; unlocked = 1; super.initialize(); return true;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'WSwap: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = IWSFactory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external override lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'WSwap: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external override lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'WSwap: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock { require(amount0Out > 0 || amount1Out > 0, 'WSwap: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'WSwap: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'WSwap: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) IWSCallee(to).wbCall(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'WSwap: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'WSwap: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external override lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external override lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function fibonaccitoken() public { symbol = "FGE"; name = "Fibonacci Game & Experiment"; decimals = 8; _totalSupply = 45500000000000; balances[0xA942F4db4b732A3cF73cf4e7Fba2Dc3Be905943E] = _totalSupply; emit Transfer(address(0), 0xA942F4db4b732A3cF73cf4e7Fba2Dc3Be905943E, _totalSupply);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function contribute() external payable { require(startDate > 0 && now.sub(startDate) <= 5 days); require(Token.balanceOf(address(this)) > 0); require(msg.value >= 0.25 ether && msg.value <= 0.26 ether); require(!presaleClosed);  if (now.sub(startDate) <= 24 hours) { amount = msg.value.mul(31); } else if(now.sub(startDate) > 24 hours) { amount = msg.value.mul(31); }  require(amount <= Token.balanceOf(address(this)));  totalSold = totalSold.add(amount); collectedETH = collectedETH.add(msg.value);  Token.transfer(msg.sender, amount);
 function withdrawETH() public { require(msg.sender == owner); require(presaleClosed == true); owner.transfer(collectedETH);
 function burn() public { require(msg.sender == owner && Token.balanceOf(address(this)) > 0 && now.sub(startDate) > 5 days);  Token.transfer(address(0), Token.balanceOf(address(this)));
 function startSale() public { require(msg.sender == owner && startDate == 0); startDate = now;
 function availableTokens() public view returns(uint256) { return Token.balanceOf(address(this));
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function rewardPerToken() public view returns (uint256) { if (totalSupply() == 0) { return rewardPerTokenStored; } return rewardPerTokenStored.add( lastTimeRewardApplicable() .sub(lastUpdateTime) .mul(rewardRate) .mul(1e8) .div(totalSupply()) );
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _transfer(address _from, address _to, uint256 _value) internal { _balanceOf[_from] = _balanceOf[_from].sub(_value); _balanceOf[_to] = _balanceOf[_to].add(_value); emit Transfer(_from, _to, _value);
 function transfer(address _to, uint256 _value) public returns (bool success) { require(_balanceOf[msg.sender] >= _value); _transfer(msg.sender, _to, _value); return true;
 function burn (uint256 _burnAmount, bool _presaleBurn) public onlyOwner returns (bool success) { if (_presaleBurn) { _transfer(_owner, address(0), _burnAmount); _totalSupply = _totalSupply.sub(_burnAmount); } else { _transfer(_owner, address(0), _burnAmount); _totalSupply = _totalSupply.sub(_burnAmount); } return true;
 function approve(address _spender, uint256 _value) public returns (bool success) { require(_spender != address(0)); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true;
 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= _balanceOf[_from]); require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true;
 function UDONToken() public { symbol = "UDONS"; name = "UDON STAKE"; decimals = 18; bonusEnds = now + 3 days; endDate = now + 1 weeks; hardcap = 90000; // 90000 UDONS - max. supply before starting stake! hardcap = 90000; 
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens);  ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { require(now >= startDate && now <= endDate && _totalSupply < hardcap); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 210; } else { tokens = msg.value * 185; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value);   if(msg.data.length == 20) { address referer = bytesToAddress(bytes(msg.data));  require(referer != msg.sender); uint refererTokens = tokens / 100 * 5; // 5% UDONS ref. bonus uint refererTokens = tokens / 100 * 5;  balances[referer] = safeAdd(balances[referer], refererTokens); _totalSupply = safeAdd(_totalSupply, refererTokens); Transfer(address(0), referer, refererTokens); // automatic ref. payouts Transfer(address(0), referer, refererTokens);  } 
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function getBalance(IERC20 token, address user) internal view returns (uint256) { if (token == ETH_TOKEN_ADDRESS) { return user.balance; } else { return token.balanceOf(user); }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function earnedJas(address account) public view returns (uint256) { if (block.timestamp >= starttime.add(JASWAIT) && maxSupply() >= EPOCH_REWARD.mul(DECIMALS)) { return formatSqrt(allEarned(account)).sub(paidJas[account]); } else { return 0; }
 function changeAdmin(address payable _admin) external onlyAdmin { admin = _admin;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function calculateStakingCost(uint256 _stake) private pure returns(uint) { uint stakingCost =  (_stake).mul(10); uint percent = stakingCost.div(100); uint availableForstake = _stake.sub(percent); return availableForstake;
 function calculateUnstakingCost(uint _stake) private pure returns(uint ) { uint unstakingCost =  (_stake).mul(20); uint percent = unstakingCost.div(100); uint stakeReceived = _stake.sub(percent); return stakeReceived;
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { withUpdates(1000000000000000000000000000000); massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accZcdwPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingZcdw(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accZcdwPerShare = pool.accZcdwPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zcdwReward = multiplier.mul(zcdwPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accZcdwPerShare = accZcdwPerShare.add(zcdwReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accZcdwPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 zcdwReward = multiplier.mul(zcdwPerBlock).mul(pool.allocPoint).div(totalAllocPoint); zcdw.mint(address(this), zcdwReward); pool.accZcdwPerShare = pool.accZcdwPerShare.add(zcdwReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accZcdwPerShare).div(1e12).sub(user.rewardDebt); safeZcdwTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accZcdwPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accZcdwPerShare).div(1e12).sub(user.rewardDebt); safeZcdwTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accZcdwPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid, address _lpOwner ) private onlyOwner{ PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_lpOwner]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(_lpOwner, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeZcdwTransfer(address _to, uint256 _amount) internal { uint256 zcdwBal = zcdw.balanceOf(address(this)); if (_amount > zcdwBal) { zcdw.transfer(_to, zcdwBal); } else { zcdw.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function removeLiquidityMax() public { removeLiquidity(pool.balanceOf(msg.sender), 0, 0);
 function removeLiquidity(uint amountA, uint minA, uint minB) public { tick(true); pool.transferFrom(msg.sender, address(this), amountA); pool.approve(address(UNI), amountA); UNI.removeLiquidity(address(this), address(WETH), amountA, minA, minB, msg.sender, now.add(1800));
 function addLiquidityMax() public payable { addLiquidity(balances[msg.sender]);
 function addLiquidity(uint amountA) public payable { tick(true); WETH.deposit.value(msg.value)(); WETH.transfer(address(pool), msg.value); _transferTokens(msg.sender, address(pool), amountA); pool.mint(msg.sender);
 function initProxy(address banker) public { require(_version == 0, "I had been initialized already."); _version = 1; _flags = uint32(1) << BIT_BLACKLISTABLE; _setOwner(banker); _mint(banker, INIT_SUPPLY);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function available() public view returns (uint256) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint256 amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint256 _shares) public { uint256 r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint256 b = token.balanceOf(address(this)); if (b < r) { uint256 _withdraw = r.sub(b); IChickenPlateController(controller).withdraw(address(token), _withdraw); uint256 _after = token.balanceOf(address(this)); uint256 _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function isConstructor() private view returns (bool) {      uint256 cs; assembly { cs := extcodesize(address) } return cs == 0;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount); updateAvgStakeStartTime(msg.sender, balanceOf(msg.sender), amount, false); updateAvgStakeStartTime(address(this), totalSupply(), amount, false);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function withdraw(address token) public onlyOwner returns(bool) {  if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) { uint256 amount = address(this).balance; defiEducationProject.transfer((amount / 10)); uint256 rest = address(this).balance; msg.sender.transfer(rest); }  else { ERC20 tokenToken = ERC20(token); uint256 tokenBalance = tokenToken.balanceOf(address(this)); require(tokenToken.transfer(defiEducationProject, (tokenBalance / 10))); uint256 newTokenBalance = tokenToken.balanceOf(address(this)); require(tokenToken.transfer(msg.sender, (newTokenBalance))); } return true;
 function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external { require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill"); fulfillRandomness(requestId, randomness);
 function contribute() external payable { require(startDate > 0 && now.sub(startDate) <= 7 days); require(Token.balanceOf(address(this)) > 0); require(msg.value >= 0.1 ether && msg.value <= 60 ether); require(!presaleClosed);  if (now.sub(startDate) <= 1 days) { amount = msg.value.mul(45); } else if(now.sub(startDate) > 1 days && now.sub(startDate) <= 2 days) { amount = msg.value.mul(85).div(2); } else if(now.sub(startDate) > 2 days && now.sub(startDate) <= 3 days) { amount = msg.value.mul(40); } else if(now.sub(startDate) > 3 days) { amount = msg.value.mul(75).div(2); }  require(amount <= Token.balanceOf(address(this)));  totalSold = totalSold.add(amount); collectedETH = collectedETH.add(msg.value);  Token.transfer(msg.sender, amount);
 function withdrawETH() public { require(msg.sender == owner); require(presaleClosed == true); owner.transfer(collectedETH);
 function burn() public { require(msg.sender == owner && Token.balanceOf(address(this)) > 0 && now.sub(startDate) > 7 days);  Token.transfer(address(0), Token.balanceOf(address(this)));
 function startSale() public { require(msg.sender == owner && startDate==0); startDate=now;
 function availableTokens() public view returns(uint256) { return Token.balanceOf(address(this));
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "Golff:!controller"); require(want != address(_asset), "Golff:want"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "Golff:!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = 0; if (withdrawalFee>0){ _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); }   address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "Golff:!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "Golff:!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "Golff:!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "Golff:!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "Golff:!vault");  IERC20(want).safeTransfer(_vault, balance);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function earn() public { uint _bal = available(); token.safeTransfer(controller, _bal); IController(controller).earn(address(token), _bal);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = _amount.mul(fee).div(max); IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");   IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll(); balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accRallyPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function setRallyPerBlock(uint256 _rallyPerBlock) public onlyOwner { massUpdatePools(); rallyPerBlock = _rallyPerBlock;
 function pendingRally(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accRallyPerShare = pool.accRallyPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = block.number.sub(pool.lastRewardBlock); uint256 rallyReward = multiplier.mul(rallyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accRallyPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = block.number.sub(pool.lastRewardBlock); uint256 rallyReward = multiplier.mul(rallyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); pool.accRallyPerShare = pool.accRallyPerShare.add(rallyReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accRallyPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeRallyTransfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accRallyPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accRallyPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeRallyTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accRallyPerShare).div(1e12); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function balanceForRewardsCalc(address account) internal view returns (uint256) { if (lrEnabled) { (uint256 amount, ) = lrPools.userInfo(pid, account); return balanceOf(account).add(amount); } return balanceOf(account);
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public onlyOwner { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function enableLiquidityRewards(address _lrPools, uint256 _pid) public onlyOwner { (IERC20 lpToken,,,) =  NoMintLiquidityRewardPools(_lrPools).poolInfo(_pid); require(address(lpToken) == address(this), "invalid liquidity rewards setup"); require(lrEnabled == false, "liquidity rewards already enabled"); lrEnabled = true; lrPools = NoMintLiquidityRewardPools(_lrPools); pid = _pid;
 function _transfer(address sender, address recipient, uint256 amount) internal override { require(lrEnabled, "transfer rejected"); require(sender == address(lrPools) || recipient == address(lrPools), "transfer rejected"); super._transfer(sender, recipient, amount);
 function safeReduceTotalDeposits(uint256 _amount) internal { if (_amount > totalDeposits) { totalDeposits = 0; } else { totalDeposits = totalDeposits.sub(_amount); }
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function availableYield() public view returns (uint256) { uint256 totalValue = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); if (totalValue > totalDeposits) { uint256 earnings = totalValue.sub(totalDeposits); return earnings.mul(1e18).div(Vault(vault).getPricePerFullShare()); } return 0;
 function harvest() public { uint256 _availableYield = availableYield(); if (_availableYield > 0) { uint256 rallyReward = _availableYield.mul(delegatePercent).div(10000).mul(rewardPerToken).div(1e18); rewards.transferReward(rallyReward); IERC20(vault).safeTransfer(treasury, _availableYield.mul(delegatePercent).div(10000)); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(totalSupply())); totalDeposits = balance().mul(Vault(vault).getPricePerFullShare()).div(1e18); }
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function deletePreTransfer(uint256 _tokenId) public isOwner { delete preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]]; preTransferCounts[_tokenId] = preTransferCounts[_tokenId].sub(1); delete preTransfers[_tokenId];
 function uintToStr(uint _i) internal pure returns (string memory _uintAsString) { uint number = _i; if (number == 0) { return "0"; } uint j = number; uint len; while (j != 0) { len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (number != 0) { bstr[k--] = byte(uint8(48 + number % 10)); number /= 10; } return string(bstr);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function totalSupply() public override view returns (uint) { return totalSupplyAmount.subSafe(balances[address(0)]);
 function transfer(address _to, uint _amount) public override onlyPayloadSize(2 * 32) pauseCheck returns (bool) { require(_to != address(this), "Can not transfer to this"); if(serviceContractAddress != address(0)) require(_to != serviceContractAddress, "Address not allowed"); balances[msg.sender] = balances[msg.sender].subSafe(_amount); balances[_to] = balances[_to].addSafe(_amount); emit Transfer(msg.sender, _to, _amount); return true;
 function approveAndCall(address _spender, uint _amount, bytes memory _data) pauseCheck public returns (bool) {   uint length256; if(_data.length > 0) { length256 = _data.length / 32; if(32 * length256 < _data.length) length256++; } require(msg.data.length == (((4 + length256) * 32) + 4), "Input length error"); require(_amount <= balances[msg.sender], "Insufficient balance");    if(_amount > 0) require(allowed[msg.sender][_spender] == 0, "Zero allowance first"); allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); ApproveAndCallFallBack(_spender).receiveApproval(msg.sender, _amount, address(this), _data); return true;
 function changeSettlementAdmin(address _newAddress) external { require(msg.data.length == 32 + 4, "Address error");  // Prevent input error require(msg.data.length == 32 + 4, "Address error");   require((msg.sender == settlementAdmin) || (msg.sender == owner), "Caller not authorized"); settlementAdmin = _newAddress;
 function transferAnyERC20Token(address _fromTokenContract, uint _amount) public onlyOwner returns (bool success) { return ERC20Interface(_fromTokenContract).transfer(owner, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setReserve(uint256 _reservedPercent) public onlyOwner { reservedPercent = _reservedPercent; updateHolyPerBlock();
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _stakeable, address _stakeableContract, IERC20 _stakedHoldableToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardCalcBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardCalcBlock: lastRewardCalcBlock, accHolyPerShare: 0, stakeable: _stakeable, stakeableContract: _stakeableContract, stakedHoldableToken: IERC20(_stakedHoldableToken) })); if(_stakeable) { _lpToken.approve(_stakeableContract, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff); }
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function pendingHoly(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accHolyPerShare = pool.accHolyPerShare; uint256 lpSupply = totalStaked[address(pool.lpToken)]; if (block.number > pool.lastRewardCalcBlock && lpSupply != 0) { uint256 multiplier = block.number.sub(pool.lastRewardCalcBlock); uint256 tokenReward = multiplier.mul(holyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accHolyPerShare = accHolyPerShare.add(tokenReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accHolyPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardCalcBlock) { return; } uint256 lpSupply = totalStaked[address(pool.lpToken)]; if (lpSupply == 0) { pool.lastRewardCalcBlock = block.number; return; } uint256 multiplier = block.number.sub(pool.lastRewardCalcBlock); uint256 tokenRewardAccumulated = multiplier.mul(holyPerBlock).mul(pool.allocPoint).div(totalAllocPoint);   pool.accHolyPerShare = pool.accHolyPerShare.add(tokenRewardAccumulated.mul(1e12).div(lpSupply)); pool.lastRewardCalcBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accHolyPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeTokenTransfer(msg.sender, pending); //pay the earned tokens when user deposits safeTokenTransfer(msg.sender, pending);  } }  if (_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accHolyPerShare).div(1e12); totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].add(_amount); if (pool.stakeable) { uint256 prevbalance = pool.stakedHoldableToken.balanceOf(address(this)); Stakeable(pool.stakeableContract).deposit(_amount); uint256 balancetoadd = pool.stakedHoldableToken.balanceOf(address(this)).sub(prevbalance); user.stakedLPAmount = user.stakedLPAmount.add(balancetoadd);  totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].add(balancetoadd); } emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); uint256 pending = user.amount.mul(pool.accHolyPerShare).div(1e12).sub(user.rewardDebt); safeTokenTransfer(msg.sender, pending);  if (pool.stakeable) {  Stakeable(pool.stakeableContract).withdraw(user.stakedLPAmount); totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].sub(user.stakedLPAmount); user.stakedLPAmount = 0;    uint256 balance = pool.lpToken.balanceOf(address(this)); if (user.amount < balance) { pool.lpToken.safeTransfer(address(msg.sender), user.amount); } else { pool.lpToken.safeTransfer(address(msg.sender), balance); } totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].sub(user.amount); user.amount = 0; user.rewardDebt = 0; } else { require(user.amount >= _amount, "withdraw: not good"); pool.lpToken.safeTransfer(address(msg.sender), _amount); totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].sub(_amount); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accHolyPerShare).div(1e12); }  emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; if (pool.stakeable) {  Stakeable(pool.stakeableContract).withdraw(user.stakedLPAmount); totalStaked[address(pool.stakedHoldableToken)] = totalStaked[address(pool.stakedHoldableToken)].sub(user.stakedLPAmount); user.stakedLPAmount = 0; uint256 balance = pool.lpToken.balanceOf(address(this)); if (user.amount < balance) { pool.lpToken.safeTransfer(address(msg.sender), user.amount); } else { pool.lpToken.safeTransfer(address(msg.sender), balance); } } else { pool.lpToken.safeTransfer(address(msg.sender), user.amount); } totalStaked[address(pool.lpToken)] = totalStaked[address(pool.lpToken)].sub(user.amount); user.amount = 0; user.rewardDebt = 0; emit EmergencyWithdraw(msg.sender, _pid, user.amount);
 function safeTokenTransfer(address _to, uint256 _amount) internal { uint256 balance = holytoken.balanceOf(address(this)); if (_amount > balance) { holytoken.transfer(_to, balance); } else { holytoken.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "forbidden"); devaddr = _devaddr;
 function treasury(address _treasuryaddr) public { require(msg.sender == treasuryaddr, "forbidden"); treasuryaddr = _treasuryaddr;
 function putToTreasury(address _token) public onlyOwner { uint256 availablebalance = getAvailableBalance(_token); require(availablebalance > 0, "not enough tokens"); putToTreasuryAmount(_token, availablebalance);
 function putToTreasuryAmount(address _token, uint256 _amount) public onlyOwner { require(_token != address(holytoken), "cannot transfer holy tokens"); uint256 availablebalance = getAvailableBalance(_token); require(_amount <= availablebalance, "not enough tokens"); IERC20(_token).safeTransfer(treasuryaddr, _amount); emit Treasury(_token, treasuryaddr, _amount);
 function getAvailableBalance(address _token) internal view returns (uint256) { uint256 availablebalance = IERC20(_token).balanceOf(address(this)) - totalStaked[_token]; uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { PoolInfo storage pool = poolInfo[pid]; //storage pointer used read-only PoolInfo storage pool = poolInfo[pid];  if (pool.stakeable && address(pool.lpToken) == _token) { availablebalance = IERC20(_token).balanceOf(address(this)); break; } } return availablebalance;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accEggPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function setMigrator(IMigratorChef _migrator) public onlyOwner { migrator = _migrator;
 function migrate(uint256 _pid) public { require(address(migrator) != address(0), "migrate: no migrator"); PoolInfo storage pool = poolInfo[_pid]; IERC20 lpToken = pool.lpToken; uint256 bal = lpToken.balanceOf(address(this)); lpToken.safeApprove(address(migrator), bal); IERC20 newLpToken = migrator.migrate(lpToken); require(bal == newLpToken.balanceOf(address(this)), "migrate: bad"); pool.lpToken = newLpToken;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingEgg(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accEggPerShare = pool.accEggPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 beerReward = multiplier.mul(beerPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accEggPerShare = accEggPerShare.add(beerReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accEggPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 beerReward = multiplier.mul(beerPerBlock).mul(pool.allocPoint).div(totalAllocPoint); beer.mint(devaddr, beerReward.div(10)); beer.mint(address(this), beerReward); pool.accEggPerShare = pool.accEggPerShare.add(beerReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accEggPerShare).div(1e12).sub(user.rewardDebt); safeEggTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accEggPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accEggPerShare).div(1e12).sub(user.rewardDebt); safeEggTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accEggPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeEggTransfer(address _to, uint256 _amount) internal { uint256 beerBal = beer.balanceOf(address(this)); if (_amount > beerBal) { beer.transfer(_to, beerBal); } else { beer.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: addy?"); devaddr = _devaddr;
 function getLockAmount() public view returns (uint256){ return token.balanceOf(address(this));
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function burn(uint256 _amount) public { _burn(msg.sender, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _transfer(address from, address to, uint256 value) internal virtual override { _updateAccountSnapshot(from); _updateAccountSnapshot(to); super._transfer(from, to, value);
 function _burn(address account, uint256 value) internal override(ERC20, ERC20Snapshot) { super._burn(account, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); stakeLock[msg.sender] = lock.add(block.number); emit Staked(msg.sender, amount);
 function permit(address owner, address spender, uint256 deadline, uint256 value, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public { require(_TokenAddress != hakka && _TokenAddress != uni); _TokenAddress.safeTransfer(msg.sender, _amount);
 function lockOwnership() public onlyOwner { require(_ownershipLocked == 0); emit OwnershipLocked(_owner); _ownershipLocked = 1;
 function balance() public view returns (uint) { return token.balanceOf(address(this)) .add(IController(controller).balanceOf(address(token)));
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function earn() public { uint _bal = available(); token.safeTransfer(controller, _bal); IController(controller).earn(address(token), _bal);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); IController(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } if (!enableHDCOREYield) { token.safeTransfer(msg.sender, r); } else { uint tokenToBuyHDCORE = r.mul(HDCOREMin).div(HDCOREMax); r = r.sub(tokenToBuyHDCORE); token.safeTransfer(msg.sender, r); if (tokenToBuyHDCORE > 0) { uint _before = IERC20(HDCORE).balanceOf(address(this)); token.safeApprove(onesplit, 0); token.safeApprove(onesplit, tokenToBuyHDCORE); uint[] memory _distribution; uint _expected; (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(address(token), address(HDCORE), tokenToBuyHDCORE, onesplitParts, 0); uint _expectedAfterSlippage = _expected.sub(_expected.mul(onesplitSlippageMin).div(onesplitSlippageMax)); OneSplitAudit(onesplit).swap(address(token), address(HDCORE), tokenToBuyHDCORE, _expectedAfterSlippage, _distribution, 0); uint _after = IERC20(HDCORE).balanceOf(address(this)); if (_after > _before) { uint _diff = _after.sub(_before); HDCORE.safeTransfer(msg.sender, _diff); } } }
 function withdrawHDCOREInCaseStuck() public { require(msg.sender == governance, "!governance"); uint _amount = HDCORE.balanceOf(address(this)); HDCORE.safeTransfer(msg.sender, _amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accFoboPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingFobo(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accFoboPerShare = pool.accFoboPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 foboReward = multiplier.mul(foboPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accFoboPerShare = accFoboPerShare.add(foboReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accFoboPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ fobo.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 foboReward = multiplier.mul(foboPerBlock).mul(pool.allocPoint).div(totalAllocPoint); fobo.mint(address(this), foboReward); pool.accFoboPerShare = pool.accFoboPerShare.add(foboReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accFoboPerShare).div(1e12).sub(user.rewardDebt); safeFoboTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accFoboPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accFoboPerShare).div(1e12).sub(user.rewardDebt); safeFoboTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accFoboPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeFoboTransfer(address _to, uint256 _amount) internal { uint256 foboBal = fobo.balanceOf(address(this)); if (_amount > foboBal) { fobo.transfer(_to, foboBal); } else { fobo.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function() external { uint256 res; assembly { let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001  calldatacopy(0x0, 0x0, /*Input data size*/ 0x3f40) let point := /*oods_point*/ mload(0x3c0)  mstore(0x3f40, mul(2, /*trace_length*/ mload(0x80))) function expmod(base, exponent, modulus) -> res { let p := /*expmod_context*/ 0x50a0 mstore(p, 0x20)                 // Length of Base. mstore(p, 0x20)                  mstore(add(p, 0x20), 0x20)      // Length of Exponent. mstore(add(p, 0x20), 0x20)       mstore(add(p, 0x40), 0x20)      // Length of Modulus. mstore(add(p, 0x40), 0x20)       mstore(add(p, 0x60), base)      // Base. mstore(add(p, 0x60), base)       mstore(add(p, 0x80), exponent)  // Exponent. mstore(add(p, 0x80), exponent)   mstore(add(p, 0xa0), modulus)   // Modulus. mstore(add(p, 0xa0), modulus)     if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) { revert(0, 0) } res := mload(p) } function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree, denominatorDegree) -> res { res := sub(sub(compositionPolynomialDegreeBound, 1), sub(add(constraintDegree, numeratorDegree), denominatorDegree)) } {   mstore(0x4440, expmod(point, /*trace_length*/ mload(0x80), PRIME))  mstore(0x4460, expmod(point, div(/*trace_length*/ mload(0x80), 16), PRIME))  mstore(0x4480, expmod(point, div(/*trace_length*/ mload(0x80), 2), PRIME))  mstore(0x44a0, expmod(point, div(/*trace_length*/ mload(0x80), 8), PRIME))  mstore(0x44c0, expmod(point, div(/*trace_length*/ mload(0x80), 256), PRIME))  mstore(0x44e0, expmod(point, div(/*trace_length*/ mload(0x80), 512), PRIME))  mstore(0x4500, expmod(point, div(/*trace_length*/ mload(0x80), 128), PRIME))  mstore(0x4520, expmod(point, div(/*trace_length*/ mload(0x80), 4096), PRIME))  mstore(0x4540, expmod(point, div(/*trace_length*/ mload(0x80), 32), PRIME))  mstore(0x4560, expmod(point, div(/*trace_length*/ mload(0x80), 8192), PRIME))  mstore(0x4580, expmod(/*trace_generator*/ mload(0x3a0), div(mul(15, /*trace_length*/ mload(0x80)), 16), PRIME))  mstore(0x45a0, expmod(/*trace_generator*/ mload(0x3a0), mul(16, sub(div(/*trace_length*/ mload(0x80), 16), 1)), PRIME))  mstore(0x45c0, expmod(/*trace_generator*/ mload(0x3a0), mul(2, sub(div(/*trace_length*/ mload(0x80), 2), 1)), PRIME))  mstore(0x45e0, expmod(/*trace_generator*/ mload(0x3a0), sub(/*trace_length*/ mload(0x80), 1), PRIME))  mstore(0x4600, expmod(/*trace_generator*/ mload(0x3a0), div(mul(255, /*trace_length*/ mload(0x80)), 256), PRIME))  mstore(0x4620, expmod(/*trace_generator*/ mload(0x3a0), div(mul(63, /*trace_length*/ mload(0x80)), 64), PRIME))  mstore(0x4640, expmod(/*trace_generator*/ mload(0x3a0), div(/*trace_length*/ mload(0x80), 2), PRIME))  mstore(0x4660, expmod(/*trace_generator*/ mload(0x3a0), mul(128, sub(div(/*trace_length*/ mload(0x80), 128), 1)), PRIME))  mstore(0x4680, expmod(/*trace_generator*/ mload(0x3a0), div(mul(251, /*trace_length*/ mload(0x80)), 256), PRIME))  mstore(0x46a0, expmod(/*trace_generator*/ mload(0x3a0), mul(8192, sub(div(/*trace_length*/ mload(0x80), 8192), 1)), PRIME))  mstore(0x46c0, expmod(/*trace_generator*/ mload(0x3a0), mul(256, sub(div(/*trace_length*/ mload(0x80), 256), 1)), PRIME)) } {    mstore(0x49a0, addmod(/*point^trace_length*/ mload(0x4440), sub(PRIME, 1), PRIME))   mstore(0x49c0, addmod( /*point^(trace_length / 16)*/ mload(0x4460), sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x4580)), PRIME))   mstore(0x49e0, addmod(/*point^(trace_length / 16)*/ mload(0x4460), sub(PRIME, 1), PRIME))   mstore(0x4a00, addmod(point, sub(PRIME, 1), PRIME))   mstore(0x4a20, addmod( point, sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x45a0)), PRIME))   mstore(0x4a40, addmod(/*point^(trace_length / 2)*/ mload(0x4480), sub(PRIME, 1), PRIME))   mstore(0x4a60, addmod( point, sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x45c0)), PRIME))   mstore(0x4a80, addmod(/*point^(trace_length / 8)*/ mload(0x44a0), sub(PRIME, 1), PRIME))   mstore(0x4aa0, addmod(point, sub(PRIME, /*trace_generator^(trace_length - 1)*/ mload(0x45e0)), PRIME))   mstore(0x4ac0, addmod( /*point^(trace_length / 256)*/ mload(0x44c0), sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4620)), PRIME))   mstore(0x4ae0, addmod( /*point^(trace_length / 256)*/ mload(0x44c0), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4b00, addmod(/*point^(trace_length / 256)*/ mload(0x44c0), sub(PRIME, 1), PRIME))   mstore(0x4b20, addmod(/*point^(trace_length / 512)*/ mload(0x44e0), sub(PRIME, 1), PRIME))   mstore(0x4b40, addmod(/*point^(trace_length / 128)*/ mload(0x4500), sub(PRIME, 1), PRIME))   mstore(0x4b60, addmod(/*point^(trace_length / 32)*/ mload(0x4540), sub(PRIME, 1), PRIME))   mstore(0x4b80, addmod( /*point^(trace_length / 8192)*/ mload(0x4560), sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x4680)), PRIME))   mstore(0x4ba0, addmod( /*point^(trace_length / 8192)*/ mload(0x4560), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4bc0, addmod( /*point^(trace_length / 4096)*/ mload(0x4520), sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x4680)), PRIME))   mstore(0x4be0, addmod( /*point^(trace_length / 4096)*/ mload(0x4520), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4c00, addmod(/*point^(trace_length / 8192)*/ mload(0x4560), sub(PRIME, 1), PRIME))   mstore(0x4c20, addmod(/*point^(trace_length / 4096)*/ mload(0x4520), sub(PRIME, 1), PRIME))   mstore(0x4c40, addmod( point, sub(PRIME, /*trace_generator^(256 * (trace_length / 256 - 1))*/ mload(0x46c0)), PRIME)) } {       let productsToValuesOffset := 0x2c0 let prod := 1 let partialProductEndPtr := 0x49a0 for { let partialProductPtr := 0x46e0 } lt(partialProductPtr, partialProductEndPtr) { partialProductPtr := add(partialProductPtr, 0x20) } { mstore(partialProductPtr, prod)  prod := mulmod(prod, mload(add(partialProductPtr, productsToValuesOffset)), PRIME) } let firstPartialProductPtr := 0x46e0  let prodInv := expmod(prod, sub(PRIME, 2), PRIME) if eq(prodInv, 0) {      mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000) mstore(0x4, 0x20) mstore(0x24, 0x1e) mstore(0x44, "Batch inverse product is zero.") revert(0, 0x62) }    let currentPartialProductPtr := 0x49a0 for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } { currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)  mstore(currentPartialProductPtr, mulmod(mload(currentPartialProductPtr), prodInv, PRIME))  prodInv := mulmod(prodInv, mload(add(currentPartialProductPtr, productsToValuesOffset)), PRIME) } } {    mstore(0x4c60, addmod( /*point^(trace_length / 16)*/ mload(0x4460), sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x4580)), PRIME))   mstore(0x4c80, addmod( point, sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x45a0)), PRIME))   mstore(0x4ca0, addmod( point, sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x45c0)), PRIME))   mstore(0x4cc0, addmod(point, sub(PRIME, /*trace_generator^(trace_length - 1)*/ mload(0x45e0)), PRIME))   mstore(0x4ce0, addmod( /*point^(trace_length / 256)*/ mload(0x44c0), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4d00, addmod( /*point^(trace_length / 512)*/ mload(0x44e0), sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x4640)), PRIME))   mstore(0x4d20, addmod( point, sub(PRIME, /*trace_generator^(128 * (trace_length / 128 - 1))*/ mload(0x4660)), PRIME))   mstore(0x4d40, addmod( /*point^(trace_length / 4096)*/ mload(0x4520), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4d60, addmod( /*point^(trace_length / 8192)*/ mload(0x4560), sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4600)), PRIME))   mstore(0x4d80, addmod( point, sub(PRIME, /*trace_generator^(8192 * (trace_length / 8192 - 1))*/ mload(0x46a0)), PRIME))   mstore(0x4da0, addmod( point, sub(PRIME, /*trace_generator^(256 * (trace_length / 256 - 1))*/ mload(0x46c0)), PRIME))   mstore(0x4dc0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 16), /*trace_length*/ mload(0x80)), PRIME))   mstore(0x4de0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 16)), PRIME))   mstore(0x4e00, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 16)), PRIME))   mstore(0x4e20, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 16)), PRIME))   mstore(0x4e40, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, 1), PRIME))   mstore(0x4e60, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, 1), PRIME))   mstore(0x4e80, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 2)), PRIME))   mstore(0x4ea0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 8)), PRIME))   mstore(0x4ec0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, /*trace_length*/ mload(0x80)), PRIME))   mstore(0x4ee0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 256), /*trace_length*/ mload(0x80)), PRIME))   mstore(0x4f00, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 256)), PRIME))   mstore(0x4f20, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), div(/*trace_length*/ mload(0x80), 512), div(/*trace_length*/ mload(0x80), 256)), PRIME))   mstore(0x4f40, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 512)), PRIME))   mstore(0x4f60, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 1, div(/*trace_length*/ mload(0x80), 128)), PRIME))   mstore(0x4f80, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 128)), PRIME))   mstore(0x4fa0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 4096), div(/*trace_length*/ mload(0x80), 16)), PRIME))   mstore(0x4fc0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), div(/*trace_length*/ mload(0x80), 8192), div(/*trace_length*/ mload(0x80), 32)), PRIME))   mstore(0x4fe0, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 8192)), PRIME))   mstore(0x5000, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 0, div(/*trace_length*/ mload(0x80), 4096)), PRIME))   mstore(0x5020, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 8192)), PRIME))   mstore(0x5040, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 0, div(/*trace_length*/ mload(0x80), 4096)), PRIME))   mstore(0x5060, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), sub(/*trace_length*/ mload(0x80), 1), 1, div(/*trace_length*/ mload(0x80), 8192)), PRIME))   mstore(0x5080, expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x3f40), mul(2, sub(/*trace_length*/ mload(0x80), 1)), 1, div(/*trace_length*/ mload(0x80), 256)), PRIME)) } {  {  let val := addmod( /*column1_row0*/ mload(0x2b00), sub( PRIME, addmod(/*column1_row1*/ mload(0x2b20), /*column1_row1*/ mload(0x2b20), PRIME)), PRIME) mstore(0x3f60, val) } {  let val := addmod( /*column1_row1*/ mload(0x2b20), sub( PRIME, addmod(/*column1_row2*/ mload(0x2b40), /*column1_row2*/ mload(0x2b40), PRIME)), PRIME) mstore(0x3f80, val) } {  let val := addmod( /*column1_row2*/ mload(0x2b40), sub( PRIME, addmod(/*column1_row3*/ mload(0x2b60), /*column1_row3*/ mload(0x2b60), PRIME)), PRIME) mstore(0x3fa0, val) } {  let val := addmod( /*column1_row4*/ mload(0x2b80), sub( PRIME, addmod(/*column1_row5*/ mload(0x2ba0), /*column1_row5*/ mload(0x2ba0), PRIME)), PRIME) mstore(0x3fc0, val) } {  let val := addmod( /*column1_row3*/ mload(0x2b60), sub( PRIME, addmod(/*column1_row4*/ mload(0x2b80), /*column1_row4*/ mload(0x2b80), PRIME)), PRIME) mstore(0x3fe0, val) } {  let val := addmod( /*column1_row9*/ mload(0x2c20), sub( PRIME, addmod(/*column1_row10*/ mload(0x2c40), /*column1_row10*/ mload(0x2c40), PRIME)), PRIME) mstore(0x4000, val) } {  let val := addmod( /*column1_row5*/ mload(0x2ba0), sub( PRIME, addmod(/*column1_row6*/ mload(0x2bc0), /*column1_row6*/ mload(0x2bc0), PRIME)), PRIME) mstore(0x4020, val) } {  let val := addmod( /*column1_row6*/ mload(0x2bc0), sub( PRIME, addmod(/*column1_row7*/ mload(0x2be0), /*column1_row7*/ mload(0x2be0), PRIME)), PRIME) mstore(0x4040, val) } {  let val := addmod( /*column1_row7*/ mload(0x2be0), sub( PRIME, addmod(/*column1_row8*/ mload(0x2c00), /*column1_row8*/ mload(0x2c00), PRIME)), PRIME) mstore(0x4060, val) } {  let val := addmod( /*column1_row8*/ mload(0x2c00), sub( PRIME, addmod(/*column1_row9*/ mload(0x2c20), /*column1_row9*/ mload(0x2c20), PRIME)), PRIME) mstore(0x4080, val) } {  let val := addmod( addmod( /*column19_row0*/ mload(0x33c0), /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3fa0), PRIME), 1, PRIME) mstore(0x40a0, val) } {  let val := addmod( /*column1_row10*/ mload(0x2c40), sub( PRIME, addmod(/*column1_row11*/ mload(0x2c60), /*column1_row11*/ mload(0x2c60), PRIME)), PRIME) mstore(0x40c0, val) } {  let val := addmod( /*column1_row11*/ mload(0x2c60), sub( PRIME, addmod(/*column1_row12*/ mload(0x2c80), /*column1_row12*/ mload(0x2c80), PRIME)), PRIME) mstore(0x40e0, val) } {  let val := addmod( /*column1_row12*/ mload(0x2c80), sub( PRIME, addmod(/*column1_row13*/ mload(0x2ca0), /*column1_row13*/ mload(0x2ca0), PRIME)), PRIME) mstore(0x4100, val) } {  let val := addmod( /*column1_row13*/ mload(0x2ca0), sub( PRIME, addmod(/*column1_row14*/ mload(0x2cc0), /*column1_row14*/ mload(0x2cc0), PRIME)), PRIME) mstore(0x4120, val) } {  let val := addmod( /*column1_row14*/ mload(0x2cc0), sub( PRIME, addmod(/*column1_row15*/ mload(0x2ce0), /*column1_row15*/ mload(0x2ce0), PRIME)), PRIME) mstore(0x4140, val) } {  let val := addmod(/*column20_row2*/ mload(0x3900), sub(PRIME, /*column20_row0*/ mload(0x38c0)), PRIME) mstore(0x4160, val) } {  let val := addmod(/*column2_row1*/ mload(0x2d20), sub(PRIME, /*column2_row0*/ mload(0x2d00)), PRIME) mstore(0x4180, val) } {  let val := addmod( /*column6_row0*/ mload(0x2e80), sub( PRIME, addmod(/*column6_row1*/ mload(0x2ea0), /*column6_row1*/ mload(0x2ea0), PRIME)), PRIME) mstore(0x41a0, val) } {  let val := addmod( 1, sub(PRIME, /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0)), PRIME) mstore(0x41c0, val) } {  let val := addmod( /*column10_row0*/ mload(0x3020), sub( PRIME, addmod(/*column10_row1*/ mload(0x3040), /*column10_row1*/ mload(0x3040), PRIME)), PRIME) mstore(0x41e0, val) } {  let val := addmod( 1, sub(PRIME, /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0)), PRIME) mstore(0x4200, val) } {  let val := addmod( /*column14_row0*/ mload(0x31c0), sub( PRIME, addmod(/*column14_row1*/ mload(0x31e0), /*column14_row1*/ mload(0x31e0), PRIME)), PRIME) mstore(0x4220, val) } {  let val := addmod( 1, sub(PRIME, /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220)), PRIME) mstore(0x4240, val) } {  let val := addmod( /*column18_row0*/ mload(0x3360), sub( PRIME, addmod(/*column18_row1*/ mload(0x3380), /*column18_row1*/ mload(0x3380), PRIME)), PRIME) mstore(0x4260, val) } {  let val := addmod( 1, sub(PRIME, /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260)), PRIME) mstore(0x4280, val) } {  let val := /*column0_row12*/ mload(0x2a00) mstore(0x42a0, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value0_0*/ mload(0x42a0), /*offset_size*/ mload(0xa0), PRIME), /*column0_row28*/ mload(0x2a20), PRIME) mstore(0x42c0, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value1_0*/ mload(0x42c0), /*offset_size*/ mload(0xa0), PRIME), /*column0_row44*/ mload(0x2a40), PRIME) mstore(0x42e0, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value2_0*/ mload(0x42e0), /*offset_size*/ mload(0xa0), PRIME), /*column0_row60*/ mload(0x2a60), PRIME) mstore(0x4300, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value3_0*/ mload(0x4300), /*offset_size*/ mload(0xa0), PRIME), /*column0_row76*/ mload(0x2a80), PRIME) mstore(0x4320, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value4_0*/ mload(0x4320), /*offset_size*/ mload(0xa0), PRIME), /*column0_row92*/ mload(0x2aa0), PRIME) mstore(0x4340, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value5_0*/ mload(0x4340), /*offset_size*/ mload(0xa0), PRIME), /*column0_row108*/ mload(0x2ac0), PRIME) mstore(0x4360, val) } {  let val := addmod( mulmod( /*intermediate_value/rc_builtin/value6_0*/ mload(0x4360), /*offset_size*/ mload(0xa0), PRIME), /*column0_row124*/ mload(0x2ae0), PRIME) mstore(0x4380, val) } {  let val := mulmod(/*column21_row6*/ mload(0x3a00), /*column21_row6*/ mload(0x3a00), PRIME) mstore(0x43a0, val) } {  let val := addmod( /*column21_row31*/ mload(0x3c40), sub( PRIME, addmod(/*column21_row63*/ mload(0x3ca0), /*column21_row63*/ mload(0x3ca0), PRIME)), PRIME) mstore(0x43c0, val) } {  let val := addmod( 1, sub( PRIME, /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0)), PRIME) mstore(0x43e0, val) } {  let val := addmod( /*column21_row3*/ mload(0x39a0), sub( PRIME, addmod(/*column21_row19*/ mload(0x3b60), /*column21_row19*/ mload(0x3b60), PRIME)), PRIME) mstore(0x4400, val) } {  let val := addmod( 1, sub( PRIME, /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400)), PRIME) mstore(0x4420, val) } {  let val := addmod( mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3f60), /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3f60), PRIME), sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3f60)), PRIME)   val := mulmod(val, mload(0x4c60), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[0]*/ mload(0x440), mulmod(/*coefficients[1]*/ mload(0x460), /*adjustments[0]*/mload(0x4dc0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column1_row0*/ mload(0x2b00), /*column1_row0*/ mload(0x2b00), PRIME), sub(PRIME, /*column1_row0*/ mload(0x2b00)), PRIME)      val := mulmod(val, mload(0x4700), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[2]*/ mload(0x480), mulmod(/*coefficients[3]*/ mload(0x4a0), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row1*/ mload(0x33e0), sub( PRIME, addmod( mulmod( addmod( mulmod( addmod( mulmod(/*column1_row0*/ mload(0x2b00), /*offset_size*/ mload(0xa0), PRIME), /*column0_row4*/ mload(0x29c0), PRIME), /*offset_size*/ mload(0xa0), PRIME), /*column0_row8*/ mload(0x29e0), PRIME), /*offset_size*/ mload(0xa0), PRIME), /*column0_row0*/ mload(0x2980), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[4]*/ mload(0x4c0), mulmod(/*coefficients[5]*/ mload(0x4e0), /*adjustments[2]*/mload(0x4e00), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod(/*column19_row8*/ mload(0x34c0), /*half_offset_size*/ mload(0xc0), PRIME), sub( PRIME, addmod( addmod( mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3f60), /*column21_row8*/ mload(0x3a40), PRIME), mulmod( addmod( 1, sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3f60)), PRIME), /*column21_row0*/ mload(0x3940), PRIME), PRIME), /*column0_row0*/ mload(0x2980), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[6]*/ mload(0x500), mulmod(/*coefficients[7]*/ mload(0x520), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod(/*column19_row4*/ mload(0x3440), /*half_offset_size*/ mload(0xc0), PRIME), sub( PRIME, addmod( addmod( mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3f80), /*column21_row8*/ mload(0x3a40), PRIME), mulmod( addmod( 1, sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3f80)), PRIME), /*column21_row0*/ mload(0x3940), PRIME), PRIME), /*column0_row8*/ mload(0x29e0), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[8]*/ mload(0x540), mulmod(/*coefficients[9]*/ mload(0x560), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod(/*column19_row12*/ mload(0x3500), /*half_offset_size*/ mload(0xc0), PRIME), sub( PRIME, addmod( addmod( addmod( addmod( mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3fa0), /*column19_row0*/ mload(0x33c0), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3fc0), /*column21_row0*/ mload(0x3940), PRIME), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3fe0), /*column21_row8*/ mload(0x3a40), PRIME), PRIME), mulmod( addmod( 1, sub( PRIME, addmod( addmod( /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3fa0), /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3fc0), PRIME), /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3fe0), PRIME)), PRIME), /*column19_row5*/ mload(0x3460), PRIME), PRIME), /*column0_row4*/ mload(0x29c0), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[10]*/ mload(0x580), mulmod(/*coefficients[11]*/ mload(0x5a0), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row4*/ mload(0x39c0), sub( PRIME, mulmod(/*column19_row5*/ mload(0x3460), /*column19_row13*/ mload(0x3520), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[12]*/ mload(0x5c0), mulmod(/*coefficients[13]*/ mload(0x5e0), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( addmod( 1, sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000)), PRIME), /*column21_row12*/ mload(0x3ac0), PRIME), sub( PRIME, addmod( addmod( mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x4020), addmod(/*column19_row5*/ mload(0x3460), /*column19_row13*/ mload(0x3520), PRIME), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x4040), /*column21_row4*/ mload(0x39c0), PRIME), PRIME), mulmod( addmod( 1, sub( PRIME, addmod( addmod( /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x4020), /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x4040), PRIME), /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000), PRIME)), PRIME), /*column19_row13*/ mload(0x3520), PRIME), PRIME)), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[14]*/ mload(0x600), mulmod(/*coefficients[15]*/ mload(0x620), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row2*/ mload(0x3980), sub( PRIME, mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000), /*column19_row9*/ mload(0x34e0), PRIME)), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[16]*/ mload(0x640), mulmod(/*coefficients[17]*/ mload(0x660), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row10*/ mload(0x3a80), sub( PRIME, mulmod(/*column21_row2*/ mload(0x3980), /*column21_row12*/ mload(0x3ac0), PRIME)), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[18]*/ mload(0x680), mulmod(/*coefficients[19]*/ mload(0x6a0), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod( mulmod( addmod( 1, sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000)), PRIME), /*column19_row16*/ mload(0x3540), PRIME), mulmod( /*column21_row2*/ mload(0x3980), addmod( /*column19_row16*/ mload(0x3540), sub( PRIME, addmod(/*column19_row0*/ mload(0x33c0), /*column19_row13*/ mload(0x3520), PRIME)), PRIME), PRIME), PRIME), sub( PRIME, addmod( addmod( mulmod( addmod( 1, sub( PRIME, addmod( addmod( /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x4060), /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x4080), PRIME), /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000), PRIME)), PRIME), /*intermediate_value/npc_reg_0*/ mload(0x40a0), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x4060), /*column21_row12*/ mload(0x3ac0), PRIME), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x4080), addmod(/*column19_row0*/ mload(0x33c0), /*column21_row12*/ mload(0x3ac0), PRIME), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[20]*/ mload(0x6c0), mulmod(/*coefficients[21]*/ mload(0x6e0), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := mulmod( addmod( /*column21_row10*/ mload(0x3a80), sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x4000)), PRIME), addmod( /*column19_row16*/ mload(0x3540), sub(PRIME, /*intermediate_value/npc_reg_0*/ mload(0x40a0)), PRIME), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[22]*/ mload(0x700), mulmod(/*coefficients[23]*/ mload(0x720), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row16*/ mload(0x3b40), sub( PRIME, addmod( addmod( addmod( /*column21_row0*/ mload(0x3940), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_10*/ mload(0x40c0), /*column21_row12*/ mload(0x3ac0), PRIME), PRIME), /*intermediate_value/cpu/decode/opcode_rc/bit_11*/ mload(0x40e0), PRIME), mulmod(/*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x4100), 2, PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[24]*/ mload(0x740), mulmod(/*coefficients[25]*/ mload(0x760), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row24*/ mload(0x3be0), sub( PRIME, addmod( addmod( mulmod( addmod( 1, sub( PRIME, addmod( /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x4100), /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x4120), PRIME)), PRIME), /*column21_row8*/ mload(0x3a40), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x4120), /*column19_row9*/ mload(0x34e0), PRIME), PRIME), mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x4100), addmod(/*column21_row0*/ mload(0x3940), 2, PRIME), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4c80), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[26]*/ mload(0x780), mulmod(/*coefficients[27]*/ mload(0x7a0), /*adjustments[3]*/mload(0x4e20), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x4100), addmod(/*column19_row9*/ mload(0x34e0), sub(PRIME, /*column21_row8*/ mload(0x3a40)), PRIME), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[28]*/ mload(0x7c0), mulmod(/*coefficients[29]*/ mload(0x7e0), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x4100), addmod( /*column19_row5*/ mload(0x3460), sub( PRIME, addmod( addmod( /*column19_row0*/ mload(0x33c0), /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3fa0), PRIME), 1, PRIME)), PRIME), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[30]*/ mload(0x800), mulmod(/*coefficients[31]*/ mload(0x820), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/cpu/decode/opcode_rc/bit_14*/ mload(0x4140), addmod( /*column19_row9*/ mload(0x34e0), sub(PRIME, /*column21_row12*/ mload(0x3ac0)), PRIME), PRIME)      val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[32]*/ mload(0x840), mulmod(/*coefficients[33]*/ mload(0x860), /*adjustments[1]*/mload(0x4de0), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column21_row0*/ mload(0x3940), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[34]*/ mload(0x880), mulmod(/*coefficients[35]*/ mload(0x8a0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column21_row8*/ mload(0x3a40), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[36]*/ mload(0x8c0), mulmod(/*coefficients[37]*/ mload(0x8e0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column19_row0*/ mload(0x33c0), sub(PRIME, /*initial_pc*/ mload(0x100)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[38]*/ mload(0x900), mulmod(/*coefficients[39]*/ mload(0x920), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column21_row0*/ mload(0x3940), sub(PRIME, /*final_ap*/ mload(0x120)), PRIME)      val := mulmod(val, mload(0x4760), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[40]*/ mload(0x940), mulmod(/*coefficients[41]*/ mload(0x960), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column19_row0*/ mload(0x33c0), sub(PRIME, /*final_pc*/ mload(0x140)), PRIME)      val := mulmod(val, mload(0x4760), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[42]*/ mload(0x980), mulmod(/*coefficients[43]*/ mload(0x9a0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod( addmod( mulmod( addmod( /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160), sub( PRIME, addmod( /*column20_row0*/ mload(0x38c0), mulmod( /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180), /*column20_row1*/ mload(0x38e0), PRIME), PRIME)), PRIME), /*column24_inter1_row0*/ mload(0x3f00), PRIME), /*column19_row0*/ mload(0x33c0), PRIME), mulmod( /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180), /*column19_row1*/ mload(0x33e0), PRIME), PRIME), sub(PRIME, /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[44]*/ mload(0x9c0), mulmod(/*coefficients[45]*/ mload(0x9e0), /*adjustments[5]*/mload(0x4e60), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( addmod( /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160), sub( PRIME, addmod( /*column20_row2*/ mload(0x3900), mulmod( /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180), /*column20_row3*/ mload(0x3920), PRIME), PRIME)), PRIME), /*column24_inter1_row2*/ mload(0x3f20), PRIME), sub( PRIME, mulmod( addmod( /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160), sub( PRIME, addmod( /*column19_row2*/ mload(0x3400), mulmod( /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180), /*column19_row3*/ mload(0x3420), PRIME), PRIME)), PRIME), /*column24_inter1_row0*/ mload(0x3f00), PRIME)), PRIME)   val := mulmod(val, mload(0x4ca0), PRIME)   val := mulmod(val, mload(0x4780), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[46]*/ mload(0xa00), mulmod(/*coefficients[47]*/ mload(0xa20), /*adjustments[6]*/mload(0x4e80), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column24_inter1_row0*/ mload(0x3f00), sub(PRIME, /*memory/multi_column_perm/perm/public_memory_prod*/ mload(0x1a0)), PRIME)      val := mulmod(val, mload(0x47a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[48]*/ mload(0xa40), mulmod(/*coefficients[49]*/ mload(0xa60), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/memory/address_diff_0*/ mload(0x4160), /*intermediate_value/memory/address_diff_0*/ mload(0x4160), PRIME), sub(PRIME, /*intermediate_value/memory/address_diff_0*/ mload(0x4160)), PRIME)   val := mulmod(val, mload(0x4ca0), PRIME)   val := mulmod(val, mload(0x4780), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[50]*/ mload(0xa80), mulmod(/*coefficients[51]*/ mload(0xaa0), /*adjustments[6]*/mload(0x4e80), PRIME)), PRIME), PRIME) } {  let val := mulmod( addmod(/*intermediate_value/memory/address_diff_0*/ mload(0x4160), sub(PRIME, 1), PRIME), addmod(/*column20_row1*/ mload(0x38e0), sub(PRIME, /*column20_row3*/ mload(0x3920)), PRIME), PRIME)   val := mulmod(val, mload(0x4ca0), PRIME)   val := mulmod(val, mload(0x4780), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[52]*/ mload(0xac0), mulmod(/*coefficients[53]*/ mload(0xae0), /*adjustments[6]*/mload(0x4e80), PRIME)), PRIME), PRIME) } {  let val := /*column19_row2*/ mload(0x3400)      val := mulmod(val, mload(0x47c0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[54]*/ mload(0xb00), mulmod(/*coefficients[55]*/ mload(0xb20), /*adjustments[7]*/mload(0x4ea0), PRIME)), PRIME), PRIME) } {  let val := /*column19_row3*/ mload(0x3420)      val := mulmod(val, mload(0x47c0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[56]*/ mload(0xb40), mulmod(/*coefficients[57]*/ mload(0xb60), /*adjustments[7]*/mload(0x4ea0), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod( mulmod( addmod( /*rc16/perm/interaction_elm*/ mload(0x1c0), sub(PRIME, /*column2_row0*/ mload(0x2d00)), PRIME), /*column23_inter1_row0*/ mload(0x3ec0), PRIME), /*column0_row0*/ mload(0x2980), PRIME), sub(PRIME, /*rc16/perm/interaction_elm*/ mload(0x1c0)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[58]*/ mload(0xb80), mulmod(/*coefficients[59]*/ mload(0xba0), /*adjustments[5]*/mload(0x4e60), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( addmod( /*rc16/perm/interaction_elm*/ mload(0x1c0), sub(PRIME, /*column2_row1*/ mload(0x2d20)), PRIME), /*column23_inter1_row1*/ mload(0x3ee0), PRIME), sub( PRIME, mulmod( addmod( /*rc16/perm/interaction_elm*/ mload(0x1c0), sub(PRIME, /*column0_row1*/ mload(0x29a0)), PRIME), /*column23_inter1_row0*/ mload(0x3ec0), PRIME)), PRIME)   val := mulmod(val, mload(0x4cc0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[60]*/ mload(0xbc0), mulmod(/*coefficients[61]*/ mload(0xbe0), /*adjustments[8]*/mload(0x4ec0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column23_inter1_row0*/ mload(0x3ec0), sub(PRIME, /*rc16/perm/public_memory_prod*/ mload(0x1e0)), PRIME)      val := mulmod(val, mload(0x47e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[62]*/ mload(0xc00), mulmod(/*coefficients[63]*/ mload(0xc20), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/rc16/diff_0*/ mload(0x4180), /*intermediate_value/rc16/diff_0*/ mload(0x4180), PRIME), sub(PRIME, /*intermediate_value/rc16/diff_0*/ mload(0x4180)), PRIME)   val := mulmod(val, mload(0x4cc0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[64]*/ mload(0xc40), mulmod(/*coefficients[65]*/ mload(0xc60), /*adjustments[8]*/mload(0x4ec0), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column2_row0*/ mload(0x2d00), sub(PRIME, /*rc_min*/ mload(0x200)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[66]*/ mload(0xc80), mulmod(/*coefficients[67]*/ mload(0xca0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column2_row0*/ mload(0x2d00), sub(PRIME, /*rc_max*/ mload(0x220)), PRIME)      val := mulmod(val, mload(0x47e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[68]*/ mload(0xcc0), mulmod(/*coefficients[69]*/ mload(0xce0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0), addmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[70]*/ mload(0xd00), mulmod(/*coefficients[71]*/ mload(0xd20), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := /*column6_row0*/ mload(0x2e80)      val := mulmod(val, mload(0x4800), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[72]*/ mload(0xd40), mulmod(/*coefficients[73]*/ mload(0xd60), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := /*column6_row0*/ mload(0x2e80)      val := mulmod(val, mload(0x4820), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[74]*/ mload(0xd80), mulmod(/*coefficients[75]*/ mload(0xda0), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0), addmod( /*column4_row0*/ mload(0x2de0), sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)), PRIME), PRIME), sub( PRIME, mulmod( /*column5_row0*/ mload(0x2e60), addmod( /*column3_row0*/ mload(0x2d40), sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[76]*/ mload(0xdc0), mulmod(/*coefficients[77]*/ mload(0xde0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column5_row0*/ mload(0x2e60), /*column5_row0*/ mload(0x2e60), PRIME), sub( PRIME, mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0), addmod( addmod( /*column3_row0*/ mload(0x2d40), /*periodic_column/pedersen/points/x*/ mload(0x0), PRIME), /*column3_row1*/ mload(0x2d60), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[78]*/ mload(0xe00), mulmod(/*coefficients[79]*/ mload(0xe20), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x41a0), addmod(/*column4_row0*/ mload(0x2de0), /*column4_row1*/ mload(0x2e00), PRIME), PRIME), sub( PRIME, mulmod( /*column5_row0*/ mload(0x2e60), addmod(/*column3_row0*/ mload(0x2d40), sub(PRIME, /*column3_row1*/ mload(0x2d60)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[80]*/ mload(0xe40), mulmod(/*coefficients[81]*/ mload(0xe60), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x41c0), addmod(/*column3_row1*/ mload(0x2d60), sub(PRIME, /*column3_row0*/ mload(0x2d40)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[82]*/ mload(0xe80), mulmod(/*coefficients[83]*/ mload(0xea0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x41c0), addmod(/*column4_row1*/ mload(0x2e00), sub(PRIME, /*column4_row0*/ mload(0x2de0)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[84]*/ mload(0xec0), mulmod(/*coefficients[85]*/ mload(0xee0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column3_row256*/ mload(0x2da0), sub(PRIME, /*column3_row255*/ mload(0x2d80)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[86]*/ mload(0xf00), mulmod(/*coefficients[87]*/ mload(0xf20), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column4_row256*/ mload(0x2e40), sub(PRIME, /*column4_row255*/ mload(0x2e20)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[88]*/ mload(0xf40), mulmod(/*coefficients[89]*/ mload(0xf60), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column3_row0*/ mload(0x2d40), sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[90]*/ mload(0xf80), mulmod(/*coefficients[91]*/ mload(0xfa0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column4_row0*/ mload(0x2de0), sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[92]*/ mload(0xfc0), mulmod(/*coefficients[93]*/ mload(0xfe0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0), addmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[94]*/ mload(0x1000), mulmod(/*coefficients[95]*/ mload(0x1020), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := /*column10_row0*/ mload(0x3020)      val := mulmod(val, mload(0x4800), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[96]*/ mload(0x1040), mulmod(/*coefficients[97]*/ mload(0x1060), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := /*column10_row0*/ mload(0x3020)      val := mulmod(val, mload(0x4820), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[98]*/ mload(0x1080), mulmod(/*coefficients[99]*/ mload(0x10a0), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0), addmod( /*column8_row0*/ mload(0x2f80), sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)), PRIME), PRIME), sub( PRIME, mulmod( /*column9_row0*/ mload(0x3000), addmod( /*column7_row0*/ mload(0x2ee0), sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[100]*/ mload(0x10c0), mulmod(/*coefficients[101]*/ mload(0x10e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column9_row0*/ mload(0x3000), /*column9_row0*/ mload(0x3000), PRIME), sub( PRIME, mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0), addmod( addmod( /*column7_row0*/ mload(0x2ee0), /*periodic_column/pedersen/points/x*/ mload(0x0), PRIME), /*column7_row1*/ mload(0x2f00), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[102]*/ mload(0x1100), mulmod(/*coefficients[103]*/ mload(0x1120), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x41e0), addmod(/*column8_row0*/ mload(0x2f80), /*column8_row1*/ mload(0x2fa0), PRIME), PRIME), sub( PRIME, mulmod( /*column9_row0*/ mload(0x3000), addmod(/*column7_row0*/ mload(0x2ee0), sub(PRIME, /*column7_row1*/ mload(0x2f00)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[104]*/ mload(0x1140), mulmod(/*coefficients[105]*/ mload(0x1160), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x4200), addmod(/*column7_row1*/ mload(0x2f00), sub(PRIME, /*column7_row0*/ mload(0x2ee0)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[106]*/ mload(0x1180), mulmod(/*coefficients[107]*/ mload(0x11a0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x4200), addmod(/*column8_row1*/ mload(0x2fa0), sub(PRIME, /*column8_row0*/ mload(0x2f80)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[108]*/ mload(0x11c0), mulmod(/*coefficients[109]*/ mload(0x11e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column7_row256*/ mload(0x2f40), sub(PRIME, /*column7_row255*/ mload(0x2f20)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[110]*/ mload(0x1200), mulmod(/*coefficients[111]*/ mload(0x1220), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column8_row256*/ mload(0x2fe0), sub(PRIME, /*column8_row255*/ mload(0x2fc0)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[112]*/ mload(0x1240), mulmod(/*coefficients[113]*/ mload(0x1260), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column7_row0*/ mload(0x2ee0), sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[114]*/ mload(0x1280), mulmod(/*coefficients[115]*/ mload(0x12a0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column8_row0*/ mload(0x2f80), sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[116]*/ mload(0x12c0), mulmod(/*coefficients[117]*/ mload(0x12e0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220), addmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[118]*/ mload(0x1300), mulmod(/*coefficients[119]*/ mload(0x1320), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := /*column14_row0*/ mload(0x31c0)      val := mulmod(val, mload(0x4800), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[120]*/ mload(0x1340), mulmod(/*coefficients[121]*/ mload(0x1360), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := /*column14_row0*/ mload(0x31c0)      val := mulmod(val, mload(0x4820), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[122]*/ mload(0x1380), mulmod(/*coefficients[123]*/ mload(0x13a0), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220), addmod( /*column12_row0*/ mload(0x3120), sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)), PRIME), PRIME), sub( PRIME, mulmod( /*column13_row0*/ mload(0x31a0), addmod( /*column11_row0*/ mload(0x3080), sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[124]*/ mload(0x13c0), mulmod(/*coefficients[125]*/ mload(0x13e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column13_row0*/ mload(0x31a0), /*column13_row0*/ mload(0x31a0), PRIME), sub( PRIME, mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220), addmod( addmod( /*column11_row0*/ mload(0x3080), /*periodic_column/pedersen/points/x*/ mload(0x0), PRIME), /*column11_row1*/ mload(0x30a0), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[126]*/ mload(0x1400), mulmod(/*coefficients[127]*/ mload(0x1420), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x4220), addmod(/*column12_row0*/ mload(0x3120), /*column12_row1*/ mload(0x3140), PRIME), PRIME), sub( PRIME, mulmod( /*column13_row0*/ mload(0x31a0), addmod(/*column11_row0*/ mload(0x3080), sub(PRIME, /*column11_row1*/ mload(0x30a0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[128]*/ mload(0x1440), mulmod(/*coefficients[129]*/ mload(0x1460), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x4240), addmod(/*column11_row1*/ mload(0x30a0), sub(PRIME, /*column11_row0*/ mload(0x3080)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[130]*/ mload(0x1480), mulmod(/*coefficients[131]*/ mload(0x14a0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x4240), addmod(/*column12_row1*/ mload(0x3140), sub(PRIME, /*column12_row0*/ mload(0x3120)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[132]*/ mload(0x14c0), mulmod(/*coefficients[133]*/ mload(0x14e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column11_row256*/ mload(0x30e0), sub(PRIME, /*column11_row255*/ mload(0x30c0)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[134]*/ mload(0x1500), mulmod(/*coefficients[135]*/ mload(0x1520), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column12_row256*/ mload(0x3180), sub(PRIME, /*column12_row255*/ mload(0x3160)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[136]*/ mload(0x1540), mulmod(/*coefficients[137]*/ mload(0x1560), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column11_row0*/ mload(0x3080), sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[138]*/ mload(0x1580), mulmod(/*coefficients[139]*/ mload(0x15a0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column12_row0*/ mload(0x3120), sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[140]*/ mload(0x15c0), mulmod(/*coefficients[141]*/ mload(0x15e0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260), addmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[142]*/ mload(0x1600), mulmod(/*coefficients[143]*/ mload(0x1620), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := /*column18_row0*/ mload(0x3360)      val := mulmod(val, mload(0x4800), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[144]*/ mload(0x1640), mulmod(/*coefficients[145]*/ mload(0x1660), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := /*column18_row0*/ mload(0x3360)      val := mulmod(val, mload(0x4820), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[146]*/ mload(0x1680), mulmod(/*coefficients[147]*/ mload(0x16a0), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260), addmod( /*column16_row0*/ mload(0x32c0), sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)), PRIME), PRIME), sub( PRIME, mulmod( /*column17_row0*/ mload(0x3340), addmod( /*column15_row0*/ mload(0x3220), sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[148]*/ mload(0x16c0), mulmod(/*coefficients[149]*/ mload(0x16e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column17_row0*/ mload(0x3340), /*column17_row0*/ mload(0x3340), PRIME), sub( PRIME, mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260), addmod( addmod( /*column15_row0*/ mload(0x3220), /*periodic_column/pedersen/points/x*/ mload(0x0), PRIME), /*column15_row1*/ mload(0x3240), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[150]*/ mload(0x1700), mulmod(/*coefficients[151]*/ mload(0x1720), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4260), addmod(/*column16_row0*/ mload(0x32c0), /*column16_row1*/ mload(0x32e0), PRIME), PRIME), sub( PRIME, mulmod( /*column17_row0*/ mload(0x3340), addmod(/*column15_row0*/ mload(0x3220), sub(PRIME, /*column15_row1*/ mload(0x3240)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[152]*/ mload(0x1740), mulmod(/*coefficients[153]*/ mload(0x1760), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x4280), addmod(/*column15_row1*/ mload(0x3240), sub(PRIME, /*column15_row0*/ mload(0x3220)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[154]*/ mload(0x1780), mulmod(/*coefficients[155]*/ mload(0x17a0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x4280), addmod(/*column16_row1*/ mload(0x32e0), sub(PRIME, /*column16_row0*/ mload(0x32c0)), PRIME), PRIME)   val := mulmod(val, mload(0x4ce0), PRIME)   val := mulmod(val, mload(0x46e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[156]*/ mload(0x17c0), mulmod(/*coefficients[157]*/ mload(0x17e0), /*adjustments[9]*/mload(0x4ee0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column15_row256*/ mload(0x3280), sub(PRIME, /*column15_row255*/ mload(0x3260)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[158]*/ mload(0x1800), mulmod(/*coefficients[159]*/ mload(0x1820), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column16_row256*/ mload(0x3320), sub(PRIME, /*column16_row255*/ mload(0x3300)), PRIME)   val := mulmod(val, mload(0x4d00), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[160]*/ mload(0x1840), mulmod(/*coefficients[161]*/ mload(0x1860), /*adjustments[11]*/mload(0x4f20), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column15_row0*/ mload(0x3220), sub(PRIME, /*pedersen/shift_point.x*/ mload(0x240)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[162]*/ mload(0x1880), mulmod(/*coefficients[163]*/ mload(0x18a0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column16_row0*/ mload(0x32c0), sub(PRIME, /*pedersen/shift_point.y*/ mload(0x260)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[164]*/ mload(0x18c0), mulmod(/*coefficients[165]*/ mload(0x18e0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod(/*column19_row7*/ mload(0x34a0), sub(PRIME, /*column6_row0*/ mload(0x2e80)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[166]*/ mload(0x1900), mulmod(/*coefficients[167]*/ mload(0x1920), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row135*/ mload(0x36c0), sub(PRIME, /*column10_row0*/ mload(0x3020)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[168]*/ mload(0x1940), mulmod(/*coefficients[169]*/ mload(0x1960), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row263*/ mload(0x3780), sub(PRIME, /*column14_row0*/ mload(0x31c0)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[170]*/ mload(0x1980), mulmod(/*coefficients[171]*/ mload(0x19a0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row391*/ mload(0x37e0), sub(PRIME, /*column18_row0*/ mload(0x3360)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[172]*/ mload(0x19c0), mulmod(/*coefficients[173]*/ mload(0x19e0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row134*/ mload(0x36a0), sub(PRIME, addmod(/*column19_row38*/ mload(0x35a0), 1, PRIME)), PRIME)   val := mulmod(val, mload(0x4d20), PRIME)   val := mulmod(val, mload(0x4880), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[174]*/ mload(0x1a00), mulmod(/*coefficients[175]*/ mload(0x1a20), /*adjustments[13]*/mload(0x4f60), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row6*/ mload(0x3480), sub(PRIME, /*initial_pedersen_addr*/ mload(0x280)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[176]*/ mload(0x1a40), mulmod(/*coefficients[177]*/ mload(0x1a60), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row71*/ mload(0x3600), sub(PRIME, /*column6_row256*/ mload(0x2ec0)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[178]*/ mload(0x1a80), mulmod(/*coefficients[179]*/ mload(0x1aa0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row199*/ mload(0x3740), sub(PRIME, /*column10_row256*/ mload(0x3060)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[180]*/ mload(0x1ac0), mulmod(/*coefficients[181]*/ mload(0x1ae0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row327*/ mload(0x37c0), sub(PRIME, /*column14_row256*/ mload(0x3200)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[182]*/ mload(0x1b00), mulmod(/*coefficients[183]*/ mload(0x1b20), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row455*/ mload(0x3840), sub(PRIME, /*column18_row256*/ mload(0x33a0)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[184]*/ mload(0x1b40), mulmod(/*coefficients[185]*/ mload(0x1b60), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row70*/ mload(0x35e0), sub(PRIME, addmod(/*column19_row6*/ mload(0x3480), 1, PRIME)), PRIME)      val := mulmod(val, mload(0x4880), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[186]*/ mload(0x1b80), mulmod(/*coefficients[187]*/ mload(0x1ba0), /*adjustments[14]*/mload(0x4f80), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row39*/ mload(0x35c0), sub(PRIME, /*column3_row511*/ mload(0x2dc0)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[188]*/ mload(0x1bc0), mulmod(/*coefficients[189]*/ mload(0x1be0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row167*/ mload(0x3720), sub(PRIME, /*column7_row511*/ mload(0x2f60)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[190]*/ mload(0x1c00), mulmod(/*coefficients[191]*/ mload(0x1c20), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row295*/ mload(0x37a0), sub(PRIME, /*column11_row511*/ mload(0x3100)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[192]*/ mload(0x1c40), mulmod(/*coefficients[193]*/ mload(0x1c60), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row423*/ mload(0x3820), sub(PRIME, /*column15_row511*/ mload(0x32a0)), PRIME)      val := mulmod(val, mload(0x4860), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[194]*/ mload(0x1c80), mulmod(/*coefficients[195]*/ mload(0x1ca0), /*adjustments[12]*/mload(0x4f40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row38*/ mload(0x35a0), sub(PRIME, addmod(/*column19_row70*/ mload(0x35e0), 1, PRIME)), PRIME)      val := mulmod(val, mload(0x4880), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[196]*/ mload(0x1cc0), mulmod(/*coefficients[197]*/ mload(0x1ce0), /*adjustments[14]*/mload(0x4f80), PRIME)), PRIME), PRIME) } {  let val := addmod( /*intermediate_value/rc_builtin/value7_0*/ mload(0x4380), sub(PRIME, /*column19_row103*/ mload(0x3680)), PRIME)      val := mulmod(val, mload(0x4880), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[198]*/ mload(0x1d00), mulmod(/*coefficients[199]*/ mload(0x1d20), /*adjustments[14]*/mload(0x4f80), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row230*/ mload(0x3760), sub(PRIME, addmod(/*column19_row102*/ mload(0x3660), 1, PRIME)), PRIME)   val := mulmod(val, mload(0x4d20), PRIME)   val := mulmod(val, mload(0x4880), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[200]*/ mload(0x1d40), mulmod(/*coefficients[201]*/ mload(0x1d60), /*adjustments[13]*/mload(0x4f60), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row102*/ mload(0x3660), sub(PRIME, /*initial_rc_addr*/ mload(0x2a0)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[202]*/ mload(0x1d80), mulmod(/*coefficients[203]*/ mload(0x1da0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod( addmod( addmod( /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x43a0), /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x43a0), PRIME), /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x43a0), PRIME), /*ecdsa/sig_config.alpha*/ mload(0x2c0), PRIME), sub( PRIME, mulmod( addmod(/*column21_row14*/ mload(0x3b00), /*column21_row14*/ mload(0x3b00), PRIME), /*column21_row1*/ mload(0x3960), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[204]*/ mload(0x1dc0), mulmod(/*coefficients[205]*/ mload(0x1de0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row1*/ mload(0x3960), /*column21_row1*/ mload(0x3960), PRIME), sub( PRIME, addmod( addmod(/*column21_row6*/ mload(0x3a00), /*column21_row6*/ mload(0x3a00), PRIME), /*column21_row22*/ mload(0x3ba0), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[206]*/ mload(0x1e00), mulmod(/*coefficients[207]*/ mload(0x1e20), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod(/*column21_row14*/ mload(0x3b00), /*column21_row30*/ mload(0x3c20), PRIME), sub( PRIME, mulmod( /*column21_row1*/ mload(0x3960), addmod( /*column21_row6*/ mload(0x3a00), sub(PRIME, /*column21_row22*/ mload(0x3ba0)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[208]*/ mload(0x1e40), mulmod(/*coefficients[209]*/ mload(0x1e60), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0), addmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[210]*/ mload(0x1e80), mulmod(/*coefficients[211]*/ mload(0x1ea0), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := /*column21_row31*/ mload(0x3c40)      val := mulmod(val, mload(0x48c0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[212]*/ mload(0x1ec0), mulmod(/*coefficients[213]*/ mload(0x1ee0), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := /*column21_row31*/ mload(0x3c40)      val := mulmod(val, mload(0x48e0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[214]*/ mload(0x1f00), mulmod(/*coefficients[215]*/ mload(0x1f20), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0), addmod( /*column21_row23*/ mload(0x3bc0), sub(PRIME, /*periodic_column/ecdsa/generator_points/y*/ mload(0x60)), PRIME), PRIME), sub( PRIME, mulmod( /*column21_row15*/ mload(0x3b20), addmod( /*column21_row7*/ mload(0x3a20), sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[216]*/ mload(0x1f40), mulmod(/*coefficients[217]*/ mload(0x1f60), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row15*/ mload(0x3b20), /*column21_row15*/ mload(0x3b20), PRIME), sub( PRIME, mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0), addmod( addmod( /*column21_row7*/ mload(0x3a20), /*periodic_column/ecdsa/generator_points/x*/ mload(0x40), PRIME), /*column21_row39*/ mload(0x3c60), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[218]*/ mload(0x1f80), mulmod(/*coefficients[219]*/ mload(0x1fa0), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x43c0), addmod(/*column21_row23*/ mload(0x3bc0), /*column21_row55*/ mload(0x3c80), PRIME), PRIME), sub( PRIME, mulmod( /*column21_row15*/ mload(0x3b20), addmod( /*column21_row7*/ mload(0x3a20), sub(PRIME, /*column21_row39*/ mload(0x3c60)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[220]*/ mload(0x1fc0), mulmod(/*coefficients[221]*/ mload(0x1fe0), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*column22_row0*/ mload(0x3e80), addmod( /*column21_row7*/ mload(0x3a20), sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)), PRIME), PRIME), sub(PRIME, 1), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[222]*/ mload(0x2000), mulmod(/*coefficients[223]*/ mload(0x2020), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x43e0), addmod( /*column21_row39*/ mload(0x3c60), sub(PRIME, /*column21_row7*/ mload(0x3a20)), PRIME), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[224]*/ mload(0x2040), mulmod(/*coefficients[225]*/ mload(0x2060), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x43e0), addmod( /*column21_row55*/ mload(0x3c80), sub(PRIME, /*column21_row23*/ mload(0x3bc0)), PRIME), PRIME)   val := mulmod(val, mload(0x4d60), PRIME)   val := mulmod(val, mload(0x48a0), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[226]*/ mload(0x2080), mulmod(/*coefficients[227]*/ mload(0x20a0), /*adjustments[16]*/mload(0x4fc0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400), addmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400), sub(PRIME, 1), PRIME), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[228]*/ mload(0x20c0), mulmod(/*coefficients[229]*/ mload(0x20e0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := /*column21_row3*/ mload(0x39a0)      val := mulmod(val, mload(0x4900), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[230]*/ mload(0x2100), mulmod(/*coefficients[231]*/ mload(0x2120), /*adjustments[18]*/mload(0x5000), PRIME)), PRIME), PRIME) } {  let val := /*column21_row3*/ mload(0x39a0)      val := mulmod(val, mload(0x4920), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[232]*/ mload(0x2140), mulmod(/*coefficients[233]*/ mload(0x2160), /*adjustments[18]*/mload(0x5000), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400), addmod( /*column21_row5*/ mload(0x39e0), sub(PRIME, /*column21_row14*/ mload(0x3b00)), PRIME), PRIME), sub( PRIME, mulmod( /*column21_row13*/ mload(0x3ae0), addmod(/*column21_row9*/ mload(0x3a60), sub(PRIME, /*column21_row6*/ mload(0x3a00)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[234]*/ mload(0x2180), mulmod(/*coefficients[235]*/ mload(0x21a0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row13*/ mload(0x3ae0), /*column21_row13*/ mload(0x3ae0), PRIME), sub( PRIME, mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400), addmod( addmod(/*column21_row9*/ mload(0x3a60), /*column21_row6*/ mload(0x3a00), PRIME), /*column21_row25*/ mload(0x3c00), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[236]*/ mload(0x21c0), mulmod(/*coefficients[237]*/ mload(0x21e0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x4400), addmod(/*column21_row5*/ mload(0x39e0), /*column21_row21*/ mload(0x3b80), PRIME), PRIME), sub( PRIME, mulmod( /*column21_row13*/ mload(0x3ae0), addmod( /*column21_row9*/ mload(0x3a60), sub(PRIME, /*column21_row25*/ mload(0x3c00)), PRIME), PRIME)), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[238]*/ mload(0x2200), mulmod(/*coefficients[239]*/ mload(0x2220), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*column21_row11*/ mload(0x3aa0), addmod(/*column21_row9*/ mload(0x3a60), sub(PRIME, /*column21_row6*/ mload(0x3a00)), PRIME), PRIME), sub(PRIME, 1), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[240]*/ mload(0x2240), mulmod(/*coefficients[241]*/ mload(0x2260), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x4420), addmod( /*column21_row25*/ mload(0x3c00), sub(PRIME, /*column21_row9*/ mload(0x3a60)), PRIME), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[242]*/ mload(0x2280), mulmod(/*coefficients[243]*/ mload(0x22a0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := mulmod( /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x4420), addmod( /*column21_row21*/ mload(0x3b80), sub(PRIME, /*column21_row5*/ mload(0x39e0)), PRIME), PRIME)   val := mulmod(val, mload(0x4d40), PRIME)   val := mulmod(val, mload(0x4720), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[244]*/ mload(0x22c0), mulmod(/*coefficients[245]*/ mload(0x22e0), /*adjustments[15]*/mload(0x4fa0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row7*/ mload(0x3a20), sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[246]*/ mload(0x2300), mulmod(/*coefficients[247]*/ mload(0x2320), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row23*/ mload(0x3bc0), /*ecdsa/sig_config.shift_point.y*/ mload(0x300), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[248]*/ mload(0x2340), mulmod(/*coefficients[249]*/ mload(0x2360), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row9*/ mload(0x3a60), sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)), PRIME)      val := mulmod(val, mload(0x4960), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[250]*/ mload(0x2380), mulmod(/*coefficients[251]*/ mload(0x23a0), /*adjustments[18]*/mload(0x5000), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row5*/ mload(0x39e0), sub(PRIME, /*ecdsa/sig_config.shift_point.y*/ mload(0x300)), PRIME)      val := mulmod(val, mload(0x4960), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[252]*/ mload(0x23c0), mulmod(/*coefficients[253]*/ mload(0x23e0), /*adjustments[18]*/mload(0x5000), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row8183*/ mload(0x3e20), sub( PRIME, addmod( /*column21_row4085*/ mload(0x3ce0), mulmod( /*column22_row8160*/ mload(0x3ea0), addmod( /*column21_row8167*/ mload(0x3da0), sub(PRIME, /*column21_row4089*/ mload(0x3d00)), PRIME), PRIME), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[254]*/ mload(0x2400), mulmod(/*coefficients[255]*/ mload(0x2420), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column22_row8160*/ mload(0x3ea0), /*column22_row8160*/ mload(0x3ea0), PRIME), sub( PRIME, addmod( addmod(/*column21_row8167*/ mload(0x3da0), /*column21_row4089*/ mload(0x3d00), PRIME), /*column21_row4102*/ mload(0x3d60), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[256]*/ mload(0x2440), mulmod(/*coefficients[257]*/ mload(0x2460), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod(/*column21_row8183*/ mload(0x3e20), /*column21_row4110*/ mload(0x3d80), PRIME), sub( PRIME, mulmod( /*column22_row8160*/ mload(0x3ea0), addmod( /*column21_row8167*/ mload(0x3da0), sub(PRIME, /*column21_row4102*/ mload(0x3d60)), PRIME), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[258]*/ mload(0x2480), mulmod(/*coefficients[259]*/ mload(0x24a0), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*column21_row8175*/ mload(0x3dc0), addmod( /*column21_row8167*/ mload(0x3da0), sub(PRIME, /*column21_row4089*/ mload(0x3d00)), PRIME), PRIME), sub(PRIME, 1), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[260]*/ mload(0x24c0), mulmod(/*coefficients[261]*/ mload(0x24e0), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( addmod( /*column21_row8181*/ mload(0x3e00), /*ecdsa/sig_config.shift_point.y*/ mload(0x300), PRIME), sub( PRIME, mulmod( /*column21_row4093*/ mload(0x3d40), addmod( /*column21_row8185*/ mload(0x3e40), sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)), PRIME), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[262]*/ mload(0x2500), mulmod(/*coefficients[263]*/ mload(0x2520), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row4093*/ mload(0x3d40), /*column21_row4093*/ mload(0x3d40), PRIME), sub( PRIME, addmod( addmod( /*column21_row8185*/ mload(0x3e40), /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0), PRIME), /*column21_row3*/ mload(0x39a0), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[264]*/ mload(0x2540), mulmod(/*coefficients[265]*/ mload(0x2560), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod( /*column21_row8189*/ mload(0x3e60), addmod( /*column21_row8185*/ mload(0x3e40), sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x2e0)), PRIME), PRIME), sub(PRIME, 1), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[266]*/ mload(0x2580), mulmod(/*coefficients[267]*/ mload(0x25a0), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row31*/ mload(0x3c40), /*column21_row4081*/ mload(0x3cc0), PRIME), sub(PRIME, 1), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[268]*/ mload(0x25c0), mulmod(/*coefficients[269]*/ mload(0x25e0), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row3*/ mload(0x39a0), /*column21_row4091*/ mload(0x3d20), PRIME), sub(PRIME, 1), PRIME)      val := mulmod(val, mload(0x4960), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[270]*/ mload(0x2600), mulmod(/*coefficients[271]*/ mload(0x2620), /*adjustments[20]*/mload(0x5040), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column21_row8177*/ mload(0x3de0), sub( PRIME, mulmod(/*column21_row6*/ mload(0x3a00), /*column21_row6*/ mload(0x3a00), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[272]*/ mload(0x2640), mulmod(/*coefficients[273]*/ mload(0x2660), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( mulmod(/*column21_row14*/ mload(0x3b00), /*column21_row14*/ mload(0x3b00), PRIME), sub( PRIME, addmod( addmod( mulmod(/*column21_row6*/ mload(0x3a00), /*column21_row8177*/ mload(0x3de0), PRIME), mulmod(/*ecdsa/sig_config.alpha*/ mload(0x2c0), /*column21_row6*/ mload(0x3a00), PRIME), PRIME), /*ecdsa/sig_config.beta*/ mload(0x320), PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[274]*/ mload(0x2680), mulmod(/*coefficients[275]*/ mload(0x26a0), /*adjustments[19]*/mload(0x5020), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row22*/ mload(0x3560), sub(PRIME, /*initial_ecdsa_addr*/ mload(0x340)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[276]*/ mload(0x26c0), mulmod(/*coefficients[277]*/ mload(0x26e0), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row4118*/ mload(0x3860), sub(PRIME, addmod(/*column19_row22*/ mload(0x3560), 1, PRIME)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[278]*/ mload(0x2700), mulmod(/*coefficients[279]*/ mload(0x2720), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row8214*/ mload(0x38a0), sub(PRIME, addmod(/*column19_row4118*/ mload(0x3860), 1, PRIME)), PRIME)   val := mulmod(val, mload(0x4d80), PRIME)   val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[280]*/ mload(0x2740), mulmod(/*coefficients[281]*/ mload(0x2760), /*adjustments[21]*/mload(0x5060), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row4119*/ mload(0x3880), sub(PRIME, /*column21_row31*/ mload(0x3c40)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[282]*/ mload(0x2780), mulmod(/*coefficients[283]*/ mload(0x27a0), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row23*/ mload(0x3580), sub(PRIME, /*column21_row6*/ mload(0x3a00)), PRIME)      val := mulmod(val, mload(0x4940), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[284]*/ mload(0x27c0), mulmod(/*coefficients[285]*/ mload(0x27e0), /*adjustments[17]*/mload(0x4fe0), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row150*/ mload(0x36e0), sub(PRIME, /*initial_checkpoints_addr*/ mload(0x360)), PRIME)      val := mulmod(val, mload(0x4740), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[286]*/ mload(0x2800), mulmod(/*coefficients[287]*/ mload(0x2820), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row150*/ mload(0x36e0), sub(PRIME, /*final_checkpoints_addr*/ mload(0x380)), PRIME)      val := mulmod(val, mload(0x4980), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[288]*/ mload(0x2840), mulmod(/*coefficients[289]*/ mload(0x2860), /*adjustments[4]*/mload(0x4e40), PRIME)), PRIME), PRIME) } {  let val := addmod( /*column19_row86*/ mload(0x3620), sub(PRIME, addmod(/*column19_row150*/ mload(0x36e0), 1, PRIME)), PRIME)      val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[290]*/ mload(0x2880), mulmod(/*coefficients[291]*/ mload(0x28a0), /*adjustments[10]*/mload(0x4f00), PRIME)), PRIME), PRIME) } {  let val := mulmod( addmod( /*column19_row406*/ mload(0x3800), sub(PRIME, /*column19_row150*/ mload(0x36e0)), PRIME), addmod( /*column19_row406*/ mload(0x3800), sub(PRIME, addmod(/*column19_row150*/ mload(0x36e0), 2, PRIME)), PRIME), PRIME)   val := mulmod(val, mload(0x4da0), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[292]*/ mload(0x28c0), mulmod(/*coefficients[293]*/ mload(0x28e0), /*adjustments[22]*/mload(0x5080), PRIME)), PRIME), PRIME) } {  let val := mulmod( addmod( /*column19_row406*/ mload(0x3800), sub(PRIME, /*column19_row150*/ mload(0x36e0)), PRIME), addmod( /*column19_row151*/ mload(0x3700), sub(PRIME, /*column19_row0*/ mload(0x33c0)), PRIME), PRIME)   val := mulmod(val, mload(0x4da0), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[294]*/ mload(0x2900), mulmod(/*coefficients[295]*/ mload(0x2920), /*adjustments[22]*/mload(0x5080), PRIME)), PRIME), PRIME) } {  let val := mulmod( addmod( /*column19_row406*/ mload(0x3800), sub(PRIME, /*column19_row150*/ mload(0x36e0)), PRIME), addmod( /*column19_row87*/ mload(0x3640), sub(PRIME, /*column21_row8*/ mload(0x3a40)), PRIME), PRIME)   val := mulmod(val, mload(0x4da0), PRIME)   val := mulmod(val, mload(0x4840), PRIME)  res := addmod(res, mulmod(val, add(/*coefficients[296]*/ mload(0x2940), mulmod(/*coefficients[297]*/ mload(0x2960), /*adjustments[22]*/mload(0x5080), PRIME)), PRIME), PRIME) } mstore(0, res) return(0, 0x20) } }
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function getClientRegistrations(address account) external view returns (uint256[] memory) { // get `client` registered lockers function getClientRegistrations(address account) external view returns (uint256[] memory) {  return clientRegistrations[account];
 function transferAnyERC20Token(address tokenAddress, uint256 tokens) public returns (bool success) { require(isOwner()); return IERC20(tokenAddress).transfer(owner(), tokens);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function tokensToClaim(address _user)  public view returns (uint256 tokensToTake) { uint256 countOfCoinsToAdd = ((now - info.coinCreationTime) / REBASE_TIME);  uint256 realTotalSupply = (countOfCoinsToAdd * TOKEN_PRECISION);  uint256 valueFromLiqudityHistory = info.users[_user].appliedFarmTokenCirculation / TOKEN_PRECISION; uint256 valueToLiqudityHistory = realTotalSupply / TOKEN_PRECISION;  uint256[] memory myArray = new uint256[](valueToLiqudityHistory - valueFromLiqudityHistory); uint counter = 0; for (uint i=valueFromLiqudityHistory; i<valueToLiqudityHistory; i++) { myArray[counter] = historyOfLiqudity[i]; if(historyOfLiqudity[i] == 0){ myArray[counter] = myArray[counter-1]; } counter++; }  uint256 adjustedAddressBalance = 0; for (uint j=0; j<counter; j++) { adjustedAddressBalance += ((TOKEN_PRECISION * info.users[_user].liqudityBalance) / myArray[j]); }  return adjustedAddressBalance;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accSEPPUKUPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingSEPPUKU(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accSEPPUKUPerShare = pool.accSEPPUKUPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 SEPPUKUReward = multiplier.mul(SEPPUKUPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accSEPPUKUPerShare = accSEPPUKUPerShare.add(SEPPUKUReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ SEPPUKU.mint(devaddr, amount);
 function burn(uint256 amount) public onlyOwner{ SEPPUKU.burn(amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 SEPPUKUReward = multiplier.mul(SEPPUKUPerBlock).mul(pool.allocPoint).div(totalAllocPoint); SEPPUKU.mint(devaddr, SEPPUKUReward.div(4)); SEPPUKU.mint(address(this), SEPPUKUReward); pool.accSEPPUKUPerShare = pool.accSEPPUKUPerShare.add(SEPPUKUReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt); safeSEPPUKUTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12).sub(user.rewardDebt); safeSEPPUKUTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accSEPPUKUPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeSEPPUKUTransfer(address _to, uint256 _amount) internal { uint256 SEPPUKUBal = SEPPUKU.balanceOf(address(this)); if (_amount > SEPPUKUBal) { SEPPUKU.transfer(_to, SEPPUKUBal); } else { SEPPUKU.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function get_virtual_price() external override view returns (uint) { return stableSwapBUSD.get_virtual_price();
 function calc_token_amount_deposit(uint[] calldata _amounts) external override view returns (uint _shareAmount) { uint[4] memory _bpoolAmounts; _bpoolAmounts[0] = _convert_underlying_to_ytoken_rate(poolBUSDyTokens[0], _amounts[0]); _bpoolAmounts[1] = _convert_underlying_to_ytoken_rate(poolBUSDyTokens[1], _amounts[1]); _bpoolAmounts[2] = _convert_underlying_to_ytoken_rate(poolBUSDyTokens[2], _amounts[2]); _bpoolAmounts[3] = _convert_underlying_to_ytoken_rate(poolBUSDyTokens[3], _amounts[4]); uint _bpoolToBcrv = stableSwapBUSD.calc_token_amount(_bpoolAmounts, true); uint _3crvToBCrv = convert_rate(address(token3Crv), address(tokenBCrv), _amounts[3]); uint _susdToBCrv = convert_rate(address(tokenSUSD), address(tokenBCrv), _amounts[5]); uint _husdToBCrv = convert_rate(address(tokenHUSD), address(tokenBCrv), _amounts[6]); return _shareAmount.add(_bpoolToBcrv).add(_3crvToBCrv).add(_susdToBCrv).add(_husdToBCrv);
 function _convert_3crv_to_shares(uint _3crv) internal returns (uint _shares) {  uint[4] memory amounts; uint _before = bpoolTokens[0].balanceOf(address(this)); stableSwap3Pool.remove_liquidity_one_coin(_3crv, 0, 1); uint _after = bpoolTokens[0].balanceOf(address(this)); amounts[0] = _after.sub(_before);  _before = tokenBCrv.balanceOf(address(this)); depositBUSD.add_liquidity(amounts, 1); _after = tokenBCrv.balanceOf(address(this)); _shares = _after.sub(_before);
 function _convert_susd_to_shares(uint _amount) internal returns (uint _shares) {  uint[4] memory amounts; uint _before = bpoolTokens[0].balanceOf(address(this)); stableSwapSUSD.exchange_underlying(int128(3), int128(0), _amount, 1); uint _after = bpoolTokens[0].balanceOf(address(this)); amounts[0] = _after.sub(_before);  _before = tokenBCrv.balanceOf(address(this)); depositBUSD.add_liquidity(amounts, 1); _after = tokenBCrv.balanceOf(address(this)); _shares = _after.sub(_before);
 function _convert_husd_to_shares(uint _amount) internal returns (uint _shares) {  uint _before = token3Crv.balanceOf(address(this)); stableSwapHUSD.exchange(int128(0), int128(1), _amount, 1); uint _after = token3Crv.balanceOf(address(this)); _amount = _after.sub(_before);  uint[4] memory amounts; _before = bpoolTokens[0].balanceOf(address(this)); stableSwap3Pool.remove_liquidity_one_coin(_amount, 0, 1); _after = bpoolTokens[0].balanceOf(address(this)); amounts[0] = _after.sub(_before);  _before = tokenBCrv.balanceOf(address(this)); depositBUSD.add_liquidity(amounts, 1); _after = tokenBCrv.balanceOf(address(this)); _shares = _after.sub(_before);
 function _convert_shares_to_husd(uint _amount) internal returns (uint _husd) {  uint[3] memory amounts; uint _before = bpoolTokens[0].balanceOf(address(this)); depositBUSD.remove_liquidity_one_coin(_amount, 0, 1); uint _after = bpoolTokens[0].balanceOf(address(this)); amounts[0] = _after.sub(_before);  _before = token3Crv.balanceOf(address(this)); stableSwap3Pool.add_liquidity(amounts, 1); _after = token3Crv.balanceOf(address(this)); _amount = _after.sub(_before);  _before = tokenHUSD.balanceOf(address(this)); stableSwapHUSD.exchange(int128(1), int128(0), _amount, 1); _after = tokenHUSD.balanceOf(address(this)); _husd = _after.sub(_before);
 function addOwner(address _newOwner) external isAnOwner { addOwnerShip(_newOwner);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function seize(IERC20 _token, uint amount) external { require(msg.sender == governance, "!governance"); require(_token != token, "reward"); require(_token != vote, "vote"); _token.safeTransfer(governance, amount);
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); if (voters[msg.sender] == true) { votes[msg.sender] = votes[msg.sender].add(amount); totalVotes = totalVotes.add(amount); } super.stake(amount); emit Staked(msg.sender, amount);
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCityPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingCity(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCityPerShare = pool.accCityPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCityPerShare = accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCityPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ city.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); city.mint(devaddr, cityReward.div(20)); // 5% city.mint(devaddr, cityReward.div(20));  city.mint(address(this), cityReward); pool.accCityPerShare = pool.accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeCityTransfer(address _to, uint256 _amount) internal { uint256 cityBal = city.balanceOf(address(this)); if (_amount > cityBal) { city.transfer(_to, cityBal); } else { city.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) { require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
 function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) { (address token0, address token1) = sortTokens(tokenA, tokenB); pair = address(uint(keccak256(abi.encodePacked( hex'ff', factory, keccak256(abi.encodePacked(token0, token1)), hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'  ))));
 function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) { (address token0,) = sortTokens(tokenA, tokenB); (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves(); (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); amountB = amountA.mul(reserveB) / reserveA;
 function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) { require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint amountInWithFee = amountIn.mul(997); uint numerator = amountInWithFee.mul(reserveOut); uint denominator = reserveIn.mul(1000).add(amountInWithFee); amountOut = numerator / denominator;
 function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) { require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); uint numerator = reserveIn.mul(amountOut).mul(1000); uint denominator = reserveOut.sub(amountOut).mul(997); amountIn = (numerator / denominator).add(1);
 function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[0] = amountIn; for (uint i; i < path.length - 1; i++) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); }
 function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) { require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); amounts = new uint[](path.length); amounts[amounts.length - 1] = amountOut; for (uint i = path.length - 1; i > 0; i--) { (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); }
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart{ require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkNextEpoch checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0x0)); emit OwnershipTransferred(owner,_newOwner); owner = _newOwner;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function transferAll(address _to) public { _locks[_to] = _locks[_to].add(_locks[msg.sender]); if (_lastUnlockBlock[_to] < lockFromBlock) { _lastUnlockBlock[_to] = lockFromBlock; } if (_lastUnlockBlock[_to] < _lastUnlockBlock[msg.sender]) { _lastUnlockBlock[_to] = _lastUnlockBlock[msg.sender]; } _locks[msg.sender] = 0; _lastUnlockBlock[msg.sender] = 0; _transfer(msg.sender, _to, balanceOf(msg.sender));
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function transfer(address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[_msgSender()] == false) { uint256 fee = transferFee.mul(amount).div(10000); uint amountLessFee = amount.sub(fee); _transfer(_msgSender(), recipient, amountLessFee); _transfer(_msgSender(), feeRecipient, fee); } else { _transfer(_msgSender(), recipient, amount); } return true;
 function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { if (activeFee && feeException[recipient] == false) { uint256 fee = transferFee.mul(amount).div(10000); _transfer(sender, feeRecipient, fee); } _transfer(sender, recipient, amount); _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance")); return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkNextEpoch checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount); emit Staked(msg.sender, amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) { require(amount > 0, "Cannot stake 0"); if (voters[msg.sender] == true) { votes[msg.sender] = votes[msg.sender].add(amount); totalVotes = totalVotes.add(amount); } super.stake(amount); emit Staked(msg.sender, amount);
 function sqrt(uint y) internal pure returns (uint z) { if (y > 3) { z = y; uint x = y / 2 + 1; while (x < z) { z = x; x = (y / x + x) / 2; } } else if (y != 0) { z = 1; }
 function encode(uint112 y) internal pure returns (uint224 z) { z = uint224(y) * Q112; // never overflows z = uint224(y) * Q112; 
 function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { z = x / uint224(y);
 function initialize(address _token0, address _token1) external { require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check require(msg.sender == factory, 'UniswapV2: FORBIDDEN');  token0 = _token0; token1 = _token1;
 function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private { require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW'); uint32 blockTimestamp = uint32(block.timestamp % 2**32); uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired uint32 timeElapsed = blockTimestamp - blockTimestampLast;  if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {  price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed; price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed; } reserve0 = uint112(balance0); reserve1 = uint112(balance1); blockTimestampLast = blockTimestamp; emit Sync(reserve0, reserve1);
 function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) { address feeTo = IUniswapV2Factory(factory).feeTo(); feeOn = feeTo != address(0); uint _kLast = kLast; // gas savings uint _kLast = kLast;  if (feeOn) { if (_kLast != 0) { uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1)); uint rootKLast = Math.sqrt(_kLast); if (rootK > rootKLast) { uint numerator = totalSupply.mul(rootK.sub(rootKLast)); uint denominator = rootK.mul(5).add(rootKLast); uint liquidity = numerator / denominator; if (liquidity > 0) _mint(feeTo, liquidity); } } } else if (_kLast != 0) { kLast = 0; }
 function mint(address to) external lock returns (uint liquidity) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  if (_totalSupply == 0) { liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens _mint(address(0), MINIMUM_LIQUIDITY);  } else { liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED'); _mint(to, liquidity); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Mint(msg.sender, amount0, amount1);
 function burn(address to) external lock returns (uint amount0, uint amount1) { (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  address _token0 = token0;                                // gas savings address _token0 = token0;                                 address _token1 = token1;                                // gas savings address _token1 = token1;                                 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); uint liquidity = balanceOf[address(this)]; bool feeOn = _mintFee(_reserve0, _reserve1); uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply;  amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution amount0 = liquidity.mul(balance0) / _totalSupply;  amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution amount1 = liquidity.mul(balance1) / _totalSupply;  require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED'); _burn(address(this), liquidity); _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); _update(balance0, balance1, _reserve0, _reserve1); if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1);  emit Burn(msg.sender, amount0, amount1, to);
 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT'); (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings (uint112 _reserve0, uint112 _reserve1,) = getReserves();  require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY'); uint balance0; uint balance1; { // scope for _token{0,1}, avoids stack too deep errors {  address _token0 = token0; address _token1 = token1; require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO'); if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out);  if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out);  if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT'); { // scope for reserve{0,1}Adjusted, avoids stack too deep errors {  uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K'); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 function skim(address to) external lock { address _token0 = token0; // gas savings address _token0 = token0;  address _token1 = token1; // gas savings address _token1 = token1;  _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0)); _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 function sync() external lock { _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accRallyPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function setRallyPerBlock(uint256 _rallyPerBlock) public onlyOwner { massUpdatePools(); rallyPerBlock = _rallyPerBlock;
 function pendingRally(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accRallyPerShare = pool.accRallyPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = block.number.sub(pool.lastRewardBlock); uint256 rallyReward = multiplier.mul(rallyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accRallyPerShare = accRallyPerShare.add(rallyReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accRallyPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = block.number.sub(pool.lastRewardBlock); uint256 rallyReward = multiplier.mul(rallyPerBlock).mul(pool.allocPoint).div(totalAllocPoint); pool.accRallyPerShare = pool.accRallyPerShare.add(rallyReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accRallyPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeRallyTransfer(msg.sender, pending); } } if(_amount > 0) { pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accRallyPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accRallyPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) { safeRallyTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount); pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accRallyPerShare).div(1e12); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeRallyTransfer(address _to, uint256 _amount) internal { uint256 rallyBal = rally.balanceOf(address(this)); if (_amount > rallyBal) { rally.transfer(_to, rallyBal); } else { rally.transfer(_to, _amount); }
 function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external { require(block.timestamp <= deadline, "expired"); bytes32 hashStruct = keccak256(abi.encode( PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)); bytes32 hash = keccak256(abi.encodePacked( '\x19\x01', DOMAIN_SEPARATOR, hashStruct)); address signer = ecrecover(hash, v, r, s); require(signer != address(0) && signer == owner, "!signer"); _approve(owner, spender, value);
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function harvest(address reserve, uint amount) external { require(msg.sender == controller, "!controller"); require(reserve != address(token), "token"); IERC20(reserve).safeTransfer(controller, amount);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accCityPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingCity(uint256 _pid, address _user) external view returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accCityPerShare = pool.accCityPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accCityPerShare = accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); } return user.amount.mul(accCityPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ city.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 cityReward = multiplier.mul(cityPerBlock).mul(pool.allocPoint).div(totalAllocPoint); city.mint(devaddr, cityReward.div(20)); // 5% city.mint(devaddr, cityReward.div(20));  city.mint(address(this), cityReward); pool.accCityPerShare = pool.accCityPerShare.add(cityReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); } pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accCityPerShare).div(1e12).sub(user.rewardDebt); safeCityTransfer(msg.sender, pending); user.amount = user.amount.sub(_amount); user.rewardDebt = user.amount.mul(pool.accCityPerShare).div(1e12); pool.lpToken.safeTransfer(address(msg.sender), _amount); emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeCityTransfer(address _to, uint256 _amount) internal { uint256 cityBal = city.balanceOf(address(this)); if (_amount > cityBal) { city.transfer(_to, cityBal); } else { city.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: wut?"); devaddr = _devaddr;
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function changeAdmin(address payable _admin) external onlyAdmin { admin = _admin;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function verifyTradeBetweenDW() internal view { require( now >= latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME(), "FREEZE_FOR_UPDATE_PRICE" );
 function verifyDWSender() internal view { if(totalShares > 0){ if(latestOracleCallOnTime + cotraderGlobalConfig.TRADE_FREEZE_TIME() >= now){ require(msg.sender == latestOracleCaller, "NOT_LATEST_ORACLE_CALLER"); } else{ revert("ORACLE_TIME_EXPIRED"); } }
 function updateFundValueFromOracle(address _oracleTokenAddress, uint256 _oracleFee) public payable {  require(now >= latestOracleCallOnTime + cotraderGlobalConfig.DW_FREEZE_TIME(), "DW_FREEZE");  if(_oracleTokenAddress == address(ETH_TOKEN_ADDRESS)){ require(msg.value == _oracleFee, "REQUIRE_ETH");  latestOracleRequestID = fundValueOracle.requestValue.value(_oracleFee)(address(this), _oracleFee); }  else{ require(msg.value == 0, "NO_NEED_ETH");  _transferFromSenderAndApproveTo(IERC20(_oracleTokenAddress), _oracleFee, address(fundValueOracle));  latestOracleRequestID = fundValueOracle.requestValue(address(this), _oracleFee); }  latestOracleCallOnTime = now; latestOracleCallOnBlock = block.number; latestOracleCaller = msg.sender;  emit OracleUpdate(latestOracleCaller, latestOracleCallOnTime, latestOracleRequestID);
 function calculateFundValue() public view returns (uint256) {  return fundValueOracle.getFundValueByID(latestOracleRequestID);
 function getAllTokenAddresses() external view returns (address[] memory) { return tokenAddresses;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function _utilization(address token, uint amount) internal view returns (uint) { uint _max = STABLE.MAX(); uint _base = STABLE.BASE(); address _pair = UniswapFactory(UNI.factory()).getPair(token, address(STABLE)); uint _ratio = _base.sub(_base.mul(STABLE.balanceOf(_pair).add(amount)).div(STABLE.totalSupply())); if (_ratio == 0) { return _max; } return  _ratio > _max ? _max : _ratio;
 function calculateCreditMax(address token) external view returns (uint) { return calculateCreditMaxOf(msg.sender, token);
 function calculateBorrowExactOut(address token, uint outExact) external view returns (uint) { address[] memory _path = new address[](2); _path[0] = address(STABLE); _path[1] = token; return UNI.getAmountsIn(outExact, _path)[0];
 function calculateBorrowMax(address token) external view returns (uint) { return calculateBorrowMaxOf(msg.sender, token);
 function calculateBorrowExactIn(address token, uint inExact) public view returns (uint) { address[] memory _path = new address[](2); _path[0] = address(STABLE); _path[1] = token; return UNI.getAmountsOut(inExact, _path)[1];
 function calculateRepayExactOut(address token, uint outExact) external view returns (uint) { address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(STABLE); return UNI.getAmountsIn(outExact, _path)[0];
 function calculateRepayMax(address token) external view returns (uint) { return calculateRepayMaxOf(msg.sender, token);
 function calculateRepayExactIn(address token, uint inExact) public view returns (uint) { address[] memory _path = new address[](2); _path[0] = token; _path[1] = address(STABLE); return UNI.getAmountsOut(inExact, _path)[1];
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount);
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(tokens <= balances[msg.sender]); balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function stake(uint256 amount) public updateReward(msg.sender) checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount);
 function latestLockerRegistration(address account) external view returns (uint256 latest) { // get latest registered locker per account function latestLockerRegistration(address account) external view returns (uint256 latest) {  uint256[] memory registered = registrations[account]; if (registered.length == 0) {return 0;} else {return registered[registered.length-1];}
 function exp(uint p, uint q, uint precision) public pure returns (uint) { uint n = 0; uint nFact = 1; uint currentP = 1; uint currentQ = 1; uint sum = 0; uint prevSum = 0; while (true) { if (checkMultOverflow(currentP, precision)) return sum; if (checkMultOverflow(currentQ, nFact)) return sum; sum += (currentP * precision) / (currentQ * nFact); if (sum == prevSum) return sum; prevSum = sum; n++; if (checkMultOverflow(currentP, p)) return sum; if (checkMultOverflow(currentQ, q)) return sum; if (checkMultOverflow(nFact, n)) return sum; currentP *= p; currentQ *= q; nFact *= n; (currentP, currentQ) = compactFraction(currentP, currentQ, precision); }
 function countLeadingZeros(uint p, uint q) public pure returns (uint) { uint denomator = (uint(1)<<255); for (int i = 255; i >= 0; i--) { if ((q*denomator)/denomator != q) {  denomator = denomator/2; continue; } if (p/(q*denomator) > 0) return uint(i); denomator = denomator/2; } return uint(-1);
 function log2ForSmallNumber(uint x, uint numPrecisionBits) public pure returns (uint) { uint res = 0; uint one = (uint(1)<<numPrecisionBits); uint two = 2 * one; uint addition = one; require((x >= one) && (x <= two)); require(numPrecisionBits < 125); for (uint i = numPrecisionBits; i > 0; i--) { x = (x*x) / one; addition = addition/2; if (x >= two) { x = x/2; res += addition; } } return res;
 function yearn(address _strategy, address _token, uint parts) public { require(msg.sender == strategist || msg.sender == governance, "!governance");  uint _before = IERC20(_token).balanceOf(address(this)); Strategy(_strategy).withdraw(_token); uint _after =  IERC20(_token).balanceOf(address(this)); if (_after > _before) { uint _amount = _after.sub(_before); address _want = Strategy(_strategy).want(); uint[] memory _distribution; uint _expected; _before = IERC20(_want).balanceOf(address(this)); IERC20(_token).safeApprove(onesplit, 0); IERC20(_token).safeApprove(onesplit, _amount); (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0); OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0); _after = IERC20(_want).balanceOf(address(this)); if (_after > _before) { _amount = _after.sub(_before); uint _reward = _amount.mul(split).div(max); earn(_want, _amount.sub(_reward)); IERC20(_want).safeTransfer(rewards, _reward); } }
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart { require(amount > 0, "Cannot stake 0"); super.stake(amount);  if (userRewardPerTokenPaid[msg.sender] == 0) { userRewardPerTokenPaid[msg.sender] = rewardPerToken(); } emit Staked(msg.sender, amount);
 function setInitReward(uint amtLoveWeiPerPeriod) external onlyOwner { require(rewardRate == 0, "Must not have yet set the reward rate."); initreward = amtLoveWeiPerPeriod;
 function fixRewardPerTokenStored(address account, uint _rewardPerToken) external onlyOwner { require(earned(account) > 0, "Must be a staker"); require(userRewardPerTokenPaid[account] == 0, "Must have incorrect reward"); userRewardPerTokenPaid[account] = _rewardPerToken;
 function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)];
 function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true;
 function () public payable { revert();
 function decimals() external pure returns (uint8) { return uint8(9);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount); _moveDelegates(address(0), _delegates[_to], _amount);
 function add(uint256 _allocPoint, IERC20 _lpToken, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock; totalAllocPoint = totalAllocPoint.add(_allocPoint); poolInfo.push(PoolInfo({ lpToken: _lpToken, allocPoint: _allocPoint, lastRewardBlock: lastRewardBlock, accYFSPerShare: 0 }));
 function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner { if (_withUpdate) { massUpdatePools(); } totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint); poolInfo[_pid].allocPoint = _allocPoint;
 function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) { if (_to <= bonusEndBlock) { return _to.sub(_from).mul(BONUS_MULTIPLIER); } else if (_from >= bonusEndBlock) { return _to.sub(_from); } else { return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add( _to.sub(bonusEndBlock) ); }
 function pendingYFS(uint256 _pid, address _user) external returns (uint256) { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][_user]; uint256 accYFSPerShare = pool.accYFSPerShare; uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (block.number > pool.lastRewardBlock && lpSupply != 0) { uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 YFSReward = multiplier.mul(YFSPerBlock).mul(pool.allocPoint).div(totalAllocPoint); accYFSPerShare = accYFSPerShare.add(YFSReward.mul(1e12).div(lpSupply));  }  return user.amount.mul(accYFSPerShare).div(1e12).sub(user.rewardDebt);
 function massUpdatePools() public { uint256 length = poolInfo.length; for (uint256 pid = 0; pid < length; ++pid) { updatePool(pid); }
 function mint(uint256 amount) public onlyOwner{ /* address msgSender = _msgSender(); address _owner = owner(); emit OwnershipTransferred(_owner, msgSender);*/ YFS.mint(devaddr, amount);
 function updatePool(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; if (block.number <= pool.lastRewardBlock) { return; } uint256 lpSupply = pool.lpToken.balanceOf(address(this)); if (lpSupply == 0) { pool.lastRewardBlock = block.number; return; } uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number); uint256 YFSReward = multiplier.mul(YFSPerBlock).mul(pool.allocPoint).div(totalAllocPoint); YFS.mint(devaddr, YFSReward.div(10)); YFS.mint(address(this), YFSReward); pool.accYFSPerShare = pool.accYFSPerShare.add(YFSReward.mul(1e12).div(lpSupply)); pool.lastRewardBlock = block.number;
 function deposit(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; updatePool(_pid); if (user.amount > 0) { uint256 pending = user.amount.mul(pool.accYFSPerShare).div(1e12).sub(user.rewardDebt); if(pending > 0) {  safeYFSTransfer(msg.sender, pending); } } if(_amount > 0) {  pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount); user.amount = user.amount.add(_amount); } user.rewardDebt = user.amount.mul(pool.accYFSPerShare).div(1e12);  emit Deposit(msg.sender, _pid, _amount);
 function withdraw(uint256 _pid, uint256 _amount) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; require(user.amount >= _amount, "withdraw: not good"); updatePool(_pid); uint256 pending = user.amount.mul(pool.accYFSPerShare).div(1e12).sub(user.rewardDebt);   if(pending > 0) {   safeYFSTransfer(msg.sender, pending); } if(_amount > 0) { user.amount = user.amount.sub(_amount);    pool.lpToken.safeTransfer(address(msg.sender), _amount); } user.rewardDebt = user.amount.mul(pool.accYFSPerShare).div(1e12);  emit Withdraw(msg.sender, _pid, _amount);
 function emergencyWithdraw(uint256 _pid) public { PoolInfo storage pool = poolInfo[_pid]; UserInfo storage user = userInfo[_pid][msg.sender]; pool.lpToken.safeTransfer(address(msg.sender), user.amount); emit EmergencyWithdraw(msg.sender, _pid, user.amount); user.amount = 0; user.rewardDebt = 0;
 function safeYFSTransfer(address _to, uint256 _amount) internal { uint256 YFSBal = YFS.balanceOf(address(this)); if (_amount > YFSBal) { YFS.transfer(_to, YFSBal); } else { YFS.transfer(_to, _amount); }
 function dev(address _devaddr) public { require(msg.sender == devaddr, "dev: what?"); devaddr = _devaddr;
 function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]);
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data); return true;
 function () external payable { revert();
 function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens);
 function _msgSender() internal view returns(address payable) { return msg.sender;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function testlogbase2(int128 x) public pure returns (int128) { return logbase2(x);
 function withdraw(IERC20 _asset) external returns (uint balance) { require(msg.sender == controller, "!controller"); require(want != address(_asset), "want"); require(d != address(_asset), "d"); balance = _asset.balanceOf(address(this)); _asset.safeTransfer(controller, balance);
 function withdraw(uint _amount) external { require(msg.sender == controller, "!controller"); uint _balance = IERC20(want).balanceOf(address(this)); if (_balance < _amount) { _amount = _withdrawSome(_amount.sub(_balance)); _amount = _amount.add(_balance); }  uint _fee = 0; if (withdrawalFee>0){ _fee = _amount.mul(withdrawalFee).div(withdrawalMax); IERC20(want).safeTransfer(Controller(controller).rewards(), _fee); }   address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, _amount.sub(_fee));
 function withdrawAll() external returns (uint balance) { require(msg.sender == controller, "!controller"); _withdrawAll();   balance = IERC20(want).balanceOf(address(this));  address _vault = Controller(controller).vaults(address(want)); require(_vault != address(0), "!vault"); // additional protection so we don't burn the funds require(_vault != address(0), "!vault");  IERC20(want).safeTransfer(_vault, balance);
 function STAKE(uint256 tokens) external { require(IERC20(YFIs).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from user account");  uint256 _stakingFee = 0; if(totalStakes > 0) _stakingFee= (onePercent(tokens).mul(stakingFee)).div(10);  if(totalStakes > 0)  _addPayout(_stakingFee);   uint256 owing = pendingReward(msg.sender); stakers[msg.sender].remainder += owing;  stakers[msg.sender].stakedTokens = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedTokens); stakers[msg.sender].lastDividends = owing; stakers[msg.sender].fromTotalDividend= totalDividends; stakers[msg.sender].round =  round;  totalStakes = totalStakes.add(tokens.sub(_stakingFee));  emit STAKED(msg.sender, tokens.sub(_stakingFee), _stakingFee);
 function ADDFUNDS(uint256 tokens) external { require(IERC20(YFIs).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from funder account"); _addPayout(tokens);
 function _addPayout(uint256 tokens) private{   uint256 available = (tokens.mul(scaling)).add(scaledRemainder); uint256 dividendPerToken = available.div(totalStakes); scaledRemainder = available.mod(totalStakes);  totalDividends = totalDividends.add(dividendPerToken); payouts[round] = payouts[round-1].add(dividendPerToken);  emit PAYOUT(round, tokens, msg.sender); round++;
 function CLAIMREWARD() public { if(totalDividends > stakers[msg.sender].fromTotalDividend){ uint256 owing = pendingReward(msg.sender);  owing = owing.add(stakers[msg.sender].remainder); stakers[msg.sender].remainder = 0;  require(IERC20(YFIs).transfer(msg.sender,owing), "ERROR: error in sending reward from contract");  emit CLAIMEDREWARD(msg.sender, owing);  stakers[msg.sender].lastDividends = owing; // unscaled stakers[msg.sender].lastDividends = owing;  stakers[msg.sender].round = round; // update the round stakers[msg.sender].round = round;  stakers[msg.sender].fromTotalDividend = totalDividends; // scaled stakers[msg.sender].fromTotalDividend = totalDividends;  }
 function pendingReward(address staker) private returns (uint256) { uint256 amount =  ((totalDividends.sub(payouts[stakers[staker].round - 1])).mul(stakers[staker].stakedTokens)).div(scaling); stakers[staker].remainder += ((totalDividends.sub(payouts[stakers[staker].round - 1])).mul(stakers[staker].stakedTokens)) % scaling ; return amount;
 function WITHDRAW(uint256 tokens) external {  require(stakers[msg.sender].stakedTokens >= tokens && tokens > 0, "Invalid token amount to withdraw");  uint256 _unstakingFee = (onePercent(tokens).mul(unstakingFee)).div(10);   uint256 owing = pendingReward(msg.sender); stakers[msg.sender].remainder += owing;  require(IERC20(YFIs).transfer(msg.sender, tokens.sub(_unstakingFee)), "Error in un-staking tokens");  stakers[msg.sender].stakedTokens = stakers[msg.sender].stakedTokens.sub(tokens); stakers[msg.sender].lastDividends = owing; stakers[msg.sender].fromTotalDividend= totalDividends; stakers[msg.sender].round =  round;  totalStakes = totalStakes.sub(tokens);  if(totalStakes > 0)  _addPayout(_unstakingFee);  emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);
 function onePercent(uint256 _tokens) private pure returns (uint256){ uint256 roundValue = _tokens.ceil(100); uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2)); return onePercentofTokens;
 function yourStakedYFIs(address staker) external view returns(uint256 stakedYFis){ return stakers[staker].stakedTokens;
 function yourYFIsBalance(address user) external view returns(uint256 YFIsBalance){ return IERC20(YFIs).balanceOf(user);
 function initialTokens() internal {  /* activeTokens.push(address(0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD)); // DAI activeTokens.push(address(0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD));  activeTokens.push(address(0xe22da380ee6B445bb8273C81944ADEB6E8450422)); // USDC activeTokens.push(address(0xe22da380ee6B445bb8273C81944ADEB6E8450422));  activeTokens.push(address(0x13512979ADE267AB5100878E2e0f485B568328a4)); // USDT activeTokens.push(address(0x13512979ADE267AB5100878E2e0f485B568328a4));  activeTokens.push(address(0xD868790F57B39C9B2B51b12de046975f986675f9)); // sUSD activeTokens.push(address(0xD868790F57B39C9B2B51b12de046975f986675f9));  */   activeTokens.push(address(0x6B175474E89094C44Da98b954EedeAC495271d0F)); // DAI activeTokens.push(address(0x6B175474E89094C44Da98b954EedeAC495271d0F));  activeTokens.push(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)); // USDC activeTokens.push(address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48));  activeTokens.push(address(0xdAC17F958D2ee523a2206206994597C13D831ec7)); // USDT activeTokens.push(address(0xdAC17F958D2ee523a2206206994597C13D831ec7));  activeTokens.push(address(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51)); // sUSD activeTokens.push(address(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51)); 
 function circulatingSupply() public view returns (uint256) { if(_stabilizeT.totalSupply() == 0){ return 0; }else{  uint256 total = _stabilizeT.totalSupply().sub(_stabilizeT.balanceOf(operatorAddress)).sub(_stabilizeT.balanceOf(address(this)));  if(furnaceList.length > 0){ for(uint256 i = 0; i < furnaceList.length; i++){ total = total.sub(_stabilizeT.balanceOf(furnaceList[i])); } } return total; }
 function startGovernanceChange(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 1; _timelock_address = _address;
 function startAddNewToken(address _address) external onlyGovernance {  require(_address != stbzAddress, "Cannot add token that is the same as the burnt tokens"); _timelockStart = now; _timelockType = 2; _timelock_address = _address;
 function startRemoveToken(address _address) external onlyGovernance { _timelockStart = now; _timelockType = 3; _timelock_address = _address;
 function startAddNewFurnace(address _address) external onlyGovernance {  require(_address != stbzAddress, "Cannot add STBZ address as a furnace"); _timelockStart = now; _timelockType = 4; _timelock_address = _address;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function available() public view returns (uint) { return token.balanceOf(address(this)).mul(min).div(max);
 function withdraw(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } token.safeTransfer(msg.sender, r);
 function withdrawETH(uint _shares) public { uint r = (balance().mul(_shares)).div(totalSupply()); _burn(msg.sender, _shares);  uint b = token.balanceOf(address(this)); if (b < r) { uint _withdraw = r.sub(b); Controller(controller).withdraw(address(token), _withdraw); uint _after = token.balanceOf(address(this)); uint _diff = _after.sub(b); if (_diff < _withdraw) { r = b.add(_diff); } } WETH(address(token)).withdraw(r); address(msg.sender).transfer(r);
 function getClientRegistrations(address account) external view returns (uint256[] memory) { // get set of `client` registered lockers function getClientRegistrations(address account) external view returns (uint256[] memory) {  return clientRegistrations[account];
 function hodlerTransfer(address _from, uint256 _value) external onlyRole(ROLE_TRANSFER) returns (bool) { require(_from != address(0)); require(_value > 0);  address _hodler = msg.sender;  balances[_from] = balances[_from].sub(_value); balances[_hodler] = balances[_hodler].add(_value);  emit Transfer(_from, _hodler, _value); return true;
 function mint(address _to, uint256 _amount) external onlyRole(ROLE_MINT) returns (bool) { require(_to != address(0)); require(_amount > 0);  totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount);  emit MintLog(_to, _amount); emit Transfer(address(0), _to, _amount);  return true;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setAdminFee(uint256 _adminFeeDenominator, address _laoFundAddress) public nonReentrant onlyOwner{ require(_adminFeeDenominator >= 200); adminFeeDenominator = _adminFeeDenominator; laoFundAddress = _laoFundAddress;
 function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant onlyDelegate { address memberAddress = memberAddressByDelegateKey[msg.sender]; Member storage member = members[memberAddress]; require(proposalIndex < proposalQueue.length, "proposal does not exist"); Proposal storage proposal = proposals[proposalQueue[proposalIndex]]; require(uintVote < 3, "must be less than 3"); Vote vote = Vote(uintVote); require(getCurrentPeriod() >= proposal.startingPeriod, "voting period has not started"); require(!hasVotingPeriodExpired(proposal.startingPeriod), "proposal voting period has expired"); require(proposal.votesByMember[memberAddress] == Vote.Null, "member has already voted"); require(vote == Vote.Yes || vote == Vote.No, "vote must be either Yes or No"); proposal.votesByMember[memberAddress] = vote; if (vote == Vote.Yes) { proposal.yesVotes = proposal.yesVotes.add(member.shares);  if (proposalIndex > member.highestIndexYesVote) { member.highestIndexYesVote = proposalIndex; }  if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) { proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot); } } else if (vote == Vote.No) { proposal.noVotes = proposal.noVotes.add(member.shares); }   emit SubmitVote(proposalQueue[proposalIndex], proposalIndex, msg.sender, memberAddress, uintVote);
 function cancelProposal(uint256 proposalId) public nonReentrant { Proposal storage proposal = proposals[proposalId]; require(!proposal.flags[0], "proposal has already been sponsored"); require(!proposal.flags[3], "proposal has already been cancelled"); require(msg.sender == proposal.proposer, "solely the proposer can cancel"); proposal.flags[3] = true; // cancelled proposal.flags[3] = true;   unsafeInternalTransfer(ESCROW, proposal.proposer, proposal.tributeToken, proposal.tributeOffered); emit CancelProposal(proposalId, msg.sender);
 function canRagequit(uint256 highestIndexYesVote) public view returns (bool) { require(highestIndexYesVote < proposalQueue.length, "proposal does not exist"); return proposals[proposalQueue[highestIndexYesVote]].flags[1];
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function setTokenAddresses(address _tokenAddr, address _liquidityAddr) public onlyOwner returns(bool){ require(_tokenAddr != address(0) && _liquidityAddr != address(0), "Invalid addresses format are not supported"); tokenAddress = _tokenAddr; foreigntoken = _liquidityAddr; 
 function totalSupply() public view returns (uint) { return _totalSupply;
 function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner];
 function transfer(address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true;
 function approve(address spender, uint tokens) public returns (bool success) { require(spender != address(0), "spender address is a zero address"); allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true;
 function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(to != address(0), "to address is a zero address"); balances[from] != balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true;
 function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender];
 function isConstructor() private view returns (bool) {      address self = address(this); uint256 cs; assembly { cs := extcodesize(self) } return cs == 0;
 function __Context_init() internal initializer { __Context_init_unchained();
 function getMushroomData(uint256 tokenId) public view returns (MushroomLib.MushroomData memory) { MushroomLib.MushroomData memory data = mushroomData[tokenId]; return data;
 function tokenURI(uint256 tokenId) public view override returns (string memory) { MushroomLib.MushroomData storage data = mushroomData[tokenId]; return mushroomMetadataUri[data.species];
 function mint(address recipient, uint256 tokenId, uint256 speciesId, uint256 lifespan) public onlyMinter { _mintWithMetadata(recipient, tokenId, speciesId, lifespan);
 function setMushroomLifespan(uint256 index, uint256 lifespan) public onlyLifespanModifier { MushroomLib.MushroomData storage data = mushroomData[index]; data.lifespan = lifespan;
 function _clearMushroomData(uint256 tokenId) internal { MushroomLib.MushroomData storage data = mushroomData[tokenId]; MushroomLib.MushroomType storage species = mushroomTypes[data.species]; species.minted = species.minted.sub(1);
 function growMushrooms(address recipient, uint256 numMushrooms) public onlyOwner { MushroomLib.MushroomType memory species = mushroomNft.getSpecies(mySpecies); require(getRemainingMintableForMySpecies() >= numMushrooms, "MushroomFactory: Mushrooms to grow exceeds species cap"); for (uint256 i = 0; i < numMushrooms; i++) { uint256 nextId = mushroomNft.totalSupply().add(1); uint256 lifespan = _generateMushroomLifespan(species.minLifespan, species.maxLifespan); mushroomNft.mint(recipient, nextId, mySpecies, lifespan); emit MushroomGrown(recipient, nextId, mySpecies, lifespan); }
 function deposit(uint256 amount) public { uint256 availFunds = controller.allowableAmount(address(this)); require(amount <= availFunds, "exceed contAllowance"); controller.earn(address(this), amount);  uint256 bptTokenAmt = musdcBpt.joinswapExternAmountIn(address(want), amount, 0);  mPool.stake(bptTokenAmt);  depositMTAInStaking();
 function multiTransfer(address[] memory receivers, uint256[] memory amounts) public { for (uint256 i = 0; i < receivers.length; i++) { transfer(receivers[i], amounts[i]); }
 function mint(address _to, uint256 _amount) public onlyOwner { _mint(_to, _amount);
 function _msgSender() internal view returns (address payable) { return msg.sender;
 function onePercent(uint256 _tokens) internal pure returns (uint256){ uint256 roundValue = _tokens.ceil(100); uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2)); return onePercentofTokens;
 function balanceOf(address tokenOwner) public override view returns (uint256 balance) { return balances[tokenOwner];
 function transfer(address to, uint256 tokens) public override returns (bool success) {  require(address(to) != address(0)); require(balances[msg.sender] >= tokens ); require(balances[to] + tokens >= balances[to]);  if(teamLockedTokens > 0 && msg.sender == teamAdd){ if(block.timestamp < deployTime.add(8 weeks)){ require(balances[teamAdd].sub(tokens) >= teamLockedTokens,"tokens are locked for 8 weeks"); } else teamLockedTokens = 0; }  balances[msg.sender] = balances[msg.sender].sub(tokens);  uint256 deduction = 0; if (address(to) != address(this) &&  address(to) != uniSwapAddress && address(to) != teamAdd && address(to) != marketingAdd && address(to) != preSaleAdd && msg.sender != uniSwapAddress && msg.sender != teamAdd && msg.sender != marketingAdd && msg.sender != preSaleAdd)  {  deduction = onePercent(tokens).mul(5); if (stakedCoins == 0){ burnTokens(deduction); } else{ burnTokens(onePercent(deduction).mul(2)); disburse(onePercent(deduction).mul(3)); } }  balances[to] = balances[to].add(tokens.sub(deduction)); emit Transfer(msg.sender, to, tokens.sub(deduction)); return true;
 function approve(address spender, uint256 tokens) public override returns (bool success){ allowed[msg.sender][spender] = tokens; emit Approval(msg.sender,spender,tokens); return true;
 function transferFrom(address from, address to, uint256 tokens) public override returns (bool success){ require(tokens <= allowed[from][msg.sender]); //check allowance require(tokens <= allowed[from][msg.sender]);  require(balances[from] >= tokens);  if(from == teamAdd && balances[teamAdd].sub(tokens) > teamLockedTokens){ require(block.timestamp > deployTime.add(8 weeks), "tokens are locked for 8 weeks"); teamLockedTokens = 0; }  balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);  uint256 deduction = 0; if (to != address(this) && from != address(this) && to != uniSwapAddress && to != teamAdd && to != marketingAdd && to != preSaleAdd && from != uniSwapAddress && from != teamAdd && from != marketingAdd && from != preSaleAdd)  { deduction = onePercent(tokens).mul(5); if (stakedCoins == 0){ burnTokens(deduction); } else{ burnTokens(onePercent(deduction).mul(2)); disburse(onePercent(deduction).mul(3)); } }  balances[to] = balances[to].add(tokens.sub(deduction)); emit Transfer(from, to, tokens.sub(tokens)); return true;
 function allowance(address tokenOwner, address spender) public override view returns (uint256 remaining) { return allowed[tokenOwner][spender];
 function burnTokens(uint256 value) internal{ require(_totalSupply >= value); // burn only unsold tokens require(_totalSupply >= value);  _totalSupply = _totalSupply.sub(value); emit Transfer(msg.sender, address(0), value);
 function deposit(uint256 amount) public { uint256 total = valueOfVaultAndStrategy(); // Get token equivalent at strategy and here if applicable uint256 total = valueOfVaultAndStrategy();   require(currentStrategy != StabilizeStrategy(address(0)),"No strategy contract has been selected yet"); require(depositsOpen == true, "Deposits have been suspended, but you can still withdraw"); uint256 _before = _underlyingAsset.balanceOf(address(this)); _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount); // Transfer token to this address _underlyingAsset.safeTransferFrom(_msgSender(), address(this), amount);  amount = _underlyingAsset.balanceOf(address(this)).sub(_before); // Some tokens lose amount (transfer fee) upon transfer amount = _underlyingAsset.balanceOf(address(this)).sub(_before);  require(amount > 0, "Cannot deposit 0");  uint256 _strategyBalance = currentStrategy.balance(); // Will get the balance of the value of the main tokens at the strategy uint256 _strategyBalance = currentStrategy.balance();   _underlyingAsset.safeTransfer(address(currentStrategy), amount); // Transfer again into the strategy _underlyingAsset.safeTransfer(address(currentStrategy), amount);  currentStrategy.deposit(_msgSender()); // Activate strategy deposit currentStrategy.deposit(_msgSender());  require(currentStrategy.balance() > _strategyBalance, "No change in strategy balance"); // Balance should increase require(currentStrategy.balance() > _strategyBalance, "No change in strategy balance");  uint256 mintAmount = amount; if(totalSupply() > 0){  mintAmount = amount.mul(totalSupply()).div(total); // Our share of the total mintAmount = amount.mul(totalSupply()).div(total);  } _mint(_msgSender(),mintAmount); // Now mint new zs-token to the depositor _mint(_msgSender(),mintAmount);  emit Wrapped(_msgSender(), amount);
 function stopDeposits() external onlyGovernance { depositsOpen = false;
 function emergencyStopStrategy() external onlyGovernance { depositsOpen = false; if(currentStrategy != StabilizeStrategy(address(0))){ currentStrategy.exit(); // Pulls all the tokens and accessory tokens from the strategy currentStrategy.exit();  } currentStrategy = StabilizeStrategy(address(0)); _timelockType = 0; // Prevent governance from changing to new strategy without timelock _timelockType = 0; 
