function initialize(uint256 _hsp, uint256 _hrp, uint256 _bdur, uint256 _dbt, uint256 _mim, uint256 _vssm) returns (bool) { if (initializedTo < 8) { if (owner == 0) owner = msg.sender; hashSubmissionPeriod = _hsp; hashRevealPeriod = _hrp; baseDuration = _bdur; durationBumpTo = _dbt; minIncrementMillis = _mim; valueSubmissionSubsidyMillis = _vssm; for (uint256 i = initializedTo; i < 8 && msg.gas > 1100000; i++) { GasRemaining(msg.gas, i); if (i < 4) { auctions[i] = new OnePhaseAuction(); OnePhaseAuction(auctions[i]).initialize(this, baseDuration, durationBumpTo, minIncrementMillis, i); } else { auctions[i] = new TwoPhaseAuction(); TwoPhaseAuction(auctions[i]).initialize(this, hashSubmissionPeriod, hashRevealPeriod, valueSubmissionSubsidyMillis, i - 3); } } initializedTo = i; if (initializedTo == 8) return true; else return false; } return true; }
function initialize(address _t, uint256 _baseDuration, uint256 _durationBumpTo, uint256 _minIncrementMillis, uint256 _tp) returns (bool) { if (msg.sender != owner) return false; if (phase == 1 || phase == 2) return false; phase = 1; target = adStorer(_t); auctionEnd = block.timestamp + _baseDuration; durationBumpTo = _durationBumpTo; minIncrementMillis = _minIncrementMillis; nextBidIndex = 0; bestBidValue = 0; bestBidIndex = 0; auctionType = _tp; mostRecentAuctionStart = block.number; AuctionInitialized(); return true; }
function bid(string metadata) returns (int256) { if (phase != 1) { msg.sender.send(msg.value); return (-1); } if (phase == 1 && block.timestamp >= auctionEnd) { phase = 2; msg.sender.send(msg.value); return (-1); } if (msg.value * 1000 < bestBidValue * (1000 + minIncrementMillis)) { msg.sender.send(msg.value); return (-1); } if (msg.value > bestBidValue) { bestBidValue = msg.value; bestBidIndex = nextBidIndex; } bids[nextBidIndex].bidValue = msg.value; bids[nextBidIndex].metadata = metadata; bids[nextBidIndex].bidder = msg.sender; BidSubmitted(nextBidIndex, msg.value, metadata, msg.sender); nextBidIndex = nextBidIndex + 1; if (auctionEnd - block.timestamp < durationBumpTo) auctionEnd = block.timestamp + durationBumpTo; if ((auctionType & 2) == 2) totalRevenue += msg.value; return int256(nextBidIndex) - 1; }
function increaseBid(uint256 index) returns (bool) { if ((auctionType & 1) == 0) { msg.sender.send(msg.value); return (false); } if (phase != 1) { msg.sender.send(msg.value); return (false); } if (phase == 1 && block.timestamp >= auctionEnd) { msg.sender.send(msg.value); phase = 2; return (false); } if ((bids[index].bidValue + msg.value) * 1000 < bestBidValue * (1000 + minIncrementMillis)) { msg.sender.send(msg.value); return(false); } if (index >= nextBidIndex) { msg.sender.send(msg.value); return false; } if (bids[index].bidder != msg.sender) { msg.sender.send(msg.value); return false; } bids[index].bidValue += msg.value; if (bids[index].bidValue > bestBidValue) { bestBidValue = bids[index].bidValue; bestBidIndex = index; } if ((auctionType & 2) == 2) totalRevenue += msg.value; BidIncreased(index, msg.value, bids[index].bidValue, bids[index].metadata, bids[index].bidder); if (auctionEnd - block.timestamp < durationBumpTo) auctionEnd = block.timestamp + durationBumpTo; return(true); }
function ping() returns(bool) { if (phase == 1 && block.timestamp >= auctionEnd) phase = 2; if (phase != 2) return(false); uint _nbi = nextBidIndex; while (msg.gas > 100000 && _nbi > 0) { _nbi -= 1; if (_nbi == bestBidIndex) { } else { if ((auctionType & 2) == 0) bids[_nbi].bidder.send(bids[_nbi].bidValue); bids[_nbi].bidValue = 0; } } nextBidIndex = _nbi; if (_nbi == 0) { phase = 0; bool success; if (bestBidValue > 0) { AuctionWinner(bestBidIndex, bestBidValue, bids[bestBidIndex].metadata, bids[bestBidIndex].bidder); success = target.acceptAuctionResult(bids[bestBidIndex].bidder, bestBidValue, bids[bestBidIndex].metadata); } else { success = target.acceptAuctionResult(0, 0, ""); } if ((auctionType & 2) == 2) AuctionFinalized(totalRevenue); else AuctionFinalized(bestBidValue); owner.send(this.balance); if (!success) { while (1 == 1) { _nbi = _nbi; } } return(true); } return(false); }
function initialize(address _t, uint256 _hsp, uint256 _hrp, uint256 _vssm, uint256 _tp) returns (bool) { if (msg.sender != owner) return false; if (phase == 1 || phase == 2) return false; phase = 1; target = adStorer(_t); hashSubmissionEnd = block.timestamp + _hsp; hashRevealEnd = block.timestamp + _hsp + _hrp; valueSubmissionSubsidyMillis = _vssm; nextBidIndex = 0; bestBidValue = 0; secondBestBidValue = 0; totalValueSubmitted = 0; auctionRevenue = 0; auctionType = _tp; mostRecentAuctionStart = block.number; AuctionInitialized(); return true; }
function commitBid(bytes32 bidValueHash, string metadata) returns (int256) { if (phase != 1) { msg.sender.send(msg.value); return (-1); } if (phase == 1 && block.timestamp >= hashSubmissionEnd) { msg.sender.send(msg.value); return (-1); } bids[nextBidIndex].bidValueHash = bidValueHash; bids[nextBidIndex].valueSubmitted = msg.value; bids[nextBidIndex].metadata = metadata; bids[nextBidIndex].bidder = msg.sender; BidCommitted(nextBidIndex, bidValueHash, metadata, msg.sender); nextBidIndex = nextBidIndex + 1; totalValueSubmitted += msg.value; return int256(nextBidIndex) - 1; }
function revealBid(uint256 index, uint256 bidValue, bytes32 nonce) returns (bool) { if (phase == 1 && block.timestamp >= hashRevealEnd) { phase = 2; } if (phase != 1) { return (false); } if (phase == 1 && block.timestamp < hashSubmissionEnd) { return (false); } if (index >= nextBidIndex) return false; if (bidValue > bids[index].valueSubmitted) return false; if (sha3(bidValue, nonce) != bids[index].bidValueHash) return false; if (bidValue > bestBidValue) { secondBestBidValue = bestBidValue; bestBidValue = bidValue; bestBidIndex = index; } else if (bidValue > secondBestBidValue) { secondBestBidValue = bidValue; } if (auctionType == 3 || auctionType == 4) { bids[index].bidValue = bidValue; auctionRevenue += bidValue; } BidRevealed(index, bidValue, bids[index].metadata, bids[index].bidder); return true; }
function ping() returns(bool) { if (phase == 1 && block.timestamp >= hashRevealEnd) phase = 2; if (phase != 2) return(false); uint _nbi = nextBidIndex; uint _ar; if (auctionType == 1) _ar = bestBidValue; else if (auctionType == 2) _ar = secondBestBidValue; else if (auctionType == 3) _ar = auctionRevenue; else if (auctionType == 4) _ar = auctionRevenue + secondBestBidValue - bestBidValue; while (msg.gas > 500000 && _nbi > 0) { _nbi -= 1; uint256 subsidy = bids[_nbi].valueSubmitted * _ar * valueSubmissionSubsidyMillis / totalValueSubmitted / 1000; if (_nbi == bestBidIndex) { if (auctionType == 1 || auctionType == 3) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - bestBidValue + subsidy); else if (auctionType == 2 || auctionType == 4) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - secondBestBidValue + subsidy); } else { if (auctionType == 1 || auctionType == 2) bids[_nbi].bidder.send(bids[_nbi].valueSubmitted + subsidy); else bids[_nbi].bidder.send(bids[_nbi].valueSubmitted - bids[_nbi].bidValue + subsidy); bids[_nbi].bidValueHash = 0; } } nextBidIndex = _nbi; if (_nbi == 0) { phase = 0; bool success; if (bestBidValue > 0) { AuctionWinner(bestBidIndex, bestBidValue, bids[bestBidIndex].metadata, bids[bestBidIndex].bidder); success = target.acceptAuctionResult(bids[bestBidIndex].bidder, bestBidValue, bids[bestBidIndex].metadata); } else { success = target.acceptAuctionResult(0, 0, ""); } AuctionFinalized(_ar); owner.send(this.balance); if (!success) { while (1 == 1) { _nbi = _nbi; } } return(true); } return(false); }
enum Commitment { Hidden(bytes32 hash), Revealed(uint value) }
function insert(Heap[T] storage _heap, T _value)
function length() constant returns (uint) { return back - front; }
function capacity() constant returns (uint) { return q.length - 1; }
function push(uint /*Value*/ data)
function pop() returns (uint /* Value */ r)
function Gavsino() { if (msg.value > 0) m_totalShares = msg.value / 1000000000000000; else m_totalShares = 1; m_shares[msg.sender] = m_totalShares; }
function bet(uint pIn256, hash key) { m_owing += msg.value; m_orders[key].amount = msg.value; m_orders[key].pIn256 = pIn256; m_orders[key].number = block.number; log1(0, key); }
function claim(hash bet) { hash key = sha3(bet); if (m_orders[key].amount > 0) { uint refund = (m_orders[key].amount * 1 / 200); uint w = winningsWithKey(key, bet) + refund; msg.sender.send(w); m_owing -= m_orders[key].amount; delete m_orders[key]; log1(0, key); } }
function insert(uint k, uint v) returns (uint size)
function sum() returns (uint s)
function append(data storage self, bytes32 _data) { var index = uint80(self.items.push(Item({prev: self.last, next: None, data: _data}))); if (self.last == None) { if (self.first != None || self.count != 0) throw; self.first = self.last = index; self.count = 1; } else { self.items[self.last - 1].next = index; self.last = index; self.count ++; } }
function remove(data storage self, uint80 _index) { Item item = self.items[_index - 1]; if (item.prev == None) self.first = item.next; if (item.next == None) self.last = item.prev; if (item.prev != None) self.items[item.prev - 1].next = item.next; if (item.next != None) self.items[item.next - 1].prev = item.prev; delete self.items[_index - 1]; self.count--; }
function find(data storage self, bytes32 _value) returns (uint80) { var it = iterate_start(self); while (iterate_valid(self, it)) { if (iterate_get(self, it) == _value) return it; it = iterate_next(self, it); } return it; }
function iterate_start(data storage self) returns (uint80) { return self.first; }
function modExp(uint x, uint k, uint m) returns (uint r) { r = 1; for (uint s = 1; s <= k; s *= 2) { if (k & s != 0) r = mulmod(r, x, m); x = mulmod(x, x, m); } }
function compare(string _a, string _b) returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; }
function equal(string _a, string _b) returns (bool) { return compare(_a, _b) == 0; }
function indexOf(string _haystack, string _needle) returns (int)
event onNewLoan(address indexed from, uint indexed lid);
function onAuctionEnd(string _name) internal;
function claimComputation(bytes _data, bytes32 _hash) { sessions.push(VerificationSession({ claimant: msg.sender, challenger: address(0), data: _data, hash: _hash, queries: new uint16[](0), values: new uint[4][](0) })); NewClaim(sessions.length - 1); }
function query(uint session, uint16 _i) onlyChallenger(session) { if (_i > 2048) throw; sessions[session].queries.push(_i); NewQuery(session); }
function respond(uint session, uint[4] _value) onlyClaimant(session) { var s = sessions[session]; if (s.values.length >= s.queries.length) throw; s.values.push(_value); NewResponse(session); }
function convict(uint session, uint q1, uint q2, uint q3) onlyChallenger(session) { var s = sessions[session]; var i = s.queries[q1]; if (s.queries[q2] != i + 1) throw; var input = s.values[q1]; var output = s.values[q2]; if (i < 1024) { if (!verifyFirstHalf(input, output)) Convicted(session); } else { var auxIndex = s.queries[q3]; if (auxIndex != (input[2] / 0x100000000000000000000000000000000000000000000000000000000) % 1024) throw; var auxInput = s.values[q3]; if (!verifySecondHalf(input, auxInput, output)) Convicted(session); } }
function convictInitial(uint session, uint q) onlyChallenger(session) { var s = sessions[session]; if (s.queries[q] != 0) throw; var v = s.values[q]; var h = KeyDeriv.pbkdf2(s.data, s.data, 128); if (uint(h[0]) != v[0] || uint(h[1]) != v[1] || uint(h[2]) != v[2] || uint(h[3]) != v[3]) Convicted(session); }
function convictFinal(uint session, uint q) onlyChallenger(session) { var s = sessions[session]; if (s.queries[q] != 2048) throw; var v = s.values[q]; bytes memory val = new bytes(128); for (uint i = 0; i < 128; i ++) val[i] = byte(uint8(v[i / 32] / 2**((32 - (i % 32)) * 8))); var h = KeyDeriv.pbkdf2(val, val, 32); if (h[0] != s.hash) Convicted(session); }
function verifyFirstHalf(uint[4] input, uint[4] output) constant returns (bool) { var (a, b, c, d) = Salsa8.round(input[0], input[1], input[2], input[3]); return (a == output[0] && b == output[1] && c == output[2] && d == output[3]); }
function verifySecondHalf(uint[4] input, uint[4] vinput, uint[4] output) constant returns (bool) { input[0] ^= vinput[0]; input[1] ^= vinput[1]; input[2] ^= vinput[2]; input[3] ^= vinput[3]; return verifyFirstHalf(input, output); }
function pbkdf2(bytes key, bytes salt, uint dklen) constant returns (bytes32[4] r) { var msg = new bytes(salt.length + 4); for (uint i = 0; i < salt.length; i++) msg[i] = salt[i]; for (i = 0; i * 32 < dklen; i++) { msg[msg.length - 1] = bytes1(uint8(i + 1)); r[i] = hmacsha256(key, msg); } }
event Confirmation(address owner, bytes32 operation);
event OwnerChanged(address oldOwner, address newOwner);
event RequirementChanged(uint newRequirement);
modifier onlyowner { require(isOwner(msg.sender)); _; }
modifier onlymanyowners(bytes32 _operation) { require(confirmAndCheck(_operation)); _; }
function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; }
function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } }
function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); }
function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); }
function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } }
modifier limitedDaily(uint _value) { require(underLimit(_value)); _; }
function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); }
function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; }
function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; }
function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; }
function today() private constant returns (uint) { return now / 1 days; }
event Deposit(address _from, uint value);
event SingleTransact(address owner, uint value, address to, bytes data);
event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);
event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);
function changeOwner(address _from, address _to) external;
function Wallet(address[] _owners, uint _required, uint _daylimit)
function kill(address _to) onlymanyowners(sha3(msg.data)) external { selfdestruct(_to); }
function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); require(_to.call.value(_value)(_data)); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } }
function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { require(m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint128[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) sum := add(term,sum) } } }
function getMax(uint128[] storage self) public view returns(uint128 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint128[] storage self) public view returns(uint128 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,2))) remainder := mod(i,2) for { let j := 0 } lt(j, mul(remainder, 4)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint128[] storage self, uint128 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint128[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint128 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint128[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint16[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) sum := add(term,sum) } } }
function getMax(uint16[] storage self) public view returns(uint16 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint16[] storage self) public view returns(uint16 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,16))) remainder := mod(i,16) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,65536) } term := and(0x000000000000000000000000000000000000000000000000000000000000ffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint16[] storage self, uint16 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint16[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint16 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint16[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint32[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) sum := add(term,sum) } } }
function getMax(uint32[] storage self) public view returns(uint32 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint32[] storage self) public view returns(uint32 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,8))) remainder := mod(i,8) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x00000000000000000000000000000000000000000000000000000000ffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint32[] storage self, uint32 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint32[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint32 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint32[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint64[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) sum := add(term,sum) } } }
function getMax(uint64[] storage self) public view returns(uint64 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint64[] storage self) public view returns(uint64 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,4))) remainder := mod(i,4) for { let j := 0 } lt(j, mul(remainder, 2)) { j := add(j, 1) } { term := div(term,4294967296) } term := and(0x000000000000000000000000000000000000000000000000ffffffffffffffff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint64[] storage self, uint64 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint64[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint64 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint64[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function sumElements(uint8[] storage self) public view returns(uint256 sum) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) sum := add(term,sum) } } }
function getMax(uint8[] storage self) public view returns(uint8 maxValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) maxValue := 0 for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) switch lt(maxValue, term) case 1 { maxValue := term } } } }
function getMin(uint8[] storage self) public view returns(uint8 minValue) { uint256 term; uint8 remainder; assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { term := sload(add(sha3(0x60,0x20),div(i,32))) remainder := mod(i,32) for { let j := 0 } lt(j, remainder) { j := add(j, 1) } { term := div(term,256) } term := and(0x00000000000000000000000000000000000000000000000000000000000000ff,term) switch eq(i,0) case 1 { minValue := term } switch gt(minValue, term) case 1 { minValue := term } } } }
function indexOf(uint8[] storage self, uint8 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint8[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint8 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint8[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount)
function () payable public { sendPurchase(); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function init(DirectCrowdsaleStorage storage self,
function receivePurchase(DirectCrowdsaleStorage storage self, uint256 _amount) returns (bool) { require(msg.sender != self.base.owner); require(self.base.validPurchase()); require((self.base.ownerBalance + _amount) <= self.base.capAmount); if ((self.changeInterval > 0) && (now >= (self.lastPriceChangeTime + self.changeInterval))) { self.lastPriceChangeTime = self.lastPriceChangeTime + self.changeInterval; uint256 index = (now-self.base.startTime)/self.changeInterval; if (self.tokenPricePoints.length <= index) index = self.tokenPricePoints.length - 1; self.base.changeTokenPrice(self.tokenPricePoints[index]); LogTokenPriceChange(self.base.tokensPerEth,"Token Price has changed!"); } uint256 numTokens;  uint256 numTokens;  bool err; uint256 newBalance;  uint256 newBalance;  uint256 weiTokens;  uint256 weiTokens;  uint256 zeros;  uint256 zeros;  uint256 leftoverWei;  uint256 leftoverWei;  uint256 remainder;  uint256 remainder;  (err,weiTokens) = _amount.times(self.base.tokensPerEth); require(!err); if(self.base.tokenDecimals <= 18){ zeros = 10**(18-uint256(self.base.tokenDecimals)); numTokens = weiTokens/zeros; leftoverWei = weiTokens % zeros; self.base.leftoverWei[msg.sender] += leftoverWei; } else { zeros = 10**(uint256(self.base.tokenDecimals)-18); numTokens = weiTokens*zeros; } self.base.hasContributed[msg.sender] += _amount - leftoverWei; require(numTokens <= self.base.token.balanceOf(this)); (err,newBalance) = self.base.ownerBalance.plus(_amount-leftoverWei); require(!err); self.base.ownerBalance = newBalance;    self.base.ownerBalance = newBalance;    self.base.withdrawTokensMap[msg.sender] += numTokens; (err,remainder) = self.base.withdrawTokensMap[self.base.owner].minus(numTokens); self.base.withdrawTokensMap[self.base.owner] = remainder; LogTokensBought(msg.sender, numTokens); return true; }
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegError(address user, string Msg);
event LogAddressTokenCapChange(uint256 amount, string Msg);
event LogAddressTokenCapCalculated(uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function calculateAddressTokenCap(EvenDistroCrowdsaleStorage storage self)
function getMin(uint256 a, uint256 b) internal pure returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegError(address user, string Msg);
event LogAddressTokenCapChange(uint256 amount, string Msg);
event LogAddressTokenCapCalculated(uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant)
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants)
function calculateAddressTokenCap(EvenDistroCrowdsaleStorage storage self)
function getMin(uint256 a, uint256 b) internal pure returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount)
function () payable { sendPurchase(); }
function () payable { sendPurchase(); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
event LogTokensBought(address indexed buyer, uint256 amount);
event LogAddressCapExceeded(address indexed buyer, uint256 amount, string Msg);
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogErrorMsg(string Msg);
event LogAddressCapChange(uint256 amount, string Msg);
event LogAddressCapCalculated(uint256 saleCap, uint256 numRegistered, uint256 cap, string Msg);
function init(EvenDistroCrowdsaleStorage storage self,
function registerUser(EvenDistroCrowdsaleStorage storage self, address _registrant) returns (bool) { require(msg.sender == self.base.owner); if ((self.changeInterval > 0) && (now >= self.base.startTime - 3 days)) { LogErrorMsg("Can only register users earlier than 3 days before the sale!"); return false; } if(self.isRegistered[_registrant]) { LogErrorMsg("Registrant address is already registered for the sale!"); return false; } uint256 result; bool err; self.isRegistered[_registrant] = true; (err,result) = self.numRegistered.plus(1); require(!err); self.numRegistered = result; LogUserRegistered(_registrant); return true; }
function registerUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants) returns (bool) { require(msg.sender == self.base.owner); if (self.changeInterval > 0) { require(now < self.base.startTime - 3 days); } bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = registerUser(self,_registrants[i]); } }
function unregisterUser(EvenDistroCrowdsaleStorage storage self, address _registrant) returns (bool) { require(msg.sender == self.base.owner); if ((self.changeInterval > 0) && (now >= self.base.startTime - 3 days)) { LogErrorMsg("Can only register and unregister users earlier than 3 days before the sale!"); return false; } if(!self.isRegistered[_registrant]) { LogErrorMsg("Registrant address not registered for the sale!"); return false; } uint256 result; bool err; self.isRegistered[_registrant] = false; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(EvenDistroCrowdsaleStorage storage self, address[] _registrants) returns (bool) { require(msg.sender == self.base.owner); if (self.changeInterval > 0) { require(now < self.base.startTime - 3 days); } bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } }
function calculateAddressCap(EvenDistroCrowdsaleStorage storage self) internal returns (bool) { require(self.numRegistered > 0); if ((now > self.base.startTime) || (now < (self.base.startTime - 3 days)) || (self.changeInterval == 0))  { return false; } require(!self.base.rateSet);   require(!self.base.rateSet);   uint256 result; bool err; (err,result) = self.base.capAmount.dividedBy(self.numRegistered); require(!err); self.addressCap = result; LogAddressCapCalculated(self.base.capAmount,self.numRegistered,result,"Address cap was Calculated!"); }
function getMin(uint256 a, uint256 b) internal constant returns (uint256) { if (a<b) { return a; } else { return b; } }
function receivePurchase(EvenDistroCrowdsaleStorage storage self, uint256 _amount) returns (bool) { require(msg.sender != self.base.owner); require(self.isRegistered[msg.sender]); require(self.base.validPurchase()); require((self.base.ownerBalance + _amount) <= self.base.capAmount); require((self.base.hasContributed[msg.sender]) < self.addressCap); bool err; uint256 result; if ((self.changeInterval > 0) && (now >= (self.lastCapChangeTime + self.changeInterval))) { uint256 numIntervals = (((now-(now%self.changeInterval))-self.lastCapChangeTime)/self.changeInterval); (err,result) = self.addressCap.times(self.capPercentMultiplier ** (numIntervals)); require(!err); (err,result) = result.dividedBy(100**numIntervals); require(!err); self.addressCap = result; self.lastCapChangeTime = self.lastCapChangeTime + (self.changeInterval*numIntervals); LogAddressCapChange(result, "Address cap has increased!"); } uint256 numTokens;  uint256 numTokens;  uint256 zeros;  uint256 zeros;  uint256 leftoverWei;  uint256 leftoverWei;  uint256 remainder = 0;  uint256 remainder = 0;  uint256 allowedWei;   uint256 allowedWei;   (err,allowedWei) = self.addressCap.minus(self.base.hasContributed[msg.sender]); require(!err); allowedWei = getMin(_amount,allowedWei); leftoverWei = _amount - allowedWei; (err,result) = allowedWei.times(self.base.tokensPerEth); require(!err); if(self.base.tokenDecimals <= 18){ zeros = 10**(18-uint256(self.base.tokenDecimals)); numTokens = result/zeros; remainder = result % zeros; } else { zeros = 10**(uint256(self.base.tokenDecimals)-18); numTokens = result*zeros; } self.base.leftoverWei[msg.sender] += leftoverWei+remainder; if(((self.base.hasContributed[msg.sender] + _amount)) > self.addressCap) { LogAddressCapExceeded(msg.sender,self.base.leftoverWei[msg.sender],"Cap Per Address has been exceeded! Please withdraw leftover Wei!"); } self.base.hasContributed[msg.sender] += allowedWei - remainder; require(numTokens <= self.base.token.balanceOf(this)); self.base.ownerBalance = self.base.ownerBalance + (allowedWei - remainder); self.base.withdrawTokensMap[msg.sender] += numTokens; (err,remainder) = self.base.withdrawTokensMap[self.base.owner].minus(numTokens); require(!err); self.base.withdrawTokensMap[self.base.owner] = remainder; LogTokensBought(msg.sender, numTokens); return true; }
event LogBidAccepted(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidWithdrawn(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidRemoved(address indexed bidder, uint256 personalValuation);
event LogErrorMsg(uint256 amount, string Msg);
event LogTokenPriceChange(uint256 amount, string Msg);
event BucketAndValuationAndCommitted(uint256 bucket, uint256 valuation, uint256 committed);
function init(InteractiveCrowdsaleStorage storage self,
function numDigits(uint256 _number) public pure returns (uint256) { uint256 _digits = 0; while (_number != 0) { _number /= 10; _digits++; } return _digits; }
function calculateTokenPurchase(uint256 _amount,
function getCurrentBonus(InteractiveCrowdsaleStorage storage self) internal view returns (uint256){ uint256 bonusTime = self.endWithdrawalTime - self.base.startTime; uint256 elapsed = now - self.base.startTime; uint256 percentElapsed = (elapsed * 100)/bonusTime; bool err; uint256 currentBonus; (err,currentBonus) = self.priceBonusPercent.minus(((percentElapsed * self.priceBonusPercent)/100)); require(!err); return currentBonus; }
function submitBid(InteractiveCrowdsaleStorage storage self,
function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(self.personalCaps[msg.sender] > 0); uint256 refundWei; if (now >= self.endWithdrawalTime) { require(self.personalCaps[msg.sender] < self.totalValuation); refundWei = self.base.hasContributed[msg.sender]; } else { require(!self.hasManuallyWithdrawn[msg.sender]);   require(!self.hasManuallyWithdrawn[msg.sender]);   /*********************************************************************** The following lines were commented out due to stack depth, but they represent the variables and calculations from the paper. The actual code is the same thing spelled out using current variables.  See section 4 of the white paper for formula used ************************************************************************/ uint256 multiplierPercent = (100 * (self.endWithdrawalTime - now)) / (self.endWithdrawalTime - self.base.startTime); refundWei = (multiplierPercent * self.base.hasContributed[msg.sender]) / 100; self.valuationSums[self.personalCaps[msg.sender]] -= refundWei; self.numBidsAtValuation[self.personalCaps[msg.sender]] -= 1; self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender] - ((self.pricePurchasedAt[msg.sender] - self.base.tokensPerEth) / 3); self.hasManuallyWithdrawn[msg.sender] = true; } self.base.leftoverWei[msg.sender] += refundWei; self.base.hasContributed[msg.sender] -= refundWei; uint256 _proposedCommit; uint256 _proposedValue; uint256 _currentBucket; bool loop; bool exists; if(self.personalCaps[msg.sender] >= self.totalValuation){ _proposedCommit = self.valueCommitted - refundWei; if(_proposedCommit <= self.currentBucket){ if(self.totalValuation > self.currentBucket){ _proposedCommit += self.valuationSums[self.currentBucket]; } if(_proposedCommit >= self.currentBucket){ _proposedValue = self.currentBucket; } else { loop = true; } } else { if(self.totalValuation == self.currentBucket){ _proposedValue = self.totalValuation; } else { _proposedValue = _proposedCommit; } } if(loop){ (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV); while(_proposedCommit <= _currentBucket){ _proposedCommit += self.valuationSums[_currentBucket]; if(_proposedCommit >= _currentBucket){ _proposedValue = _currentBucket; } else { (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV); } } if(_proposedValue == 0) { _proposedValue = _proposedCommit; } self.currentBucket = _currentBucket; } self.totalValuation = _proposedValue; self.valueCommitted = _proposedCommit; } LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]); BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted); return true; }
function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now >= self.base.endTime); require(!self.isFinalized);  require(!self.isFinalized);  require(setCanceled(self)); self.isFinalized = true; require(launchToken(self)); uint256 computedValue; if(!self.isCanceled){ if(self.totalValuation == self.currentBucket){ self.q = (100*(self.valueCommitted - self.totalValuation)/(self.valuationSums[self.totalValuation])) + 1; computedValue = self.valueCommitted - self.valuationSums[self.totalValuation]; computedValue += (self.q * self.valuationSums[self.totalValuation])/100; } else { computedValue = self.totalValuation; } self.base.ownerBalance = computedValue;   self.base.ownerBalance = computedValue;   } }
function launchToken(InteractiveCrowdsaleStorage storage self) internal returns (bool) { uint256 _fullValue = (self.totalValuation*100)/uint256(self.percentBeingSold); uint256 _bonusValue = ((self.totalValuation * (100 + self.priceBonusPercent))/100) - self.totalValuation; uint256 _supply = (_fullValue * self.base.tokensPerEth)/1000000000000000000; uint256 _bonusTokens = (_bonusValue * self.base.tokensPerEth)/1000000000000000000; uint256 _ownerTokens = _supply - ((_supply * uint256(self.percentBeingSold))/100); uint256 _totalSupply = _supply + _bonusTokens; self.base.token = new CrowdsaleToken(address(this), self.tokenInfo.name, self.tokenInfo.symbol, self.tokenInfo.decimals, _totalSupply, self.tokenInfo.stillMinting); if(!self.isCanceled){ self.base.token.transfer(self.base.owner, _ownerTokens); } else { self.base.token.transfer(self.base.owner, _supply); self.base.token.burnToken(_bonusTokens); } self.base.token.changeOwner(self.base.owner); self.base.startingTokenBalance = _supply - _ownerTokens; return true; }
function setCanceled(InteractiveCrowdsaleStorage storage self) internal returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.base.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return true; }
function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now > self.base.endTime); require(self.personalCaps[msg.sender] > 0); uint256 numTokens; uint256 remainder; if(!self.isFinalized){ require(setCanceled(self)); require(self.isCanceled); } if (self.isCanceled) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; LogErrorMsg(self.totalValuation, "Sale is canceled, all bids have been refunded!"); return true; } if (self.personalCaps[msg.sender] < self.totalValuation) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; return self.base.withdrawLeftoverWei(); } else if (self.personalCaps[msg.sender] == self.totalValuation) { uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100; self.base.leftoverWei[msg.sender] += refundAmount; self.base.hasContributed[msg.sender] -= refundAmount; } LogErrorMsg(self.base.hasContributed[msg.sender],"contribution"); LogErrorMsg(self.pricePurchasedAt[msg.sender],"price"); LogErrorMsg(self.q,"percentage"); (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], self.pricePurchasedAt[msg.sender]); self.base.withdrawTokensMap[msg.sender] += numTokens; self.valueCommitted = self.valueCommitted - remainder; self.base.leftoverWei[msg.sender] += remainder; uint256 _fullBonus; uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100; (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice); uint256 _leftoverBonus = _fullBonus - numTokens; self.base.token.burnToken(_leftoverBonus); self.base.hasContributed[msg.sender] = 0; self.base.withdrawTokens(); self.base.withdrawLeftoverWei(); }
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);
event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);
event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);
event LogNoticeMsg(address _buyer, uint256 value, string Msg);
event LogErrorMsg(uint256 amount, string Msg);
function init(CrowdsaleStorage storage self,
function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) { return (now >= self.startTime && now <= self.endTime); }
function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) { return now > self.endTime; }
function validPurchase(CrowdsaleStorage storage self) internal returns (bool) { bool nonZeroPurchase = msg.value != 0; if (crowdsaleActive(self) && nonZeroPurchase) { return true; } else { LogErrorMsg(msg.value, "Invalid Purchase! Check start time and amount of ether."); return false; } }
function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) { bool ok; if (self.withdrawTokensMap[msg.sender] == 0) { LogErrorMsg(0, "Sender has no tokens to withdraw!"); return false; } if (msg.sender == self.owner) { if(!crowdsaleEnded(self)){ LogErrorMsg(0, "Owner cannot withdraw extra tokens until after the sale!"); return false; } else { if(self.percentBurn > 0){ uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100; self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount; ok = self.token.burnToken(_burnAmount); require(ok); } } } var total = self.withdrawTokensMap[msg.sender]; self.withdrawTokensMap[msg.sender] = 0; ok = self.token.transfer(msg.sender, total); require(ok); LogTokensWithdrawn(msg.sender, total); return true; }
function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) { if (self.leftoverWei[msg.sender] == 0) { LogErrorMsg(0, "Sender has no extra wei to withdraw!"); return false; } var total = self.leftoverWei[msg.sender]; self.leftoverWei[msg.sender] = 0; msg.sender.transfer(total); LogWeiWithdrawn(msg.sender, total); return true; }
function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) { if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) { LogErrorMsg(0, "Cannot withdraw owner ether until after the sale!"); return false; } require(msg.sender == self.owner); require(self.ownerBalance > 0); uint256 amount = self.ownerBalance; self.ownerBalance = 0; self.owner.transfer(amount); LogOwnerEthWithdrawn(msg.sender,amount,"Crowdsale owner has withdrawn all funds!"); return true; }
function changeTokenPrice(CrowdsaleStorage storage self,
function setTokens(CrowdsaleStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(!self.tokensSet); require(now < self.endTime); uint256 _tokenBalance; _tokenBalance = self.token.balanceOf(this); self.withdrawTokensMap[msg.sender] = _tokenBalance; self.startingTokenBalance = _tokenBalance; self.tokensSet = true; return true; }
function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)
function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) { return self.startingTokenBalance - self.withdrawTokensMap[self.owner]; }
event LogBidAccepted(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidWithdrawn(address indexed bidder, uint256 amount, uint256 personalValuation);
event LogBidRemoved(address indexed bidder, uint256 personalValuation);
event LogErrorMsg(uint256 amount, string Msg);
event LogTokenPriceChange(uint256 amount, string Msg);
event BucketAndValuationAndCommitted(uint256 bucket, uint256 valuation, uint256 committed);
function init(InteractiveCrowdsaleStorage storage self,
function numDigits(uint256 _number) public pure returns (uint256) { uint256 _digits = 0; while (_number != 0) { _number /= 10; _digits++; } return _digits; }
function calculateTokenPurchase(uint256 _amount,
function getCurrentBonus(InteractiveCrowdsaleStorage storage self) internal view returns (uint256){ uint256 bonusTime = self.endWithdrawalTime - self.base.startTime; uint256 elapsed = now - self.base.startTime; uint256 percentElapsed = (elapsed * 100)/bonusTime; bool err; uint256 currentBonus; (err,currentBonus) = self.priceBonusPercent.minus(((percentElapsed * self.priceBonusPercent)/100)); require(!err); return currentBonus; }
function submitBid(InteractiveCrowdsaleStorage storage self,
function withdrawBid(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(self.personalCaps[msg.sender] > 0); uint256 refundWei; if (now >= self.endWithdrawalTime) { require(self.personalCaps[msg.sender] < self.totalValuation); refundWei = self.base.hasContributed[msg.sender]; } else { require(!self.hasManuallyWithdrawn[msg.sender]);   require(!self.hasManuallyWithdrawn[msg.sender]);   /*********************************************************************** The following lines were commented out due to stack depth, but they represent the variables and calculations from the paper. The actual code is the same thing spelled out using current variables.  See section 4 of the white paper for formula used ************************************************************************/ uint256 multiplierPercent = (100 * (self.endWithdrawalTime - now)) / (self.endWithdrawalTime - self.base.startTime); refundWei = (multiplierPercent * self.base.hasContributed[msg.sender]) / 100; self.valuationSums[self.personalCaps[msg.sender]] -= refundWei; self.numBidsAtValuation[self.personalCaps[msg.sender]] -= 1; self.pricePurchasedAt[msg.sender] = self.pricePurchasedAt[msg.sender] - ((self.pricePurchasedAt[msg.sender] - self.base.tokensPerEth) / 3); self.hasManuallyWithdrawn[msg.sender] = true; } self.base.leftoverWei[msg.sender] += refundWei; self.base.hasContributed[msg.sender] -= refundWei; uint256 _proposedCommit; uint256 _proposedValue; uint256 _currentBucket; bool loop; bool exists; if(self.personalCaps[msg.sender] >= self.totalValuation){ _proposedCommit = self.valueCommitted - refundWei; if(_proposedCommit <= self.currentBucket){ if(self.totalValuation > self.currentBucket){ _proposedCommit += self.valuationSums[self.currentBucket]; } if(_proposedCommit >= self.currentBucket){ _proposedValue = self.currentBucket; } else { loop = true; } } else { if(self.totalValuation == self.currentBucket){ _proposedValue = self.totalValuation; } else { _proposedValue = _proposedCommit; } } if(loop){ (exists,_currentBucket) = self.valuationsList.getAdjacent(self.currentBucket, PREV); while(_proposedCommit <= _currentBucket){ _proposedCommit += self.valuationSums[_currentBucket]; if(_proposedCommit >= _currentBucket){ _proposedValue = _currentBucket; } else { (exists,_currentBucket) = self.valuationsList.getAdjacent(_currentBucket, PREV); } } if(_proposedValue == 0) { _proposedValue = _proposedCommit; } self.currentBucket = _currentBucket; } self.totalValuation = _proposedValue; self.valueCommitted = _proposedCommit; } LogBidWithdrawn(msg.sender, refundWei, self.personalCaps[msg.sender]); BucketAndValuationAndCommitted(self.currentBucket, self.totalValuation, self.valueCommitted); return true; }
function finalizeSale(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now >= self.base.endTime); require(!self.isFinalized);  require(!self.isFinalized);  require(setCanceled(self)); self.isFinalized = true; require(launchToken(self)); uint256 computedValue; if(!self.isCanceled){ if(self.totalValuation == self.currentBucket){ self.q = (100*(self.valueCommitted - self.totalValuation)/(self.valuationSums[self.totalValuation])) + 1; computedValue = self.valueCommitted - self.valuationSums[self.totalValuation]; computedValue += (self.q * self.valuationSums[self.totalValuation])/100; } else { computedValue = self.totalValuation; } self.base.ownerBalance = computedValue;   self.base.ownerBalance = computedValue;   } }
function launchToken(InteractiveCrowdsaleStorage storage self) internal returns (bool) { uint256 _fullValue = (self.totalValuation*100)/uint256(self.percentBeingSold); uint256 _bonusValue = ((self.totalValuation * (100 + self.priceBonusPercent))/100) - self.totalValuation; uint256 _supply = (_fullValue * self.base.tokensPerEth)/1000000000000000000; uint256 _bonusTokens = (_bonusValue * self.base.tokensPerEth)/1000000000000000000; uint256 _ownerTokens = _supply - ((_supply * uint256(self.percentBeingSold))/100); uint256 _totalSupply = _supply + _bonusTokens; self.base.token = new CrowdsaleToken(address(this), self.tokenInfo.name, self.tokenInfo.symbol, self.tokenInfo.decimals, _totalSupply, self.tokenInfo.stillMinting); if(!self.isCanceled){ self.base.token.transfer(self.base.owner, _ownerTokens); } else { self.base.token.transfer(self.base.owner, _supply); self.base.token.burnToken(_bonusTokens); } self.base.token.changeOwner(self.base.owner); self.base.startingTokenBalance = _supply - _ownerTokens; return true; }
function setCanceled(InteractiveCrowdsaleStorage storage self) internal returns(bool){ bool canceled = (self.totalValuation < self.minimumRaise) || ((now > (self.base.endTime + 30 days)) && !self.isFinalized); if(canceled) {self.isCanceled = true;} return true; }
function retreiveFinalResult(InteractiveCrowdsaleStorage storage self) public returns (bool) { require(now > self.base.endTime); require(self.personalCaps[msg.sender] > 0); uint256 numTokens; uint256 remainder; if(!self.isFinalized){ require(setCanceled(self)); require(self.isCanceled); } if (self.isCanceled) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; LogErrorMsg(self.totalValuation, "Sale is canceled, all bids have been refunded!"); return true; } if (self.personalCaps[msg.sender] < self.totalValuation) { self.base.leftoverWei[msg.sender] += self.base.hasContributed[msg.sender]; self.base.hasContributed[msg.sender] = 0; return self.base.withdrawLeftoverWei(); } else if (self.personalCaps[msg.sender] == self.totalValuation) { uint256 refundAmount = (self.q*self.base.hasContributed[msg.sender])/100; self.base.leftoverWei[msg.sender] += refundAmount; self.base.hasContributed[msg.sender] -= refundAmount; } LogErrorMsg(self.base.hasContributed[msg.sender],"contribution"); LogErrorMsg(self.pricePurchasedAt[msg.sender],"price"); LogErrorMsg(self.q,"percentage"); (numTokens, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], self.pricePurchasedAt[msg.sender]); self.base.withdrawTokensMap[msg.sender] += numTokens; self.valueCommitted = self.valueCommitted - remainder; self.base.leftoverWei[msg.sender] += remainder; uint256 _fullBonus; uint256 _fullBonusPrice = (self.base.tokensPerEth*(100 + self.priceBonusPercent))/100; (_fullBonus, remainder) = calculateTokenPurchase(self.base.hasContributed[msg.sender], _fullBonusPrice); uint256 _leftoverBonus = _fullBonus - numTokens; self.base.token.burnToken(_leftoverBonus); self.base.hasContributed[msg.sender] = 0; self.base.withdrawTokens(); self.base.withdrawLeftoverWei(); }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function listExists(LinkedList storage self)
function nodeExists(LinkedList storage self, uint256 _node)
function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; uint256 i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; }
function getNode(LinkedList storage self, uint256 _node)
function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)
function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)
function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; }
function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { uint256 c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } }
function remove(LinkedList storage self, uint256 _node) internal returns (uint256) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; }
function push(LinkedList storage self, uint256 _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); }
function pop(LinkedList storage self, bool _direction) internal returns (uint256) { bool exists; uint256 adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); }
function nodeExists(uint256 _node) view public returns (bool) { return list.nodeExists(_node); }
function sizeOf() view public returns (uint256 numElements) { return list.sizeOf(); }
function getNode(uint256 _node)
function getAdjacent(uint256 _node, bool _direction)
function getSortedSpot(uint256 _node, uint256 _value, bool _direction)
function insert(uint256 _node, uint256 _new, bool _direction) public { list.insert(_node,_new,_direction); }
function remove(uint256 _node) public returns (uint256) { return list.remove(_node); }
function push(uint256 _node, bool _direction) public { list.push(_node,_direction); }
function pop(bool _direction) public returns (uint256) { return list.pop(_direction); }
function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); }
function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; }
function toSliceB32(bytes32 self) internal returns (slice ret) { assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); }
function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); }
function toString(slice self) internal view returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; }
function len(slice self) internal view returns (uint) { var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; }
function empty(slice self) internal view returns (bool) { return self._len == 0; }
function compare(slice self, slice other) internal view returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); }
function equals(slice self, slice other) internal view returns (bool) { return compare(self, other) == 0; }
function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; }
function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); }
function ord(slice self) internal view returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; }
function keccak(slice self) internal view returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } }
function startsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; }
function endsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; }
function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; }
function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; }
function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; }
function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); }
function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { self._len = 0; } else { self._len -= token._len + needle._len; } return token; }
function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); }
function count(slice self, slice needle) internal view returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } }
function contains(slice self, slice needle) internal view returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; }
function concat(slice self, slice other) internal view returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; }
function join(slice self, slice[] parts) internal view returns (string) { if (parts.length == 0) return ""; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; }
function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); }
function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; }
function toSliceB32(bytes32 self) internal returns (slice ret) { assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); }
function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); }
function toString(slice self) internal view returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; }
function len(slice self) internal view returns (uint) { var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; }
function empty(slice self) internal view returns (bool) { return self._len == 0; }
function compare(slice self, slice other) internal view returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { uint256 mask = uint256(-1); if(shortest < 32) { mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); } var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); }
function equals(slice self, slice other) internal view returns (bool) { return compare(self, other) == 0; }
function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; }
function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); }
function ord(slice self) internal view returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; }
function keccak(slice self) internal view returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } }
function startsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; }
function endsWith(slice self, slice needle) internal view returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; }
function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; }
function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr)
function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; }
function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; }
function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; }
function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); }
function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { self._len = 0; } else { self._len -= token._len + needle._len; } return token; }
function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); }
function count(slice self, slice needle) internal view returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } }
function contains(slice self, slice needle) internal view returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; }
function concat(slice self, slice other) internal view returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; }
function join(slice self, slice[] parts) internal view returns (string) { if (parts.length == 0) return ""; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool) { bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool) { self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) { return self.allowed[_owner][_spender]; }
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function init(VestingStorage storage self,
function initializeETHBalance(VestingStorage storage self, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(!self.isToken); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function initializeTokenBalance(VestingStorage storage self, CrowdsaleToken token, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(self.isToken); require(token.balanceOf(this) == _balance); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function registerUser(VestingStorage storage self,
function registerUsers(VestingStorage storage self,
function unregisterUser(VestingStorage storage self, address _registrant) public returns (bool) { require((msg.sender == self.owner) || (msg.sender == address(this))); if (now >= self.startTime) { LogErrorMsg(self.startTime, "Can only register and unregister users before the vesting starts!"); return false; } uint256 _totalHolding; uint256 result; bool err; _totalHolding = self.holdingAmount[_registrant][0] + self.holdingAmount[_registrant][1]; if(_totalHolding == 0) { LogErrorMsg(0, "Registrant address not registered for the vesting!"); return false; } self.holdingAmount[_registrant][0] = 0; self.holdingAmount[_registrant][1] = 0; self.contractBalance += _totalHolding; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(VestingStorage storage self, address[] _registrants) public returns (bool) { require(msg.sender == self.owner); bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } return ok; }
function swapRegistration(VestingStorage storage self, address _replacementRegistrant) public returns (bool) { require(_replacementRegistrant != 0); require(self.holdingAmount[_replacementRegistrant][0] == 0); uint256 _vestAmount = self.holdingAmount[msg.sender][0]; uint256 _bonus = self.holdingAmount[msg.sender][1]; uint256 _withdrawnAmount = self.hasWithdrawn[msg.sender]; require(_vestAmount > 0); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; self.hasWithdrawn[msg.sender] = 0; self.holdingAmount[_replacementRegistrant][0] = _vestAmount; self.holdingAmount[_replacementRegistrant][1] = _bonus; self.hasWithdrawn[_replacementRegistrant] = _withdrawnAmount; LogRegistrationReplaced(msg.sender, _replacementRegistrant, self.hasWithdrawn[_replacementRegistrant]); return true; }
function calculateWithdrawal(VestingStorage storage self, address _beneficiary) internal view returns (uint256) { require(_beneficiary != 0); require(self.holdingAmount[_beneficiary][0] > 0); require(self.numRegistered > 0); bool err; uint256 _numIntervals = (now-self.startTime)/self.timeInterval; uint256 _amountReleased = ((_numIntervals*self.percentPerInterval)*self.holdingAmount[_beneficiary][0])/100; (err, _amountReleased) = _amountReleased.minus(self.hasWithdrawn[_beneficiary]); return _amountReleased; }
function withdrawETH(VestingStorage storage self) public returns (bool) { require(now > self.startTime); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; msg.sender.transfer(_withdrawAmount); LogETHWithdrawn(msg.sender,_withdrawAmount); return true; }
function withdrawTokens(VestingStorage storage self,CrowdsaleToken token) public returns (bool) { require(now > self.startTime); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); require(ok); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; ok = token.transfer(msg.sender, _withdrawAmount); require(ok); LogTokensWithdrawn(msg.sender,_withdrawAmount); return true; }
function sendETH(VestingStorage storage self, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[_beneficiary][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; _beneficiary.transfer(_withdrawAmount); LogETHWithdrawn(_beneficiary,_withdrawAmount); return true; }
function sendTokens(VestingStorage storage self,CrowdsaleToken token, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1];  self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; ok = token.transfer(_beneficiary, _withdrawAmount); require(ok); LogTokensWithdrawn(_beneficiary,_withdrawAmount); return true; }
function ownerWithdrawExtraETH(VestingStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(!self.isToken); uint256 _contractBalance = this.balance; self.contractBalance = 0; self.owner.transfer(_contractBalance); LogETHWithdrawn(self.owner,_contractBalance); return true; }
function ownerWithdrawExtraTokens(VestingStorage storage self, CrowdsaleToken token) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(self.isToken); uint256 _contractBalance = token.balanceOf(this); self.contractBalance = 0; token.transfer(self.owner,_contractBalance); LogTokensWithdrawn(self.owner,_contractBalance); return true; }
function getPercentReleased(VestingStorage storage self) public view returns (uint256) { require(now > self.startTime); return self.percentPerInterval * ((now-self.startTime)/self.timeInterval); }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function init(VestingStorage storage self,
function initializeETHBalance(VestingStorage storage self, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(!self.isToken); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function initializeTokenBalance(VestingStorage storage self, CrowdsaleToken token, uint256 _balance) public returns (bool) { require(msg.sender == self.owner); require(now < self.startTime); require(_balance != 0); require(self.isToken); require(token.balanceOf(this) == _balance); require(self.totalSupply == 0); self.totalSupply = _balance; self.contractBalance = _balance; return true; }
function registerUser(VestingStorage storage self,
function registerUsers(VestingStorage storage self,
function unregisterUser(VestingStorage storage self, address _registrant) public returns (bool) { require((msg.sender == self.owner) || (msg.sender == address(this))); if (now >= self.startTime) { LogErrorMsg(self.startTime, "Can only register and unregister users before the vesting starts!"); return false; } uint256 _totalHolding; uint256 result; bool err; _totalHolding = self.holdingAmount[_registrant][0] + self.holdingAmount[_registrant][1]; if(_totalHolding == 0) { LogErrorMsg(0, "Registrant address not registered for the vesting!"); return false; } self.holdingAmount[_registrant][0] = 0; self.holdingAmount[_registrant][1] = 0; self.contractBalance += _totalHolding; (err,result) = self.numRegistered.minus(1); require(!err); self.numRegistered = result; LogUserUnRegistered(_registrant); return true; }
function unregisterUsers(VestingStorage storage self, address[] _registrants) public returns (bool) { require(msg.sender == self.owner); bool ok; for (uint256 i = 0; i < _registrants.length; i++) { ok = unregisterUser(self,_registrants[i]); } return ok; }
function swapRegistration(VestingStorage storage self, address _replacementRegistrant) public returns (bool) { require(_replacementRegistrant != 0); require(self.holdingAmount[_replacementRegistrant][0] == 0); uint256 _vestAmount = self.holdingAmount[msg.sender][0]; uint256 _bonus = self.holdingAmount[msg.sender][1]; uint256 _withdrawnAmount = self.hasWithdrawn[msg.sender]; require(_vestAmount > 0); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; self.hasWithdrawn[msg.sender] = 0; self.holdingAmount[_replacementRegistrant][0] = _vestAmount; self.holdingAmount[_replacementRegistrant][1] = _bonus; self.hasWithdrawn[_replacementRegistrant] = _withdrawnAmount; LogRegistrationReplaced(msg.sender, _replacementRegistrant, self.hasWithdrawn[_replacementRegistrant]); return true; }
function calculateWithdrawal(VestingStorage storage self, address _beneficiary) internal view returns (uint256) { require(_beneficiary != 0); require(self.holdingAmount[_beneficiary][0] > 0); require(self.numRegistered > 0); bool err; uint256 _numIntervals = (now-self.startTime)/self.timeInterval; uint256 _amountReleased = ((_numIntervals*self.percentPerInterval)*self.holdingAmount[_beneficiary][0])/100000; (err, _amountReleased) = _amountReleased.minus(self.hasWithdrawn[_beneficiary]); return _amountReleased; }
function withdrawETH(VestingStorage storage self) public returns (bool) { require(now > self.startTime); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; msg.sender.transfer(_withdrawAmount); LogETHWithdrawn(msg.sender,_withdrawAmount); return true; }
function withdrawTokens(VestingStorage storage self,CrowdsaleToken token) public returns (bool) { require(now > self.startTime); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[msg.sender][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, msg.sender); uint256 _bonusAmount = self.holdingAmount[msg.sender][1]; self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); require(ok); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[msg.sender][0] + self.holdingAmount[msg.sender][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[msg.sender]); require(!err); self.holdingAmount[msg.sender][0] = 0; self.holdingAmount[msg.sender][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, msg.sender); } } self.hasWithdrawn[msg.sender] += _withdrawAmount; ok = token.transfer(msg.sender, _withdrawAmount); require(ok); LogTokensWithdrawn(msg.sender,_withdrawAmount); return true; }
function sendETH(VestingStorage storage self, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(!self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1]; self.holdingAmount[_beneficiary][1] = 0; self.contractBalance += _bonusAmount; } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; _beneficiary.transfer(_withdrawAmount); LogETHWithdrawn(_beneficiary,_withdrawAmount); return true; }
function sendTokens(VestingStorage storage self,CrowdsaleToken token, address _beneficiary) public returns (bool) { require(now > self.startTime); require(msg.sender == self.owner); require(self.isToken); bool ok; bool err; uint256 _withdrawAmount; if((now < self.endTime) && (self.holdingAmount[_beneficiary][1] > 0)){ _withdrawAmount = calculateWithdrawal(self, _beneficiary); uint256 _bonusAmount = self.holdingAmount[_beneficiary][1];  self.holdingAmount[msg.sender][1] = 0; ok = token.burnToken(_bonusAmount); } else { if(now > self.endTime){ _withdrawAmount = self.holdingAmount[_beneficiary][0] + self.holdingAmount[_beneficiary][1]; (ok, _withdrawAmount) = _withdrawAmount.minus(self.hasWithdrawn[_beneficiary]); require(!err); self.holdingAmount[_beneficiary][0] = 0; self.holdingAmount[_beneficiary][1] = 0; } else { _withdrawAmount = calculateWithdrawal(self, _beneficiary); } } self.hasWithdrawn[_beneficiary] += _withdrawAmount; ok = token.transfer(_beneficiary, _withdrawAmount); require(ok); LogTokensWithdrawn(_beneficiary,_withdrawAmount); return true; }
function ownerWithdrawExtraETH(VestingStorage storage self) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(!self.isToken); uint256 _contractBalance = this.balance; self.contractBalance = 0; self.owner.transfer(_contractBalance); LogETHWithdrawn(self.owner,_contractBalance); return true; }
function ownerWithdrawExtraTokens(VestingStorage storage self, CrowdsaleToken token) public returns (bool) { require(msg.sender == self.owner); require(now > self.endTime); require(self.isToken); uint256 _contractBalance = token.balanceOf(this); self.contractBalance = 0; token.transfer(self.owner,_contractBalance); LogTokensWithdrawn(self.owner,_contractBalance); return true; }
function getPercentReleased(VestingStorage storage self) public view returns (uint256) { require(now > self.startTime); return (self.percentPerInterval * ((now-self.startTime)/self.timeInterval))/1000; }
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogETHWithdrawn(address beneficiary, uint256 amount);
event LogErrorMsg(uint256 amount, string Msg);
event LogUserRegistered(address registrant, uint256 vestAmount, uint256 bonus);
event LogUserUnRegistered(address registrant);
event LogRegistrationReplaced(address currentRegistrant, address newRegistrant, uint256 amountWithdrawn);
event LogTokensWithdrawn(address beneficiary, uint256 amount);
function checkChangeOwnerArgs(uint256 _from, uint256 _to)
function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max)
function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min)
function checkRequiredChange(uint256 _newRequired, uint256 _length)
function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) { return _required - _count; }
function changeOwner(WalletMainLib.WalletData storage self,
function addOwner(WalletMainLib.WalletData storage self,
function removeOwner(WalletMainLib.WalletData storage self,
function changeRequiredAdmin(WalletMainLib.WalletData storage self,
function changeRequiredMajor(WalletMainLib.WalletData storage self,
function changeRequiredMinor(WalletMainLib.WalletData storage self,
function changeMajorThreshold(WalletMainLib.WalletData storage self,
function getOwners(WalletMainLib.WalletData storage self) public view returns (address[51]) { address[51] memory o; for(uint256 i = 0; i<self.owners.length; i++){ o[i] = self.owners[i]; } return o; }
function getOwnerIndex(WalletMainLib.WalletData storage self, address _owner) public view returns (uint256) { return self.ownerIndex[_owner]; }
function getMaxOwners(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.maxOwners; }
function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; }
function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; }
function getRequiredMinor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMinor; }
function getRequiredMajor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMajor; }
function getCurrentSpend(WalletMainLib.WalletData storage self, address _token) public view returns (uint256[2]) { uint256[2] memory cs; cs[0] = self.currentSpend[_token][0]; cs[1] = self.currentSpend[_token][1]; return cs; }
function getMajorThreshold(WalletMainLib.WalletData storage self, address _token) public view returns (uint256) { return self.majorThreshold[_token]; }
function getTransactionLength(WalletMainLib.WalletData storage self, bytes32 _id) public view returns (uint256) { return self.transactionInfo[_id].length; }
function getTransactionConfirms(WalletMainLib.WalletData storage self,
function getTransactionConfirmCount(WalletMainLib.WalletData storage self,
function getTransactionSuccess(WalletMainLib.WalletData storage self,
function init(WalletData storage self,
function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)
function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){ return _required - _count; }
function getAmount(bytes _txData) public pure returns (bool,uint256) { bytes32 getSig; bytes4 sig; bytes4 tSig = 0xa9059cbb;  bytes4 tSig = 0xa9059cbb;  bytes4 aSig = 0x095ea7b3;  bytes4 aSig = 0x095ea7b3;  bytes4 tfSig = 0x23b872dd;  bytes4 tfSig = 0x23b872dd;  bool transfer; bytes32 _amountData; uint256 _amount; assembly { getSig := mload(add(_txData,0x20)) } sig = bytes4(getSig); if(sig ==  tSig || sig == aSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x44)) } _amount = uint256(_amountData); } else if(sig == tfSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x64)) } _amount = uint256(_amountData); } return (transfer,_amount); }
function getRequired(WalletData storage self,
function createContract(bytes _txData, uint256 _value) public { address _newContract; bool allGood; assembly { _newContract := create(_value, add(_txData, 0x20), mload(_txData)) allGood := gt(extcodesize(_newContract),0) } require(allGood); LogContractCreated(_newContract, _value); }
function serveTx(WalletData storage self,
function confirmTx(WalletData storage self, bytes32 _id)
function revokeConfirm(WalletData storage self, bytes32 _id)
function sumElements(uint256[] storage self) public view returns(uint256 sum) { assembly { mstore(0x60,self_slot) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { sum := add(sload(add(sha3(0x60,0x20),i)),sum) } } }
function getMax(uint256[] storage self) public view returns(uint256 maxValue) { assembly { mstore(0x60,self_slot) maxValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), maxValue) case 1 { maxValue := sload(add(sha3(0x60,0x20),i)) } } } }
function getMin(uint256[] storage self) public view returns(uint256 minValue) { assembly { mstore(0x60,self_slot) minValue := sload(sha3(0x60,0x20)) for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } { switch gt(sload(add(sha3(0x60,0x20),i)), minValue) case 0 { minValue := sload(add(sha3(0x60,0x20),i)) } } } }
function indexOf(uint256[] storage self, uint256 value, bool isSorted)
function getParentI(uint256 index) private pure returns (uint256 pI) { uint256 i = index - 1; pI = i/2; }
function getLeftChildI(uint256 index) private pure returns (uint256 lcI) { uint256 i = index * 2; lcI = i + 1; }
function heapSort(uint256[] storage self) public { uint256 end = self.length - 1; uint256 start = getParentI(end); uint256 root = start; uint256 lChild; uint256 rChild; uint256 swap; uint256 temp; while(start >= 0){ root = start; lChild = getLeftChildI(start); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end+1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } if(start == 0) break; else start = start - 1; } while(end > 0){ temp = self[end]; self[end] = self[0]; self[0] = temp; end = end - 1; root = 0; lChild = getLeftChildI(0); while(lChild <= end){ rChild = lChild + 1; swap = root; if(self[swap] < self[lChild]) swap = lChild; if((rChild <= end) && (self[swap]<self[rChild])) swap = rChild; if(swap == root) lChild = end + 1; else { temp = self[swap]; self[swap] = self[root]; self[root] = temp; root = swap; lChild = getLeftChildI(root); } } } }
function uniq(uint256[] storage self) public returns (uint256 length) { bool contains; uint256 index; for (uint256 i = 0; i < self.length; i++) { (contains, index) = indexOf(self, self[i], false); if (i > index) { for (uint256 j = i; j < self.length - 1; j++){ self[j] = self[j + 1]; } delete self[self.length - 1]; self.length--; i--; } } length = self.length; }
function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } }
function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } }
function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } }
function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } }
function init(TokenStorage storage self,
function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); bool err; uint256 balance; (err,balance) = self.balances[msg.sender].minus(_value); require(!err); self.balances[msg.sender] = balance; self.balances[_to] = self.balances[_to] + _value; Transfer(msg.sender, _to, _value); return true; }
function transferFrom(TokenStorage storage self,
function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) { return self.balances[_owner]; }
function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (self.allowed[msg.sender][_spender] == 0)); self.allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; }
function allowance(TokenStorage storage self, address _owner, address _spender)
function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)
function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) { require((self.owner == msg.sender) && (_newOwner > 0)); self.owner = _newOwner; OwnerChange(msg.sender, _newOwner); return true; }
function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) { require((self.owner == msg.sender) && self.stillMinting); uint256 _newAmount; bool err; (err, _newAmount) = self.totalSupply.plus(_amount); require(!err); self.totalSupply =  _newAmount; self.balances[self.owner] = self.balances[self.owner] + _amount; Transfer(0x0, self.owner, _amount); return true; }
function closeMint(TokenStorage storage self) public returns (bool) { require(self.owner == msg.sender); self.stillMinting = false; MintingClosed(true); return true; }
function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) { uint256 _newBalance; bool err; (err, _newBalance) = self.balances[msg.sender].minus(_amount); require(!err); self.balances[msg.sender] = _newBalance; self.totalSupply = self.totalSupply - _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0x0, _amount); return true; }
function checkChangeOwnerArgs(uint256 _from, uint256 _to)
function checkNewOwnerArgs(uint256 _index, uint256 _length, uint256 _max)
function checkRemoveOwnerArgs(uint256 _index, uint256 _length, uint256 _min)
function checkRequiredChange(uint256 _newRequired, uint256 _length)
function calcConfirmsNeeded(uint256 _required, uint256 _count) private pure returns (uint256) { return _required - _count; }
function changeOwner(WalletMainLib.WalletData storage self,
function addOwner(WalletMainLib.WalletData storage self,
function removeOwner(WalletMainLib.WalletData storage self,
function changeRequiredAdmin(WalletMainLib.WalletData storage self,
function changeRequiredMajor(WalletMainLib.WalletData storage self,
function changeRequiredMinor(WalletMainLib.WalletData storage self,
function changeMajorThreshold(WalletMainLib.WalletData storage self,
function getOwners(WalletMainLib.WalletData storage self) public view returns (address[51]) { address[51] memory o; for(uint256 i = 0; i<self.owners.length; i++){ o[i] = self.owners[i]; } return o; }
function getOwnerIndex(WalletMainLib.WalletData storage self, address _owner) public view returns (uint256) { return self.ownerIndex[_owner]; }
function getMaxOwners(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.maxOwners; }
function getOwnerCount(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.owners.length - 1; }
function getRequiredAdmin(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredAdmin; }
function getRequiredMinor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMinor; }
function getRequiredMajor(WalletMainLib.WalletData storage self) public view returns (uint256) { return self.requiredMajor; }
function getCurrentSpend(WalletMainLib.WalletData storage self, address _token) public view returns (uint256[2]) { uint256[2] memory cs; cs[0] = self.currentSpend[_token][0]; cs[1] = self.currentSpend[_token][1]; return cs; }
function getMajorThreshold(WalletMainLib.WalletData storage self, address _token) public view returns (uint256) { return self.majorThreshold[_token]; }
function getTransactionLength(WalletMainLib.WalletData storage self, bytes32 _id) public view returns (uint256) { return self.transactionInfo[_id].length; }
function getTransactionConfirms(WalletMainLib.WalletData storage self,
function getTransactionConfirmCount(WalletMainLib.WalletData storage self,
function getTransactionSuccess(WalletMainLib.WalletData storage self,
function init(WalletData storage self,
function checkNotConfirmed(WalletData storage self, bytes32 _id, uint256 _txIndex)
function calcConfirmsNeeded(uint256 _required, uint256 _count) public pure returns (uint256){ return _required - _count; }
function getAmount(bytes _txData) public pure returns (bool,uint256) { bytes32 getSig; bytes4 sig; bytes4 tSig = 0xa9059cbb;  bytes4 tSig = 0xa9059cbb;  bytes4 aSig = 0x095ea7b3;  bytes4 aSig = 0x095ea7b3;  bytes4 tfSig = 0x23b872dd;  bytes4 tfSig = 0x23b872dd;  bool transfer; bytes32 _amountData; uint256 _amount; assembly { getSig := mload(add(_txData,0x20)) } sig = bytes4(getSig); if(sig ==  tSig || sig == aSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x44)) } _amount = uint256(_amountData); } else if(sig == tfSig){ transfer = true; assembly { _amountData := mload(add(_txData,0x64)) } _amount = uint256(_amountData); } return (transfer,_amount); }
function getRequired(WalletData storage self,
function createContract(bytes _txData, uint256 _value) public { address _newContract; bool allGood; assembly { _newContract := create(_value, add(_txData, 0x20), mload(_txData)) allGood := gt(extcodesize(_newContract),0) } require(allGood); LogContractCreated(_newContract, _value); }
function serveTx(WalletData storage self,
function confirmTx(WalletData storage self, bytes32 _id)
function revokeConfirm(WalletData storage self, bytes32 _id)
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
modifier onlyRole(bytes32 role) { _checkRole(role, _msgSender()); _; }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId); }
function hasRole(bytes32 role, address account) public view override returns (bool) { return _roles[role].members[account]; }
function _checkRole(bytes32 role, address account) internal view { if(!hasRole(role, account)) { revert(string(abi.encodePacked( "AccessControl: account ", Strings.toHexString(uint160(account), 20), " is missing role ", Strings.toHexString(uint256(role), 32) ))); } }
function getRoleAdmin(bytes32 role) public view override returns (bytes32) { return _roles[role].adminRole; }
function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { _grantRole(role, account); }
function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) { _revokeRole(role, account); }
function renounceRole(bytes32 role, address account) public virtual override { require(account == _msgSender(), "AccessControl: can only renounce roles for self"); _revokeRole(role, account); }
function _setupRole(bytes32 role, address account) internal virtual { _grantRole(role, account); }
function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { emit RoleAdminChanged(role, getRoleAdmin(role), adminRole); _roles[role].adminRole = adminRole; }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId); }
function getRoleMember(bytes32 role, uint256 index) public view override returns (address) { return _roleMembers[role].at(index); }
function getRoleMemberCount(bytes32 role) public view override returns (uint256) { return _roleMembers[role].length(); }
function grantRole(bytes32 role, address account) public virtual override { super.grantRole(role, account); _roleMembers[role].add(account); }
function revokeRole(bytes32 role, address account) public virtual override { super.revokeRole(role, account); _roleMembers[role].remove(account); }
function renounceRole(bytes32 role, address account) public virtual override { super.renounceRole(role, account); _roleMembers[role].remove(account); }
function _setupRole(bytes32 role, address account) internal virtual override { super._setupRole(role, account); _roleMembers[role].add(account); }
function owner() public view virtual returns (address) { return _owner; }
modifier onlyOwner() { require(owner() == _msgSender(), "Ownable: caller is not the owner"); _; }
function renounceOwnership() public virtual onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }
function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), "Ownable: new owner is the zero address"); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; }
function totalShares() public view returns (uint256) { return _totalShares; }
function totalReleased() public view returns (uint256) { return _totalReleased; }
function shares(address account) public view returns (uint256) { return _shares[account]; }
function released(address account) public view returns (uint256) { return _released[account]; }
function payee(uint256 index) public view returns (address) { return _payees[index]; }
function release(address payable account) public virtual { require(_shares[account] > 0, "PaymentSplitter: account has no shares"); uint256 totalReceived = address(this).balance + _totalReleased; uint256 payment = totalReceived * _shares[account] / _totalShares - _released[account]; require(payment != 0, "PaymentSplitter: account is not due payment"); _released[account] = _released[account] + payment; _totalReleased = _totalReleased + payment; Address.sendValue(account, payment); emit PaymentReleased(account, payment); }
function _addPayee(address account, uint256 shares_) private { require(account != address(0), "PaymentSplitter: account is the zero address"); require(shares_ > 0, "PaymentSplitter: shares are 0"); require(_shares[account] == 0, "PaymentSplitter: account already has shares"); _payees.push(account); _shares[account] = shares_; _totalShares = _totalShares + shares_; emit PayeeAdded(account, shares_); }
event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);
event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);
event Cancelled(bytes32 indexed id);
event MinDelayChange(uint256 oldDuration, uint256 newDuration);
modifier onlyRoleOrOpenRole(bytes32 role) { if (!hasRole(role, address(0))) { _checkRole(role, _msgSender()); } _; }
function isOperation(bytes32 id) public view virtual returns (bool pending) { return getTimestamp(id) > 0; }
function isOperationPending(bytes32 id) public view virtual returns (bool pending) { return getTimestamp(id) > _DONE_TIMESTAMP; }
function isOperationReady(bytes32 id) public view virtual returns (bool ready) { uint256 timestamp = getTimestamp(id); return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp; }
function isOperationDone(bytes32 id) public view virtual returns (bool done) { return getTimestamp(id) == _DONE_TIMESTAMP; }
function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) { return _timestamps[id]; }
function getMinDelay() public view virtual returns (uint256 duration) { return _minDelay; }
function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) { return keccak256(abi.encode(target, value, data, predecessor, salt)); }
function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) { return keccak256(abi.encode(targets, values, datas, predecessor, salt)); }
function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) { bytes32 id = hashOperation(target, value, data, predecessor, salt); _schedule(id, delay); emit CallScheduled(id, 0, target, value, data, predecessor, delay); }
function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) { require(targets.length == values.length, "TimelockController: length mismatch"); require(targets.length == datas.length, "TimelockController: length mismatch"); bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _schedule(id, delay); for (uint256 i = 0; i < targets.length; ++i) { emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay); } }
function _schedule(bytes32 id, uint256 delay) private { require(!isOperation(id), "TimelockController: operation already scheduled"); require(delay >= getMinDelay(), "TimelockController: insufficient delay"); _timestamps[id] = block.timestamp + delay; }
function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) { require(isOperationPending(id), "TimelockController: operation cannot be cancelled"); delete _timestamps[id]; emit Cancelled(id); }
function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { bytes32 id = hashOperation(target, value, data, predecessor, salt); _beforeCall(predecessor); _call(id, 0, target, value, data); _afterCall(id); }
function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) { require(targets.length == values.length, "TimelockController: length mismatch"); require(targets.length == datas.length, "TimelockController: length mismatch"); bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt); _beforeCall(predecessor); for (uint256 i = 0; i < targets.length; ++i) { _call(id, i, targets[i], values[i], datas[i]); } _afterCall(id); }
function _beforeCall(bytes32 predecessor) private view { require(predecessor == bytes32(0) || isOperationDone(predecessor), "TimelockController: missing dependency"); }
function _afterCall(bytes32 id) private { require(isOperationReady(id), "TimelockController: operation is not ready"); _timestamps[id] = _DONE_TIMESTAMP; }
function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private { (bool success,) = target.call{value: value}(data); require(success, "TimelockController: underlying transaction reverted"); emit CallExecuted(id, index, target, value, data); }
function updateDelay(uint256 newDelay) external virtual { require(msg.sender == address(this), "TimelockController: caller must be timelock"); emit MinDelayChange(_minDelay, newDelay); _minDelay = newDelay; }
function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);
function onFlashLoan(
function maxFlashLoan(
function flashFee(
function flashLoan(
event BeforeTokenTransfer();
function callTransfer(address dest, uint256 amount) public { _asyncTransfer(dest, amount); }
function doAdd(uint256 a, uint256 b) public pure returns (uint256) { return SafeMath.add(a, b); }
function supportsInterface(bytes4 interfaceId) public view override returns (bool) { return _supportedInterfaces[interfaceId]; }
function _registerInterface(bytes4 interfaceId) internal { require(interfaceId != 0xffffffff, "ERC165InterfacesSupported: invalid interface id"); _supportedInterfaces[interfaceId] = true; }
function _authorizeUpgrade(address) internal virtual override {}
function clone(address implementation) internal returns (address instance) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create(0, ptr, 0x37) } require(instance != address(0), "ERC1167: create failed"); }
function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000) instance := create2(0, ptr, 0x37, salt) } require(instance != address(0), "ERC1167: create2 failed"); }
function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) { assembly { let ptr := mload(0x40) mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000) mstore(add(ptr, 0x14), shl(0x60, implementation)) mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000) mstore(add(ptr, 0x38), shl(0x60, deployer)) mstore(add(ptr, 0x4c), salt) mstore(add(ptr, 0x6c), keccak256(ptr, 0x37)) predicted := keccak256(add(ptr, 0x37), 0x55) } }
function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) { return predictDeterministicAddress(implementation, salt, address(this)); }
function _delegate(address implementation) internal virtual { assembly { calldatacopy(0, 0, calldatasize()) let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) returndatacopy(0, 0, returndatasize()) switch result case 0 { revert(0, returndatasize()) } default { return(0, returndatasize()) } } }
function _implementation() internal view virtual returns (address);
function _fallback() internal virtual { _beforeFallback(); _delegate(_implementation()); }
function _beforeFallback() internal virtual { }
function _beacon() internal view virtual returns (address) { return _getBeacon(); }
function _implementation() internal view virtual override returns (address) { return IBeacon(_getBeacon()).implementation(); }
function _setBeacon(address beacon, bytes memory data) internal virtual { _upgradeBeaconToAndCall(beacon, data, false); }
function implementation() external view returns (address);
event Upgraded(address indexed implementation);
function implementation() public view virtual override returns (address) { return _implementation; }
function upgradeTo(address newImplementation) public virtual onlyOwner { _setImplementation(newImplementation); emit Upgraded(newImplementation); }
function _setImplementation(address newImplementation) private { require(Address.isContract(newImplementation), "UpgradeableBeacon: implementation is not a contract"); _implementation = newImplementation; }
function _implementation() internal view virtual override returns (address impl) { return ERC1967Storage._getImplementation(); }
function _getImplementation() internal view returns (address) { return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value; }
function _setImplementation(address newImplementation) internal { require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract"); StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation; }
function _getBeacon() internal view returns (address) { return StorageSlot.getAddressSlot(_BEACON_SLOT).value; }
function _setBeacon(address newBeacon) internal { require( Address.isContract(newBeacon), "ERC1967: new beacon is not a contract" ); require( Address.isContract(IBeacon(newBeacon).implementation()), "ERC1967: beacon implementation is not a contract" ); StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon; }
function _getAdmin() internal view returns (address) { return StorageSlot.getAddressSlot(_ADMIN_SLOT).value; }
function _setAdmin(address newAdmin) internal { require(newAdmin != address(0), "ERC1967: new admin is the zero address"); StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin; }
event Upgraded(address indexed implementation);
event BeaconUpgraded(address indexed beacon);
event AdminChanged(address previousAdmin, address newAdmin);
function _upgradeTo(address newImplementation) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); }
function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal { _setImplementation(newImplementation); emit Upgraded(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); } }
function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal { address oldImplementation = _getImplementation(); _setImplementation(newImplementation); if (data.length > 0 || forceCall) { Address.functionDelegateCall(newImplementation, data); } StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT); if (!rollbackTesting.value) { rollbackTesting.value = true; Address.functionDelegateCall( newImplementation, abi.encodeWithSignature( "upgradeTo(address)", oldImplementation ) ); rollbackTesting.value = false; require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades"); _setImplementation(newImplementation); emit Upgraded(newImplementation); } }
function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal { _setBeacon(newBeacon); emit BeaconUpgraded(newBeacon); if (data.length > 0 || forceCall) { Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data); } }
function _changeAdmin(address newAdmin) internal { emit AdminChanged(_getAdmin(), newAdmin); _setAdmin(newAdmin); }
function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) { (bool success, bytes memory returndata) = address(proxy).staticcall(hex"5c60da1b"); require(success); return abi.decode(returndata, (address)); }
function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) { (bool success, bytes memory returndata) = address(proxy).staticcall(hex"f851a440"); require(success); return abi.decode(returndata, (address)); }
function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner { proxy.changeAdmin(newAdmin); }
function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner { proxy.upgradeTo(implementation); }
function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner { proxy.upgradeToAndCall{value: msg.value}(implementation, data); }
modifier ifAdmin() { if (msg.sender == _getAdmin()) { _; } else { _fallback(); } }
function admin() external ifAdmin returns (address admin_) { admin_ = _getAdmin(); }
function implementation() external ifAdmin returns (address implementation_) { implementation_ = _implementation(); }
function changeAdmin(address newAdmin) external virtual ifAdmin { _changeAdmin(newAdmin); }
function upgradeTo(address newImplementation) external ifAdmin { _upgradeToAndCall(newImplementation, bytes(""), false); }
function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin { _upgradeToAndCall(newImplementation, data, true); }
function _admin() internal view virtual returns (address) { return _getAdmin(); }
function _beforeFallback() internal virtual override { require(msg.sender != _getAdmin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target"); super._beforeFallback(); }
modifier initializer() { require(_initializing || !_initialized, "Initializable: contract is already initialized"); bool isTopLevelCall = !_initializing; if (isTopLevelCall) { _initializing = true; _initialized = true; } _; if (isTopLevelCall) { _initializing = false; } }
event Paused(address account);
event Unpaused(address account);
function paused() public view virtual returns (bool) { return _paused; }
modifier whenNotPaused() { require(!paused(), "Pausable: paused"); _; }
modifier whenPaused() { require(paused(), "Pausable: not paused"); _; }
function _pause() internal virtual whenNotPaused { _paused = true; emit Paused(_msgSender()); }
function _unpause() internal virtual whenPaused { _paused = false; emit Unpaused(_msgSender()); }
function withdrawPayments(address payable payee) public virtual { _escrow.withdraw(payee); }
function payments(address dest) public view returns (uint256) { return _escrow.depositsOf(dest); }
function _asyncTransfer(address dest, uint256 amount) internal virtual { _escrow.deposit{ value: amount }(dest); }
modifier nonReentrant() { require(_status != _ENTERED, "ReentrancyGuard: reentrant call"); _status = _ENTERED; _; _status = _NOT_ENTERED; }
function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) { return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC1155MetadataURI).interfaceId || super.supportsInterface(interfaceId); }
function uri(uint256) public view virtual override returns (string memory) { return _uri; }
function balanceOf(address account, uint256 id) public view virtual override returns (uint256) { require(account != address(0), "ERC1155: balance query for the zero address"); return _balances[id][account]; }
function balanceOfBatch(
function setApprovalForAll(address operator, bool approved) public virtual override { require(_msgSender() != operator, "ERC1155: setting approval status for self"); _operatorApprovals[_msgSender()][operator] = approved; emit ApprovalForAll(_msgSender(), operator, approved); }
function isApprovedForAll(address account, address operator) public view virtual override returns (bool) { return _operatorApprovals[account][operator]; }
function safeTransferFrom(
function safeBatchTransferFrom(
function _setURI(string memory newuri) internal virtual { _uri = newuri; }
function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual { require(account != address(0), "ERC1155: mint to the zero address"); address operator = _msgSender(); _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data); _balances[id][account] += amount; emit TransferSingle(operator, address(0), account, id, amount); _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data); }
function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual { require(to != address(0), "ERC1155: mint to the zero address"); require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch"); address operator = _msgSender(); _beforeTokenTransfer(operator, address(0), to, ids, amounts, data); for (uint i = 0; i < ids.length; i++) { _balances[ids[i]][to] += amounts[i]; } emit TransferBatch(operator, address(0), to, ids, amounts); _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data); }
function _burn(address account, uint256 id, uint256 amount) internal virtual { require(account != address(0), "ERC1155: burn from the zero address"); address operator = _msgSender(); _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), ""); uint256 accountBalance = _balances[id][account]; require(accountBalance >= amount, "ERC1155: burn amount exceeds balance"); _balances[id][account] = accountBalance - amount; emit TransferSingle(operator, account, address(0), id, amount); }
function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual { require(account != address(0), "ERC1155: burn from the zero address"); require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch"); address operator = _msgSender(); _beforeTokenTransfer(operator, account, address(0), ids, amounts, ""); for (uint i = 0; i < ids.length; i++) { uint256 id = ids[i]; uint256 amount = amounts[i]; uint256 accountBalance = _balances[id][account]; require(accountBalance >= amount, "ERC1155: burn amount exceeds balance"); _balances[id][account] = accountBalance - amount; } emit TransferBatch(operator, account, address(0), ids, amounts); }
function _beforeTokenTransfer(
event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);
event ApprovalForAll(address indexed account, address indexed operator, bool approved);
event URI(string value, uint256 indexed id);
function balanceOf(address account, uint256 id) external view returns (uint256);
function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);
function setApprovalForAll(address operator, bool approved) external;
function isApprovedForAll(address account, address operator) external view returns (bool);
function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;
function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
function onERC1155Received(
function onERC1155BatchReceived(
function _beforeTokenTransfer(
function uri(uint256 id) external view returns (string memory);
function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have minter role to mint"); _mint(to, id, amount, data); }
function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have minter role to mint"); _mintBatch(to, ids, amounts, data); }
function pause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have pauser role to pause"); _pause(); }
function unpause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC1155PresetMinterPauser: must have pauser role to unpause"); _unpause(); }
function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerable, ERC1155) returns (bool) { return super.supportsInterface(interfaceId); }
function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) { return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId); }
function name() public view virtual override returns (string memory) { return _name; }
function symbol() public view virtual override returns (string memory) { return _symbol; }
function decimals() public view virtual override returns (uint8) { return 18; }
function totalSupply() public view virtual override returns (uint256) { return _totalSupply; }
function balanceOf(address account) public view virtual override returns (uint256) { return _balances[account]; }
function transfer(address recipient, uint256 amount) public virtual override returns (bool) { _transfer(_msgSender(), recipient, amount); return true; }
function allowance(address owner, address spender) public view virtual override returns (uint256) { return _allowances[owner][spender]; }
function approve(address spender, uint256 amount) public virtual override returns (bool) { _approve(_msgSender(), spender, amount); return true; }
function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { _transfer(sender, recipient, amount); uint256 currentAllowance = _allowances[sender][_msgSender()]; require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance"); _approve(sender, _msgSender(), currentAllowance - amount); return true; }
function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) { _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue); return true; }
function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) { uint256 currentAllowance = _allowances[_msgSender()][spender]; require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero"); _approve(_msgSender(), spender, currentAllowance - subtractedValue); return true; }
function _transfer(address sender, address recipient, uint256 amount) internal virtual { require(sender != address(0), "ERC20: transfer from the zero address"); require(recipient != address(0), "ERC20: transfer to the zero address"); _beforeTokenTransfer(sender, recipient, amount); uint256 senderBalance = _balances[sender]; require(senderBalance >= amount, "ERC20: transfer amount exceeds balance"); _balances[sender] = senderBalance - amount; _balances[recipient] += amount; emit Transfer(sender, recipient, amount); }
function _mint(address account, uint256 amount) internal virtual { require(account != address(0), "ERC20: mint to the zero address"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; _balances[account] += amount; emit Transfer(address(0), account, amount); }
function _burn(address account, uint256 amount) internal virtual { require(account != address(0), "ERC20: burn from the zero address"); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance >= amount, "ERC20: burn amount exceeds balance"); _balances[account] = accountBalance - amount; _totalSupply -= amount; emit Transfer(account, address(0), amount); }
function _approve(address owner, address spender, uint256 amount) internal virtual { require(owner != address(0), "ERC20: approve from the zero address"); require(spender != address(0), "ERC20: approve to the zero address"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); }
function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }
function totalSupply() external view returns (uint256);
function balanceOf(address account) external view returns (uint256);
function transfer(address recipient, uint256 amount) external returns (bool);
function allowance(address owner, address spender) external view returns (uint256);
function approve(address spender, uint256 amount) external returns (bool);
function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
function maxFlashLoan(address token) public view override returns (uint256) { return token == address(this) ? type(uint256).max - ERC20.totalSupply() : 0; }
function flashFee(address token, uint256 amount) public view virtual override returns (uint256) { require(token == address(this), "ERC20FlashMint: wrong token"); amount; return 0; }
function flashLoan(
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override { require(block.timestamp <= deadline, "ERC20Permit: expired deadline"); bytes32 structHash = keccak256( abi.encode( _PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline ) ); bytes32 hash = _hashTypedDataV4(structHash); address signer = ECDSA.recover(hash, v, r, s); require(signer == owner, "ERC20Permit: invalid signature"); _approve(owner, spender, value); }
function nonces(address owner) public view virtual override returns (uint256) { return _nonces[owner].current(); }
function DOMAIN_SEPARATOR() external view override returns (bytes32) { return _domainSeparatorV4(); }
function _useNonce(address owner) internal virtual returns (uint256 current) { Counters.Counter storage nonce = _nonces[owner]; current = nonce.current(); nonce.increment(); }
function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
function nonces(address owner) external view returns (uint256);
function DOMAIN_SEPARATOR() external view returns (bytes32);
function burn(uint256 amount) public virtual { _burn(_msgSender(), amount); }
function burnFrom(address account, uint256 amount) public virtual { uint256 currentAllowance = allowance(account, _msgSender()); require(currentAllowance >= amount, "ERC20: burn amount exceeds allowance"); _approve(account, _msgSender(), currentAllowance - amount); _burn(account, amount); }
function cap() public view virtual returns (uint256) { return _cap; }
function _mint(address account, uint256 amount) internal virtual override { require(ERC20.totalSupply() + amount <= cap(), "ERC20Capped: cap exceeded"); super._mint(account, amount); }
function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override { super._beforeTokenTransfer(from, to, amount); require(!paused(), "ERC20Pausable: token transfer while paused"); }
event Snapshot(uint256 id);
function _snapshot() internal virtual returns (uint256) { _currentSnapshotId.increment(); uint256 currentId = _currentSnapshotId.current(); emit Snapshot(currentId); return currentId; }
function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) { (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]); return snapshotted ? value : balanceOf(account); }
function totalSupplyAt(uint256 snapshotId) public view virtual returns(uint256) { (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots); return snapshotted ? value : totalSupply(); }
function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override { super._beforeTokenTransfer(from, to, amount); if (from == address(0)) { _updateAccountSnapshot(to); _updateTotalSupplySnapshot(); } else if (to == address(0)) { _updateAccountSnapshot(from); _updateTotalSupplySnapshot(); } else { _updateAccountSnapshot(from); _updateAccountSnapshot(to); } }
function name() external view returns (string memory);
function symbol() external view returns (string memory);
function decimals() external view returns (uint8);
function mint(address to, uint256 amount) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have minter role to mint"); _mint(to, amount); }
function pause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to pause"); _pause(); }
function unpause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC20PresetMinterPauser: must have pauser role to unpause"); _unpause(); }
function safeApprove(IERC20 token, address spender, uint256 value) internal { require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance" ); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); }
function _callOptionalReturn(IERC20 token, bytes memory data) private { bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed"); if (returndata.length > 0) {  if (returndata.length > 0) {  require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed"); } }
function token() public view virtual returns (IERC20) { return _token; }
function beneficiary() public view virtual returns (address) { return _beneficiary; }
function releaseTime() public view virtual returns (uint256) { return _releaseTime; }
function release() public virtual { require(block.timestamp >= releaseTime(), "TokenTimelock: current time is before release time"); uint256 amount = token().balanceOf(address(this)); require(amount > 0, "TokenTimelock: no tokens to release"); token().safeTransfer(beneficiary(), amount); }
function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) { return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId); }
function balanceOf(address owner) public view virtual override returns (uint256) { require(owner != address(0), "ERC721: balance query for the zero address"); return _balances[owner]; }
function ownerOf(uint256 tokenId) public view virtual override returns (address) { address owner = _owners[tokenId]; require(owner != address(0), "ERC721: owner query for nonexistent token"); return owner; }
function name() public view virtual override returns (string memory) { return _name; }
function symbol() public view virtual override returns (string memory) { return _symbol; }
function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token"); string memory baseURI = _baseURI(); return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : ''; }
function _baseURI() internal view virtual returns (string memory) { return ""; }
function approve(address to, uint256 tokenId) public virtual override { address owner = ERC721.ownerOf(tokenId); require(to != owner, "ERC721: approval to current owner"); require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), "ERC721: approve caller is not owner nor approved for all" ); _approve(to, tokenId); }
function getApproved(uint256 tokenId) public view virtual override returns (address) { require(_exists(tokenId), "ERC721: approved query for nonexistent token"); return _tokenApprovals[tokenId]; }
function setApprovalForAll(address operator, bool approved) public virtual override { require(operator != _msgSender(), "ERC721: approve to caller"); _operatorApprovals[_msgSender()][operator] = approved; emit ApprovalForAll(_msgSender(), operator, approved); }
function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) { return _operatorApprovals[owner][operator]; }
function transferFrom(address from, address to, uint256 tokenId) public virtual override { require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved"); _transfer(from, to, tokenId); }
function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override { safeTransferFrom(from, to, tokenId, ""); }
function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override { require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved"); _safeTransfer(from, to, tokenId, _data); }
function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual { _transfer(from, to, tokenId); require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer"); }
function _exists(uint256 tokenId) internal view virtual returns (bool) { return _owners[tokenId] != address(0); }
function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) { require(_exists(tokenId), "ERC721: operator query for nonexistent token"); address owner = ERC721.ownerOf(tokenId); return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender)); }
function _safeMint(address to, uint256 tokenId) internal virtual { _safeMint(to, tokenId, ""); }
function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual { _mint(to, tokenId); require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer"); }
function _mint(address to, uint256 tokenId) internal virtual { require(to != address(0), "ERC721: mint to the zero address"); require(!_exists(tokenId), "ERC721: token already minted"); _beforeTokenTransfer(address(0), to, tokenId); _balances[to] += 1; _owners[tokenId] = to; emit Transfer(address(0), to, tokenId); }
function _burn(uint256 tokenId) internal virtual { address owner = ERC721.ownerOf(tokenId); _beforeTokenTransfer(owner, address(0), tokenId); _approve(address(0), tokenId); _balances[owner] -= 1; delete _owners[tokenId]; emit Transfer(owner, address(0), tokenId); }
function _transfer(address from, address to, uint256 tokenId) internal virtual { require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer of token that is not own"); require(to != address(0), "ERC721: transfer to the zero address"); _beforeTokenTransfer(from, to, tokenId); _approve(address(0), tokenId); _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to; emit Transfer(from, to, tokenId); }
function _approve(address to, uint256 tokenId) internal virtual { _tokenApprovals[tokenId] = to; emit Approval(ERC721.ownerOf(tokenId), to, tokenId); }
function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }
event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
function balanceOf(address owner) external view returns (uint256 balance);
function ownerOf(uint256 tokenId) external view returns (address owner);
function safeTransferFrom(address from, address to, uint256 tokenId) external;
function transferFrom(address from, address to, uint256 tokenId) external;
function approve(address to, uint256 tokenId) external;
function getApproved(uint256 tokenId) external view returns (address operator);
function setApprovalForAll(address operator, bool _approved) external;
function isApprovedForAll(address owner, address operator) external view returns (bool);
function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
function burn(uint256 tokenId) public virtual { require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721Burnable: caller is not owner nor approved"); _burn(tokenId); }
function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) { return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId); }
function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) { require(index < ERC721.balanceOf(owner), "ERC721Enumerable: owner index out of bounds"); return _ownedTokens[owner][index]; }
function totalSupply() public view virtual override returns (uint256) { return _allTokens.length; }
function tokenByIndex(uint256 index) public view virtual override returns (uint256) { require(index < ERC721Enumerable.totalSupply(), "ERC721Enumerable: global index out of bounds"); return _allTokens[index]; }
function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override { super._beforeTokenTransfer(from, to, tokenId); if (from == address(0)) { _addTokenToAllTokensEnumeration(tokenId); } else if (from != to) { _removeTokenFromOwnerEnumeration(from, tokenId); } if (to == address(0)) { _removeTokenFromAllTokensEnumeration(tokenId); } else if (to != from) { _addTokenToOwnerEnumeration(to, tokenId); } }
function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private { uint256 length = ERC721.balanceOf(to); _ownedTokens[to][length] = tokenId; _ownedTokensIndex[tokenId] = length; }
function _addTokenToAllTokensEnumeration(uint256 tokenId) private { _allTokensIndex[tokenId] = _allTokens.length; _allTokens.push(tokenId); }
function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private { uint256 lastTokenIndex = ERC721.balanceOf(from) - 1; uint256 tokenIndex = _ownedTokensIndex[tokenId]; if (tokenIndex != lastTokenIndex) { uint256 lastTokenId = _ownedTokens[from][lastTokenIndex]; _ownedTokens[from][tokenIndex] = lastTokenId;  _ownedTokens[from][tokenIndex] = lastTokenId;  _ownedTokensIndex[lastTokenId] = tokenIndex;  _ownedTokensIndex[lastTokenId] = tokenIndex;  } delete _ownedTokensIndex[tokenId]; delete _ownedTokens[from][lastTokenIndex]; }
function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private { uint256 lastTokenIndex = _allTokens.length - 1; uint256 tokenIndex = _allTokensIndex[tokenId]; uint256 lastTokenId = _allTokens[lastTokenIndex]; _allTokens[tokenIndex] = lastTokenId;  _allTokens[tokenIndex] = lastTokenId;  _allTokensIndex[lastTokenId] = tokenIndex;  _allTokensIndex[lastTokenId] = tokenIndex;  delete _allTokensIndex[tokenId]; _allTokens.pop(); }
function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override { super._beforeTokenTransfer(from, to, tokenId); require(!paused(), "ERC721Pausable: token transfer while paused"); }
function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), "ERC721URIStorage: URI query for nonexistent token"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = _baseURI(); if (bytes(base).length == 0) { return _tokenURI; } if (bytes(_tokenURI).length > 0) { return string(abi.encodePacked(base, _tokenURI)); } return super.tokenURI(tokenId); }
function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual { require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token"); _tokenURIs[tokenId] = _tokenURI; }
function _burn(uint256 tokenId) internal virtual override { super._burn(tokenId); if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; } }
function totalSupply() external view returns (uint256);
function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
function tokenByIndex(uint256 index) external view returns (uint256);
function name() external view returns (string memory);
function symbol() external view returns (string memory);
function tokenURI(uint256 tokenId) external view returns (string memory);
function mint(address to) public virtual { require(hasRole(MINTER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have minter role to mint"); _mint(to, _tokenIdTracker.current()); _tokenIdTracker.increment(); }
function pause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause"); _pause(); }
function unpause() public virtual { require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to unpause"); _unpause(); }
function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerable, ERC721, ERC721Enumerable) returns (bool) { return super.supportsInterface(interfaceId); }
function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) { return this.onERC721Received.selector; }
function name() public view virtual override returns (string memory) { return _name; }
function symbol() public view virtual override returns (string memory) { return _symbol; }
function decimals() public pure virtual returns (uint8) { return 18; }
function granularity() public view virtual override returns (uint256) { return 1; }
function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) { return _totalSupply; }
function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) { return _balances[tokenHolder]; }
function send(address recipient, uint256 amount, bytes memory data) public virtual override  { _send(_msgSender(), recipient, amount, data, "", true); }
function transfer(address recipient, uint256 amount) public virtual override returns (bool) { require(recipient != address(0), "ERC777: transfer to the zero address"); address from = _msgSender(); _callTokensToSend(from, from, recipient, amount, "", ""); _move(from, from, recipient, amount, "", ""); _callTokensReceived(from, from, recipient, amount, "", "", false); return true; }
function burn(uint256 amount, bytes memory data) public virtual override  { _burn(_msgSender(), amount, data, ""); }
function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) { return operator == tokenHolder || (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) || _operators[tokenHolder][operator]; }
function authorizeOperator(address operator) public virtual override  { require(_msgSender() != operator, "ERC777: authorizing self as operator"); if (_defaultOperators[operator]) { delete _revokedDefaultOperators[_msgSender()][operator]; } else { _operators[_msgSender()][operator] = true; } emit AuthorizedOperator(operator, _msgSender()); }
function revokeOperator(address operator) public virtual override  { require(operator != _msgSender(), "ERC777: revoking self as operator"); if (_defaultOperators[operator]) { _revokedDefaultOperators[_msgSender()][operator] = true; } else { delete _operators[_msgSender()][operator]; } emit RevokedOperator(operator, _msgSender()); }
function defaultOperators() public view virtual override returns (address[] memory) { return _defaultOperatorsArray; }
function operatorSend(
function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public virtual override { require(isOperatorFor(_msgSender(), account), "ERC777: caller is not an operator for holder"); _burn(account, amount, data, operatorData); }
function allowance(address holder, address spender) public view virtual override returns (uint256) { return _allowances[holder][spender]; }
function approve(address spender, uint256 value) public virtual override returns (bool) { address holder = _msgSender(); _approve(holder, spender, value); return true; }
function transferFrom(address holder, address recipient, uint256 amount) public virtual override returns (bool) { require(recipient != address(0), "ERC777: transfer to the zero address"); require(holder != address(0), "ERC777: transfer from the zero address"); address spender = _msgSender(); _callTokensToSend(spender, holder, recipient, amount, "", ""); _move(spender, holder, recipient, amount, "", ""); uint256 currentAllowance = _allowances[holder][spender]; require(currentAllowance >= amount, "ERC777: transfer amount exceeds allowance"); _approve(holder, spender, currentAllowance - amount); _callTokensReceived(spender, holder, recipient, amount, "", "", false); return true; }
function _mint(
function _mint(
function _send(
function _burn(
function _approve(address holder, address spender, uint256 value) internal { require(holder != address(0), "ERC777: approve from the zero address"); require(spender != address(0), "ERC777: approve to the zero address"); _allowances[holder][spender] = value; emit Approval(holder, spender, value); }
function _callTokensToSend(
function _callTokensReceived(
function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }
function name() external view returns (string memory);
function symbol() external view returns (string memory);
function granularity() external view returns (uint256);
function totalSupply() external view returns (uint256);
function balanceOf(address owner) external view returns (uint256);
function send(address recipient, uint256 amount, bytes calldata data) external;
function burn(uint256 amount, bytes calldata data) external;
function isOperatorFor(address operator, address tokenHolder) external view returns (bool);
function authorizeOperator(address operator) external;
function revokeOperator(address operator) external;
function defaultOperators() external view returns (address[] memory);
function operatorSend(
function operatorBurn(
function tokensReceived(
function tokensToSend(
function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0; }
function sendValue(address payable recipient, uint256 amount) internal { require(address(this).balance >= amount, "Address: insufficient balance"); (bool success, ) = recipient.call{ value: amount }(""); require(success, "Address: unable to send value, recipient may have reverted"); }
function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCall(target, data, "Address: low-level call failed"); }
function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, errorMessage); }
function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, "Address: low-level call with value failed"); }
function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) { require(address(this).balance >= value, "Address: insufficient balance for call"); require(isContract(target), "Address: call to non-contract"); (bool success, bytes memory returndata) = target.call{ value: value }(data); return _verifyCallResult(success, returndata, errorMessage); }
function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) { return functionStaticCall(target, data, "Address: low-level static call failed"); }
function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) { require(isContract(target), "Address: static call to non-contract"); (bool success, bytes memory returndata) = target.staticcall(data); return _verifyCallResult(success, returndata, errorMessage); }
function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) { return functionDelegateCall(target, data, "Address: low-level delegate call failed"); }
function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) { require(isContract(target), "Address: delegate call to non-contract"); (bool success, bytes memory returndata) = target.delegatecall(data); return _verifyCallResult(success, returndata, errorMessage); }
function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) { if (array.length == 0) { return 0; } uint256 low = 0; uint256 high = array.length; while (low < high) { uint256 mid = Math.average(low, high); if (array[mid] > element) { high = mid; } else { low = mid + 1; } } if (low > 0 && array[low - 1] == element) { return low - 1; } else { return low; } }
function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) { address addr; require(address(this).balance >= amount, "Create2: insufficient balance"); require(bytecode.length != 0, "Create2: bytecode length is zero"); assembly { addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt) } require(addr != address(0), "Create2: Failed on deploy"); return addr; }
function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) { return computeAddress(salt, bytecodeHash, address(this)); }
function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) { bytes32 _data = keccak256( abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash) ); return address(uint160(uint256(_data))); }
function multicall(bytes[] calldata data) external returns (bytes[] memory results) { results = new bytes[](data.length); for (uint i = 0; i < data.length; i++) { results[i] = Address.functionDelegateCall(address(this), data[i]); } return results; }
function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) { assembly { r.slot := slot } }
function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) { assembly { r.slot := slot } }
function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) { assembly { r.slot := slot } }
function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) { assembly { r.slot := slot } }
function toString(uint256 value) internal pure returns (string memory) { if (value == 0) { return "0"; } uint256 temp = value; uint256 digits; while (temp != 0) { digits++; temp /= 10; } bytes memory buffer = new bytes(digits); while (value != 0) { digits -= 1; buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); value /= 10; } return string(buffer); }
function toHexString(uint256 value) internal pure returns (string memory) { if (value == 0) { return "0x00"; } uint256 temp = value; uint256 length = 0; while (temp != 0) { length++; temp >>= 8; } return toHexString(value, length); }
function toHexString(uint256 value, uint256 length) internal pure returns (string memory) { bytes memory buffer = new bytes(2 * length + 2); buffer[0] = "0"; buffer[1] = "x"; for (uint256 i = 2 * length + 1; i > 1; --i) { buffer[i] = alphabet[value & 0xf]; value >>= 4; } require(value == 0, "Strings: hex length insufficient"); return string(buffer); }
function _domainSeparatorV4() internal view returns (bytes32) { if (block.chainid == _CACHED_CHAIN_ID) { return _CACHED_DOMAIN_SEPARATOR; } else { return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION); } }
function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) { return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash); }
function recover(bytes32 hash, bytes memory signature) internal pure returns (address) { bytes32 r; bytes32 s; uint8 v; if (signature.length == 65) { assembly { r := mload(add(signature, 0x20)) s := mload(add(signature, 0x40)) v := byte(0, mload(add(signature, 0x60))) } } else if (signature.length == 64) { assembly { let vs := mload(add(signature, 0x40)) r := mload(add(signature, 0x20)) s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) v := add(shr(255, vs), 27) } } else { revert("ECDSA: invalid signature length"); } return recover(hash, v, r, s); }
function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) { require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature 's' value"); require(v == 27 || v == 28, "ECDSA: invalid signature 'v' value"); address signer = ecrecover(hash, v, r, s); require(signer != address(0), "ECDSA: invalid signature"); return signer; }
function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) { return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)); }
function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) { return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash)); }
function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) { bytes32 computedHash = leaf; for (uint256 i = 0; i < proof.length; i++) { bytes32 proofElement = proof[i]; if (computedHash <= proofElement) { computedHash = keccak256(abi.encodePacked(computedHash, proofElement)); } else { computedHash = keccak256(abi.encodePacked(proofElement, computedHash)); } } return computedHash == root; }
function withdrawalAllowed(address payee) public view virtual returns (bool);
function deposit(address payee) public payable virtual onlyOwner { uint256 amount = msg.value; _deposits[payee] = _deposits[payee] + amount; emit Deposited(payee, amount); }
function withdraw(address payable payee) public virtual onlyOwner { uint256 payment = _deposits[payee]; _deposits[payee] = 0; payee.sendValue(payment); emit Withdrawn(payee, payment); }
function state() public view virtual returns (State) { return _state; }
function beneficiary() public view virtual returns (address payable) { return _beneficiary; }
function deposit(address refundee) public payable virtual override { require(state() == State.Active, "RefundEscrow: can only deposit while active"); super.deposit(refundee); }
function close() public virtual onlyOwner { require(state() == State.Active, "RefundEscrow: can only close while active"); _state = State.Closed; emit RefundsClosed(); }
function enableRefunds() public onlyOwner virtual { require(state() == State.Active, "RefundEscrow: can only enable refunds while active"); _state = State.Refunding; emit RefundsEnabled(); }
function beneficiaryWithdraw() public virtual { require(state() == State.Closed, "RefundEscrow: beneficiary can only withdraw while closed"); beneficiary().sendValue(address(this).balance); }
function withdrawalAllowed(address) public view override returns (bool) { return state() == State.Refunding; }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IERC165).interfaceId; }
function supportsERC165(address account) internal view returns (bool) { return _supportsERC165Interface(account, type(IERC165).interfaceId) && !_supportsERC165Interface(account, _INTERFACE_ID_INVALID); }
function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) { return supportsERC165(account) && _supportsERC165Interface(account, interfaceId); }
function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool[] memory) { bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length); if (supportsERC165(account)) { for (uint256 i = 0; i < interfaceIds.length; i++) { interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]); } } return interfaceIdsSupported; }
function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) { if (!supportsERC165(account)) { return false; } for (uint256 i = 0; i < interfaceIds.length; i++) { if (!_supportsERC165Interface(account, interfaceIds[i])) { return false; } } return true; }
function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) { bytes memory encodedParams = abi.encodeWithSelector(IERC165(account).supportsInterface.selector, interfaceId); (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams); if (result.length < 32) return false; return success && abi.decode(result, (bool)); }
function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId]; }
function _registerInterface(bytes4 interfaceId) internal virtual { require(interfaceId != 0xffffffff, "ERC165: invalid interface id"); _supportedInterfaces[interfaceId] = true; }
function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) public view virtual override returns (bytes32) { return _supportedInterfaces[interfaceHash][account] ? _ERC1820_ACCEPT_MAGIC : bytes32(0x00); }
function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal virtual { _supportedInterfaces[interfaceHash][account] = true; }
function supportsInterface(bytes4 interfaceId) external view returns (bool);
function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);
function setManager(address account, address newManager) external;
function getManager(address account) external view returns (address);
function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;
function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);
function interfaceHash(string calldata interfaceName) external pure returns (bytes32);
function updateERC165Cache(address account, bytes4 interfaceId) external;
function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);
function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);
function max(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; }
function min(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; }
function average(uint256 a, uint256 b) internal pure returns (uint256) { return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2); }
function toUint128(uint256 value) internal pure returns (uint128) { require(value < 2**128, "SafeCast: value doesn\'t fit in 128 bits"); return uint128(value); }
function toUint64(uint256 value) internal pure returns (uint64) { require(value < 2**64, "SafeCast: value doesn\'t fit in 64 bits"); return uint64(value); }
function toUint32(uint256 value) internal pure returns (uint32) { require(value < 2**32, "SafeCast: value doesn\'t fit in 32 bits"); return uint32(value); }
function toUint16(uint256 value) internal pure returns (uint16) { require(value < 2**16, "SafeCast: value doesn\'t fit in 16 bits"); return uint16(value); }
function toUint8(uint256 value) internal pure returns (uint8) { require(value < 2**8, "SafeCast: value doesn\'t fit in 8 bits"); return uint8(value); }
function toUint256(int256 value) internal pure returns (uint256) { require(value >= 0, "SafeCast: value must be positive"); return uint256(value); }
function toInt128(int256 value) internal pure returns (int128) { require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\'t fit in 128 bits"); return int128(value); }
function toInt64(int256 value) internal pure returns (int64) { require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\'t fit in 64 bits"); return int64(value); }
function toInt32(int256 value) internal pure returns (int32) { require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\'t fit in 32 bits"); return int32(value); }
function toInt16(int256 value) internal pure returns (int16) { require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\'t fit in 16 bits"); return int16(value); }
function toInt8(int256 value) internal pure returns (int8) { require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\'t fit in 8 bits"); return int8(value); }
function toInt256(uint256 value) internal pure returns (int256) { require(value < 2**255, "SafeCast: value doesn't fit in an int256"); return int256(value); }
function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { uint256 c = a + b; if (c < a) return (false, 0); return (true, c); } }
function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b > a) return (false, 0); return (true, a - b); } }
function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (a == 0) return (true, 0); uint256 c = a * b; if (c / a != b) return (false, 0); return (true, c); } }
function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b == 0) return (false, 0); return (true, a / b); } }
function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b == 0) return (false, 0); return (true, a % b); } }
function add(uint256 a, uint256 b) internal pure returns (uint256) { return a + b; }
function sub(uint256 a, uint256 b) internal pure returns (uint256) { return a - b; }
function mul(uint256 a, uint256 b) internal pure returns (uint256) { return a * b; }
function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; }
function mod(uint256 a, uint256 b) internal pure returns (uint256) { return a % b; }
function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked { require(b <= a, errorMessage); return a - b; } }
function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked { require(b > 0, errorMessage); return a / b; } }
function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked { require(b > 0, errorMessage); return a % b; } }
function mul(int256 a, int256 b) internal pure returns (int256) { return a * b; }
function div(int256 a, int256 b) internal pure returns (int256) { return a / b; }
function sub(int256 a, int256 b) internal pure returns (int256) { return a - b; }
function add(int256 a, int256 b) internal pure returns (int256) { return a + b; }
function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) { map._values[key] = value; return map._keys.add(key); }
function _remove(Map storage map, bytes32 key) private returns (bool) { delete map._values[key]; return map._keys.remove(key); }
function _contains(Map storage map, bytes32 key) private view returns (bool) { return map._keys.contains(key); }
function _length(Map storage map) private view returns (uint256) { return map._keys.length(); }
function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) { bytes32 key = map._keys.at(index); return (key, map._values[key]); }
function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) { bytes32 value = map._values[key]; if (value == bytes32(0)) { return (_contains(map, key), bytes32(0)); } else { return (true, value); } }
function _get(Map storage map, bytes32 key) private view returns (bytes32) { bytes32 value = map._values[key]; require(value != 0 || _contains(map, key), "EnumerableMap: nonexistent key"); return value; }
function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) { bytes32 value = map._values[key]; require(value != 0 || _contains(map, key), errorMessage); return value; }
function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) { return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value)))); }
function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) { return _remove(map._inner, bytes32(key)); }
function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) { return _contains(map._inner, bytes32(key)); }
function length(UintToAddressMap storage map) internal view returns (uint256) { return _length(map._inner); }
function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) { (bytes32 key, bytes32 value) = _at(map._inner, index); return (uint256(key), address(uint160(uint256(value)))); }
function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) { (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key)); return (success, address(uint160(uint256(value)))); }
function get(UintToAddressMap storage map, uint256 key) internal view returns (address) { return address(uint160(uint256(_get(map._inner, bytes32(key))))); }
function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) { return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage)))); }
function _add(Set storage set, bytes32 value) private returns (bool) { if (!_contains(set, value)) { set._values.push(value); set._indexes[value] = set._values.length; return true; } else { return false; } }
function _remove(Set storage set, bytes32 value) private returns (bool) { uint256 valueIndex = set._indexes[value]; if (valueIndex != 0) {  if (valueIndex != 0) {  uint256 toDeleteIndex = valueIndex - 1; uint256 lastIndex = set._values.length - 1; bytes32 lastvalue = set._values[lastIndex]; set._values[toDeleteIndex] = lastvalue; set._indexes[lastvalue] = valueIndex;  set._indexes[lastvalue] = valueIndex;  set._values.pop(); delete set._indexes[value]; return true; } else { return false; } }
function _contains(Set storage set, bytes32 value) private view returns (bool) { return set._indexes[value] != 0; }
function _length(Set storage set) private view returns (uint256) { return set._values.length; }
function _at(Set storage set, uint256 index) private view returns (bytes32) { require(set._values.length > index, "EnumerableSet: index out of bounds"); return set._values[index]; }
function add(Bytes32Set storage set, bytes32 value) internal returns (bool) { return _add(set._inner, value); }
function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) { return _remove(set._inner, value); }
function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) { return _contains(set._inner, value); }
function length(Bytes32Set storage set) internal view returns (uint256) { return _length(set._inner); }
function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) { return _at(set._inner, index); }
function add(AddressSet storage set, address value) internal returns (bool) { return _add(set._inner, bytes32(uint256(uint160(value)))); }
function remove(AddressSet storage set, address value) internal returns (bool) { return _remove(set._inner, bytes32(uint256(uint160(value)))); }
function contains(AddressSet storage set, address value) internal view returns (bool) { return _contains(set._inner, bytes32(uint256(uint160(value)))); }
function length(AddressSet storage set) internal view returns (uint256) { return _length(set._inner); }
function at(AddressSet storage set, uint256 index) internal view returns (address) { return address(uint160(uint256(_at(set._inner, index)))); }
function add(UintSet storage set, uint256 value) internal returns (bool) { return _add(set._inner, bytes32(value)); }
function remove(UintSet storage set, uint256 value) internal returns (bool) { return _remove(set._inner, bytes32(value)); }
function contains(UintSet storage set, uint256 value) internal view returns (bool) { return _contains(set._inner, bytes32(value)); }
function length(UintSet storage set) internal view returns (uint256) { return _length(set._inner); }
function at(UintSet storage set, uint256 index) internal view returns (uint256) { return uint256(_at(set._inner, index)); }
