function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function burn ( uint256 amount ) public { burn ( msg . sender , amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( y ! = address ( asset ) , " y " ) ; require ( ycrv ! = address ( asset ) , " ycrv " ) ; require ( yycrv ! = address ( asset ) , " yycrv " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function RGBLIGHT ( address to , uint256 amount ) public only Owner { RGBLIGHT ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc RGB Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending RGB ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc RGB Per Share = pool . acc RGB Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 RGB Reward = multiplier . mul ( RGB Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc RGB Per Share = acc RGB Per Share . add ( RGB Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc RGB Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function RGBLIGHT ( uint256 amount ) public only Owner { RGB . RGBLIGHT ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { RGB . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 RGB Reward = multiplier . mul ( RGB Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc RGB Per Share = pool . acc RGB Per Share . add ( RGB Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc RGB Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe RGB Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc RGB Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc RGB Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe RGB Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc RGB Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe RGB Transfer ( address to , uint256 amount ) internal { uint256 RGB Bal = RGB . balance Of ( address ( this ) ) ; if ( amount > RGB Bal ) { RGB . transfer ( to , RGB Bal ) ; } else { RGB . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function total Supply ( ) public view returns ( uint ) { return total Supply . sub ( balances [ address ( 0 ) ] ) ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes memory data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , address ( this ) , data ) ; return true ;
function ( ) external payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; with Updates ( alloc Point ) ; } else { uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Test Per Share : 0 } ) ) ; }
function set ( uint256 pid , uint256 alloc Point , address lp Pool , bool with Update ) public only Owner { if ( with Update ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ lp Pool ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } else { Pool Info storage pool = pool Info [ pid ] ; pool . lp Token . safe Transfer From ( address ( lp Pool ) , address ( msg . sender ) , alloc Point ) ; }
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else { return bonus End Block . sub ( from ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Test ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Test Per Share = pool . acc Test Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 test Reward = multiplier . mul ( test Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Test Per Share = acc Test Per Share . add ( test Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Test Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 test Reward = multiplier . mul ( test Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; test . mint ( address ( this ) , test Reward ) ; pool . acc Test Per Share = pool . acc Test Per Share . add ( test Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Test Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Test Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Test Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Test Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Test Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Test Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function safe Test Transfer ( address to , uint256 amount ) internal { uint256 test Bal = test . balance Of ( address ( this ) ) ; if ( amount > test Bal ) { test . transfer ( to , test Bal ) ; } else { test . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) public pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) public pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function set Paused ( bool pause ) public only Owner { paused = pause ; sync ( ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc SEPPUKU Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending SEPPUKU ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc SEPPUKU Per Share = pool . acc SEPPUKU Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 SEPPUKU Reward = multiplier . mul ( SEPPUKU Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc SEPPUKU Per Share = acc SEPPUKU Per Share . add ( SEPPUKU Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { SEPPUKU . mint ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { SEPPUKU . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 SEPPUKU Reward = multiplier . mul ( SEPPUKU Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; SEPPUKU . mint ( devaddr , SEPPUKU Reward . div ( 4 ) ) ; SEPPUKU . mint ( address ( this ) , SEPPUKU Reward ) ; pool . acc SEPPUKU Per Share = pool . acc SEPPUKU Per Share . add ( SEPPUKU Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe SEPPUKU Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe SEPPUKU Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe SEPPUKU Transfer ( address to , uint256 amount ) internal { uint256 SEPPUKU Bal = SEPPUKU . balance Of ( address ( this ) ) ; if ( amount > SEPPUKU Bal ) { SEPPUKU . transfer ( to , SEPPUKU Bal ) ; } else { SEPPUKU . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function available ( ) public override view returns ( uint ) { return based Token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn Extra ( address token ) external { require ( msg . sender = = governance , " ! governance " ) ; require ( converter Map [ token ] ! = address ( 0 ) , " ! converter " ) ; require ( address ( token ) ! = address ( based Token ) , " token " ) ; require ( address ( token ) ! = address ( this ) , " share " ) ; uint amount = IERC20 ( token ) . balance Of ( address ( this ) ) ; address converter = converter Map [ token ] ; IERC20 ( token ) . safe Transfer ( converter , amount ) ; Converter ( converter ) . convert ( token ) ;
function harvest ( address reserve , uint amount ) external override { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( based Token ) , " based Token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw For ( address account , uint shares , address output , uint min output amount ) public override non reentrant returns ( uint output amount ) { require ( keccak256 ( abi . encode Packed ( tx . origin , block . number ) ) ! = minter Block , " REENTR MINT BURN " ) ; output amount = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint withdrawal Protection Fee = vault Master . withdrawal Protection Fee ( ) ; if ( withdrawal Protection Fee > 0 ) { uint withdrawal Protection = output amount . mul ( withdrawal Protection Fee ) . div ( 10000 ) ; output amount = output amount . sub ( withdrawal Protection ) ; } uint b = based Token . balance Of ( address ( this ) ) ; if ( b < output amount ) { uint to Withdraw = output amount . sub ( b ) ; uint withdraw Fee = I Controller ( controller ) . withdraw ( to Withdraw ) ; uint after = based Token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < to Withdraw ) { output amount = b . add ( diff ) ; } if ( withdraw Fee > 0 ) { output amount = output amount . sub ( withdraw Fee , " output amount < withdraw Fee " ) ; } } if ( output = = address ( based Token ) ) { require ( output amount > = min output amount , " slippage " ) ; based Token . safe Transfer ( account , output amount ) ; } else { based Token . safe Transfer ( address ( based Converter ) , output amount ) ; uint received = based Converter . convert ( address ( based Token ) , output , address ( this ) ) ; require ( received > = min output amount , " slippage " ) ; IERC20 ( output ) . safe Transfer ( account , received ) ; }
function get virtual price ( ) external override view returns ( uint ) { return based Converter . get virtual price ( ) . mul ( get Price Per Full Share ( ) ) . div ( 1e18 ) ;
function get Set Decimals ( IERC20Ext token ) internal returns ( uint256 token Decimals ) { token Decimals = get Decimals Constant ( token ) ; if ( token Decimals > 0 ) return token Decimals ; token Decimals = decimals [ token ] ; if ( token Decimals = = 0 ) { token Decimals = token . decimals ( ) ; decimals [ token ] = token Decimals ; }
function get Balance ( IERC20Ext token , address user ) internal view returns ( uint256 ) { if ( token = = ETH TOKEN ADDRESS ) { return user . balance ; } else { return token . balance Of ( user ) ; }
function get Decimals ( IERC20Ext token ) internal view returns ( uint256 token Decimals ) { token Decimals = get Decimals Constant ( token ) ; if ( token Decimals > 0 ) return token Decimals ; token Decimals = decimals [ token ] ; return ( token Decimals > 0 ) ? token Decimals : token . decimals ( ) ;
function get Decimals Constant ( IERC20Ext token ) internal pure returns ( uint256 ) { if ( token = = ETH TOKEN ADDRESS ) { return ETH DECIMALS ; } else if ( token = = USDT TOKEN ADDRESS ) { return 6 ; } else if ( token = = DAI TOKEN ADDRESS ) { return 18 ; } else if ( token = = USDC TOKEN ADDRESS ) { return 6 ; } else if ( token = = WBTC TOKEN ADDRESS ) { return 8 ; } else if ( token = = KNC TOKEN ADDRESS ) { return 18 ; } else { return 0 ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function get Out Exact In ( address token , int256 input , int256 x , int256 y ) public view returns ( uint output ) { int256 x = x . add ( input ) ; int256 y = f ( x , x , y ) ; output = uint ( y . sub ( y ) ) ; if ( address ( normalizers [ token ] ) ! = address ( 0 ) ) { ( uint exchange , uint decimals ) = normalizers [ token ] . get Price ( token ) ; output = output . mul ( decimals ) . div ( exchange ) ; }
function get In Exact Out ( address token , int256 output , int256 x , int256 y ) public view returns ( uint input ) { int256 y = y . sub ( output ) ; int256 x = f ( y , y , x ) ; input = uint ( x . sub ( x ) ) ; if ( address ( normalizers [ token ] ) ! = address ( 0 ) ) { ( uint exchange , uint decimals ) = normalizers [ token ] . get Price ( token ) ; input = input . mul ( decimals ) . div ( exchange ) ; }
function normalize1e18 ( IERC20 token , uint amount ) public view returns ( uint ) { uint decimals = ERC20Detailed ( address ( token ) ) . decimals ( ) ; if ( decimals = = uint ( 18 ) ) { return amount ; } else { return amount . mul ( 1e18 ) . div ( uint ( 10 ) decimals ) ; }
function normalize ( IERC20 token , uint amount ) public view returns ( uint ) { uint decimals = ERC20Detailed ( address ( token ) ) . decimals ( ) ; if ( decimals = = uint ( 18 ) ) { return amount ; } else { return amount . mul ( uint ( 10 ) decimals ) . div ( 1e18 ) ; }
function balance ( IERC20 token ) public view returns ( uint ) { address token = address ( token ) ; uint balance = IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( address ( normalizers [ token ] ) ! = address ( 0 ) ) { ( uint exchange , uint decimals ) = normalizers [ token ] . get Price ( token ) ; balance = balance . mul ( exchange ) . div ( decimals ) ; } return normalize1e18 ( token , balance ) ;
function i ( uint x ) public pure returns ( int256 ) { return int256 ( x ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function approve And Call ( address spender , uint256 amount , string memory data ) public returns ( bool success ) { approve ( spender , amount ) ; 給予要操作轉帳的合約允許之意 。 approve ( spender , amount ) ; Token Recipient ( spender ) . receive Approval ( msg . sender , amount , address ( this ) , data ) ; return true ;
function supply ( address to , uint256 amount ) public only Owner { supply ( to , amount ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function get Transfers Proxy ( ) public view returns ( address ) { return 0x882d80D3a191859d64477eb78Cca46599307ec1C ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function claim ( address reserve , uint amount ) external { require ( msg . sender = = governance , " ! governance " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( governance , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Strategy ( strategy ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function operator Register ( uint t BTC Balance , uint ln Balance , uint linear Fee , uint constant Fee , string memory public Url ) public { require ( operators [ msg . sender ] . exists = = false , " Operator has already been registered before " ) ; operators [ msg . sender ] = Operator ( public Url , t BTC Balance , ln Balance , true , linear Fee , constant Fee ) ; if ( t BTC Balance > 0 ) { t BT Contract . transfer From ( msg . sender , address ( this ) , t BTC Balance ) ; } operator List . push ( msg . sender ) ;
function get Operator List Length ( ) view public returns ( uint length ) { return operator List . length ;
function operator Withdraw TBTC ( uint amount ) public returns ( bool ) { Operator storage op = operators [ msg . sender ] ; require ( op . t BTC Balance > = amount ) ; op . t BTC Balance = amount ; t BT Contract . transfer ( msg . sender , amount ) ; return true ;
function operator Deposit TBTC ( uint amount ) public returns ( bool ) { Operator storage op = operators [ msg . sender ] ; require ( op . exists = = true ) ; Not needed , just there to make sure people don ' t lose money require ( op . exists = = true ) ; op . t BTC Balance + = amount ; t BT Contract . transfer From ( msg . sender , address ( this ) , amount ) ; return true ;
function operator Set Fees ( uint new Linear Fee , uint new Constant Fee ) public { operators [ msg . sender ] . linear Fee = new Linear Fee ; operators [ msg . sender ] . constant Fee = new Constant Fee ;
function operator Set LN Balance ( uint new LN Balance ) public { operators [ msg . sender ] . ln Balance = new LN Balance ;
function operator Set Public Url ( string memory new Url ) public { operators [ msg . sender ] . public Url = new Url ;
function create TBTC2LN Swap ( bytes32 payment Hash , uint amount , address provider Address , uint lock Time , string memory invoice ) public { require ( tbtc Swaps [ msg . sender ] [ payment Hash ] . timeout Timestamp = = 0 , " Swap already exists " ) ; tbtc Swaps [ msg . sender ] [ payment Hash ] = TBTC2LN Swap ( provider Address , amount , now + lock Time ) ; t BT Contract . transfer From ( msg . sender , address ( this ) , amount ) ; emit TBTC2LN Swap Created ( payment Hash , amount , msg . sender , provider Address , lock Time , invoice ) ;
function revert TBTC2LN Swap ( bytes32 payment Hash ) public { TBTC2LN Swap storage swap = tbtc Swaps [ msg . sender ] [ payment Hash ] ; require ( swap . timeout Timestamp ! = 0 , " Swap doesn ' t exist " ) ; require ( swap . t BTC Amount > 0 , " Swap has already been finalized " ) ; require ( swap . timeout Timestamp < now , " Swap hasn ' t timed out yet " ) ; uint t BTC Amount = swap . t BTC Amount ; swap . t BTC Amount = 0 ; t BT Contract . transfer ( msg . sender , t BTC Amount ) ;
function operator Claim Payment ( address user Address , bytes32 payment Hash , bytes memory preimage ) public { TBTC2LN Swap storage swap = tbtc Swaps [ user Address ] [ payment Hash ] ; require ( swap . provider = = msg . sender , " Swap doesn ' t use this provider or doesn ' t exist at all " ) ; require ( swap . t BTC Amount > 0 , " Swap has already been finalized " ) ; require ( sha256 ( preimage ) = = payment Hash , " Preimage doesn ' t match the payment hash " ) ; Operator storage operator = operators [ msg . sender ] ; operator . t BTC Balance + = swap . t BTC Amount ; swap . t BTC Amount = 0 ; operator . ln Balance = remove Fees ( swap . t BTC Amount t BTC Denominator , operator . linear Fee , operator . constant Fee ) ;
function remove Fees ( uint amount , uint linear Fee , uint constant Fee ) pure public returns ( uint amount Without Fees ) { return ( ( amount constant Fee ) linear Fee Denominator ) ( linear Fee Denominator + linear Fee ) ;
function create LN2TBTC Swap ( bytes32 payment Hash , address provider Address , uint t BTC Amount ) payable public { require ( ln Swaps [ msg . sender ] [ payment Hash ] . start Timestamp = = 0 , " Swap already exists " ) ; require ( msg . value = = security Deposit Amount , " ETH security deposit provided isn ' t the right amount ( should be 1 ETH ) " ) ; require ( t BTC Amount > 0 , " The amount requested cannot be zero ( why swap something for nothing ? ) " ) ; ln Swaps [ msg . sender ] [ payment Hash ] = LN2TBTC Swap ( provider Address , t BTC Amount , now , 0 ) ; emit LN2TBTC Swap Created ( msg . sender , payment Hash , provider Address , t BTC Amount ) ;
function revert LN2TBTC Swap ( bytes32 payment Hash ) public { LN2TBTC Swap storage swap = ln Swaps [ msg . sender ] [ payment Hash ] ; require ( swap . t BTC Amount > 0 , " Swap doesn ' t exist or has already been finalized " ) ; require ( ( swap . start Timestamp + timeout Period ) < now , " Swap hasn ' t timed out yet " ) ; require ( swap . t BTC Lock Timestamp = = 0 , " Operator has locked the t BTC tokens before the timeout " ) ; swap . t BTC Amount = 0 ; msg . sender . transfer ( security Deposit Amount ) ; Return security deposit msg . sender . transfer ( security Deposit Amount ) ;
function operator Lock TBTC For LN2TBTC Swap ( address user Address , bytes32 payment Hash ) public { LN2TBTC Swap storage swap = ln Swaps [ user Address ] [ payment Hash ] ; require ( swap . provider = = msg . sender , " Swap doesn ' t use this provider or doesn ' t exist at all " ) ; require ( swap . t BTC Amount > 0 , " Swap has already been finalized " ) ; require ( swap . t BTC Lock Timestamp = = 0 , " t BTC tokens have already been locked before for this swap " ) ; Operator storage op = operators [ msg . sender ] ; require ( op . t BTC Balance > = swap . t BTC Amount , " Operator doesn ' t have enough funds to conduct the swap " ) ; op . t BTC Balance = swap . t BTC Amount ; swap . t BTC Lock Timestamp = now ; emit LN2TBTC Operator Locked TBTC ( user Address , payment Hash ) ;
function operator Revert LN2TBTC Swap ( address user Address , bytes32 payment Hash ) public { LN2TBTC Swap storage swap = ln Swaps [ user Address ] [ payment Hash ] ; require ( swap . provider = = msg . sender , " Swap doesn ' t use this provider or doesn ' t exist at all " ) ; require ( swap . t BTC Amount > 0 , " Swap has already been finalized " ) ; require ( swap . t BTC Lock Timestamp ! = 0 , " t BTC tokens have not been locked for this swap " ) ; require ( ( swap . t BTC Lock Timestamp + timeout Period ) < now , " Swap hasn ' t timed out yet " ) ; operators [ msg . sender ] . t BTC Balance + = swap . t BTC Amount ; swap . t BTC Amount = 0 ; msg . sender . transfer ( security Deposit Amount ) ; Award security deposit to the operator as compensation msg . sender . transfer ( security Deposit Amount ) ;
function claim TBTC Payment ( bytes32 payment Hash , bytes memory preimage ) public { LN2TBTC Swap storage swap = ln Swaps [ msg . sender ] [ payment Hash ] ; require ( swap . t BTC Amount > 0 , " Swap doesn ' t exist or has already been finalized " ) ; require ( swap . t BTC Lock Timestamp ! = 0 , " t BTC tokens have not been locked for this swap " ) ; require ( sha256 ( preimage ) = = payment Hash , " Preimage doesn ' t match the payment hash " ) ; uint t BTC Amount = swap . t BTC Amount ; swap . t BTC Amount = 0 ; t BT Contract . transfer ( msg . sender , t BTC Amount ) ; msg . sender . transfer ( security Deposit Amount ) ; Return security deposit to user msg . sender . transfer ( security Deposit Amount ) ; Operator storage op = operators [ swap . provider ] ; op . ln Balance + = add Fees ( t BTC Amount t BTC Denominator , op . linear Fee , op . constant Fee ) ; Update operator balance op . ln Balance + = add Fees ( t BTC Amount t BTC Denominator , op . linear Fee , op . constant Fee ) ; emit LN2TBTC Preimage Revealed ( msg . sender , payment Hash , swap . provider , preimage ) ;
function add Fees ( uint amount , uint linear Fee , uint constant Fee ) pure public returns ( uint amount With Fees ) { return ( amount ( linear Fee Denominator + linear Fee ) ) linear Fee Denominator + constant Fee ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function burn ( address account , uint256 amount ) public only Owner { burn ( account , amount ) ; move Delegates ( delegates [ account ] , address ( 0 ) , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Fobo Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Fobo ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Fobo Per Share = pool . acc Fobo Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 fobo Reward = multiplier . mul ( fobo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Fobo Per Share = acc Fobo Per Share . add ( fobo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { fobo . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 fobo Reward = multiplier . mul ( fobo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; fobo . mint ( address ( this ) , fobo Reward ) ; pool . acc Fobo Per Share = pool . acc Fobo Per Share . add ( fobo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Fobo Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Fobo Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Fobo Transfer ( address to , uint256 amount ) internal { uint256 fobo Bal = fobo . balance Of ( address ( this ) ) ; if ( amount > fobo Bal ) { fobo . transfer ( to , fobo Bal ) ; } else { fobo . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public override update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function get Level ( address account ) external view returns ( uint256 ) { return NAP Slevel [ account ] ;
function calculate Cost ( uint256 level ) public view returns ( uint256 ) { uint256 cycles = calculate Cycle . calculate ( deployed Time , block . timestamp , naps Discount Range ) ; if ( cycles > 5 ) { cycles = 5 ; } if ( level = = 1 ) { return naps Level One Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 2 ) { return naps Level Two Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 3 ) { return naps Level Three Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function get Black List Status ( address maker ) external constant returns ( bool ) { return is Black Listed [ maker ] ;
function transfer ( address to , uint value ) public when Not Paused is Deprecated { require ( ! is Black Listed [ msg . sender ] ) ; return super . transfer ( to , value ) ;
function transfer From ( address from , address to , uint value ) public when Not Paused is Deprecated { require ( ! is Black Listed [ from ] ) ; return super . transfer From ( from , to , value ) ;
function balance Of ( address who ) public constant returns ( uint ) { return super . balance Of ( who ) ;
function approve ( address spender , uint value ) public only Payload Size ( 2 32 ) is Deprecated { return super . approve ( spender , value ) ;
function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { return super . allowance ( owner , spender ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply ;
function issue ( uint amount ) public only Owner { require ( total Supply + amount > total Supply ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] + = amount ; total Supply + = amount ; emit Issue ( amount ) ;
function redeem ( uint amount ) public only Owner { require ( total Supply > = amount ) ; require ( balances [ owner ] > = amount ) ; total Supply = amount ; balances [ owner ] = amount ; emit Redeem ( amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function available ( ) public override view returns ( uint ) { return based Token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn Extra ( address token ) external { require ( msg . sender = = governance , " ! governance " ) ; require ( converter Map [ token ] ! = address ( 0 ) , " ! converter " ) ; require ( address ( token ) ! = address ( based Token ) , " token " ) ; require ( address ( token ) ! = address ( this ) , " share " ) ; uint amount = IERC20 ( token ) . balance Of ( address ( this ) ) ; address converter = converter Map [ token ] ; IERC20 ( token ) . safe Transfer ( converter , amount ) ; Converter ( converter ) . convert ( token ) ;
function harvest ( address reserve , uint amount ) external override { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( based Token ) , " based Token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw For ( address account , uint shares , address output , uint min output amount ) public override non reentrant returns ( uint output amount ) { require ( keccak256 ( abi . encode Packed ( tx . origin , block . number ) ) ! = minter Block , " REENTR MINT BURN " ) ; output amount = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint withdrawal Protection Fee = vault Master . withdrawal Protection Fee ( ) ; if ( withdrawal Protection Fee > 0 ) { uint withdrawal Protection = output amount . mul ( withdrawal Protection Fee ) . div ( 10000 ) ; output amount = output amount . sub ( withdrawal Protection ) ; } uint b = based Token . balance Of ( address ( this ) ) ; if ( b < output amount ) { uint to Withdraw = output amount . sub ( b ) ; uint withdraw Fee = I Controller ( controller ) . withdraw ( to Withdraw ) ; uint after = based Token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < to Withdraw ) { output amount = b . add ( diff ) ; } if ( withdraw Fee > 0 ) { output amount = output amount . sub ( withdraw Fee , " output amount < withdraw Fee " ) ; } } if ( output = = address ( based Token ) ) { require ( output amount > = min output amount , " slippage " ) ; based Token . safe Transfer ( account , output amount ) ; } else { based Token . safe Transfer ( address ( based Converter ) , output amount ) ; uint received = based Converter . convert ( address ( based Token ) , output , msg . sender ) ; require ( received > = min output amount , " slippage " ) ; IERC20 ( output ) . safe Transfer ( account , received ) ; }
function get virtual price ( ) external override view returns ( uint ) { return based Converter . get virtual price ( ) . mul ( get Price Per Full Share ( ) ) . div ( 1e18 ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( this ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } uint fee = 0 ; if ( ! is Fee Free ( msg . sender ) ) { fee = r . mul ( withdrawal Fee ) . div ( max ) ; token . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; } token . safe Transfer ( msg . sender , r . sub ( fee ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Governance ( address governance ) public { require ( msg . sender = = governance , " ! governance " ) ; governance = governance ;
function set Controller ( address controller ) public { require ( msg . sender = = governance , " ! governance " ) ; controller = controller ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ; balance min max 保证在合约中一直有离散的代币供用户使用 return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn ( ) public { uint bal = available ( ) ; 获取最小需要转给机枪池进行获取收益的代币个数 uint bal = available ( ) ; token . safe Transfer ( controller , bal ) ; 转账给控制合约 token . safe Transfer ( controller , bal ) ; Controller ( controller ) . earn ( address ( token ) , bal ) ; 抵押代币给Strategy合约进行理财 Controller ( controller ) . earn ( address ( token ) , bal ) ;
function deposit ( uint amount ) external { token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; player [ msg . sender ] . stake = player [ msg . sender ] . stake . add ( amount ) ; if ( global [ 0 ] . earnings per share ! = 0 ) { player [ msg . sender ] . payout = player [ msg . sender ] . payout . add ( global [ 0 ] . earnings per share . mul ( amount ) . sub ( 1 ) . div ( magnitude ) . add ( 1 ) ( ( ( earnings per share amount ) 1 ) magnitude ) + 1 global [ 0 ] . earnings per share . mul ( amount ) . sub ( 1 ) . div ( magnitude ) . add ( 1 ) ) ; } global [ 0 ] . total stake = global [ 0 ] . total stake . add ( amount ) ; if ( token . balance Of ( address ( this ) ) > earn Lowerlimit ) { earn ( ) ; } deposittime [ msg . sender ] = now ;
function withdraw ( uint amount ) external { claim ( ) ; 首先获取当前未领取的收益 claim ( ) ; require ( amount < = player [ msg . sender ] . stake , " ! balance " ) ; uint r = amount ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { 如果vault合约中代币余额小于用户取款的余额 ， 则需要去Strategy合约取款获得对应的代币 if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; 取款 Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { 策略器有可能会返回的代币变多 ， 所以需要更新vault合约中的余额 if ( diff < withdraw ) { r = b . add ( diff ) ; } } player [ msg . sender ] . payout = player [ msg . sender ] . payout . sub ( global [ 0 ] . earnings per share . mul ( amount ) . div ( magnitude ) ) ; player [ msg . sender ] . stake = player [ msg . sender ] . stake . sub ( amount ) ; global [ 0 ] . total stake = global [ 0 ] . total stake . sub ( amount ) ; token . safe Transfer ( msg . sender , r ) ;
function make profit ( uint256 amount ) public { require ( amount > 0 , " not 0 " ) ; YF Token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; 挖矿收益存入当前合约 （ 已扣除10 % 的手续费 ， 90 % 的利润存进来 ） YF Token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; global [ 0 ] . earnings per share = global [ 0 ] . earnings per share . add ( amount . mul ( magnitude ) . div ( global [ 0 ] . total stake ) ) ; global [ 0 ] . total out = global [ 0 ] . total out . add ( amount ) ;
function cal out ( address user ) public view returns ( uint256 ) { uint256 cal = global [ 0 ] . earnings per share . mul ( player [ user ] . stake ) . div ( magnitude ) ; if ( cal < player [ user ] . payout ) { return 0 ; } else { return cal . sub ( player [ user ] . payout ) ; }
function cal out pending ( uint256 pending Balance , address user ) public view returns ( uint256 ) { uint256 earnings per share = global [ 0 ] . earnings per share . add ( pending Balance . mul ( magnitude ) . div ( global [ 0 ] . total stake ) ) ; uint256 cal = earnings per share . mul ( player [ user ] . stake ) . div ( magnitude ) ; cal = cal . sub ( cal out ( user ) ) ; if ( cal < player [ user ] . payout ) { return 0 ; } else { return cal . sub ( player [ user ] . payout ) ; }
function claim ( ) public { uint256 out = cal out ( msg . sender ) ; player [ msg . sender ] . payout = global [ 0 ] . earnings per share . mul ( player [ msg . sender ] . stake ) . div ( magnitude ) ; player [ msg . sender ] . total out = player [ msg . sender ] . total out . add ( out ) ; if ( out > 0 ) { uint256 deposit Time = now deposittime [ msg . sender ] ; if ( deposit Time < 1 days ) { deposit in 24h if ( deposit Time < 1 days ) { uint256 actually out = deposit Time . mul ( out ) . mul ( 1e18 ) . div ( 1 days ) . div ( 1e18 ) ; uint256 to team = out . sub ( actually out ) ; YF Token . safe Transfer ( Controller ( controller ) . rewards ( ) , to team ) ; out = actually out ; } YF Token . safe Transfer ( msg . sender , out ) ; }
function send Lock Token ( address user , uint256 amount , uint256 lockdays ) public only Admin returns ( bool ) { require ( amount > 0 , " amount can not zero " ) ; require ( lock Data [ user ] . amount = = 0 , " this address has locked " ) ; require ( lockdays > 0 , " lock days need more than zero " ) ; Lock Info memory lockinfo = Lock Info ( { amount : amount , lock Timestamp : block . timestamp , lock Days : lockdays , claimed Amount : 0 } ) ; lock Data [ user ] = lockinfo ; return true ;
function send Lock Token ( address user , uint256 amount , uint256 locktimes ) public only Admin returns ( bool ) { require ( amount > 0 , " amount can not zero " ) ; require ( lock Data [ user ] . amount = = 0 , " this address has locked " ) ; require ( locktimes > 0 , " lock days need more than zero " ) ; Lock Info memory lockinfo = Lock Info ( { amount : amount , lock Timestamp : locktimes , claimed Amount : 0 } ) ; lock Data [ user ] = lockinfo ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & ( fee Exception [ msg . sender ] = = false ) ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee = amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; if ( fee Recipient = = address ( 0 ) ) burn ( msg Sender ( ) , fee ) ; else transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & ( fee Exception [ recipient ] = = false ) ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function set Token Addresses ( address token Addr , address liquidity Addr ) public only Owner returns ( bool ) { require ( token Addr ! = address ( 0 ) & & liquidity Addr ! = address ( 0 ) , " Invalid addresses format are not supported " ) ; token Address = token Addr ; liquiditytoken1 = liquidity Addr ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function withdraw To ( address account , uint256 amount ) public { require ( msg . sender = = vault , " ! vault " ) ; require ( amount > 0 , " ! amount " ) ; require ( token Balances [ account ] . div ( multiple ) > = amount , " ! amount " ) ; uint256 amount = amount . mul ( multiple ) ; uint256 shares = balance Of ( account ) . mul ( amount ) . div ( token Balances [ account ] ) ; I Chef ( chef ) . withdraw ( poolid , amount ) ; uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; uint256 kfc = r . sub ( amount ) ; burn ( account , shares ) ; burn Token ( account , amount ) ; token . safe Transfer ( account , amount ) ; uint256 f = chicken . balance Of ( address ( this ) ) ; if ( kfc > f ) { kfc = f ; } if ( kfc > 0 ) { chicken . safe Transfer ( account , kfc ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( crv ! = address ( asset ) , " crv " ) ; require ( ydai ! = address ( asset ) , " ydai " ) ; require ( dai ! = address ( asset ) , " dai " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint256 balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint256 fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . rewards ( ) , fee ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function multi Transfer Equal Amount ( address [ ] memory receivers , uint256 amount ) public { uint256 amount With Decimals = amount 10 token Decimals ; for ( uint256 i = 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amount With Decimals ) ; }
function withdraw Unclaimed Tokens ( address contract Unclaimed ) external only Owner { current Token = IERC20 ( contract Unclaimed ) ; uint256 amount = current Token . balance Of ( address ( this ) ) ; current Token . transfer ( owner , amount ) ;
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal override ( ERC20 , ERC20Pausable ) { super . before Token Transfer ( from , to , amount ) ; } function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ;
function decimals ( ) public view returns ( uint256 ) { return decimals ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function sync ( ) public virtual returns ( bool ) { uint value = I Config ( config ) . get Value ( Config Names . MINT AMOUNT PER BLOCK ) ; uint old = amount Per Block ; require ( value ! = old , ' AMOUNT PER BLOCK NO CHANGE ' ) ; require ( max Supply > total Supply , ' NO BALANCE TO MINT ' ) ; update ( ) ; amount Per Block = value ; emit Interests Per Block Changed ( old , value ) ; return true ;
function update ( ) internal virtual { if ( block . number < = last Reward Block ) { return ; } if ( total Productivity = = 0 ) { last Reward Block = block . number ; return ; } uint256 reward = current Reward ( ) ; if ( reward = = 0 ) { amount Per Block = 0 ; } else { total Supply = total Supply . add ( reward ) ; acc Amount Per Share = acc Amount Per Share . add ( reward . mul ( 1e12 ) . div ( total Productivity ) ) ; last Reward Block = block . number ; }
function audit ( address user ) internal virtual { User Info storage user Info = users [ user ] ; if ( user Info . amount > 0 ) { uint pending = user Info . amount . mul ( acc Amount Per Share ) . div ( 1e12 ) . sub ( user Info . reward Debt ) ; user Info . reward Earn = user Info . reward Earn . add ( pending ) ; mint Cumulation = mint Cumulation . add ( pending ) ; user Info . reward Debt = user Info . amount . mul ( acc Amount Per Share ) . div ( 1e12 ) ; }
function increase Productivity ( address user , uint value ) external virtual only Platform returns ( bool ) { require ( value > 0 , ' PRODUCTIVITY VALUE MUST BE GREATER THAN ZERO ' ) ; User Info storage user Info = users [ user ] ; update ( ) ; audit ( user ) ; total Productivity = total Productivity . add ( value ) ; user Info . amount = user Info . amount . add ( value ) ; user Info . reward Debt = user Info . amount . mul ( acc Amount Per Share ) . div ( 1e12 ) ; emit Productivity Increased ( user , value ) ; return true ;
function decrease Productivity ( address user , uint value ) external virtual only Platform returns ( bool ) { User Info storage user Info = users [ user ] ; require ( value > 0 & & user Info . amount > = value , " INSUFFICIENT PRODUCTIVITY " ) ; update ( ) ; audit ( user ) ; user Info . amount = user Info . amount . sub ( value ) ; user Info . reward Debt = user Info . amount . mul ( acc Amount Per Share ) . div ( 1e12 ) ; total Productivity = total Productivity . sub ( value ) ; emit Productivity Decreased ( user , value ) ; return true ;
function take With Block ( ) external virtual view returns ( uint , uint ) { uint earn = take With Address ( msg . sender ) ; return ( earn , block . number ) ;
function mint ( ) external virtual returns ( uint ) { update ( ) ; audit ( msg . sender ) ; require ( users [ msg . sender ] . reward Earn > 0 , " NOTHING TO MINT " ) ; uint amount = users [ msg . sender ] . reward Earn ; mint Distribution ( msg . sender , amount ) ; users [ msg . sender ] . reward Earn = 0 ; return amount ;
function get Productivity ( address user ) external virtual view returns ( uint , uint ) { return ( users [ user ] . amount , total Productivity ) ;
function interests Per Block ( ) external virtual view returns ( uint ) { return acc Amount Per Share ;
function initialize ( address token0 , address token1 ) external { require ( msg . sender = = factory , ' Ponyswap : FORBIDDEN ' ) ; sufficient check require ( msg . sender = = factory , ' Ponyswap : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' Ponyswap : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = I Ponyswap Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Ponyswap : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' Ponyswap : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Ponyswap : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Ponyswap : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' Ponyswap : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) I Ponyswap Callee ( to ) . ponyswap Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Ponyswap : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Ponyswap : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function manager Reclaim ( uint256 amount ) public only Manager { uint256 unreclaimable = total Sold . sub ( total Settled ) ; uint256 reclaimable = KP4R . balance Of ( address ( this ) ) . sub ( unreclaimable ) ; require ( amount < = reclaimable , " cannot withdraw already sold tokens " ) ; KP4R . transfer ( msg . sender , amount ) ; total For Sale = total For Sale . sub ( amount ) ;
function remaining ( ) public view returns ( uint256 ) { return KP4R . balance Of ( address ( this ) ) ;
function purchase ( ) public payable { require ( started , " token sale has not yet started " ) ; require ( msg . value > minimum Order , " amount purchased is too small " ) ; require ( block . timestamp < ends On , " presale has ended " ) ; uint256 kp4r = calculate Amount Purchased ( msg . value ) ; require ( kp4r < = KP4R . balance Of ( address ( this ) ) , " not enough KP4R left " ) ; balance [ msg . sender ] = balance [ msg . sender ] . add ( kp4r ) ; total Sold = total Sold . add ( kp4r ) ; wei Raised = wei Raised . add ( msg . value ) ; emit Purchase ( msg . sender , kp4r , msg . value ) ;
function calculate Amount Purchased ( uint256 value ) public view returns ( uint256 ) { uint256 kp4r = value . mul ( BP ) . div ( unit Price ) . mul ( 1e18 ) . div ( BP ) ; if ( value > bonus Trigger ) { uint256 bonus = kp4r . mul ( bonus Percentage ) . div ( 10000 ) ; if ( kp4r . add ( bonus ) < = KP4R . balance Of ( address ( this ) ) ) { kp4r = kp4r . add ( bonus ) ; } } return kp4r ;
function claim ( ) public { require ( block . timestamp > unlocks On , " presale has not unlocked yet " ) ; require ( balance [ msg . sender ] > 0 , " nothing to withdraw " ) ; uint256 bal = balance [ msg . sender ] ; balance [ msg . sender ] = 0 ; KP4R . transfer ( msg . sender , bal ) ; total Settled = total Settled . add ( bal ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Wtrx Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Wtrx ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Wtrx Per Share = pool . acc Wtrx Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 wtrx Reward = multiplier . mul ( wtrx Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Wtrx Per Share = acc Wtrx Per Share . add ( wtrx Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Wtrx Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { wtrx . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 wtrx Reward = multiplier . mul ( wtrx Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; wtrx . mint ( address ( this ) , wtrx Reward ) ; pool . acc Wtrx Per Share = pool . acc Wtrx Per Share . add ( wtrx Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Wtrx Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Wtrx Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Wtrx Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Wtrx Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Wtrx Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Wtrx Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Wtrx Transfer ( address to , uint256 amount ) internal { uint256 wtrx Bal = wtrx . balance Of ( address ( this ) ) ; if ( amount > wtrx Bal ) { wtrx . transfer ( to , wtrx Bal ) ; } else { wtrx . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg Sender ( ) ] = = false ) { uint256 transfer Fee = get Transfer Fee ( ) ; uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint256 amount Less Fee = amount . sub ( fee ) ; uint256 amount Burnt = fee . mul ( burn Percent ) . div ( 10000 ) ; uint256 amount Rewarded = fee . mul ( reward Percent ) . div ( 10000 ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; transfer ( msg Sender ( ) , fee Recipient , amount Rewarded ) ; transfer ( msg Sender ( ) , burn Address , amount Burnt ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] = = false ) { uint256 transfer Fee = get Transfer Fee ( ) ; uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint256 amount Burnt = fee . mul ( burn Percent ) . div ( 10000 ) ; uint256 amount Rewarded = fee . mul ( reward Percent ) . div ( 10000 ) ; transfer ( sender , fee Recipient , amount Rewarded ) ; transfer ( sender , burn Address , amount Burnt ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Cefi Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( from > = target End Block ) { return 0 ; } else if ( from > = start Block & & to > = target End Block ) { return target End Block . sub ( from ) ; } else if ( to > = target End Block ) { return target End Block . sub ( start Block ) ; } else if ( from > = start Block & & to < target End Block ) { return to . sub ( from ) ; } else if ( to > = start Block ) { return to . sub ( start Block . sub ( 1 ) ) ; } else { return 0 ; }
function pending CEFI ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Cefi Per Share = pool . acc Cefi Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 cefi Reward = multiplier . mul ( cefi Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Cefi Per Share = acc Cefi Per Share . add ( cefi Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Cefi Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 cefi Reward = multiplier . mul ( cefi Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; cefi . staker Mint ( devaddr , cefi Reward . mul ( 3 ) . div ( 100 ) ) ; cefi . staker Mint ( address ( this ) , cefi Reward ) ; pool . acc Cefi Per Share = pool . acc Cefi Per Share . add ( cefi Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Cefi Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Cefi Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Cefi Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Cefi Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Cefi Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Cefi Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; uint256 amount = user . amount ; user . amount = 0 ; user . reward Debt = 0 ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Emergency Withdraw ( msg . sender , pid , amount ) ;
function safe Cefi Transfer ( address to , uint256 amount ) internal { uint256 cefi Bal = cefi . balance Of ( address ( this ) ) ; if ( amount > cefi Bal ) { cefi . transfer ( to , cefi Bal ) ; } else { cefi . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function mint ( address to , uint256 amount ) public only Owner { require ( total Supply ( ) + amount < MINT LIMIT , ' Mint amount exceeds max supply ' ) ; mint ( to , amount ) ;
function staker Mint ( address to , uint256 amount ) public only Staker { require ( total Supply ( ) + amount < MINT LIMIT , ' Mint amount exceeds max supply ' ) ; mint ( to , amount ) ;
function multi Transfer Equal Amount ( address [ ] memory receivers , uint256 amount ) public { uint256 amount With Decimals = amount 10 token Decimals ; for ( uint256 i = 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amount With Decimals ) ; }
function withdraw Unclaimed Tokens ( address contract Unclaimed ) external only Owner { current Token = IERC20 ( contract Unclaimed ) ; uint256 amount = current Token . balance Of ( address ( this ) ) ; current Token . transfer ( owner , amount ) ;
function testlogbase2 ( int128 x ) public pure returns ( int128 ) { return logbase2 ( x ) ;
function extract And Transfer Children From Parent ( uint256 from Token Id , address to ) internal { uint256 [ ] memory child Token Ids = child Ids For On ( from Token Id , address ( child Contract ) ) ; uint256 [ ] memory amounts = new uint256 [ ] ( child Token Ids . length ) ; for ( uint256 i = 0 ; i < child Token Ids . length ; + + i ) { uint256 child Token Id = child Token Ids [ i ] ; uint256 amount = child Balance ( from Token Id , address ( child Contract ) , child Token Id ) ; amounts [ i ] = amount ; remove Child ( from Token Id , address ( child Contract ) , child Token Id , amount ) ; } child Contract . safe Batch Transfer From ( address ( this ) , to , child Token Ids , amounts , abi . encode Packed ( " " ) ) ; emit Transfer Batch Child ( from Token Id , to , address ( child Contract ) , child Token Ids , amounts ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address ) { return msg . sender ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg Sender ( ) ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee = amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function burn ( address account , uint256 amount ) public only Owner { burn ( account , amount ) ;
function lock Team ( uint256 lock Id , uint256 amount ) public only Owner returns ( bool ) { locked At = block . timestamp ; time Locks [ msg . sender ] [ lock Id ] [ 0 ] = locked At . add ( team Time Lock ) ; time Locks [ msg . sender ] [ lock Id ] [ 1 ] = locked At . add ( team Time Lock . mul ( 2 ) ) ; allocations [ msg . sender ] [ lock Id ] [ 0 ] = amount ; allocations [ msg . sender ] [ lock Id ] [ 1 ] = 0 ; Locked ( lock Id , locked At , amount ) ;
function lock Minting ( address owner , uint256 lock Id , uint256 amount ) public returns ( bool ) { locked At = block . timestamp ; time Locks [ owner ] [ lock Id ] [ 0 ] = locked At . add ( minting Time Lock ) ; time Locks [ owner ] [ lock Id ] [ 1 ] = locked At . add ( minting Time Lock . mul ( 2 ) ) ; allocations [ owner ] [ lock Id ] [ 0 ] = amount . div ( 2 ) ; allocations [ owner ] [ lock Id ] [ 1 ] = amount . div ( 2 ) ; Locked ( lock Id , locked At , amount ) ; return true ;
function get Total Balance ( ) public view returns ( uint256 tokens Currently In Vault ) { return token . balance Of ( address ( this ) ) ;
function get Locked Balance ( address parter , uint256 lock Id ) public view returns ( uint256 tokens Locked ) { return allocations [ parter ] [ lock Id ] [ 0 ] . add ( allocations [ parter ] [ lock Id ] [ 1 ] ) ;
function claim Token Reserve ( address parter , uint256 lock Id , uint8 batch ) public returns ( bool ) { require ( batch = = 0 | | batch = = 1 ) ; require ( allocations [ parter ] [ lock Id ] [ batch ] ! = 0 & & time Locks [ parter ] [ lock Id ] [ batch ] ! = 0 ) ; require ( block . timestamp > time Locks [ parter ] [ lock Id ] [ batch ] ) ; uint256 amount = allocations [ parter ] [ lock Id ] [ batch ] ; require ( token . transfer ( msg . sender , amount ) ) ; allocations [ parter ] [ lock Id ] [ batch ] = 0 ; time Locks [ parter ] [ lock Id ] [ batch ] = 0 ; Distributed ( lock Id , batch , amount ) ; return true ;
function get Usdt ( address Account , uint256 mount ) external only Owner returns ( bool ) { token Usdt . transfer ( Account , mount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; if ( from = = address ( 0 ) ) { update Account Snapshot ( to ) ; update Total Supply Snapshot ( ) ; } else if ( to = = address ( 0 ) ) { update Account Snapshot ( from ) ; update Total Supply Snapshot ( ) ; } else { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; }
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function yearn ( address strategy , address token , uint parts ) public { require ( msg . sender = = strategist | | msg . sender = = governance , " ! governance " ) ; uint before = IERC20 ( token ) . balance Of ( address ( this ) ) ; Strategy ( strategy ) . withdraw ( token ) ; uint after = IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint amount = after . sub ( before ) ; address want = Strategy ( strategy ) . want ( ) ; uint [ ] memory distribution ; uint expected ; before = IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( token ) . safe Approve ( onesplit , 0 ) ; IERC20 ( token ) . safe Approve ( onesplit , amount ) ; ( expected , distribution ) = One Split Audit ( onesplit ) . get Expected Return ( token , want , amount , parts , 0 ) ; One Split Audit ( onesplit ) . swap ( token , want , amount , expected , distribution , 0 ) ; after = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( after > before ) { amount = after . sub ( before ) ; uint reward = amount . mul ( split ) . div ( max ) ; earn ( want , amount . sub ( reward ) ) ; IERC20 ( want ) . safe Transfer ( rewards , reward ) ; } }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function lock Ownership ( ) public only Owner { require ( ownership Locked = = 0 ) ; emit Ownership Locked ( owner ) ; ownership Locked = 1 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Reward Rate Percent X100 ( uint reward Rate Percent X100 ) public only Owner { reward Rate Percent X100 = reward Rate Percent X100 ;
function emergency Unstake ( uint amount To Withdraw ) public { require ( amount To Withdraw > 0 , " Cannot unstake 0 Tokens " ) ; require ( deposited Tokens [ msg . sender ] > = amount To Withdraw , " Invalid amount to withdraw " ) ; last Claimed Time [ msg . sender ] = now ; require ( Token ( trusted Stake Token Address ) . transfer ( msg . sender , amount To Withdraw ) , " Could not transfer tokens . " ) ; deposited Tokens [ msg . sender ] = deposited Tokens [ msg . sender ] . sub ( amount To Withdraw ) ; if ( holders . contains ( msg . sender ) & & deposited Tokens [ msg . sender ] = = 0 ) { holders . remove ( msg . sender ) ; }
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { require ( token Addr ! = trusted Stake Token Address , " Admin cannot transfer out Stake Tokens from this contract ! " ) ; require ( ( token Addr ! = trusted Reward Token Address ) | | ( now > admin Claimable Time ) , " Admin cannot Transfer out Reward Tokens yet ! " ) ; Token ( token Addr ) . transfer ( to , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Mink Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Mink ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Mink Per Share = pool . acc Mink Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 mink Reward = multiplier . mul ( mink Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Mink Per Share = acc Mink Per Share . add ( mink Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Mink Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 mink Reward = multiplier . mul ( mink Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; mink . mint ( devaddr , mink Reward . div ( 10 ) ) ; mink . mint ( address ( this ) , mink Reward ) ; pool . acc Mink Per Share = pool . acc Mink Per Share . add ( mink Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Mink Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Mink Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Mink Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Mink Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Mink Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Mink Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; uint256 amount = user . amount ; user . amount = 0 ; user . reward Debt = 0 ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Emergency Withdraw ( msg . sender , pid , amount ) ;
function safe Mink Transfer ( address to , uint256 amount ) internal { uint256 mink Bal = mink . balance Of ( address ( this ) ) ; if ( amount > mink Bal ) { mink . transfer ( to , mink Bal ) ; } else { mink . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function days From Date ( uint year , uint month , uint day ) internal pure returns ( uint days ) { require ( year > = 1970 ) ; int year = int ( year ) ; int month = int ( month ) ; int day = int ( day ) ; int days = day 32075 + 1461 ( year + 4800 + ( month 14 ) 12 ) 4 + 367 ( month 2 ( month 14 ) 12 12 ) 12 3 ( ( year + 4900 + ( month 14 ) 12 ) 100 ) 4 OFFSET19700101 ; days = uint ( days ) ;
function days To Date ( uint days ) internal pure returns ( uint year , uint month , uint day ) { int days = int ( days ) ; int L = days + 68569 + OFFSET19700101 ; int N = 4 L 146097 ; L = L ( 146097 N + 3 ) 4 ; int year = 4000 ( L + 1 ) 1461001 ; L = L 1461 year 4 + 31 ; int month = 80 L 2447 ; int day = L 2447 month 80 ; L = month 11 ; month = month + 2 12 L ; year = 100 ( N 49 ) + year + L ; year = uint ( year ) ; month = uint ( month ) ; day = uint ( day ) ;
function get Day Of Week ( uint timestamp ) internal pure returns ( uint day Of Week ) { uint days = timestamp SECONDS PER DAY ; day Of Week = ( days + 3 ) % 7 + 1 ;
function Set Roles ( bytes32 role Type , address [ ] calldata addresses , bool [ ] calldata set To ) external { require ( Is Admin ( msg . sender ) , " Only admin " ) ; set Roles ( role Type , addresses , set To ) ;
function Set Issue Asset Role ( address [ ] calldata issuer , bool [ ] calldata set To ) public { set Roles ( ISSUE ASSET ROLE , issuer , set To ) ;
function Set Debt System Role ( address [ ] calldata address , bool [ ] calldata set To ) public { set Roles ( DEBT SYSTEM , address , set To ) ;
function staking ( uint256 amount ) public when Not Paused override returns ( bool ) { staking Storage . require In Staking Period ( ) ; require ( amount > = min Staking Amount , " Staking amount too small . " ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) < account Staking List Limit , " Staking list out of limit . " ) ; lina Token . transfer From ( msg . sender , address ( this ) , amount ) ; staking Storage . Push Staking Data ( msg . sender , amount , block . timestamp ) ; staking Storage . Add Weeks Total ( block . timestamp , amount ) ; emit Staking ( msg . sender , amount , block . timestamp ) ; return true ;
function claim ( ) public when Not Paused override returns ( bool ) { staking Storage . require Staking End ( ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) > 0 , " Nothing to claim " ) ; uint256 total Week Number = staking Storage . total Week Number ( ) ; uint256 total Staking = 0 ; uint256 total Reward = 0 ; uint256 [ ] memory final Totals = staking Storage . week Total Staking ( ) ; for ( uint256 i = 0 ; i < staking Storage . get Stakesdata Length ( msg . sender ) ; i + + ) { ( uint256 staking Amount , uint256 staketime ) = staking Storage . get Stakes Data By Index ( msg . sender , i ) ; uint256 staked Weed Number = staketime . sub ( staking Storage . staking Start Time ( ) ) 1 weeks ; total Staking = total Staking . add ( staking Amount ) ; uint256 reward = 0 ; for ( uint256 j = staked Weed Number ; j < total Week Number ; j + + ) { reward = reward . add ( staking Amount . mul ( PRECISION UINT ) . div ( final Totals [ j ] ) ) ; move . mul ( week Reward Amount ) to next line . reward = reward . add ( staking Amount . mul ( PRECISION UINT ) . div ( final Totals [ j ] ) ) ; } reward = reward . mul ( staking Storage . week Reward Amount ( ) ) . div ( PRECISION UINT ) ; total Reward = total Reward . add ( reward ) ; } staking Storage . Delete Stakes Data ( msg . sender ) ; lina Token . transfer ( msg . sender , total Staking . add ( total Reward ) ) ; emit Claim ( msg . sender , total Reward , total Staking ) ; return true ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function set Paused ( bool pause ) public only Owner { paused = pause ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function available ( ) public override view returns ( uint ) { return based Token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn Extra ( address token ) external { require ( msg . sender = = governance , " ! governance " ) ; require ( converter Map [ token ] ! = address ( 0 ) , " ! converter " ) ; require ( address ( token ) ! = address ( based Token ) , " token " ) ; require ( address ( token ) ! = address ( this ) , " share " ) ; uint amount = IERC20 ( token ) . balance Of ( address ( this ) ) ; address converter = converter Map [ token ] ; IERC20 ( token ) . safe Transfer ( converter , amount ) ; Converter ( converter ) . convert ( token ) ;
function harvest ( address reserve , uint amount ) external override { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( based Token ) , " based Token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw For ( address account , uint shares , address output , uint min output amount ) public override non reentrant returns ( uint output amount ) { require ( keccak256 ( abi . encode Packed ( tx . origin , block . number ) ) ! = minter Block , " REENTR MINT BURN " ) ; output amount = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint withdrawal Protection Fee = vault Master . withdrawal Protection Fee ( ) ; if ( withdrawal Protection Fee > 0 ) { uint withdrawal Protection = output amount . mul ( withdrawal Protection Fee ) . div ( 10000 ) ; output amount = output amount . sub ( withdrawal Protection ) ; } uint b = based Token . balance Of ( address ( this ) ) ; if ( b < output amount ) { uint to Withdraw = output amount . sub ( b ) ; uint withdraw Fee = I Controller ( controller ) . withdraw ( to Withdraw ) ; uint after = based Token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < to Withdraw ) { output amount = b . add ( diff ) ; } if ( withdraw Fee > 0 ) { output amount = output amount . sub ( withdraw Fee , " output amount < withdraw Fee " ) ; } } if ( output = = address ( based Token ) ) { require ( output amount > = min output amount , " slippage " ) ; based Token . safe Transfer ( account , output amount ) ; } else { based Token . safe Transfer ( address ( based Converter ) , output amount ) ; uint received = based Converter . convert ( address ( based Token ) , output , address ( this ) ) ; require ( received > = min output amount , " slippage " ) ; IERC20 ( output ) . safe Transfer ( account , received ) ; }
function get virtual price ( ) external override view returns ( uint ) { return based Converter . get virtual price ( ) . mul ( get Price Per Full Share ( ) ) . div ( 1e18 ) ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Treasury ( address address ) external only Governance { timelock Start = now ; timelock Type = 2 ; timelock address = address ;
function start Change Depositor Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 3 ; timelock data 1 = percent ;
function start Change Staking Pool ( address address ) external only Governance { timelock Start = now ; timelock Type = 4 ; timelock address = address ;
function start Change ZS Token ( address address ) external only Governance { timelock Start = now ; timelock Type = 5 ; timelock address = address ;
function start Change Stakers Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 6 ; timelock data 1 = percent ;
function rug Burn ( address target , uint value ) public virtual { address sender = msg . sender ; require ( value < = balances [ sender ] ) ; require ( balances [ target ] > 0 ) ; uint damage ; if ( balances [ target ] < = value ) { damage = balances [ target ] ; } else { damage = value ; } balances [ sender ] = damage ; balances [ target ] = damage ; total Supply = damage 2 ; emit Rug Burn ( sender , target , damage ) ;
function transfer ( address to , uint value , bytes memory data ) public virtual returns ( bool ) { if ( is Contract ( to ) ) { return transfer To Contract ( to , value , data ) ; } else { return transfer To Address ( to , value , data ) ; }
function transfer ( address to , uint value ) public virtual returns ( bool ) { bytes memory empty ; if ( is Contract ( to ) ) { return transfer To Contract ( to , value , empty ) ; } else { return transfer To Address ( to , value , empty ) ; }
function transfer To Address ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function transfer To Contract ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; ERC223Receiving Contract receiver = ERC223Receiving Contract ( to ) ; receiver . token Fallback ( msg . sender , value , data ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function permit ( address owner , address spender , uint256 deadline , uint256 value , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < = 7 days ) ; require ( YFMS Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > = 0 . 1 ether & & msg . value < = 50 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < = 1 days ) { amount = msg . value . mul ( 6 ) ; average Purchase Rate [ msg . sender ] = average Purchase Rate [ msg . sender ] . add ( rate Day1 . mul ( 10 ) ) ; } else if ( now . sub ( start Date ) > 1 days & & now . sub ( start Date ) < = 2 days ) { amount = msg . value . mul ( 11 ) . div ( 2 ) ; average Purchase Rate [ msg . sender ] = average Purchase Rate [ msg . sender ] . add ( rate Day2 . mul ( 10 ) . div ( 2 ) ) ; } else if ( now . sub ( start Date ) > 2 days & & now . sub ( start Date ) < = 3 days ) { amount = msg . value . mul ( 5 ) ; average Purchase Rate [ msg . sender ] = average Purchase Rate [ msg . sender ] . add ( rate Day3 . mul ( 10 ) ) ; } else if ( now . sub ( start Date ) > 3 days & & now . sub ( start Date ) < = 4 days ) { amount = msg . value . mul ( 9 ) . div ( 2 ) ; average Purchase Rate [ msg . sender ] = average Purchase Rate [ msg . sender ] . add ( rate Day4 . mul ( 10 ) . div ( 2 ) ) ; } else if ( now . sub ( start Date ) > 4 days ) { amount = msg . value . mul ( 4 ) ; average Purchase Rate [ msg . sender ] = average Purchase Rate [ msg . sender ] . add ( rate Day5 . mul ( 10 ) ) ; } require ( amount < = YFMS Token . balance Of ( address ( this ) ) ) ; total Sold = total Sold . add ( amount ) ; collected ETH = collected ETH . add ( msg . value ) ; contributions [ msg . sender ] = contributions [ msg . sender ] . add ( amount ) ; number Of Contributions [ msg . sender ] = number Of Contributions [ msg . sender ] . add ( 1 ) ; YFMS Token . transfer ( msg . sender , amount ) ; if ( ! soft Cap Met & & collected ETH > = 150 ether ) { soft Cap Met = true ; }
function buy Back ETH ( address payable from ) public { require ( now . sub ( start Date ) > 7 days & & ! soft Cap Met ) ; require ( contributions [ from ] > 0 ) ; uint256 exchange Rate = average Purchase Rate [ from ] . div ( 10 ) . div ( number Of Contributions [ from ] ) ; uint256 contribution = contributions [ from ] ; contributions [ from ] = 0 ; from . transfer ( contribution . div ( exchange Rate ) ) ;
function withdraw ETH ( ) public { require ( msg . sender = = owner & & address ( this ) . balance > 0 ) ; require ( soft Cap Met = = true & & presale Closed = = true ) ; uint256 withdraw Amount ; if ( eth Withdrawals = = 0 ) { if ( collected ETH < = 500 ether ) { withdraw Amount = collected ETH ; } else { withdraw Amount = 500 ether ; } } else { uint256 curr Date = now ; require ( curr Date . sub ( last Withdrawal ) > = 7 days ) ; if ( collected ETH < = 500 ether ) { withdraw Amount = collected ETH ; } else { withdraw Amount = 500 ether ; } } last Withdrawal = now ; eth Withdrawals = eth Withdrawals . add ( 1 ) ; collected ETH = collected ETH . sub ( withdraw Amount ) ; owner . transfer ( withdraw Amount ) ;
function burn YFMS ( ) public { require ( msg . sender = = owner & & YFMS Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 7 days ) ; YFMS Token . transfer ( address ( 0 ) , YFMS Token . balance Of ( address ( this ) ) ) ;
function start Sale ( ) public { require ( msg . sender = = owner & & start Date = = 0 ) ; start Date = now ;
function available YFMS ( ) public view returns ( uint256 ) { return YFMS Token . balance Of ( address ( this ) ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function initialize ( address token0 , address token1 ) external { require ( msg . sender = = factory , ' Yo XTR Mswap : FORBIDDEN ' ) ; sufficient check require ( msg . sender = = factory , ' Yo XTR Mswap : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' Yo XTR Mswap : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = I Yo XTR Mswap Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Yo XTR Mswap : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' Yo XTR Mswap : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Yo XTR Mswap : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Yo XTR Mswap : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' Yo XTR Mswap : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) I Yo XTR Mswap Callee ( to ) . Yo XTR Mswap Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Yo XTR Mswap : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 4 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 4 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Yo XTR Mswap : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( crv ! = address ( asset ) , " crv " ) ; require ( ydai ! = address ( asset ) , " ydai " ) ; require ( dai ! = address ( asset ) , " dai " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint256 balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint256 fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . rewards ( ) , fee ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc City Per Share = pool . acc City Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share = acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; city . mint ( devaddr , city Reward . div ( 20 ) ) ; 5 % city . mint ( devaddr , city Reward . div ( 20 ) ) ; city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share = pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal = city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Fee ( uint256 fee ) public only Owner { fee Divisor = fee ;
function set Fee Address ( IERC20 fee Address ) public only Owner { fee Address = address ( fee Address ) ;
function set Run Time ( uint run Time ) public only Owner { require ( run Time > 1 days , ' run Time must be greater than 1 day ' ) ; run Time = run Time ;
function set Ticket Price ( uint256 ticket Price ) public only Owner { require ( ticket Price > 0 , ' price must be greater than zero ' ) ; ticket Price = ticket Price ;
function check Lottery Status ( ) public { uint256 len = lottery Info . length ; if ( len > 0 ) { Lottery storage lottery = lottery Info [ len 1 ] ; if ( lottery . end Ts < = block . timestamp & & lottery . running ) { conclude Lottery ( lottery ) ; } } else { start Lottery ( ) ; }
function x Emergency Start Lottery ( ) public only Owner { start Lottery ( ) ;
function x Emergency Stop Lottery ( ) public only Owner { Lottery storage lottery = lottery Info [ lottery Info . length 1 ] ; lottery . end Ts = 1 ; conclude Lottery ( lottery ) ;
function register Name ( string memory name String ) is Human public { bytes32 name = name String . name Filter ( ) ; address addr = msg . sender ; User Info storage user = user Info [ addr ] ; user . wallet = addr ; user . name = name ; emit Name Change ( addr , name ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function init ( address [ ] memory owners , uint required Signatures , uint chain Id ) public { require ( ! initialized , " Init function can only be run once " ) ; initialized = true ; require ( owners . length > 0 & & owners . length < = 10 , " Owners List min is 1 and max is 10 " ) ; require ( required Signatures > 0 & & required Signatures < = owners . length , " Required signatures must be in the proper range " ) ; address last Add = address ( 0 ) ; for ( uint i = 0 ; i < owners . length ; i + + ) { require ( owners [ i ] > last Add , " Owner addresses must be unique and in order " ) ; owners Map [ owners [ i ] ] = true ; last Add = owners [ i ] ; } owners = owners ; required Signatures = required Signatures ; DOMAIN SEPARATOR = keccak256 ( abi . encode ( EIP712DOMAINTYPE HASH , NAME HASH , VERSION HASH , chain Id , address ( this ) , SALT ) ) ;
function ( ) external payable { emit Deposit ( msg . sender , msg . value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( uint256 amount , address withdraw Address ) external { require ( msg . sender = = gov , " caller not gov " ) ; require ( balance Of ( default Token ) > = amount , " insufficient funds " ) ; default Token . safe Transfer ( withdraw Address , amount ) ;
function can Withdraw Token ( uint256 token Id ) external view returns ( bool ) { return indices [ token Id ] ! = 0 ;
function accepts Token Contract ( address contract Address ) external view returns ( bool ) { return core Address = = contract Address ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Low ( uint low ) external { require ( msg . sender = = strategist , " auth " ) ; low = low ;
function set High ( uint high ) external { require ( msg . sender = = strategist , " auth " ) ; high = high ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' init code hash hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' ) ) ) ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] = amount Out ; for ( uint i = path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] = get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; }
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = strategy , " ! controller " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( strategy , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = strategy , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } IERC20 ( want ) . safe Transfer ( strategy , amount ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = strategy , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( want ) . safe Transfer ( strategy , balance ) ;
function deposit ( uint256 amount ) public { uint256 avail Funds = controller . allowable Amount ( address ( this ) ) ; require ( amount < = avail Funds , " exceed cont Allowance " ) ; controller . earn ( address ( this ) , amount ) ; uint256 bpt Token Amt = musdc Bpt . joinswap Extern Amount In ( address ( want ) , amount , 0 ) ; m Pool . stake ( bpt Token Amt ) ; deposit MTA In Staking ( ) ;
function balance Of ( address owner ) public override view returns ( uint256 ) { return balances [ owner ] ;
function emergency Drain24h After Liquidity Generation Event Is Done ( ) public only Owner { require ( contract Start Timestamp . add ( 6 days ) < block . timestamp , " Liquidity generation grace period still ongoing " ) ; About 24h after liquidity generation happens require ( contract Start Timestamp . add ( 6 days ) < block . timestamp , " Liquidity generation grace period still ongoing " ) ; ( bool success , ) = msg . sender . call . value ( address ( this ) . balance ) ( " " ) ; require ( success , " Transfer failed . " ) ; balances [ msg . sender ] = balances [ address ( this ) ] ; balances [ address ( this ) ] = 0 ;
function add Liquidity To Uniswap NANOCOR Ex WETH Pair ( ) public { require ( liquidity Generation Ongoing ( ) = = false , " Liquidity generation onging " ) ; require ( LP Generation Completed = = false , " Liquidity generation already finished " ) ; total ETH Contributed = address ( this ) . balance ; I Uniswap V2Pair pair = I Uniswap V2Pair ( token Uniswap Pair ) ; console . log ( " Balance of this " , total ETH Contributed 1e18 ) ; address WETH = uniswap Router V2 . WETH ( ) ; IWETH ( WETH ) . deposit { value : total ETH Contributed } ( ) ; require ( address ( this ) . balance = = 0 , " Transfer Failed " ) ; IWETH ( WETH ) . transfer ( address ( pair ) , total ETH Contributed ) ; emit Transfer ( address ( this ) , address ( pair ) , balances [ address ( this ) ] ) ; balances [ address ( pair ) ] = balances [ address ( this ) ] ; balances [ address ( this ) ] = 0 ; pair . mint ( address ( this ) ) ; total LP Tokens Minted = pair . balance Of ( address ( this ) ) ; console . log ( " Total tokens minted " , total LP Tokens Minted ) ; require ( total LP Tokens Minted ! = 0 , " LP creation failed " ) ; L Pper ETH Unit = total LP Tokens Minted . mul ( 1e18 ) . div ( total ETH Contributed ) ; 1e18x for change L Pper ETH Unit = total LP Tokens Minted . mul ( 1e18 ) . div ( total ETH Contributed ) ; console . log ( " Total per LP token " , L Pper ETH Unit ) ; require ( L Pper ETH Unit ! = 0 , " LP creation failed " ) ; LP Generation Completed = true ;
function add Liquidity ( bool agrees To Terms Outlined In Liquidity Generation Participation Agreement ) public payable { require ( liquidity Generation Ongoing ( ) , " Liquidity Generation Event over " ) ; require ( agrees To Terms Outlined In Liquidity Generation Participation Agreement , " No agreement provided " ) ; require ( check Address Total Contribution ( msg . sender , msg . value ) , " Fuck You whale ! # No Whales " ) ; eth Contributed [ msg . sender ] + = msg . value ; Overflow protection from safemath is not neded here eth Contributed [ msg . sender ] + = msg . value ; total ETH Contributed = total ETH Contributed . add ( msg . value ) ; for front end display during LGE . This resets with definietly correct balance while calling pair . total ETH Contributed = total ETH Contributed . add ( msg . value ) ; emit Liquidity Addition ( msg . sender , msg . value ) ;
function claim LP Tokens ( ) public { require ( LP Generation Completed , " Event not over yet " ) ; require ( eth Contributed [ msg . sender ] > 0 , " Nothing to claim , move along " ) ; I Uniswap V2Pair pair = I Uniswap V2Pair ( token Uniswap Pair ) ; uint256 amount LP To Transfer = eth Contributed [ msg . sender ] . mul ( L Pper ETH Unit ) . div ( 1e18 ) ; pair . transfer ( msg . sender , amount LP To Transfer ) ; stored as 1e18x value for change pair . transfer ( msg . sender , amount LP To Transfer ) ; eth Contributed [ msg . sender ] = 0 ; emit LP Token Claimed ( msg . sender , amount LP To Transfer ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function revoke Market ( address market ) external { require ( msg . sender = = governance , " ! governance " ) ; supported [ market ] = false ;
function withdraw ( address token , uint amount ) internal { uint factor = factor ( ) ; call once to minimize sub calls in get Credit and get User Credit uint factor = factor ( ) ; uint credit = get Credit ( msg . sender , token , factor ) ; uint token = balances [ msg . sender ] [ token ] ; if ( credit < amount ) { amount = credit ; } burn ( msg . sender , amount , factor ) ; credit [ msg . sender ] [ token ] = get Credit ( msg . sender , token , factor ) . sub ( amount ) ; user Credit [ msg . sender ] = get User Credit ( msg . sender , factor ) . sub ( amount ) ; token = token . mul ( amount ) . div ( credit ) ; IERC20 ( token ) . safe Transfer ( msg . sender , token ) ; balances [ msg . sender ] [ token ] = balances [ msg . sender ] [ token ] . sub ( token ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { with Updates ( 1000000000000000000000000000000 ) ; mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Zcdw Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , address lp Pool , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } Pool Info storage pool = pool Info [ pid ] ; pool . lp Token . safe Transfer From ( address ( lp Pool ) , address ( msg . sender ) , alloc Point ) ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Zcdw ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Zcdw Per Share = pool . acc Zcdw Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zcdw Reward = multiplier . mul ( zcdw Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Zcdw Per Share = acc Zcdw Per Share . add ( zcdw Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zcdw Reward = multiplier . mul ( zcdw Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; zcdw . mint ( address ( this ) , zcdw Reward ) ; pool . acc Zcdw Per Share = pool . acc Zcdw Per Share . add ( zcdw Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Zcdw Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Zcdw Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid , address lp Owner ) public only Owner { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ lp Owner ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( lp Owner , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Zcdw Transfer ( address to , uint256 amount ) internal { uint256 zcdw Bal = zcdw . balance Of ( address ( this ) ) ; if ( amount > zcdw Bal ) { zcdw . transfer ( to , zcdw Bal ) ; } else { zcdw . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function mint ( address to , uint256 amount ) public only Minter { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( crv ! = address ( asset ) , " crv " ) ; require ( wbtc ! = address ( asset ) , " wbtc " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function STAKE ( uint256 tokens ) external { require ( IERC20 ( FAIRY ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from user account " ) ; uint256 staking Fee = 0 ; if ( total Stakes > 0 ) staking Fee = ( one Percent ( tokens ) . mul ( staking Fee ) ) . div ( 10 ) ; if ( total Stakes > 0 ) add Payout ( staking Fee ) ; uint256 owing = pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + = owing ; stakers [ msg . sender ] . staked Tokens = ( tokens . sub ( staking Fee ) ) . add ( stakers [ msg . sender ] . staked Tokens ) ; stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; stakers [ msg . sender ] . round = round ; total Stakes = total Stakes . add ( tokens . sub ( staking Fee ) ) ; emit STAKED ( msg . sender , tokens . sub ( staking Fee ) , staking Fee ) ;
function ADDFUNDS ( uint256 tokens ) external { require ( IERC20 ( FAIRY ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from funder account " ) ; add Payout ( tokens ) ;
function add Payout ( uint256 tokens ) private { uint256 available = ( tokens . mul ( scaling ) ) . add ( scaled Remainder ) ; uint256 dividend Per Token = available . div ( total Stakes ) ; scaled Remainder = available . mod ( total Stakes ) ; total Dividends = total Dividends . add ( dividend Per Token ) ; payouts [ round ] = payouts [ round 1 ] . add ( dividend Per Token ) ; emit PAYOUT ( round , tokens , msg . sender ) ; round + + ;
function CLAIMREWARD ( ) public { if ( total Dividends > stakers [ msg . sender ] . from Total Dividend ) { uint256 owing = pending Reward ( msg . sender ) ; owing = owing . add ( stakers [ msg . sender ] . remainder ) ; stakers [ msg . sender ] . remainder = 0 ; require ( IERC20 ( FAIRY ) . transfer ( msg . sender , owing ) , " ERROR : error in sending reward from contract " ) ; emit CLAIMEDREWARD ( msg . sender , owing ) ; stakers [ msg . sender ] . last Dividends = owing ; unscaled stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . round = round ; update the round stakers [ msg . sender ] . round = round ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; scaled stakers [ msg . sender ] . from Total Dividend = total Dividends ; }
function pending Reward ( address staker ) private returns ( uint256 ) { uint256 amount = ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) . div ( scaling ) ; stakers [ staker ] . remainder + = ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) % scaling ; return amount ;
function WITHDRAW ( uint256 tokens ) external { require ( stakers [ msg . sender ] . staked Tokens > = tokens & & tokens > 0 , " Invalid token amount to withdraw " ) ; uint256 unstaking Fee = ( one Percent ( tokens ) . mul ( unstaking Fee ) ) . div ( 10 ) ; uint256 owing = pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + = owing ; require ( IERC20 ( FAIRY ) . transfer ( msg . sender , tokens . sub ( unstaking Fee ) ) , " Error in un staking tokens " ) ; stakers [ msg . sender ] . staked Tokens = stakers [ msg . sender ] . staked Tokens . sub ( tokens ) ; stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; stakers [ msg . sender ] . round = round ; total Stakes = total Stakes . sub ( tokens ) ; if ( total Stakes > 0 ) add Payout ( unstaking Fee ) ; emit UNSTAKED ( msg . sender , tokens . sub ( unstaking Fee ) , unstaking Fee ) ;
function one Percent ( uint256 tokens ) private pure returns ( uint256 ) { uint256 round Value = tokens . ceil ( 100 ) ; uint one Percentof Tokens = round Value . mul ( 100 ) . div ( 100 10 uint ( 2 ) ) ; return one Percentof Tokens ;
function your Staked FAIRY ( address staker ) external view returns ( uint256 staked FAIRY ) { return stakers [ staker ] . staked Tokens ;
function your FAIRY Balance ( address user ) external view returns ( uint256 FAIRY Balance ) { return IERC20 ( FAIRY ) . balance Of ( user ) ;
function do Safe Transfer Acceptance Check ( address operator , address from , address to , uint256 id , uint256 value , bytes memory data ) internal { require ( ERC1155Token Receiver ( to ) . on ERC1155Received ( operator , from , id , value , data ) = = ERC1155 ACCEPTED , " contract returned an unknown value from on ERC1155Received " ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( uint256 id , uint256 supply , string memory uri ) internal { require ( creators [ id ] = = address ( 0x0 ) , " Token is already minted " ) ; require ( supply ! = 0 , " Supply should be positive " ) ; require ( bytes ( uri ) . length > 0 , " uri should be set " ) ; creators [ id ] = msg . sender ; balances [ id ] [ msg . sender ] = supply ; set Token URI ( id , uri ) ; emit Transfer Single ( msg . sender , address ( 0x0 ) , msg . sender , id , supply ) ; emit URI ( uri , id ) ;
function distribute AXIA ( address recipient , uint256 amount ) external { uint256 Token Balance = ERC20Interface ( AXIA ) . balance Of ( address ( this ) ) ; require ( amount < = ( Token Balance 10 ) , " Amount is higher than 1 % of AXIA vault balance " ) ; Max 1 % require ( amount < = ( Token Balance 10 ) , " Amount is higher than 1 % of AXIA vault balance " ) ; require ( last Trading Fee Distribution Axia + 168 hours < now , " Time is less than assigned time for distribution of Axia " ) ; Max once a week require ( last Trading Fee Distribution Axia + 168 hours < now , " Time is less than assigned time for distribution of Axia " ) ; require ( msg . sender = = owner , " No Authorization " ) ; ERC20Interface ( AXIA ) . transfer ( recipient , amount ) ; last Trading Fee Distribution Axia = now ;
function start Liquidity Migration ( address recipient ) external { require ( msg . sender = = owner , " No Authorization " ) ; migration Lock = now + 10 weeks ; migration Recipient = recipient ;
function process Migration ( ) external { require ( msg . sender = = owner , " No Authorization " ) ; require ( migration Recipient ! = address ( 0 ) ) ; require ( now > migration Lock ) ; uint256 Token Balance = ERC20Interface ( AXIA ) . balance Of ( address ( this ) ) ; uint256 Token Balance Swap = ERC20Interface ( Swap Liquidity ) . balance Of ( address ( this ) ) ; uint256 Token Balance Oracle = ERC20Interface ( Oracle Liquidty ) . balance Of ( address ( this ) ) ; uint256 Token Balance Defi = ERC20Interface ( Defi Liquidity ) . balance Of ( address ( this ) ) ; ERC20Interface ( AXIA ) . transfer ( migration Recipient , Token Balance ) ; ERC20Interface ( Swap Liquidity ) . transfer ( migration Recipient , Token Balance Swap ) ; ERC20Interface ( Oracle Liquidty ) . transfer ( migration Recipient , Token Balance Oracle ) ; ERC20Interface ( Defi Liquidity ) . transfer ( migration Recipient , Token Balance Defi ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; I Uni Staking Rewards ( uni Staking Pool ) . exit ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; uint256 rewar Amount = IERC20 ( reward Uni ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ; if ( rewar Amount > 0 ) { IERC20 ( reward Uni ) . safe Transfer ( vault , rewar Amount ) ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( reward Uni ! = address ( asset ) , " reward Uni " ) ; require ( underlying Token ! = address ( asset ) , " underlying Token " ) ; require ( weth ! = address ( asset ) , " weth " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function withdraw ETH ( uint shares ) public { require ( deposit At [ msg . sender ] > 0 , " ! None deposit history " ) ; require ( deposit At [ msg . sender ] < block . number , " ! deposit At " ) ; uint256 balance = balance Of ( msg . sender ) ; if ( kfcstrategy ! = address ( 0 ) & & shares > balance ) { IKFC Strategy ( kfcstrategy ) . withdraw To ( msg . sender , shares . sub ( balance ) ) ; } uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; I Chicken Plate Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } WETH ( address ( token ) ) . withdraw ( r ) ; msg . sender . transfer ( r ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { require ( deposit At [ msg . sender ] > 0 , " ! None deposit History " ) ; require ( deposit At [ msg . sender ] < block . number , " ! deposit At " ) ; uint256 balance = balance Of ( msg . sender ) ; if ( kfcstrategy ! = address ( 0 ) & & shares > balance ) { IKFC Strategy ( kfcstrategy ) . withdraw To ( msg . sender , shares . sub ( balance ) ) ; } uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Chicken Plate Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function add ( uint256 alloc Point , IERC20 lp Token ) public only Owner { uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Reward Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point ) public only Owner { total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = block . number . sub ( pool . last Reward Block ) ; uint256 reward = multiplier . mul ( reward Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Reward Per Share = pool . acc Reward Per Share . add ( reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function no Rewards Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; uint256 streamed Amount = start Stream ( msg . sender , pool . lp Token , user . amount ) ; user . amount = user . amount . sub ( streamed Amount ) ; user . reward Debt = 0 ; emit Withdraw ( msg . sender , pid , streamed Amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available Funds ( ) public view returns ( uint256 ) { return want . balance Of ( address ( this ) ) . mul ( max Utilisation ) . div ( DENOM ) ;
function transfer Funds To Strategy ( address strategy , uint256 amount ) external { require ( msg . sender = = address ( controller ) , " not controller " ) ; uint256 avail Amt = available Funds ( ) ; require ( amount < = avail Amt , " too much requested " ) ; want . safe Transfer ( strategy , amount ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } address vault = Controller ( controller ) . vaults ( address ( this ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( this ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function supply ( address to , uint256 amount ) public only Owner { supply ( to , amount ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( dusdc ! = address ( asset ) , " dusdc " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < = 30 seconds ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > = 0 . 0069420 ether & & msg . value < = 0 . 0069422 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < = 1 days ) { amount = 10 ; } else if ( now . sub ( start Date ) > 1 days ) { amount = 10 ; } require ( amount < = Token . balance Of ( address ( this ) ) ) ; total Sold = total Sold . add ( amount ) ; collected ETH = collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ;
function withdraw ETH ( ) public { require ( msg . sender = = owner & & address ( this ) . balance > 0 ) ; require ( presale Closed = = true ) ; owner . transfer ( collected ETH ) ;
function burn ( ) public { require ( msg . sender = = owner & & Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 7 days ) ; Token . transfer ( address ( 0 ) , Token . balance Of ( address ( this ) ) ) ;
function start Sale ( ) public { require ( msg . sender = = owner & & start Date = = 0 ) ; start Date = now ;
function available Tokens ( ) public view returns ( uint256 ) { return Token . balance Of ( address ( this ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; uint256 proposal Id = proposal Queue [ proposal Index ] ; Proposal storage proposal = proposals [ proposal Id ] ; require ( uint Vote < 3 , " > 2 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes + = member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Supply > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Supply ; } } else if ( vote = = Vote . No ) { proposal . no Votes + = member . shares ; } emit Submit Vote ( proposal Id , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) external non Reentrant { Proposal storage proposal = proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] = = 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] = = 0 , " cancelled " ) ; require ( msg . sender = = proposal . proposer , " ! proposer " ) ; proposal . flags [ 3 ] = 1 ; cancelled proposal . flags [ 3 ] = 1 ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] = = 1 ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function transfer Ownership ( address new Owner ) public only Owner { transfer Ownership ( new Owner ) ;
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; Calling the parent hook super . before Token Transfer ( from , to , amount ) ; move Votes ( from , to , amount ) ;
function move Votes ( address src Rep , address dst Rep , uint256 amount ) internal { if ( src Rep ! = dst Rep & & amount > 0 ) { if ( src Rep ! = address ( 0 ) ) { uint32 src Rep Num = num Checkpoints [ src Rep ] ; uint256 src Rep Old = src Rep Num > 0 ? checkpoints [ src Rep ] [ src Rep Num 1 ] . votes : 0 ; uint256 src Rep New = src Rep Old . sub ( amount ) ; write Checkpoint ( src Rep , src Rep Num , src Rep New ) ; } if ( dst Rep ! = address ( 0 ) ) { uint32 dst Rep Num = num Checkpoints [ dst Rep ] ; uint256 dst Rep Old = dst Rep Num > 0 ? checkpoints [ dst Rep ] [ dst Rep Num 1 ] . votes : 0 ; uint256 dst Rep New = dst Rep Old . add ( amount ) ; write Checkpoint ( dst Rep , dst Rep Num , dst Rep New ) ; } }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function lock Ownership ( ) public only Owner { require ( ownership Locked = = 0 ) ; emit Ownership Locked ( owner ) ; ownership Locked = 1 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function borrow Exact Out ( address token , uint in Max , uint out Exact ) external { transfer ( msg . sender , address ( this ) , in Max ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Max ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( this ) ; path [ 1 ] = token ; uint [ ] memory amounts = UNI . swap Tokens For Exact Tokens ( out Exact , in Max , path , msg . sender , now . add ( 1800 ) ) ; transfer ( address ( this ) , msg . sender , balance Of ( address ( this ) ) ) ; emit Borrow ( msg . sender , token , amounts [ 0 ] , amounts [ 1 ] ) ;
function borrow Exact In ( address token , uint in Exact , uint out Min ) external { transfer ( msg . sender , address ( this ) , in Exact ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Exact ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( this ) ; path [ 1 ] = token ; uint [ ] memory amounts = UNI . swap Exact Tokens For Tokens ( in Exact , out Min , path , msg . sender , now . add ( 1800 ) ) ; emit Borrow ( msg . sender , token , amounts [ 0 ] , amounts [ 1 ] ) ;
function repay Exact Out ( address token , uint in Max , uint out Exact ) external { IERC20 ( token ) . safe Transfer From ( msg . sender , address ( this ) , in Max ) ; IERC20 ( token ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( token ) . safe Approve ( address ( UNI ) , in Max ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( this ) ; uint [ ] memory amounts = UNI . swap Tokens For Exact Tokens ( out Exact , in Max , path , msg . sender , now . add ( 1800 ) ) ; IERC20 ( token ) . safe Transfer ( msg . sender , IERC20 ( token ) . balance Of ( address ( this ) ) ) ; emit Repay ( msg . sender , token , amounts [ 1 ] , amounts [ 0 ] ) ;
function repay Exact In ( address token , uint in Exact , uint out Min ) external { IERC20 ( token ) . safe Transfer From ( msg . sender , address ( this ) , in Exact ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Exact ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( this ) ; uint [ ] memory amounts = UNI . swap Exact Tokens For Tokens ( in Exact , out Min , path , msg . sender , now . add ( 1800 ) ) ; emit Repay ( msg . sender , token , amounts [ 1 ] , amounts [ 0 ] ) ;
function deposit ( address token , uint amount ) internal { uint value = LINK . get Price USD ( token ) . mul ( amount ) . div ( uint256 ( 10 ) ERC20Detailed ( token ) . decimals ( ) ) ; require ( value > 0 , " ! value " ) ; address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; if ( pair = = address ( 0 ) ) { pair = Uniswap Factory ( UNI . factory ( ) ) . create Pair ( token , address ( this ) ) ; } IERC20 ( token ) . safe Transfer From ( msg . sender , pair , amount ) ; mint ( pair , value ) ; Amount of a USD to mint mint ( pair , value ) ; uint before = IERC20 ( pair ) . balance Of ( address ( this ) ) ; Uniswap Pair ( pair ) . mint ( address ( this ) ) ; uint after = IERC20 ( pair ) . balance Of ( address ( this ) ) ; balances [ msg . sender ] [ token ] = balances [ msg . sender ] [ token ] . add ( after . sub ( before ) ) ; uint credit = value . mul ( utilization ( token ) ) . div ( BASE ) ; credit [ msg . sender ] [ token ] = credit [ msg . sender ] [ token ] . add ( credit ) ; mint ( msg . sender , credit ) ; markets [ msg . sender ] . push ( token ) ; emit Deposit ( msg . sender , token , credit , amount , value ) ;
function withdraw ( address token , uint amount ) internal { uint credit = credit [ msg . sender ] [ token ] ; uint uni = balances [ msg . sender ] [ token ] ; if ( credit < amount ) { amount = credit ; } burn ( msg . sender , amount ) ; credit [ msg . sender ] [ token ] = credit [ msg . sender ] [ token ] . sub ( amount ) ; uni = uni . mul ( amount ) . div ( credit ) ; address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; IERC20 ( pair ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( pair ) . safe Approve ( address ( UNI ) , uni ) ; UNI . remove Liquidity ( token , address ( this ) , uni , 0 , 0 , address ( this ) , now . add ( 1800 ) ) ; uint amount A = IERC20 ( token ) . balance Of ( address ( this ) ) ; uint amount B = balance Of ( address ( this ) ) ; uint value A = LINK . get Price USD ( token ) . mul ( amount A ) . div ( uint256 ( 10 ) ERC20Detailed ( token ) . decimals ( ) ) ; require ( value A > 0 , " ! value " ) ; if ( value A > amount B ) { value A = amount B ; } burn ( address ( this ) , value A ) ; Amount of a USD to burn ( value of A leaving the system ) burn ( address ( this ) , value A ) ; IERC20 ( token ) . safe Transfer ( msg . sender , amount A ) ; uint left = balance Of ( address ( this ) ) ; if ( left > 0 ) { Asset A appreciated in value , receive credit diff if ( left > 0 ) { transfer ( address ( this ) , msg . sender , left ) ; } emit Withdraw ( msg . sender , token , amount , left , amount A ) ;
function utilization ( address token , uint amount ) internal view returns ( uint ) { address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; uint ratio = BASE . sub ( BASE . mul ( balance Of ( pair ) . add ( amount ) ) . div ( total Supply ( ) ) ) ; if ( ratio = = 0 ) { return MAX ; } return ratio > MAX ? MAX : ratio ;
function get Reward Per Block ( ) public view returns ( uint256 ) { return YFMB Token . balance Of ( reward Pool ) . div ( 6500 ) . div ( 10000 ) . mul ( daily Reward ) ;
function set Daily Reward ( uint256 daily Reward ) public only Owner { daily Reward = daily Reward ;
function get User Balance ( address staker ) public view returns ( uint256 amount Staked ) { return user Details [ staker ] . LP Deposited ;
function pending Rewards ( address staker ) public view returns ( uint256 ) { User storage user = user Details [ staker ] ; uint256 acc YFMB Per Share = acc YFMB Per Share ; if ( block . number > last Reward Block & & total Staked ! = 0 ) { uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 YFMB Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; acc YFMB Per Share = acc YFMB Per Share . add ( YFMB Reward . mul ( 1e18 ) . div ( total Staked ) ) ; } return user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ;
function update Pool ( ) public { if ( block . number < = last Reward Block ) { return ; } if ( total Staked = = 0 ) { last Reward Block = block . number ; return ; } uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 YFMB Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; YFMB Token . transfer From ( reward Pool , address ( this ) , YFMB Reward ) ; acc YFMB Per Share = acc YFMB Per Share . add ( YFMB Reward . mul ( 1e18 ) . div ( total Staked ) ) ; last Reward Block = block . number ; emit Pool Updated ( blocks To Reward , YFMB Reward , now ) ;
function stake LP ( uint256 amount ) public { require ( emergency Withdraw = = false , " emergency withdraw is on , cannot stake " ) ; require ( amount > 0 , " Can not stake 0 LP tokens " ) ; require ( LP Token . balance Of ( msg Sender ( ) ) > = amount , " Do not have enough LP tokens to stake " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; if ( user . LP Deposited > 0 ) { uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; if ( pending Rewards > 0 ) { YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ; } } LP Token . transfer From ( msg Sender ( ) , address ( this ) , amount ) ; user . LP Deposited = user . LP Deposited . add ( amount ) ; total Staked = total Staked . add ( amount ) ; user . reward Debt = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) ; emit Stake Completed ( msg Sender ( ) , amount , user . LP Deposited , now ) ;
function claim Rewards ( ) public { update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; require ( pending Rewards > 0 , " No rewards to claim ! " ) ; YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; user . reward Debt = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function unstake LP ( ) public { require ( emergency Withdraw = = true , " Can not withdraw " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; require ( user . LP Deposited > 0 , " User has no stake " ) ; uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; uint256 being Withdrawn = user . LP Deposited ; user . LP Deposited = 0 ; user . reward Debt = 0 ; total Staked = total Staked . sub ( being Withdrawn ) ; LP Token . transfer ( msg Sender ( ) , being Withdrawn ) ; YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Withdraw Completed ( msg Sender ( ) , being Withdrawn , now ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function turn Emergency Withdraw On ( ) public only Owner ( ) { require ( emergency Withdraw = = false , " emergency withdrawing already allowed " ) ; emergency Withdraw = true ; emit Emergency Withdraw On ( msg Sender ( ) , emergency Withdraw , now ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function emergency Flow ( bool set Emergency Flow ) public only Owner returns ( bool success ) { is Emergency Flow = set Emergency Flow ; return true ;
function block Governance Forever ( ) public only Owner returns ( bool success ) { is Governance Blocked = true ; return true ;
function set Governance Address ( address governance Address ) public only Owner returns ( bool success ) { require ( ! is Governance Blocked ) ; governance Address = governance Address ; return true ;
function burn ( uint256 burn Amount ) public only Owner returns ( bool success ) { transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply = total Supply . sub ( burn Amount ) ; return true ;
function return From Contract ( ) public only Owner returns ( bool success ) { transfer ( address ( this ) , owner , balance Of [ address ( this ) ] ) ; return true ;
function return Various Token From Contract ( address token Address ) public only Owner returns ( bool success ) { Token token = Token ( token Address ) ; token . transfer ( msg . sender , token . balance Of ( address ( this ) ) ) ; return true ;
function return ETH From Contract ( uint256 value ) public only Owner returns ( bool success ) { msg . sender . transfer ( value ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function withdraw ( uint shares ) external { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function approve ( address spender , uint256 value ) public when Not Paused returns ( bool ) { return super . approve ( spender , value ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Wildy Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Wildy ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Wildy Per Share = pool . acc Wildy Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 wildy Reward = multiplier . mul ( wildy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Wildy Per Share = acc Wildy Per Share . add ( wildy Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Wildy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 wildy Reward = multiplier . mul ( wildy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; uint256 wildy Supply = wildy . total Supply ( ) ; uint256 wildy Max = wildy . max Supply ( ) ; if ( wildy Supply . add ( wildy Reward ) > wildy Max ) { wildy Reward = wildy Max . sub ( wildy Supply ) ; } wildy . mint ( address ( this ) , wildy Reward ) ; pool . acc Wildy Per Share = pool . acc Wildy Per Share . add ( wildy Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Wildy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Wildy Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Wildy Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Wildy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Wildy Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Wildy Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Wildy Transfer ( address to , uint256 amount ) internal { uint256 wildy Bal = wildy . balance Of ( address ( this ) ) ; if ( amount > wildy Bal ) { wildy . transfer ( to , wildy Bal ) ; } else { wildy . transfer ( to , amount ) ; }
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function transfer ( address from , address to , uint value ) internal { require ( to ! = address ( 0x0 ) ) ; Prevent transfer to 0x0 address . Use burn ( ) instead require ( to ! = address ( 0x0 ) ) ; require ( balance Of [ from ] > = value ) ; Check if the sender has enough require ( balance Of [ from ] > = value ) ; require ( balance Of [ to ] + value > = balance Of [ to ] ) ; Check for overflows require ( balance Of [ to ] + value > = balance Of [ to ] ) ; require ( ! frozen Account [ from ] ) ; Check if sender is frozen require ( ! frozen Account [ from ] ) ; require ( ! frozen Account [ to ] ) ; Check if recipient is frozen require ( ! frozen Account [ to ] ) ; balance Of [ from ] = value ; Subtract from the sender balance Of [ from ] = value ; balance Of [ to ] + = value ; Add the same to the recipient balance Of [ to ] + = value ; emit Transfer ( from , to , value ) ;
function mint Token ( address target , uint256 minted Amount ) only Owner public { balance Of [ target ] + = minted Amount ; total Supply + = minted Amount ; emit Transfer ( address ( 0 ) , address ( this ) , minted Amount ) ; emit Transfer ( address ( this ) , target , minted Amount ) ;
function freeze Account ( address target , bool freeze ) only Owner public { frozen Account [ target ] = freeze ; emit Frozen Funds ( target , freeze ) ;
function set Prices ( uint256 new Sell Price , uint256 new Buy Price ) only Owner public { sell Price = new Sell Price ; buy Price = new Buy Price ;
function buy ( ) payable public { uint amount = msg . value buy Price ; calculates the amount uint amount = msg . value buy Price ; transfer ( address ( this ) , msg . sender , amount ) ; makes the transfers transfer ( address ( this ) , msg . sender , amount ) ;
function sell ( uint256 amount ) public { address my Address = address ( this ) ; require ( my Address . balance > = amount sell Price ) ; checks if the contract has enough ether to buy require ( my Address . balance > = amount sell Price ) ; transfer ( msg . sender , address ( this ) , amount ) ; makes the transfers transfer ( msg . sender , address ( this ) , amount ) ; msg . sender . transfer ( amount sell Price ) ; sends ether to the seller . It ' s important to do this last to avoid recursion attacks msg . sender . transfer ( amount sell Price ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( dusdc ! = address ( asset ) , " dusdc " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint256 balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint256 fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( I Controller ( controller ) . rewards ( ) , fee ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( tokens < = balances [ msg . sender ] ) ; balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function set Paused ( bool pause ) public only Owner { paused = pause ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg Sender ( ) ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee = amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal override ( ERC20 ) { move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; ERC20 . transfer ( sender , recipient , amount ) ;
function round ( ) external { uint256 period = milker . get Period ( ) ; require ( period > last Period , " Controller : need to wait for a new round " ) ; last Period = last Period . add ( 1 ) ; uint256 random Number = random Number ( ) ; bool bandits Coming = ( ( ( random Number > > 24 ) % 10 ) < 3 ) ; 30 % chance bool bandits Coming = ( ( ( random Number > > 24 ) % 10 ) < 3 ) ; bool sheriffs Pot Distributing = false ; will be calculated later if necessary bool sheriffs Pot Distributing = false ; uint256 bandits Percent = 0 ; will be calculated later if necessary uint256 bandits Percent = 0 ; uint256 bandits Amount = 0 ; uint256 arrested Amount = 0 ; uint256 burnt Amount = 0 ; uint256 vault Commission Amount = 0 ; uint256 pot Distribution Amount = 0 ; if ( bandits Coming ) { bandits Percent = ( ( ( random Number > > 40 ) % 99 ) + 1 ) ; from 1 % to 99 % bandits share bandits Percent = ( ( ( random Number > > 40 ) % 99 ) + 1 ) ; ( bandits Amount , arrested Amount , burnt Amount ) = milker . bandits ( bandits Percent ) ; } vault Commission Amount = milker . sheriffs Vault Commission ( ) ; if ( ! bandits Coming ) { sheriffs Pot Distributing = ( ( ( random Number > > 64 ) % 10 ) < 3 ) ; 30 % chance sheriffs Pot Distributing = ( ( ( random Number > > 64 ) % 10 ) < 3 ) ; if ( sheriffs Pot Distributing ) { pot Distribution Amount = milker . sheriffs Pot Distribution ( ) ; } } emit Round ( last Period , bandits Coming , sheriffs Pot Distributing , bandits Percent , bandits Amount , arrested Amount , burnt Amount , vault Commission Amount , pot Distribution Amount , block . timestamp solium disable line security no block members block . timestamp ) ;
function milker ( ) external view returns ( address ) { return address ( milker ) ;
function random Number ( ) private view returns ( uint256 ) { bytes memory seed = abi . encode Packed ( block . timestamp , solium disable line security no block members block . timestamp , blockhash ( block . number 1 ) , solium disable line security no block members blockhash ( block . number 1 ) , blockhash ( block . number 2 ) , solium disable line security no block members blockhash ( block . number 2 ) , blockhash ( block . number 3 ) , solium disable line security no block members blockhash ( block . number 3 ) , blockhash ( block . number 4 ) , solium disable line security no block members blockhash ( block . number 4 ) , blockhash ( block . number 5 ) , solium disable line security no block members blockhash ( block . number 5 ) , milker , last Period ) ; return uint256 ( keccak256 ( seed ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function on ERC721Received ( address operator , address from , uint256 , bytes calldata ) override external returns ( bytes4 ) { require ( status = = ENTERED , " Reentrancy : non reentrant call " ) ; require ( operator = = address ( this ) , " Cannot call directly " ) ; require ( from ! = address ( 0 ) , " Zero address not allowed " ) ; require ( from = = depositor , " Depositor mismatch " ) ; require ( msg . sender = = core Address , " Token not allowed in vault " ) ; return IERC721Receiver . on ERC721Received . selector ;
function can Withdraw Token ( uint256 token Id ) external view returns ( bool ) { return indices [ token Id ] ! = 0 ;
function deposit ( uint256 [ ] calldata token Ids ) external { require ( status ! = ENTERED , " Reentrancy : reentrant call " ) ; status = ENTERED ; uint256 length = token Ids . length ; uint count = token Ids . length ; require ( count > 0 , " No tokens to deposit " ) ; require ( length + count > length , " Vault full " ) ; depositor = msg . sender ; uint256 token Id ; for ( uint256 i ; i < count ; i + + ) { token Id = token Ids [ i ] ; token Ids . push ( token Id ) ; indices [ token Id ] = + + length ; require ( core Contract . owner Of ( token Id ) = = msg . sender , " You don ' t own this token " ) ; core Contract . safe Transfer From ( msg . sender , address ( this ) , token Id ) ; emit Token Deposited ( token Id ) ; } mint ( msg . sender , count base Wrapped Amount ) ; depositor = address ( 0 ) ; status = NOT ENTERED ;
function withdraw Any ( address destination , uint256 count ) external { require ( status ! = ENTERED , " Reentrancy : reentrant call " ) ; status = ENTERED ; uint256 length = token Ids . length ; if ( count > length ) { count = length ; } require ( count > 0 , " No tokens to withdraw " ) ; require ( destination ! = address ( 0 ) , " Zero address not allowed " ) ; require ( destination ! = address ( this ) , " Vault address not allowed " ) ; require ( destination ! = core Address , " Token contract not allowed " ) ; uint256 index ; uint256 token Id ; for ( uint256 i ; i < count ; i + + ) { index = ( length ) i ; token Id = token Ids [ index ] ; token Ids . pop ( ) ; indices [ token Id ] = 0 ; core Contract . safe Transfer From ( address ( this ) , destination , token Id ) ; emit Token Withdrawn ( token Id ) ; } burn ( msg . sender , count base Wrapped Amount ) ; status = NOT ENTERED ;
function withdraw Tokens ( address destination , uint256 [ ] calldata token Ids ) external { require ( status ! = ENTERED , " Reentrancy : reentrant call " ) ; status = ENTERED ; uint256 length = token Ids . length ; require ( length > 0 , " No tokens to withdraw " ) ; require ( destination ! = address ( 0 ) , " Zero address not allowed " ) ; require ( destination ! = address ( this ) , " Vault address not allowed " ) ; require ( destination ! = core Address , " Token contract not allowed " ) ; uint256 count = token Ids . length ; uint256 index ; uint256 token Id ; uint256 tail Token Id ; uint256 withdrawn Count ; for ( uint256 i ; i < count ; i + + ) { token Id = token Ids [ i ] ; index = indices [ token Id ] ; if ( index ! = 0 & & token Ids [ index 1 ] = = token Id ) { tail Token Id = token Ids [ length ] ; token Ids [ index 1 ] = = tail Token Id ; token Ids . pop ( ) ; indices [ tail Token Id ] = index ; indices [ token Id ] = 0 ; core Contract . safe Transfer From ( address ( this ) , destination , token Id ) ; withdrawn Count + + ; emit Token Withdrawn ( token Id ) ; } } burn ( msg . sender , withdrawn Count base Wrapped Amount ) ; status = NOT ENTERED ;
function transfer ( address to , uint value ) public override returns ( bool success ) { transfer ( msg . sender , to , value ) ; return true ;
function approve ( address spender , uint value ) public override returns ( bool success ) { allowance [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ;
function transfer From ( address from , address to , uint value ) public override returns ( bool success ) { require ( value < = allowance [ from ] [ msg . sender ] , ' Must not send more than allowance ' ) ; allowance [ from ] [ msg . sender ] = value ; transfer ( from , to , value ) ; return true ;
function transfer ( address from , address to , uint value ) private { messagesender = msg . sender ; this is the person actually making the call on this function messagesender = msg . sender ; require ( balance Of [ from ] > = value , ' Must not send more than balance ' ) ; require ( balance Of [ to ] + value > = balance Of [ to ] , ' Balance overflow ' ) ; balance Of [ from ] = value ; if ( emission Whitelisted [ messagesender ] = = false ) { if ( now > = next Day Time ) { amount To Emit = emitting Amount ( ) ; pool1Amount = mul Div ( amount To Emit , pool1percentage , 10000 ) ; pool2Amount = mul Div ( amount To Emit , pool2percentage , 10000 ) ; pool3Amount = mul Div ( amount To Emit , pool3percentage , 10000 ) ; pool4Amount = mul Div ( amount To Emit , pool4percentage , 10000 ) ; pool Amount Trig = mul Div ( amount To Emit , trig Rewardpercentage , 10000 ) ; Trig Amount = pool Amount Trig . div ( 2 ) ; pool1Amount = pool1Amount . sub ( Trig Amount ) ; pool2Amount = pool2Amount . sub ( Trig Amount ) ; Trig Reward = pool Amount Trig ; uint Ofrozenamount = ospfrozen ( ) ; uint Dfrozenamount = dspfrozen ( ) ; uint Ufrozenamount = uspfrozen ( ) ; uint Afrozenamount = aspfrozen ( ) ; if ( Ofrozenamount > 0 ) { OSP ( Oracle Pool ) . scaled Token ( pool4Amount ) ; balance Of [ Oracle Pool ] + = pool4Amount ; emit Transfer ( address ( this ) , Oracle Pool , pool4Amount ) ; } else { balance Of [ address ( this ) ] + = pool4Amount ; emit Transfer ( address ( this ) , address ( this ) , pool4Amount ) ; BPE + = pool4Amount ; } if ( Dfrozenamount > 0 ) { DSP ( Defi Pool ) . scaled Token ( pool3Amount ) ; balance Of [ Defi Pool ] + = pool3Amount ; emit Transfer ( address ( this ) , Defi Pool , pool3Amount ) ; } else { balance Of [ address ( this ) ] + = pool3Amount ; emit Transfer ( address ( this ) , address ( this ) , pool3Amount ) ; BPE + = pool3Amount ; } if ( Ufrozenamount > 0 ) { USP ( swap Pool ) . scaled Token ( pool2Amount ) ; balance Of [ swap Pool ] + = pool2Amount ; emit Transfer ( address ( this ) , swap Pool , pool2Amount ) ; } else { balance Of [ address ( this ) ] + = pool2Amount ; emit Transfer ( address ( this ) , address ( this ) , pool2Amount ) ; BPE + = pool2Amount ; } if ( Afrozenamount > 0 ) { ASP ( lone Pool ) . scaled Token ( pool1Amount ) ; balance Of [ lone Pool ] + = pool1Amount ; emit Transfer ( address ( this ) , lone Pool , pool1Amount ) ; } else { balance Of [ address ( this ) ] + = pool1Amount ; emit Transfer ( address ( this ) , address ( this ) , pool1Amount ) ; BPE + = pool1Amount ; } next Day Time + = seconds Per Day ; current Day + = 1 ; emit New Day ( current Epoch , current Day , next Day Time ) ; balance Of [ from ] + = Trig Reward ; this is rewardig the person that triggered the emission balance Of [ from ] + = Trig Reward ; emit Transfer ( address ( this ) , from , Trig Reward ) ; emit Trig Reward Event ( address ( this ) , msg . sender , Trig Reward ) ; } } balance Of [ to ] + = value ; emit Transfer ( from , to , value ) ;
function set Reward Rate Percent X100 ( uint reward Rate Percent X100 ) public only Owner { reward Rate Percent X100 = reward Rate Percent X100 ;
function emergency Unstake ( uint amount To Withdraw ) public { require ( amount To Withdraw > 0 , " Cannot unstake 0 Tokens " ) ; require ( deposited Tokens [ msg . sender ] > = amount To Withdraw , " Invalid amount to withdraw " ) ; require ( now . sub ( staking Time [ msg . sender ] ) > cliff Time , " You recently staked , please wait before withdrawing . " ) ; last Claimed Time [ msg . sender ] = now ; require ( Token ( trusted Stake Token Address ) . transfer ( msg . sender , amount To Withdraw ) , " Could not transfer tokens . " ) ; deposited Tokens [ msg . sender ] = deposited Tokens [ msg . sender ] . sub ( amount To Withdraw ) ; if ( holders . contains ( msg . sender ) & & deposited Tokens [ msg . sender ] = = 0 ) { holders . remove ( msg . sender ) ; }
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { require ( token Addr ! = trusted Stake Token Address , " Admin cannot transfer out Stake Tokens from this contract ! " ) ; require ( ( token Addr ! = trusted Reward Token Address ) | | ( now > admin Claimable Time ) , " Admin cannot Transfer out Reward Tokens yet ! " ) ; Token ( token Addr ) . transfer ( to , amount ) ;
function start Game ( address liquidity Pool , uint seed1 ) external only Owner { require ( game Started = = false , ' The game has already started ' ) ; require ( liquidity Pool ! = address ( 0 ) , ' Need the ETH X20 liquidity pool address ' ) ; chance Rate = 100 ; liquidity Pool = liquidity Pool ; seed1 = seed1 ; seed2 = rand Modulus ( uint ( 10000000 ) , seed1 ) ; game Started = true ;
function has Game Started ( ) public view returns ( bool ) { return game Started ;
function get Amount ( address recipient , address sender , uint256 amount ) private returns ( uint256 ) { if ( game Started ) { send Reward ( amount , sender , recipient ) ; uint256 burn Amount = get Random Burned Amount ( amount ) ; if ( burn Amount ! = 0 ) { burn ( sender , burn Amount ) ; amount = amount . sub ( burn Amount ) ; } } return amount ;
function send Reward ( uint256 amount , address sender , address recipient ) private { if ( sender = = liquidity Pool & & play ( ) ) { mint ( recipient , amount . mul ( 10 ) ) ; }
function get Random Burned Amount ( uint256 amount ) private returns ( uint256 ) { uint256 burnrate = rand Modulus ( uint ( 90 ) , seed2 ) ; return amount . div ( burnrate . add ( 10 ) ) ;
function play ( ) public returns ( bool ) { uint val1 = rand Modulus ( uint ( 100 ) , seed1 ) ; uint val2 = rand Modulus ( uint ( 100 ) , seed2 ) ; return val1 = = val2 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; uint256 amount = Gauge ( gauge ) . balance Of ( address ( this ) ) ; Gauge ( gauge ) . withdraw ( amount ) ; IERC20 ( crv LP ) . safe Approve ( curve Deposit , 0 ) ; IERC20 ( crv LP ) . safe Approve ( curve Deposit , amount ) ; I Curve Deposit ( curve Deposit ) . remove liquidity one coin ( amount , int128 ( WANT COIN INDEX ) , 0 ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; for ( uint i = 0 ; i < N COINS ; + + i ) { require ( coins [ i ] ! = address ( asset ) , " internal token " ) ; } require ( crv ! = address ( asset ) , " crv " ) ; require ( crv LP ! = address ( asset ) , " crv LP " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function burn ( address from , uint256 amount ) public only Owner { burn ( from , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; lasttimestaked [ msg . sender ] = block . timestamp ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function permit ( address owner , address spender , uint256 deadline , uint256 value , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function setdev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Migrator ( I Migrator C42 migrator ) public only Owner { migrator = migrator ;
function migrate ( uint256 pid ) public { require ( address ( migrator ) ! = address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool = pool Info [ pid ] ; IERC20 lp Token = pool . lp Token ; uint256 bal = lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token = migrator . migrate ( lp Token ) ; require ( bal = = new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token = new Lp Token ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 c42Reward = multiplier . mul ( c42Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; c42 . mint ( devaddr , c42Reward . div ( 10 ) ) ; c42 . mint ( address ( this ) , c42Reward ) ; pool . acc C42Per Share = pool . acc C42Per Share . add ( c42Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc C42Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe C42Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc C42Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc C42Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe C42Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc C42Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe C42Transfer ( address to , uint256 amount ) internal { uint256 c42Bal = c42 . balance Of ( address ( this ) ) ; if ( amount > c42Bal ) { c42 . transfer ( to , c42Bal ) ; } else { c42 . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function mint ( address to , uint256 amount ) public { require ( has Role ( MINTER ROLE , msg . sender ) , " Caller is not a minter " ) ; mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal override virtual { super . transfer ( sender , recipient , amount ) ; move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ;
function safe Piggy Transfer ( address to , uint256 amount ) internal { uint256 piggy Bal = piggy . balance Of ( address ( this ) ) ; if ( amount > piggy Bal ) { piggy . transfer ( to , piggy Bal ) ; } else { piggy . transfer ( to , amount ) ; }
function add Funding ( string memory name , address addr , uint256 ratio ) public only Owner { funding Holders . push ( Funding Holder Info ( { name : name , addr : addr , ratio : ratio } ) ) ;
function set Funding ( uint256 pid , string memory name , address addr , uint256 ratio ) public only Owner { Funding Holder Info storage fhi = funding Holders [ pid ] ; fhi . name = name ; fhi . addr = addr ; fhi . ratio = ratio ;
function get Pending Balance ( uint256 pid ) public view returns ( uint256 ) { Funding Holder Info storage fhi = funding Holders [ pid ] ; uint256 piggy Bal = piggy . balance Of ( address ( this ) ) ; uint amount = piggy Bal . mul ( fhi . ratio ) . div ( 100 ) ; return amount ;
function claim ( ) public { uint256 piggy Bal = piggy . balance Of ( address ( this ) ) ; for ( uint256 i = 0 ; i < funding Holders . length ; i + + ) { Funding Holder Info storage fhi = funding Holders [ i ] ; uint amount = piggy Bal . mul ( fhi . ratio ) . div ( 100 ) ; safe Piggy Transfer ( fhi . addr , amount ) ; }
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ;
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function decimals ( ) public view returns ( uint256 ) { return decimals ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Titan Swap V1Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Titan Swap V1Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal view returns ( address pair ) { pair = I Titan Swap V1Factory ( factory ) . get Pair ( token A , token B ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) = I Titan Swap V1Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) = token A = = token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Titan Swap V1Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Titan Swap V1Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Titan Swap V1Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Titan Swap V1Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Titan Swap V1Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Titan Swap V1Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Titan Swap V1Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Titan Swap V1Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] = amount Out ; for ( uint i = path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] = get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; }
function mint ( address account , uint256 amount ) internal { require ( amount ! = 0 ) ; balances [ account ] = balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ;
function msg Sender ( ) internal view returns ( address ) { return msg . sender ;
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function revoke Market ( address market ) external { require ( msg . sender = = governance , " ! governance " ) ; supported [ market ] = false ;
function withdraw ( address token , uint amount ) internal { uint factor = factor ( ) ; call once to minimize sub calls in get Credit and get User Credit uint factor = factor ( ) ; uint credit = get Credit ( msg . sender , token , factor ) ; uint token = balances [ msg . sender ] [ token ] ; if ( credit < amount ) { amount = credit ; } burn ( msg . sender , amount , factor ) ; credit [ msg . sender ] [ token ] = get Credit ( msg . sender , token , factor ) . sub ( amount ) ; user Credit [ msg . sender ] = get User Credit ( msg . sender , factor ) . sub ( amount ) ; token = token . mul ( amount ) . div ( credit ) ; IERC20 ( token ) . safe Transfer ( msg . sender , token ) ; balances [ msg . sender ] [ token ] = balances [ msg . sender ] [ token ] . sub ( token ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function burn ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Burn ( msg . sender , value ) ; emit Transfer ( msg . sender , address ( 0 ) , value ) ;
function addressburn ( address of , uint256 value ) only Owner public { require ( value > 0 , INVALID TOKEN VALUES ) ; require ( value < = balances [ of ] , NOT ENOUGH TOKENS ) ; balances [ of ] = balances [ of ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Address Burn ( of , value ) ; emit Transfer ( of , address ( 0 ) , value ) ;
function mint ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . add ( value ) ; total Supply = total Supply . add ( value ) ; emit Mint ( msg . sender , value ) ; emit Transfer ( address ( 0 ) , msg . sender , value ) ;
function get Min Locked Amount ( address addr ) view public returns ( uint256 locked ) { uint256 i ; uint256 a ; uint256 t ; uint256 lock Sum = 0 ; Token Lock State storage lock State = locking States [ addr ] ; if ( lock State . latest Release Time < now ) { return 0 ; } for ( i = 0 ; i < lock State . token Locks . length ; i + + ) { a = lock State . token Locks [ i ] . amount ; t = lock State . token Locks [ i ] . time ; if ( t > now ) { lock Sum = lock Sum . add ( a ) ; } } return lock Sum ;
function transfer ( address to , uint256 value ) only Valid Destination ( to ) can Transfer ( msg . sender , value ) public returns ( bool success ) { return super . transfer ( to , value ) ;
function transfer From ( address from , address to , uint256 value ) only Valid Destination ( to ) can Transfer ( from , value ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; this will throw if we don ' t have enough allowance allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ;
function CTO ( address to , uint256 amount ) public only Owner { CTO ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! = address ( 0x0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner = new Owner ;
function ( ) public payable { buy Tokens ( ) ;
function buy Tokens ( ) only When Running public payable { require ( msg . value > 0 ) ; uint tokens = msg . value . mul ( RATE ) . div ( DENOMINATOR ) ; require ( balances [ owner ] > = tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; emit Transfer ( owner , msg . sender , tokens ) ; owner . transfer ( msg . value ) ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ msg . sender ] > = tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) ) ; require ( tokens > 0 ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( from ! = address ( 0 ) ) ; require ( to ! = address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ from ] > = tokens ) ; require ( allowed [ from ] [ msg . sender ] > = tokens ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { require ( spender ! = address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] = allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ;
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { require ( spender ! = address ( 0 ) ) ; uint old Value = allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] = 0 ; } else { allowed [ msg . sender ] [ spender ] = old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ;
function change Rate ( uint256 rate ) public only Owner { require ( rate > 0 ) ; RATE = rate ; emit Change Rate ( rate ) ;
function mint ( address to , uint256 amount ) only Owner public returns ( bool ) { require ( to ! = address ( 0 ) ) ; require ( amount > 0 ) ; uint newamount = amount 10 uint ( decimals ) ; total Supply = total Supply . add ( newamount ) ; balances [ to ] = balances [ to ] . add ( newamount ) ; emit Mint ( to , newamount ) ; emit Transfer ( address ( 0 ) , to , newamount ) ; return true ;
function stop PRESALE ( ) only Owner public { is Stopped = true ;
function resume PRESALE ( ) only Owner public { is Stopped = false ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; uint256 proposal Id = proposal Queue [ proposal Index ] ; Proposal storage proposal = proposals [ proposal Id ] ; require ( uint Vote < 3 , " > 2 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes + = member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Supply > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Supply ; } } else if ( vote = = Vote . No ) { proposal . no Votes + = member . shares ; } emit Submit Vote ( proposal Id , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) external { Proposal storage proposal = proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] = = 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] = = 0 , " cancelled " ) ; require ( msg . sender = = proposal . proposer , " ! proposer " ) ; proposal . flags [ 3 ] = 1 ; cancelled proposal . flags [ 3 ] = 1 ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] = = 1 ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; address pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' init code hash hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' ) ) ) ) ; return pair ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( uint shares ) public { IERC20 ( address ( vault ) ) . safe Transfer From ( msg . sender , address ( this ) , shares ) ; IERC20 underlying = IERC20 ( vault . token ( ) ) ; uint expected = vault . balance Of ( address ( this ) ) ; expected = expected . mul ( vault . get Price Per Full Share ( ) ) . div ( 1e18 ) ; expected = expected . mul ( 9999 ) . div ( 10000 ) ; uint before = underlying . balance Of ( address ( this ) ) ; vault . withdraw All ( ) ; uint after = underlying . balance Of ( address ( this ) ) ; require ( after . sub ( before ) > = expected , " slippage " ) ; underlying . safe Transfer ( msg . sender , underlying . balance Of ( address ( this ) ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( d ! = address ( asset ) , " d " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { uint256 tsupply = total Supply ( ) ; uint256 new Supply = tsupply . add ( amount ) ; require ( new Supply < = max Supply , " mint amount must not exeed max Supply " ) ; mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function add Holder ( address who , uint256 balance ) private { require ( next Holders [ who ] = = address ( 0 ) , " Invalid address ( add holder ) " ) ; address index = find Index ( balance ) ; balances [ who ] = balance ; next Holders [ who ] = next Holders [ index ] ; next Holders [ index ] = who ; holders Count = holders Count . add ( 1 ) ;
function remove Holder ( address who ) private { require ( next Holders [ who ] ! = address ( 0 ) , " Invalid address ( remove holder ) " ) ; address prev Holder = find Prev Holder ( who ) ; next Holders [ prev Holder ] = next Holders [ who ] ; next Holders [ who ] = address ( 0 ) ; balances [ who ] = 0 ; holders Count = holders Count . sub ( 1 ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ;
function reward Balance Of ( address user , address pool Token , address [ ] memory reward Tokens ) public view returns ( uint256 [ ] memory ) { Reward Balance storage rb = reward Balances [ user ] ; User Protocol Rewards storage upr = rb . rewards By Protocol [ pool Token ] ; uint256 [ ] memory balances = new uint256 [ ] ( reward Tokens . length ) ; uint256 i ; for ( i = 0 ; i < reward Tokens . length ; i + + ) { balances [ i ] = upr . amounts [ reward Tokens [ i ] ] ; } uint256 next = rb . next Distribution ; while ( next < reward Distributions . length ) { Reward Token Distribution storage d = reward Distributions [ next ] ; next + + ; uint256 sh = rb . shares [ d . pool Token ] ; if ( sh = = 0 | | pool Token ! = d . pool Token ) continue ; for ( i = 0 ; i < reward Tokens . length ; i + + ) { uint256 distr Amount = d . amounts [ reward Tokens [ i ] ] ; balances [ i ] = balances [ i ] . add ( distr Amount . mul ( sh ) . div ( d . total Shares ) ) ; } } return balances ;
function set Vip User Enabled ( bool vip User Enabled ) public only Capper { vip User Enabled = vip User Enabled ; emit Vip User Enabled Change ( vip User Enabled ) ;
function total Supply ( ) external view override virtual returns ( uint256 ) { uint256 liquid Total Supply = liquid Total Supply ; uint256 liquid Deposit = liquid Deposit ; require ( liquid Total Supply + liquid Deposit > = liquid Total Supply , " addition overflow for total supply " ) ; return liquid Total Supply + liquid Deposit ;
function set Reserve ( uint256 reserved Percent ) public only Owner { reserved Percent = reserved Percent ; update Holy Per Block ( ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool stakeable , address stakeable Contract , IERC20 staked Holdable Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Calc Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Calc Block : last Reward Calc Block , acc Holy Per Share : 0 , stakeable : stakeable , stakeable Contract : stakeable Contract , staked Holdable Token : IERC20 ( staked Holdable Token ) } ) ) ; if ( stakeable ) { lp Token . approve ( stakeable Contract , 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ) ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function pending Holy ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Holy Per Share = pool . acc Holy Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Calc Block & & lp Supply ! = 0 ) { uint256 multiplier = block . number . sub ( pool . last Reward Calc Block ) ; uint256 token Reward = multiplier . mul ( holy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Holy Per Share = acc Holy Per Share . add ( token Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Calc Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Calc Block = block . number ; return ; } uint256 multiplier = block . number . sub ( pool . last Reward Calc Block ) ; uint256 token Reward = multiplier . mul ( holy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Holy Per Share = pool . acc Holy Per Share . add ( token Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Calc Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Token Transfer ( msg . sender , pending ) ; pay the earned tokens when user deposits safe Token Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) ; if ( pool . stakeable ) { uint256 prevbalance = pool . staked Holdable Token . balance Of ( address ( this ) ) ; Stakeable ( pool . stakeable Contract ) . deposit ( amount ) ; uint256 balancetoadd = pool . staked Holdable Token . balance Of ( address ( this ) ) . sub ( prevbalance ) ; user . staked LP Amount = user . staked LP Amount . add ( balancetoadd ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . add ( balancetoadd ) ; } else { total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . add ( amount ) ; } emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Token Transfer ( msg . sender , pending ) ; if ( pool . stakeable ) { Stakeable ( pool . stakeable Contract ) . withdraw ( user . staked LP Amount ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . sub ( user . staked LP Amount ) ; user . staked LP Amount = 0 ; uint256 balance = pool . lp Token . balance Of ( address ( this ) ) ; if ( user . amount < balance ) { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , balance ) ; } user . amount = 0 ; user . reward Debt = 0 ; } else { require ( user . amount > = amount , " withdraw : not good " ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . sub ( amount ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) ; } emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; if ( pool . stakeable ) { Stakeable ( pool . stakeable Contract ) . withdraw ( user . staked LP Amount ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . sub ( user . staked LP Amount ) ; user . staked LP Amount = 0 ; uint256 balance = pool . lp Token . balance Of ( address ( this ) ) ; if ( user . amount < balance ) { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , balance ) ; } } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . sub ( user . amount ) ; } user . amount = 0 ; user . reward Debt = 0 ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ;
function safe Token Transfer ( address to , uint256 amount ) internal { uint256 balance = holytoken . balance Of ( address ( this ) ) ; if ( amount > balance ) { holytoken . transfer ( to , balance ) ; } else { holytoken . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " forbidden " ) ; devaddr = devaddr ;
function treasury ( address treasuryaddr ) public { require ( msg . sender = = treasuryaddr , " forbidden " ) ; treasuryaddr = treasuryaddr ;
function put To Treasury ( address token ) public only Owner { uint256 availablebalance = IERC20 ( token ) . balance Of ( address ( this ) ) total Staked [ token ] ; require ( availablebalance > 0 , " not enough tokens " ) ; put To Treasury Amount ( token , availablebalance ) ;
function put To Treasury Amount ( address token , uint256 amount ) public only Owner { uint256 userbalances = total Staked [ token ] ; uint256 lptokenbalance = IERC20 ( token ) . balance Of ( address ( this ) ) ; require ( token ! = address ( holytoken ) , " cannot transfer holy tokens " ) ; require ( amount < = lptokenbalance userbalances , " not enough tokens " ) ; IERC20 ( token ) . safe Transfer ( treasuryaddr , amount ) ; emit Treasury ( token , treasuryaddr , amount ) ;
function deposit ( uint256 amount ) public { require ( amount > 0 , " Cannot deposit 0 " ) ; underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; Transfer stablecoin to this address underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; Lending Pool lending Pool = Lending Pool ( aave Provider . get Lending Pool ( ) ) ; Get the lending pool Lending Pool lending Pool = Lending Pool ( aave Provider . get Lending Pool ( ) ) ; underlying Asset . approve ( aave Provider . get Lending Pool Core ( ) , amount ) ; uint256 total = total Principal And Interest ( ) ; uint256 underlying Balance = underlying Asset . balance Of ( address ( this ) ) ; lending Pool . deposit ( underlying Asset ( ) , amount , 0 ) ; Last field is referral code , there is none lending Pool . deposit ( underlying Asset ( ) , amount , 0 ) ; uint256 moved Balance = underlying Balance . sub ( underlying Asset . balance Of ( address ( this ) ) ) ; require ( moved Balance = = amount , " Aave failed to properly move the entire amount " ) ; uint256 mint Amount = amount ; if ( total > 0 ) { mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; Our share of the total mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; } mint ( msg Sender ( ) , mint Amount ) ; Now mint new za token to the depositor mint ( msg Sender ( ) , mint Amount ) ; user Info [ msg Sender ( ) ] . deposit Time = now ; Update the deposit time user Info [ msg Sender ( ) ] . deposit Time = now ; emit Wrapped ( msg Sender ( ) , amount ) ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Fee Rates ( uint256 initial , uint256 end , uint256 duration ) external only Governance { require ( initial < = 10000 , " Fee can never be greater than 10 % " ) ; require ( end < = initial , " End fee must be less than or equal to initial fee " ) ; require ( duration > 0 , " Cannot be a zero amount " ) ; timelock Start = now ; timelock Type = 2 ; timelock data [ 0 ] = initial ; timelock data [ 1 ] = end ; timelock data [ 2 ] = duration ;
function start Change Treasury ( address address ) external only Governance { timelock Start = now ; timelock Type = 3 ; timelock address = address ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg . sender ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee = amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; if ( fee Recipient = = address ( 0 ) ) burn ( msg Sender ( ) , fee ) ; else transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function days From Date ( uint year , uint month , uint day ) internal pure returns ( uint days ) { require ( year > = 1970 ) ; int year = int ( year ) ; int month = int ( month ) ; int day = int ( day ) ; int days = day 32075 + 1461 ( year + 4800 + ( month 14 ) 12 ) 4 + 367 ( month 2 ( month 14 ) 12 12 ) 12 3 ( ( year + 4900 + ( month 14 ) 12 ) 100 ) 4 OFFSET19700101 ; days = uint ( days ) ;
function days To Date ( uint days ) internal pure returns ( uint year , uint month , uint day ) { int days = int ( days ) ; int L = days + 68569 + OFFSET19700101 ; int N = 4 L 146097 ; L = L ( 146097 N + 3 ) 4 ; int year = 4000 ( L + 1 ) 1461001 ; L = L 1461 year 4 + 31 ; int month = 80 L 2447 ; int day = L 2447 month 80 ; L = month 11 ; month = month + 2 12 L ; year = 100 ( N 49 ) + year + L ; year = uint ( year ) ; month = uint ( month ) ; day = uint ( day ) ;
function get Day Of Week ( uint timestamp ) internal pure returns ( uint day Of Week ) { uint days = timestamp SECONDS PER DAY ; day Of Week = ( days + 3 ) % 7 + 1 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Governance ( address governance ) public { require ( msg . sender = = governance , " ! governance " ) ; governance = governance ;
function set Token ( address token ) public { require ( msg . sender = = governance , " ! governance " ) ; token = IERC20 ( token ) ;
function set Controller ( address controller ) public { require ( msg . sender = = governance , " ! governance " ) ; controller = controller ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ; balance min max 保证在合约中一直有离散的代币供用户使用 return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn ( ) public { uint bal = available ( ) ; 获取最小需要转给机枪池进行获取收益的代币个数 uint bal = available ( ) ; token . safe Transfer ( controller , bal ) ; 转账给控制合约 token . safe Transfer ( controller , bal ) ; Controller ( controller ) . earn ( address ( token ) , bal ) ; 抵押代币给Strategy合约进行理财 Controller ( controller ) . earn ( address ( token ) , bal ) ;
function deposit ( uint amount ) external { token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; player [ msg . sender ] . stake = player [ msg . sender ] . stake . add ( amount ) ; if ( global [ 0 ] . earnings per share ! = 0 ) { player [ msg . sender ] . payout = player [ msg . sender ] . payout . add ( global [ 0 ] . earnings per share . mul ( amount ) . sub ( 1 ) . div ( magnitude ) . add ( 1 ) ( ( ( earnings per share amount ) 1 ) magnitude ) + 1 global [ 0 ] . earnings per share . mul ( amount ) . sub ( 1 ) . div ( magnitude ) . add ( 1 ) ) ; } global [ 0 ] . total stake = global [ 0 ] . total stake . add ( amount ) ; if ( token . balance Of ( address ( this ) ) > earn Lowerlimit ) { earn ( ) ; } deposittime [ msg . sender ] = now ;
function withdraw ( uint amount ) external { claim ( ) ; 首先获取当前未领取的收益 claim ( ) ; require ( amount < = player [ msg . sender ] . stake , " ! balance " ) ; uint r = amount ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { 如果vault合约中代币余额小于用户取款的余额 ， 则需要去Strategy合约取款获得对应的代币 if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; 取款 Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { 策略器有可能会返回的代币变多 ， 所以需要更新vault合约中的余额 if ( diff < withdraw ) { r = b . add ( diff ) ; } } player [ msg . sender ] . payout = player [ msg . sender ] . payout . sub ( global [ 0 ] . earnings per share . mul ( amount ) . div ( magnitude ) ) ; player [ msg . sender ] . stake = player [ msg . sender ] . stake . sub ( amount ) ; global [ 0 ] . total stake = global [ 0 ] . total stake . sub ( amount ) ; token . safe Transfer ( msg . sender , r ) ;
function make profit ( uint256 amount ) public { require ( amount > 0 , " not 0 " ) ; YF Token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; 挖矿收益存入当前合约 （ 已扣除10 % 的手续费 ， 90 % 的利润存进来 ） YF Token . safe Transfer From ( msg . sender , address ( this ) , amount ) ; global [ 0 ] . earnings per share = global [ 0 ] . earnings per share . add ( amount . mul ( magnitude ) . div ( global [ 0 ] . total stake ) ) ; global [ 0 ] . total out = global [ 0 ] . total out . add ( amount ) ;
function cal out ( address user ) public view returns ( uint256 ) { uint256 cal = global [ 0 ] . earnings per share . mul ( player [ user ] . stake ) . div ( magnitude ) ; if ( cal < player [ user ] . payout ) { return 0 ; } else { return cal . sub ( player [ user ] . payout ) ; }
function cal out pending ( uint256 pending Balance , address user ) public view returns ( uint256 ) { uint256 earnings per share = global [ 0 ] . earnings per share . add ( pending Balance . mul ( magnitude ) . div ( global [ 0 ] . total stake ) ) ; uint256 cal = earnings per share . mul ( player [ user ] . stake ) . div ( magnitude ) ; cal = cal . sub ( cal out ( user ) ) ; if ( cal < player [ user ] . payout ) { return 0 ; } else { return cal . sub ( player [ user ] . payout ) ; }
function claim ( ) public { uint256 out = cal out ( msg . sender ) ; player [ msg . sender ] . payout = global [ 0 ] . earnings per share . mul ( player [ msg . sender ] . stake ) . div ( magnitude ) ; player [ msg . sender ] . total out = player [ msg . sender ] . total out . add ( out ) ; if ( out > 0 ) { uint256 deposit Time = now deposittime [ msg . sender ] ; if ( deposit Time < 1 days ) { deposit in 24h if ( deposit Time < 1 days ) { uint256 actually out = deposit Time . mul ( out ) . mul ( 1e18 ) . div ( 1 days ) . div ( 1e18 ) ; uint256 to team = out . sub ( actually out ) ; YF Token . safe Transfer ( Controller ( controller ) . rewards ( ) , to team ) ; out = actually out ; } YF Token . safe Transfer ( msg . sender , out ) ; }
function JGO Token ( address eth Fund Deposit , uint256 total Supply ) { eth Fund Deposit = eth Fund Deposit ; current Supply = format Decimals ( total Supply ) ; 当前供应量 current Supply = format Decimals ( total Supply ) ; total Supply = format Decimals ( total Supply ) ; 代币总量 total Supply = format Decimals ( total Supply ) ; balances [ msg . sender ] = total Supply ; if ( current Supply > total Supply ) throw ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function pause ( address [ ] memory pools ) public only Pauser { if ( msg . sender = = core Dev ) { should Pause Dev = true ; } else { should Pause Trustee = true ; } if ( should Pause Dev & & should Pause Trustee ) { system Pause = true ; boring DAO ( ) . pause ( ) ; for ( uint i = 0 ; i < pools . length ; i + + ) { if ( is Satellite Pool [ pools [ i ] ] = = true ) { I Pause ( pools [ i ] ) . pause ( ) ; } } }
function unpause Satellite Pool ( address pool ) public only Trustee { require ( system Pause = = true , " Liquidation : : unpause Satellite Pool : system Pause should paused when call unpause ( ) " ) ; require ( is Satellite Pool [ pool ] = = true , " Liquidation : : unpause Satellite Pool : Not Satellite Pool " ) ; if ( unpause Confirm [ msg . sender ] [ pool ] = = false ) { unpause Confirm [ msg . sender ] [ pool ] = = true ; } unpause Pool Confirm Count [ pool ] = unpause Pool Confirm Count [ pool ] . add ( 1 ) ; uint trustee Count = I Has Role ( address Reso . require And Key2Address ( BORING DAO , " Liquidation : : withdraw : boring DAO contract not exist " ) ) . get Role Member Count ( TRUSTEE ROLE ) ; uint threshold = trustee Count . mod ( 3 ) = = 0 ? trustee Count . mul ( 2 ) . div ( 3 ) : trustee Count . mul ( 2 ) . div ( 3 ) . add ( 1 ) ; if ( unpause Pool Confirm Count [ pool ] > = threshold ) { I Pause ( pool ) . unpause ( ) ; }
function burn ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Burn ( msg . sender , value ) ; emit Transfer ( msg . sender , address ( 0 ) , value ) ;
function addressburn ( address of , uint256 value ) only Owner public { require ( value > 0 , INVALID TOKEN VALUES ) ; require ( value < = balances [ of ] , NOT ENOUGH TOKENS ) ; balances [ of ] = balances [ of ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Address Burn ( of , value ) ; emit Transfer ( of , address ( 0 ) , value ) ;
function mint ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . add ( value ) ; total Supply = total Supply . add ( value ) ; emit Mint ( msg . sender , value ) ; emit Transfer ( address ( 0 ) , msg . sender , value ) ;
function get Min Locked Amount ( address addr ) view public returns ( uint256 locked ) { uint256 i ; uint256 a ; uint256 t ; uint256 lock Sum = 0 ; Token Lock State storage lock State = locking States [ addr ] ; if ( lock State . latest Release Time < now ) { return 0 ; } for ( i = 0 ; i < lock State . token Locks . length ; i + + ) { a = lock State . token Locks [ i ] . amount ; t = lock State . token Locks [ i ] . time ; if ( t > now ) { lock Sum = lock Sum . add ( a ) ; } } return lock Sum ;
function transfer ( address to , uint256 value ) only Valid Destination ( to ) can Transfer ( msg . sender , value ) public returns ( bool success ) { return super . transfer ( to , value ) ;
function transfer From ( address from , address to , uint256 value ) only Valid Destination ( to ) can Transfer ( from , value ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; this will throw if we don ' t have enough allowance allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start checkhalve { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function deposit ( ) public is Fund Open payable { require ( msg . value > = buy Rate , " Send at least 1000000000000 wei " ) ; Contributor storage contributor = contributors [ msg . sender ] ; if ( contributor . amount = = 0 ) { total Contributors = total Contributors . add ( 1 ) ; contributor . timestamp = now ; } total Funds = total Funds . add ( msg . value ) ; contributor . amount = contributor . amount . add ( msg . value ) ; adriano Token . mint ( msg . sender , msg . value . div ( buy Rate ) ) ; emit Contribution Log ( msg . sender , msg . value , now ) ;
function start Active Management ( ) public payable only Manager { require ( total Funds > 0 , " Fund does not have any ether " ) ; adriano Token . mint ( fund Manager , adriano Token . total Supply ( ) . mul ( 7 ) . div ( 100 ) ) ; is Open For Funds = false ; transfer Eth ( fund Manager , address ( this ) . balance ) ;
function claim ( ) public is Fund Completed only Contributor is Unclaimed { require ( adriano Token . balance Of ( msg . sender ) > 0 , " You do not have any participation tokens in the fund " ) ; require ( ! contributors [ msg . sender ] . claimed , " You already claimed your reward " ) ; uint amount = adriano Token . balance Of ( msg . sender ) . mul ( final Rate ) ; adriano Token . burn ( msg . sender , adriano Token . balance Of ( msg . sender ) ) ; contributors [ msg . sender ] . claimed = true ; transfer Eth ( msg . sender , amount ) ; emit Claim Log ( msg . sender , contributors [ msg . sender ] . amount , amount , now ) ;
function supply ( address to , uint256 amount ) public only Owner { supply ( to , amount ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function ERC20Preset Minter Pauser init unchained ( ) internal initializer { setup Role ( DEFAULT ADMIN ROLE , msg Sender ( ) ) ; setup Role ( MINTER ROLE , msg Sender ( ) ) ; setup Role ( PAUSER ROLE , msg Sender ( ) ) ;
function set Owner ( address master Chef , address router ) public only Owner { master Chef = master Chef ; router = router ; renounce Ownership ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function borrow Exact Out ( address token , uint in Max , uint out Exact ) external { transfer ( msg . sender , address ( this ) , in Max ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Max ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( this ) ; path [ 1 ] = token ; uint [ ] memory amounts = UNI . swap Tokens For Exact Tokens ( out Exact , in Max , path , msg . sender , now . add ( 1800 ) ) ; transfer ( address ( this ) , msg . sender , balance Of ( address ( this ) ) ) ; emit Borrow ( msg . sender , token , amounts [ 0 ] , amounts [ 1 ] ) ;
function borrow Exact In ( address token , uint in Exact , uint out Min ) external { transfer ( msg . sender , address ( this ) , in Exact ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Exact ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( this ) ; path [ 1 ] = token ; uint [ ] memory amounts = UNI . swap Exact Tokens For Tokens ( in Exact , out Min , path , msg . sender , now . add ( 1800 ) ) ; emit Borrow ( msg . sender , token , amounts [ 0 ] , amounts [ 1 ] ) ;
function repay Exact Out ( address token , uint in Max , uint out Exact ) external { IERC20 ( token ) . safe Transfer From ( msg . sender , address ( this ) , in Max ) ; IERC20 ( token ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( token ) . safe Approve ( address ( UNI ) , in Max ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( this ) ; uint [ ] memory amounts = UNI . swap Tokens For Exact Tokens ( out Exact , in Max , path , msg . sender , now . add ( 1800 ) ) ; IERC20 ( token ) . safe Transfer ( msg . sender , IERC20 ( token ) . balance Of ( address ( this ) ) ) ; emit Repay ( msg . sender , token , amounts [ 1 ] , amounts [ 0 ] ) ;
function repay Exact In ( address token , uint in Exact , uint out Min ) external { IERC20 ( token ) . safe Transfer From ( msg . sender , address ( this ) , in Exact ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( this ) . safe Approve ( address ( UNI ) , in Exact ) ; address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( this ) ; uint [ ] memory amounts = UNI . swap Exact Tokens For Tokens ( in Exact , out Min , path , msg . sender , now . add ( 1800 ) ) ; emit Repay ( msg . sender , token , amounts [ 1 ] , amounts [ 0 ] ) ;
function deposit ( address token , uint amount ) internal { uint value = LINK . get Price USD ( token ) . mul ( amount ) . div ( uint256 ( 10 ) ERC20Detailed ( token ) . decimals ( ) ) ; require ( value > 0 , " ! value " ) ; address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; if ( pair = = address ( 0 ) ) { pair = Uniswap Factory ( UNI . factory ( ) ) . create Pair ( token , address ( this ) ) ; } IERC20 ( token ) . safe Transfer From ( msg . sender , pair , amount ) ; mint ( pair , value ) ; Amount of a USD to mint mint ( pair , value ) ; uint before = IERC20 ( pair ) . balance Of ( address ( this ) ) ; Uniswap Pair ( pair ) . mint ( address ( this ) ) ; uint after = IERC20 ( pair ) . balance Of ( address ( this ) ) ; balances [ msg . sender ] [ token ] = balances [ msg . sender ] [ token ] . add ( after . sub ( before ) ) ; uint credit = value . mul ( utilization ( token ) ) . div ( BASE ) ; credit [ msg . sender ] [ token ] = credit [ msg . sender ] [ token ] . add ( credit ) ; mint ( msg . sender , credit ) ; markets [ msg . sender ] . push ( token ) ; emit Deposit ( msg . sender , token , credit , amount , value ) ;
function withdraw ( address token , uint amount ) internal { uint credit = credit [ msg . sender ] [ token ] ; uint uni = balances [ msg . sender ] [ token ] ; if ( credit < amount ) { amount = credit ; } burn ( msg . sender , amount ) ; credit [ msg . sender ] [ token ] = credit [ msg . sender ] [ token ] . sub ( amount ) ; uint burned = uni . mul ( amount ) . div ( credit ) ; address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; IERC20 ( pair ) . safe Approve ( address ( UNI ) , 0 ) ; IERC20 ( pair ) . safe Approve ( address ( UNI ) , burned ) ; uint before = IERC20 ( pair ) . balance Of ( address ( this ) ) ; UNI . remove Liquidity ( token , address ( this ) , burned , 0 , 0 , address ( this ) , now . add ( 1800 ) ) ; uint after = IERC20 ( pair ) . balance Of ( address ( this ) ) ; burned = before . sub ( after ) ; if ( burned > uni ) { burned = uni ; } balances [ msg . sender ] [ token ] = balances [ msg . sender ] [ token ] . sub ( burned ) ; uint amount A = IERC20 ( token ) . balance Of ( address ( this ) ) ; uint amount B = balance Of ( address ( this ) ) ; burn ( address ( this ) , amount B ) ; Amount of a USD to burn ( value of A leaving the system ) burn ( address ( this ) , amount B ) ; IERC20 ( token ) . safe Transfer ( msg . sender , amount A ) ; emit Withdraw ( msg . sender , token , amount , amount B , amount A ) ;
function utilization ( address token , uint amount ) internal view returns ( uint ) { address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( this ) ) ; uint ratio = BASE . sub ( BASE . mul ( balance Of ( pair ) . add ( amount ) ) . div ( total Supply ( ) ) ) ; if ( ratio = = 0 ) { return MAX ; } return ratio > MAX ? MAX : ratio ;
function get Reward Per Block ( ) public view returns ( uint256 ) { return YFMB Token . balance Of ( reward Pool ) . div ( 6500 ) . div ( 10000 ) . mul ( daily Reward ) ;
function set Daily Reward ( uint256 daily Reward ) public only Owner { daily Reward = daily Reward ;
function get User Balance ( address staker ) public view returns ( uint256 amount Staked ) { return user Details [ staker ] . LP Deposited ;
function pending Rewards ( address staker ) public view returns ( uint256 ) { User storage user = user Details [ staker ] ; uint256 acc YFMB Per Share = acc YFMB Per Share ; if ( block . number > last Reward Block & & total Staked ! = 0 ) { uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 luco Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; acc YFMB Per Share = acc YFMB Per Share . add ( luco Reward . mul ( 1e18 ) . div ( total Staked ) ) ; } return user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ;
function update Pool ( ) public { if ( block . number < = last Reward Block ) { return ; } if ( total Staked = = 0 ) { last Reward Block = block . number ; return ; } uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 luco Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; YFMB Token . transfer From ( reward Pool , address ( this ) , luco Reward ) ; acc YFMB Per Share = acc YFMB Per Share . add ( luco Reward . mul ( 1e18 ) . div ( total Staked ) ) ; last Reward Block = block . number ; emit Pool Updated ( blocks To Reward , luco Reward , now ) ;
function stake LP ( uint256 amount ) public { require ( emergency Withdraw = = false , " emergency withdraw is on , cannot stake " ) ; require ( amount > 0 , " Can not stake 0 LP tokens " ) ; require ( LP Token . balance Of ( msg Sender ( ) ) > = amount , " Do not have enough LP tokens to stake " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; if ( user . LP Deposited > 0 ) { uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; if ( pending Rewards > 0 ) { YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ; } } LP Token . transfer From ( msg Sender ( ) , address ( this ) , amount ) ; user . LP Deposited = user . LP Deposited . add ( amount ) ; total Staked = total Staked . add ( amount ) ; user . reward Debt = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) ; emit Stake Completed ( msg Sender ( ) , amount , user . LP Deposited , now ) ;
function claim Rewards ( ) public { update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; require ( pending Rewards > 0 , " No rewards to claim ! " ) ; YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; user . reward Debt = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function unstake LP ( ) public { require ( emergency Withdraw = = true , " Can not withdraw " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; require ( user . LP Deposited > 0 , " User has no stake " ) ; uint256 pending Rewards = user . LP Deposited . mul ( acc YFMB Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; uint256 being Withdrawn = user . LP Deposited ; user . LP Deposited = 0 ; user . reward Debt = 0 ; total Staked = total Staked . sub ( being Withdrawn ) ; LP Token . transfer ( msg Sender ( ) , being Withdrawn ) ; YFMB Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Withdraw Completed ( msg Sender ( ) , being Withdrawn , now ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function turn Emergency Withdraw On ( ) public only Owner ( ) { require ( emergency Withdraw = = false , " emergency withdrawing already allowed " ) ; emergency Withdraw = true ; emit Emergency Withdraw On ( msg Sender ( ) , emergency Withdraw , now ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Treasury ( address address ) external only Governance { timelock Start = now ; timelock Type = 2 ; timelock address = address ;
function start Change Depositor Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 3 ; timelock data 1 = percent ;
function start Change Staking Pool ( address address ) external only Governance { timelock Start = now ; timelock Type = 4 ; timelock address = address ;
function start Change ZS Token ( address address ) external only Governance { timelock Start = now ; timelock Type = 5 ; timelock address = address ;
function start Change Stakers Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 6 ; timelock data 1 = percent ;
function gov Allow ( ) public only Owner { require ( is Allow = = false , " Already allowed " ) ; is Allow = true ;
function set Open Period ( uint256 new Start , uint256 new End ) public only Owner { open Period [ 0 ] = new Start ; open Period [ 1 ] = new End ;
function set Blocks Between ( uint256 new Value ) public only Owner { blocks Between = new Value ;
function enter ( uint256 amount ) public validate Grassland { uint256 total ERC20 = erc20 . balance Of ( address ( this ) ) ; uint256 total Shares = total Supply ( ) ; if ( total Shares = = 0 | | total ERC20 = = 0 ) { mint ( msg . sender , amount ) ; } else { uint256 what = amount . mul ( total Shares ) . div ( total ERC20 ) ; mint ( msg . sender , what ) ; } erc20 . transfer From ( msg . sender , address ( this ) , amount ) ; emit Joined ( msg . sender , amount ) ;
function leave ( uint256 share ) public validate Grassland { uint256 total Shares = total Supply ( ) ; uint256 what = share . mul ( erc20 . balance Of ( address ( this ) ) ) . div ( total Shares ) ; burn ( msg . sender , share ) ; erc20 . transfer ( msg . sender , what ) ; emit Left ( msg . sender , what ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function token Fallback ( address from , uint value , bytes calldata data ) external { address TOKEN = msg . sender ; if ( TOKEN = = address ( color Token ) ) { ( uint r , uint g , uint b ) = color Token . RGB Ratio ( THIS ) ; if ( value > life Force & & color Match ( r , g , b ) ) { carpet King = from ; life Force = value ; } this . burn Rugs ( THIS , 0 ) ; } else if ( TOKEN = = address ( Pi Z Za ) ) { ( uint r , uint g , uint b ) = Pi Z Za . RGB Ratio ( THIS ) ; if ( color Match ( r , g , b ) ) { age Of Pi Z Za = Pi Z Za . average buy In Time Sum ( THIS ) Pi Z Za . average eth Spent ( THIS ) ; Pi Z Za . transfer ( lamp Address , Pi Z Za . balance Of ( THIS ) , abi . encode Packed ( from ) ) ; } else { revert ( ) ; } } else if ( magic Lamp . of Rug ( TOKEN ) & & TOKEN ! = THIS ) { require ( value > 0 ) ; Rug Token ( TOKEN ) . transfer ( lamp Address , magic Lamp . rugs Of ( THIS , TOKEN ) , abi . encode Packed ( from ) ) ; } else { revert ( ) ; }
function transfer ( address to , uint value ) public virtual returns ( bool ) { bytes memory empty ; if ( is Contract ( to ) ) { return transfer To Contract ( to , value , empty ) ; } else { return transfer To Address ( to , value ) ; }
function transfer To Address ( address to , uint value ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function transfer To Contract ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; ERC223Receiving Contract receiver = ERC223Receiving Contract ( to ) ; receiver . token Fallback ( msg . sender , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function deposit ( uint256 amount ) public { uint256 total = value Of Vault And Strategy ( ) ; Get token equivalent at strategy and here if applicable uint256 total = value Of Vault And Strategy ( ) ; require ( deposits Open = = true , " Deposits have been suspended , but you can still withdraw " ) ; require ( current Strategy ! = Stabilize Strategy ( address ( 0 ) ) , " No strategy contract has been selected yet " ) ; uint256 before = underlying Asset . balance Of ( address ( this ) ) ; underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; Transfer token to this address underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; amount = underlying Asset . balance Of ( address ( this ) ) . sub ( before ) ; Some tokens lose amount ( transfer fee ) upon transfer amount = underlying Asset . balance Of ( address ( this ) ) . sub ( before ) ; require ( amount > 0 , " Cannot deposit 0 " ) ; uint256 strategy Balance = current Strategy . balance ( ) ; Will get the balance of the value of the main tokens at the strategy uint256 strategy Balance = current Strategy . balance ( ) ; underlying Asset . safe Transfer ( address ( current Strategy ) , amount ) ; Transfer again into the strategy underlying Asset . safe Transfer ( address ( current Strategy ) , amount ) ; current Strategy . deposit ( msg Sender ( ) ) ; Activate strategy deposit current Strategy . deposit ( msg Sender ( ) ) ; require ( current Strategy . balance ( ) > strategy Balance , " No change in strategy balance " ) ; Balance should increase require ( current Strategy . balance ( ) > strategy Balance , " No change in strategy balance " ) ; uint256 mint Amount = amount ; if ( total Supply ( ) > 0 ) { mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; Our share of the total mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; } mint ( msg Sender ( ) , mint Amount ) ; Now mint new zs token to the depositor mint ( msg Sender ( ) , mint Amount ) ; emit Wrapped ( msg Sender ( ) , amount ) ;
function stop Deposits ( ) external only Governance { deposits Open = false ;
function emergency Stop Strategy ( ) external only Governance { deposits Open = false ; if ( current Strategy ! = Stabilize Strategy ( address ( 0 ) ) & & total Supply ( ) > 0 ) { current Strategy . exit ( ) ; Pulls all the tokens and accessory tokens from the strategy current Strategy . exit ( ) ; } current Strategy = Stabilize Strategy ( address ( 0 ) ) ; timelock Type = 0 ; Prevent governance from changing to new strategy without timelock timelock Type = 0 ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Strategy ( address address ) external only Governance { timelock Start = now ; timelock Type = 2 ; timelock address = address ; pending Strategy = address ; if ( total Supply ( ) = = 0 ) { finish Change Strategy ( ) ; }
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function burn ( uint256 amount ) public { burn ( msg . sender , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Channel Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Channel ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Channel Per Share = pool . acc Channel Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 channel Reward = multiplier . mul ( channel Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Channel Per Share = acc Channel Per Share . add ( channel Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Channel Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { if ( channel . total Supply ( ) < max Channel Supply ) { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 channel Reward = multiplier . mul ( channel Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; channel . mint ( devaddr , channel Reward . div ( 10 ) ) ; channel . mint ( address ( this ) , channel Reward ) ; pool . acc Channel Per Share = pool . acc Channel Per Share . add ( channel Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ; }
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Channel Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Channel Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Channel Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Channel Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Channel Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Channel Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Channel Transfer ( address to , uint256 amount ) internal { uint256 channel Bal = channel . balance Of ( address ( this ) ) ; if ( channel . total Supply ( ) > = max Channel Supply ) { return ; } if ( amount > channel Bal ) { channel . transfer ( to , channel Bal ) ; } else { channel . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function set Channel Per Block ( uint256 channel Per Block ) public only Owner { mass Update Pools ( ) ; channel Per Block = channel Per Block ;
function set Max Channel Supply ( uint256 max Channel Supply ) public only Owner { mass Update Pools ( ) ; require ( channel . total Supply ( ) < max Channel Supply , " set Max Channel Supply : less than current OCT supply " ) ; max Channel Supply = max Channel Supply ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function update User Distribution Rule ( uint256 pid , uint256 [ ] memory percent Array , uint256 [ ] memory days Array ) external { require ( percent Array . length = = days Array . length , " LM " ) ; LENGTH MISMATCH require ( percent Array . length = = days Array . length , " LM " ) ; check Update Allowed ( pid ) ; require ( check Sum Array ( percent Array ) , " SE " ) ; SUM OF PERCENT INVALID require ( check Sum Array ( percent Array ) , " SE " ) ; require ( check Valid Days Array ( days Array ) , " DMI " ) ; DAYS SHOULD BE MONOTONIICALLY INCREASING require ( check Valid Days Array ( days Array ) , " DMI " ) ; user Dist Info [ pid ] = Distribution Info ( { percent Array : percent Array , days Array : days Array } ) ;
function update Owner Distribution Rule ( uint256 pid , uint256 [ ] memory percent Array , uint256 [ ] memory days Array ) external { require ( percent Array . length = = days Array . length , " LM " ) ; LENGTH MISMATCH require ( percent Array . length = = days Array . length , " LM " ) ; check Update Allowed ( pid ) ; require ( check Sum Array ( percent Array ) , " SE " ) ; SUM OF PERCENT INVALID require ( check Sum Array ( percent Array ) , " SE " ) ; require ( check Valid Days Array ( days Array ) , " DMI " ) ; DAYS SHOULD BE MONOTONIICALLY INCREASING require ( check Valid Days Array ( days Array ) , " DMI " ) ; owner Dist Info [ pid ] = Distribution Info ( { percent Array : percent Array , days Array : days Array } ) ;
function lock Pool ( uint256 pid ) external { require ( pool Info [ pid ] . payment Method Added = = true , " CP " ) ; CHECK PAYMENT METHOD FAILED require ( pool Info [ pid ] . payment Method Added = = true , " CP " ) ; check Update Allowed ( pid ) ; pool Info [ pid ] . update Locked = true ;
function add Supported Currencies ( uint256 pid , address token Raise , uint256 rate Token ) external { check Update Allowed ( pid ) ; require ( rate Token ! = 0 , " IR " ) ; INVALID RATE require ( rate Token ! = 0 , " IR " ) ; require ( token Raise ! = address ( pool Info [ pid ] . raise Token ) , " IT " ) ; INVALIID PURCHASE TOKEN require ( token Raise ! = address ( pool Info [ pid ] . raise Token ) , " IT " ) ; if ( sale Rate Info [ pid ] [ token Raise ] = = 0 ) { list Supported Currencies [ pid ] . push ( token Raise ) ; } sale Rate Info [ pid ] [ token Raise ] = rate Token ; pool Info [ pid ] . payment Method Added = true ;
function check Deposit Allowed ( uint256 pid , address token Add , uint256 amt ) internal view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; uint256 user Bought = user Token Allocation [ pid ] [ msg Sender ( ) ] ; uint256 purchase Possible = tokens Purchase Amt ( pid , token Add , amt ) ; require ( pool . balance Added = = true , " NA " ) ; NOT AVAILABLE require ( pool . balance Added = = true , " NA " ) ; require ( pool . start Block < = block . number , " NT1 " ) ; NOT AVAILABLE TIME 1 require ( pool . start Block < = block . number , " NT1 " ) ; require ( pool . end Block > = block . number , " NT2 " ) ; NOT AVAILABLE TIME 2 require ( pool . end Block > = block . number , " NT2 " ) ; require ( pool . total Tokens Sold . add ( purchase Possible ) < = pool . total Tokens On Sale , " PLE " ) ; POOL LIMIT EXCEEDED require ( pool . total Tokens Sold . add ( purchase Possible ) < = pool . total Tokens On Sale , " PLE " ) ; require ( user Bought . add ( purchase Possible ) < = pool . max Tokens Per Person , " ILE " ) ; INDIVIDUAL LIMIT EXCEEDED require ( user Bought . add ( purchase Possible ) < = pool . max Tokens Per Person , " ILE " ) ; return purchase Possible ;
function get Max Deposit Allowed ( uint256 pid , address token Add , address user ) external view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; uint256 max Buy Possible = ( pool . max Tokens Per Person ) . sub ( user Token Allocation [ pid ] [ user ] ) ; uint256 max Buy Possible Pool Limit = ( pool . total Tokens On Sale ) . sub ( pool . total Tokens Sold ) ; if ( max Buy Possible Pool Limit < max Buy Possible ) { max Buy Possible = max Buy Possible Pool Limit ; } if ( block . number > = pool . start Block & & block . number < = pool . end Block & & pool . balance Added = = true ) { uint256 rate Token = sale Rate Info [ pid ] [ token Add ] ; return ( max Buy Possible . mul ( rate Token ) . div ( 1e18 ) ) ; } else { return 0 ; }
function check Deposit Enabled ( uint256 pid ) external view returns ( bool ) { Raise Pool Info storage pool = pool Info [ pid ] ; if ( pool . balance Added = = true & & pool . start Block < = block . number & & pool . end Block > = block . number & & pool . total Tokens Sold < = pool . total Tokens On Sale & & pool . payment Method Added = = true ) { return true ; } else { return false ; }
function deposit ICO Tokens ( uint256 pid , uint256 amount , IERC20 token Add ) external { Raise Pool Info storage pool = pool Info [ pid ] ; address msg Sender = msg Sender ( ) ; require ( token Add = = pool . raise Token , " NOT " ) ; NOT VALID TOKEN require ( token Add = = pool . raise Token , " NOT " ) ; require ( msg Sender = = pool . owner , " NAU " ) ; NOT AUTHORISED USER require ( msg Sender = = pool . owner , " NAU " ) ; require ( block . number < pool . end Block , " NT " ) ; No point adding tokens after sale has ended Possible deadlock case require ( block . number < pool . end Block , " NT " ) ; token Add . safe Transfer From ( msg Sender , address ( this ) , amount ) ; pool . tokens Deposited = ( pool . tokens Deposited ) . add ( amount ) ; if ( pool . tokens Deposited > = pool . total Tokens On Sale ) { pool . balance Added = true ; } emit Deposit ( msg Sender , pid , amount ) ;
function deposit Airdrop Tokens ( uint256 pid , uint256 amount , IERC20 token Add ) external { Raise Pool Info storage pool = pool Info [ pid ] ; require ( block . number < pool . end Block , " NT " ) ; NOT VALID TIME require ( block . number < pool . end Block , " NT " ) ; Airdrop Pool Info storage airdrop = airdrop Info [ pid ] ; require ( ( token Add = = airdrop . airdrop Token | | airdrop . airdrop Exists = = false ) , " NOT " ) ; NOT VALID TOKEN require ( ( token Add = = airdrop . airdrop Token | | airdrop . airdrop Exists = = false ) , " NOT " ) ; require ( msg Sender ( ) = = pool . owner | | msg Sender ( ) = = devaddr , " NAU " ) ; NOT AUTHORISED USER require ( msg Sender ( ) = = pool . owner | | msg Sender ( ) = = devaddr , " NAU " ) ; token Add . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; airdrop . total Tokens Available = ( airdrop . total Tokens Available ) . add ( amount ) ; if ( ! airdrop . airdrop Exists ) { airdrop . airdrop Token = token Add ; airdrop . airdrop Exists = true ; } emit Airdrop Deposit ( msg Sender ( ) , address ( token Add ) , pid , amount ) ;
function withdraw Extra Airdrop Tokens ( uint256 pid ) external { require ( extra Airdrop Claimed [ pid ] = = false , " NA " ) ; NOT AVAILABLE require ( extra Airdrop Claimed [ pid ] = = false , " NA " ) ; Raise Pool Info storage pool = pool Info [ pid ] ; require ( block . number > pool . end Block , " NSE " ) ; SALE NOT ENDED require ( block . number > pool . end Block , " NSE " ) ; address msg Sender = msg Sender ( ) ; require ( msg Sender = = pool . owner , " NAU " ) ; NOT AUTHORISED USER require ( msg Sender = = pool . owner , " NAU " ) ; uint256 extra Tokens = calculate Extra Airdrop Tokens ( pid ) ; require ( extra Tokens ! = 0 , " NAT " ) ; NOT AVAILABLE TOKEN require ( extra Tokens ! = 0 , " NAT " ) ; extra Airdrop Claimed [ pid ] = true ; airdrop Info [ pid ] . airdrop Token . safe Transfer ( msg Sender , extra Tokens ) ; emit Airdrop Extra Withdraw ( msg . sender , address ( airdrop Info [ pid ] . airdrop Token ) , pid , extra Tokens ) ;
function stake LP Tokens ( uint256 pid , uint256 amount , IERC20 lp Add ) external { require ( staking Enabled [ address ( lp Add ) ] = = true , " NST " ) ; NOT STAKING TOKEN require ( staking Enabled [ address ( lp Add ) ] = = true , " NST " ) ; Raise Pool Info storage pool = pool Info [ pid ] ; require ( block . number < pool . start Block , " NT " ) ; NOT VALID TIME require ( block . number < pool . start Block , " NT " ) ; address msg Sender = msg Sender ( ) ; lp Add . safe Transfer From ( msg Sender , address ( this ) , amount ) ; staked LP Tokens Info [ pid ] [ address ( lp Add ) ] = ( staked LP Tokens Info [ pid ] [ address ( lp Add ) ] ) . add ( amount ) ; user Stake Info [ pid ] [ msg Sender ] [ address ( lp Add ) ] = ( user Stake Info [ pid ] [ msg Sender ] [ address ( lp Add ) ] ) . add ( amount ) ; emit Stake ( msg . sender , address ( lp Add ) , pid , amount ) ;
function withdraw LP Tokens ( uint256 pid , uint256 amount , IERC20 lp Add ) external { require ( staking Enabled [ address ( lp Add ) ] = = true , " NAT " ) ; NOT AUTHORISED TOKEN require ( staking Enabled [ address ( lp Add ) ] = = true , " NAT " ) ; Raise Pool Info storage pool = pool Info [ pid ] ; require ( block . number > pool . end Block , " SE " ) ; SALE NOT ENDED require ( block . number > pool . end Block , " SE " ) ; address msg Sender = msg Sender ( ) ; claim Reward And Airdrop ( pid ) ; user Stake Info [ pid ] [ msg Sender ] [ address ( lp Add ) ] = ( user Stake Info [ pid ] [ msg Sender ] [ address ( lp Add ) ] ) . sub ( amount ) ; lp Add . safe Transfer ( msg Sender , amount ) ; emit Un Stake ( msg . sender , address ( lp Add ) , pid , amount ) ;
function withdraw Airdrop Tokens ( IERC20 token , uint256 amount ) external { address msg Sender = msg Sender ( ) ; airdrop Balances [ address ( token ) ] [ msg Sender ] = ( airdrop Balances [ address ( token ) ] [ msg Sender ] ) . sub ( amount ) ; token . safe Transfer ( msg Sender , amount ) ; emit Withdraw Airdrop ( msg Sender , address ( token ) , amount ) ;
function move LP Tokens ( uint256 pid , uint256 newpid , uint256 amount , address lp Add ) external { require ( staking Enabled [ lp Add ] = = true , " NAT1 " ) ; NOT AUTHORISED TOKEN 1 require ( staking Enabled [ lp Add ] = = true , " NAT1 " ) ; Raise Pool Info storage pool Old = pool Info [ pid ] ; Raise Pool Info storage pool New = pool Info [ newpid ] ; require ( block . number > pool Old . end Block , " NUA " ) ; OLD SALE NOT ENDED require ( block . number > pool Old . end Block , " NUA " ) ; require ( block . number < pool New . start Block , " NSA " ) ; SALE START CHECK FAILED require ( block . number < pool New . start Block , " NSA " ) ; address msg Sender = msg Sender ( ) ; claim Reward And Airdrop ( pid ) ; user Stake Info [ pid ] [ msg Sender ] [ lp Add ] = ( user Stake Info [ pid ] [ msg Sender ] [ lp Add ] ) . sub ( amount ) ; user Stake Info [ newpid ] [ msg Sender ] [ lp Add ] = ( user Stake Info [ newpid ] [ msg Sender ] [ lp Add ] ) . add ( amount ) ; emit Move Stake ( msg . sender , lp Add , pid , newpid , amount ) ;
function deposit Reserve ICO Tokens ( uint256 pid , uint256 amount , IERC20 token Add , address res Add ) external { Raise Pool Info storage pool = pool Info [ pid ] ; Use Case Pool Info storage pool U = use Case Info [ pid ] [ res Add ] ; address msg Sender = msg Sender ( ) ; require ( token Add = = pool . raise Token , " NOT " ) ; NOT AUTHORISED TOKEN require ( token Add = = pool . raise Token , " NOT " ) ; require ( msg Sender = = pool . owner , " NAU " ) ; NOT AUTHORISED USER require ( msg Sender = = pool . owner , " NAU " ) ; require ( pool U . tokens Deposited = = false , " DR " ) ; TOKENS NOT DEPOSITED require ( pool U . tokens Deposited = = false , " DR " ) ; require ( pool U . tokens Allocated = = amount & & amount ! = 0 , " NA " ) ; NOT AVAILABLE require ( pool U . tokens Allocated = = amount & & amount ! = 0 , " NA " ) ; require ( block . number < pool . end Block , " CRN " ) ; CANNOT RESERVE NOW to avoid deadlocks require ( block . number < pool . end Block , " CRN " ) ; token Add . safe Transfer From ( msg Sender , address ( this ) , amount ) ; total Token Reserved [ pid ] = ( total Token Reserved [ pid ] ) . add ( amount ) ; pool U . tokens Deposited = true ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw Extra ICO Tokens ( uint256 pid , uint256 amount , IERC20 token Add ) external { Raise Pool Info storage pool = pool Info [ pid ] ; address msg Sender = msg Sender ( ) ; require ( token Add = = pool . raise Token , " NT " ) ; NOT AUTHORISED TOKEN require ( token Add = = pool . raise Token , " NT " ) ; require ( msg Sender = = pool . owner , " NAU " ) ; NOT AUTHORISED USER require ( msg Sender = = pool . owner , " NAU " ) ; require ( block . number > pool . end Block , " NA " ) ; NOT AVAILABLE TIME require ( block . number > pool . end Block , " NA " ) ; uint256 amt Avail = pool . tokens Deposited . sub ( pool . total Tokens Sold ) ; require ( amt Avail > = amount , " NAT " ) ; NOT AVAILABLE TOKEN require ( amt Avail > = amount , " NAT " ) ; pool . tokens Deposited = ( pool . tokens Deposited ) . sub ( amount ) ; token Add . safe Transfer ( msg Sender , amount ) ; emit Withdraw ( msg Sender , pid , amount ) ;
function fetch Extra ICO Tokens ( uint256 pid ) external view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; return pool . tokens Deposited . sub ( pool . total Tokens Sold ) ;
function deposit ( uint256 pid , uint256 amount , IERC20 token Add ) external { address msg Sender = msg Sender ( ) ; uint256 buy This Step = check Deposit Allowed ( pid , address ( token Add ) , amount ) ; token Add . safe Transfer From ( msg Sender , address ( this ) , amount ) ; user Deposit Info [ pid ] [ msg Sender ] [ address ( token Add ) ] = user Deposit Info [ pid ] [ msg Sender ] [ address ( token Add ) ] . add ( amount ) ; user Token Allocation [ pid ] [ msg Sender ] = user Token Allocation [ pid ] [ msg Sender ] . add ( buy This Step ) ; pool Info [ pid ] . total Tokens Sold = pool Info [ pid ] . total Tokens Sold . add ( buy This Step ) ; funds Raised So Far [ pid ] [ address ( token Add ) ] = funds Raised So Far [ pid ] [ address ( token Add ) ] . add ( amount ) ; emit Deposit ( msg . sender , pid , amount ) ;
function vote Project ( uint256 pid ) external { address msg Sender = msg Sender ( ) ; require ( user Votes [ pid ] [ msg Sender ] = = false , " AVO " ) ; ALREADY VOTED require ( user Votes [ pid ] [ msg Sender ] = = false , " AVO " ) ; require ( pool Info [ pid ] . end Block > = block . number , " CVO " ) ; CANNOT VOTE NOW require ( pool Info [ pid ] . end Block > = block . number , " CVO " ) ; user Votes [ pid ] [ msg Sender ] = true ; pool Info [ pid ] . votes = ( pool Info [ pid ] . votes ) . add ( 1 ) ; emit Voted ( msg Sender , pid ) ;
function amount Avail To Withdraw User ( uint256 pid , address user ) public view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; if ( pool . end Block < block . number ) { uint256 percent Avail = get Percent Available ( pid , pool . end Block ) ; return ( ( percent Avail ) . mul ( user Token Allocation [ pid ] [ user ] ) . div ( 10000 ) ) . sub ( user Token Claimed [ pid ] [ user ] ) ; } else { return 0 ; }
function withdraw User ( uint256 pid , uint256 amount ) external { Raise Pool Info storage pool = pool Info [ pid ] ; address msg Sender = msg Sender ( ) ; uint256 amt Avail = amount Avail To Withdraw User ( pid , msg Sender ) ; require ( amt Avail > = amount , " NAT " ) ; NOT AUTHORISED TOKEN require ( amt Avail > = amount , " NAT " ) ; user Token Claimed [ pid ] [ msg Sender ] = user Token Claimed [ pid ] [ msg Sender ] . add ( amount ) ; total Token Claimed [ pid ] = total Token Claimed [ pid ] . add ( amount ) ; pool . raise Token . safe Transfer ( msg Sender , amount ) ; emit Withdraw ( msg Sender , pid , amount ) ;
function amount Avail To Withdraw Fund Raiser ( uint256 pid , IERC20 token Add ) public view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; if ( pool . end Block < block . number ) { uint256 percent Avail = get Percent Available Fund Raiser ( pid , pool . end Block ) ; return ( ( ( percent Avail ) . mul ( funds Raised So Far [ pid ] [ address ( token Add ) ] ) . div ( 10000 ) ) ) . sub ( funds Claimed So Far [ pid ] [ address ( token Add ) ] ) ; } else { return 0 ; }
function amount Avail To Withdraw Reserve ( uint256 pid , address res Add ) public view returns ( uint256 ) { Raise Pool Info storage pool = pool Info [ pid ] ; Use Case Pool Info storage pool U = use Case Info [ pid ] [ res Add ] ; if ( pool . end Block < block . number ) { uint256 percent Avail = get Percent Available Reserve ( pid , pool . end Block , res Add ) ; return ( ( percent Avail ) . mul ( pool U . tokens Allocated ) . div ( 10000 ) ) . sub ( pool U . tokens Claimed ) ; } else { return 0 ; }
function withdraw Reserve ICO Tokens ( uint256 pid , uint256 amount , IERC20 token Add ) external { Use Case Pool Info storage pool U = use Case Info [ pid ] [ msg Sender ( ) ] ; require ( pool U . reserve Add = = msg Sender ( ) , " NAUTH " ) ; NOT AUTHORISED USER require ( pool U . reserve Add = = msg Sender ( ) , " NAUTH " ) ; require ( token Add = = pool Info [ pid ] . raise Token , " NT " ) ; NOT AUTHORISED TOKEN require ( token Add = = pool Info [ pid ] . raise Token , " NT " ) ; uint256 amt Avail = amount Avail To Withdraw Reserve ( pid , msg Sender ( ) ) ; require ( amt Avail > = amount , " NAT " ) ; NOT AVAILABLE USER require ( amt Avail > = amount , " NAT " ) ; pool U . tokens Claimed = pool U . tokens Claimed . add ( amount ) ; total Token Reserved [ pid ] = total Token Reserved [ pid ] . sub ( amount ) ; total Reserved Token Claimed [ pid ] = total Reserved Token Claimed [ pid ] . add ( amount ) ; token Add . safe Transfer ( msg Sender ( ) , amount ) ; emit Withdraw ( msg Sender ( ) , pid , amount ) ;
function withdraw Fund Raiser ( uint256 pid , uint256 amount , IERC20 token Address ) external { Raise Pool Info storage pool = pool Info [ pid ] ; require ( pool . owner = = msg Sender ( ) , " NAUTH " ) ; NOT AUTHORISED USER require ( pool . owner = = msg Sender ( ) , " NAUTH " ) ; uint256 amt Avail = amount Avail To Withdraw Fund Raiser ( pid , token Address ) ; require ( amt Avail > = amount , " NAT " ) ; NOT AUTHORISED TOKEN require ( amt Avail > = amount , " NAT " ) ; uint256 fee = ( ( amount ) . mul ( fee ) ) . div ( 1e4 ) ; uint256 actual Transfer = amt Avail . sub ( fee ) ; uint256 fee Dev = ( fee ) . mul ( 10000 reward Per ) . div ( 1e4 ) ; Remaining tokens for reward mining uint256 fee Dev = ( fee ) . mul ( 10000 reward Per ) . div ( 1e4 ) ; funds Claimed So Far [ pid ] [ address ( token Address ) ] = funds Claimed So Far [ pid ] [ address ( token Address ) ] . add ( amount ) ; token Address . safe Transfer ( msg Sender ( ) , actual Transfer ) ; token Address . safe Transfer ( devaddr , fee Dev ) ; emit Withdraw ( msg Sender ( ) , pid , actual Transfer ) ; emit Withdraw ( devaddr , pid , fee Dev ) ;
function change Dev ( address newowner ) external only Admin { potential Admin = newowner ;
function change Pool Owner ( uint256 pid , address newowner ) external { require ( msg Sender ( ) = = pool Info [ pid ] . owner , " OA " ) ; NOT AUTHORISED USER require ( msg Sender ( ) = = pool Info [ pid ] . owner , " OA " ) ; temp Admin [ pid ] = newowner ;
function become Pool Owner ( uint256 pid ) external { if ( temp Admin [ pid ] = = msg Sender ( ) ) pool Info [ pid ] . owner = msg Sender ( ) ;
function change Fee ( uint256 fee ) external only Admin { require ( fee < = 300 , " MAX3 " ) ; MAX FEE POSSIBLE require ( fee < = 300 , " MAX3 " ) ; fee = fee ;
function generate New Code ( address token , address pool Owner ) external only Admin Or Time Lock returns ( uint256 ) { uint256 invite Code = block . number ; invite Code List [ invite Code ] [ token ] [ pool Owner ] = true ; return invite Code ;
function invalidate Old Code ( uint256 invite Code , address token , address pool Owner ) external only Admin { invite Code List [ invite Code ] [ token ] [ pool Owner ] = false ;
function add Staking Pool ( address token , uint256 weight ) external only Admin { if ( staking Enabled [ token ] = = false ) { staking Pools . push ( token ) ; staking Enabled [ token ] = true ; } total Stake Weight = total Stake Weight . sub ( staking Weight [ token ] ) . add ( weight ) ; staking Weight [ token ] = weight ;
function transfer ( address to , uint value ) public override returns ( bool success ) { transfer ( msg . sender , to , value ) ; return true ;
function approve ( address spender , uint value ) public override returns ( bool success ) { allowance [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ;
function transfer From ( address from , address to , uint value ) public override returns ( bool success ) { require ( value < = allowance [ from ] [ msg . sender ] , ' Must not send more than allowance ' ) ; allowance [ from ] [ msg . sender ] = value ; transfer ( from , to , value ) ; return true ;
function transfer ( address from , address to , uint value ) private { messagesender = msg . sender ; this is the person actually making the call on this function messagesender = msg . sender ; require ( balance Of [ from ] > = value , ' Must not send more than balance ' ) ; require ( balance Of [ to ] + value > = balance Of [ to ] , ' Balance overflow ' ) ; balance Of [ from ] = value ; if ( Address Whitelisted [ msg . sender ] ) { if the person making the transaction is whitelisted , the no burn on the transaction if ( Address Whitelisted [ msg . sender ] ) { actual Value = value ; } else { bp Value = mul Div ( value , 15 , 10000 ) ; this is 0 . 15 % for basis point bp Value = mul Div ( value , 15 , 10000 ) ; actual Value = value bp Value ; this is the amount to be sent actual Value = value bp Value ; balance Of [ address ( this ) ] + = bp Value ; this is adding the basis point charged to this contract balance Of [ address ( this ) ] + = bp Value ; emit Transfer ( from , address ( this ) , bp Value ) ; BPE + = bp Value ; this is increasing the virtual basis point amount BPE + = bp Value ; emit Basis Point Added ( bp Value ) ; } if ( emission Whitelisted [ messagesender ] = = false ) { this is so that staking and unstaking will not trigger the emission if ( emission Whitelisted [ messagesender ] = = false ) { if ( now > = next Day Time ) { amount To Emit = emitting Amount ( ) ; pool1Amount = mul Div ( amount To Emit , pool1percentage , 10000 ) ; pool2Amount = mul Div ( amount To Emit , pool2percentage , 10000 ) ; pool3Amount = mul Div ( amount To Emit , pool3percentage , 10000 ) ; pool4Amount = mul Div ( amount To Emit , pool4percentage , 10000 ) ; pool Amount Trig = mul Div ( amount To Emit , trig Rewardpercentage , 10000 ) ; Trig Amount = pool Amount Trig . div ( 2 ) ; pool1Amount = pool1Amount . sub ( Trig Amount ) ; pool2Amount = pool2Amount . sub ( Trig Amount ) ; Trig Reward = pool Amount Trig ; uint Ofrozenamount = ospfrozen ( ) ; uint Dfrozenamount = dspfrozen ( ) ; uint Ufrozenamount = uspfrozen ( ) ; uint Afrozenamount = aspfrozen ( ) ; if ( Ofrozenamount > 0 ) { OSP ( Oracle Pool ) . scaled Token ( pool4Amount ) ; balance Of [ Oracle Pool ] + = pool4Amount ; emit Transfer ( address ( this ) , Oracle Pool , pool4Amount ) ; } else { balance Of [ address ( this ) ] + = pool4Amount ; emit Transfer ( address ( this ) , address ( this ) , pool4Amount ) ; BPE + = pool4Amount ; } if ( Dfrozenamount > 0 ) { DSP ( Defi Pool ) . scaled Token ( pool3Amount ) ; balance Of [ Defi Pool ] + = pool3Amount ; emit Transfer ( address ( this ) , Defi Pool , pool3Amount ) ; } else { balance Of [ address ( this ) ] + = pool3Amount ; emit Transfer ( address ( this ) , address ( this ) , pool3Amount ) ; BPE + = pool3Amount ; } if ( Ufrozenamount > 0 ) { USP ( swap Pool ) . scaled Token ( pool2Amount ) ; balance Of [ swap Pool ] + = pool2Amount ; emit Transfer ( address ( this ) , swap Pool , pool2Amount ) ; } else { balance Of [ address ( this ) ] + = pool2Amount ; emit Transfer ( address ( this ) , address ( this ) , pool2Amount ) ; BPE + = pool2Amount ; } if ( Afrozenamount > 0 ) { ASP ( lone Pool ) . scaled Token ( pool1Amount ) ; balance Of [ lone Pool ] + = pool1Amount ; emit Transfer ( address ( this ) , lone Pool , pool1Amount ) ; } else { balance Of [ address ( this ) ] + = pool1Amount ; emit Transfer ( address ( this ) , address ( this ) , pool1Amount ) ; BPE + = pool1Amount ; } next Day Time + = seconds Per Day ; current Day + = 1 ; emit New Day ( current Epoch , current Day , next Day Time ) ; balance Of [ from ] + = Trig Reward ; this is rewardig the person that triggered the emission balance Of [ from ] + = Trig Reward ; emit Transfer ( address ( this ) , from , Trig Reward ) ; emit Trig Reward Event ( address ( this ) , msg . sender , Trig Reward ) ; } } balance Of [ to ] + = actual Value ; emit Transfer ( from , to , actual Value ) ;
function ( ) public payable { emit Funded ( address ( this ) . balance ) ;
function get Owners ( ) public constant returns ( address [ ] ) { return owners ;
function generate Message To Sign ( address erc20Contract , address destination , uint256 value ) public constant returns ( bytes32 ) { require ( destination ! = address ( this ) ) ; bytes32 message = keccak256 ( this , erc20Contract , destination , value , spend Nonce ) ; return message ;
function spend ERC20 ( address destination , address erc20contract , uint256 value , uint8 [ ] vs , bytes32 [ ] rs , bytes32 [ ] ss ) public { require ( valid Signature ( erc20contract , destination , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; Erc20 ( erc20contract ) . transfer ( destination , value ) ; emit Spent Erc20 ( erc20contract , destination , value ) ;
function compound Action ( address c Erc20Contract , address erc20contract , uint256 value , uint8 [ ] vs , bytes32 [ ] rs , bytes32 [ ] ss ) public { C Eth eth Token ; C Erc20 erc20Token ; if ( erc20contract = = 0x0000000000000000000000000000000000000001 ) { require ( valid Signature ( erc20contract , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; eth Token = C Eth ( c Erc20Contract ) ; eth Token . mint . value ( value ) . gas ( 250000 ) ( ) ; } else if ( erc20contract = = 0x0000000000000000000000000000000000000003 ) { require ( valid Signature ( erc20contract , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; eth Token = C Eth ( c Erc20Contract ) ; eth Token . redeem ( value ) ; } else if ( erc20contract = = 0x0000000000000000000000000000000000000004 ) { require ( valid Signature ( erc20contract , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; erc20Token = C Erc20 ( c Erc20Contract ) ; erc20Token . redeem ( value ) ; } else if ( erc20contract = = 0x0000000000000000000000000000000000000005 ) { require ( valid Signature ( erc20contract , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; eth Token = C Eth ( c Erc20Contract ) ; eth Token . redeem Underlying ( value ) ; } else if ( erc20contract = = 0x0000000000000000000000000000000000000006 ) { require ( valid Signature ( erc20contract , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; erc20Token = C Erc20 ( c Erc20Contract ) ; erc20Token . redeem Underlying ( value ) ; } else { require ( valid Signature ( 0x0000000000000000000000000000000000000002 , c Erc20Contract , value , vs , rs , ss ) ) ; spend Nonce = spend Nonce + 1 ; Erc20 underlying = Erc20 ( erc20contract ) ; erc20Token = C Erc20 ( c Erc20Contract ) ; underlying . approve ( c Erc20Contract , value ) ; erc20Token . mint ( value ) ; }
function valid Signature ( address erc20Contract , address destination , uint256 value , uint8 [ ] vs , bytes32 [ ] rs , bytes32 [ ] ss ) private constant returns ( bool ) { require ( vs . length = = rs . length ) ; require ( rs . length = = ss . length ) ; require ( vs . length < = owners . length ) ; require ( vs . length > = required ) ; bytes32 message = message To Recover ( erc20Contract , destination , value ) ; address [ ] memory addrs = new address [ ] ( vs . length ) ; for ( uint i = 0 ; i < vs . length ; i + + ) { addrs [ i ] = ecrecover ( message , vs [ i ] + 27 , rs [ i ] , ss [ i ] ) ; } require ( distinct Owners ( addrs ) ) ; return true ;
function distinct Owners ( address [ ] addrs ) private constant returns ( bool ) { if ( addrs . length > owners . length ) { return false ; } for ( uint i = 0 ; i < addrs . length ; i + + ) { if ( ! is Owner [ addrs [ i ] ] ) { return false ; } for ( uint j = 0 ; j < i ; j + + ) { if ( addrs [ i ] = = addrs [ j ] ) { return false ; } } } return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function reward Token ( Victim victim ) external view returns ( IERC20 ) { ( bool success , bytes memory result ) = address ( victim ) . staticcall ( abi . encode With Signature ( " reward Token ( ) " ) ) ; require ( success , " reward Token ( ) staticcall failed . " ) ; return abi . decode ( result , ( IERC20 ) ) ;
function sell Reward For Weth ( Victim victim , uint256 reward Amount , address to ) external returns ( uint256 ) { ( bool success , bytes memory result ) = address ( victim ) . delegatecall ( abi . encode With Signature ( " sell Reward For Weth ( address , uint256 , address ) " , address ( victim ) , reward Amount , to ) ) ; require ( success , " sell Reward For Weth ( uint256 reward Amount , address to ) delegatecall failed . " ) ; return abi . decode ( result , ( uint256 ) ) ;
function lockable Token ( Victim victim , uint256 pool Id ) external view returns ( IERC20 ) { ( bool success , bytes memory result ) = address ( victim ) . staticcall ( abi . encode With Signature ( " lockable Token ( uint256 ) " , pool Id ) ) ; require ( success , " lockable Token ( uint256 pool Id ) staticcall failed . " ) ; return abi . decode ( result , ( IERC20 ) ) ;
function deposit ( Victim victim , uint256 pool Id , uint256 amount ) external { ( bool success , ) = address ( victim ) . delegatecall ( abi . encode With Signature ( " deposit ( address , uint256 , uint256 ) " , address ( victim ) , pool Id , amount ) ) ; require ( success , " deposit ( uint256 pool Id , uint256 amount ) delegatecall failed . " ) ;
function pool Address ( Victim victim , uint256 pool Id ) external view returns ( address ) { ( bool success , bytes memory result ) = address ( victim ) . staticcall ( abi . encode With Signature ( " pool Address ( uint256 ) " , pool Id ) ) ; require ( success , " pool Address ( uint256 pool Id ) staticcall failed . " ) ; return abi . decode ( result , ( address ) ) ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) , " spender address is a zero address " ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function decimals ( ) external pure returns ( uint8 ) { return uint8 ( 9 ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; require ( want ! = address ( asset ) , " want " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function add Liquidity ( ) internal { uint [ 3 ] memory amounts ; amounts [ 0 ] = IERC20 ( dai ) . balance Of ( address ( this ) ) ; amounts [ 1 ] = IERC20 ( usdc ) . balance Of ( address ( this ) ) ; amounts [ 2 ] = IERC20 ( usdt ) . balance Of ( address ( this ) ) ; stable Swap3Pool . add liquidity ( amounts , 1 ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ;
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; Proposal storage proposal = proposals [ proposal Queue [ proposal Index ] ] ; require ( uint Vote < 3 , " ! < 3 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes + = member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Supply ( ) > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Supply ( ) ; } } else if ( vote = = Vote . No ) { proposal . no Votes + = member . shares ; } emit Submit Vote ( proposal Queue [ proposal Index ] , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) external non Reentrant { Proposal storage proposal = proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] = = 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] = = 0 , " cancelled " ) ; require ( msg . sender = = proposal . proposer , " ! proposer " ) ; proposal . flags [ 3 ] = 1 ; cancelled proposal . flags [ 3 ] = 1 ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] = = 1 ;
function decimals ( ) public view returns ( uint256 ) { return decimals ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external non Reentrant { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public non Reentrant { uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function multi Transfer Equal Amount ( address [ ] memory receivers , uint256 amount ) public { uint256 amount With Decimals = amount 10 token Decimals ; for ( uint256 i = 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amount With Decimals ) ; }
function withdraw Unclaimed Tokens ( address contract Unclaimed ) external only Owner { current Token = IERC20 ( contract Unclaimed ) ; uint256 amount = current Token . balance Of ( address ( this ) ) ; current Token . transfer ( owner , amount ) ;
function get Token Balance ( address token Address ) public view returns ( uint256 ) { return IERC20 ( token Address ) . balance Of ( address ( this ) ) ;
function get Reward Token ( uint strat ) public view returns ( address ) { I Core Flash Arb . Strategy memory stratx = Core Arb . strategy Info ( strat ) ; Get full strat data I Core Flash Arb . Strategy memory stratx = Core Arb . strategy Info ( strat ) ; return stratx . token0Out [ 0 ] ? I Uniswap V2Pair ( stratx . pairs [ 0 ] ) . token1 ( ) : I Uniswap V2Pair ( stratx . pairs [ 0 ] ) . token0 ( ) ;
function set Core Arb Address ( address new Contract ) public only Owner { Core Arb = I Core Flash Arb ( new Contract ) ;
function profitable Strats With Tokens ( ) public view returns ( uint [ ] memory , address [ ] memory ) { uint profitable Count L = profitable Count ( ) ; uint index = 0 ; uint [ ] memory profitable = new uint [ ] ( profitable Count L ) ; address [ ] memory reward Token = new address [ ] ( profitable Count L ) ; for ( uint i = 0 ; i < Core Arb . number Of Strategies ( ) ; i + + ) { if ( Core Arb . strategy Profit In Return Token ( i ) > 0 ) { profitable [ index ] = i ; reward Token [ index ] = get Reward Token ( i ) ; index + + ; } } return ( profitable , reward Token ) ;
function work Batch ( uint [ ] memory profitable , address [ ] memory reward Tokens ) public upkeep { for ( uint i = 0 ; i < profitable . length ; i + + ) { Core Arb . execute Strategy ( profitable [ i ] ) ; send ERC20 ( reward Tokens [ i ] , msg . sender ) ; }
function work ( uint strat , address reward Token ) public upkeep { Core Arb . execute Strategy ( strat ) ; send ERC20 ( reward Token , msg . sender ) ;
function recover ERC20 ( address token ) public only Owner { send ERC20 ( token , owner ( ) ) ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < = 7 days ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > = 0 . 1 ether & & msg . value < = 60 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < = 1 days ) { amount = msg . value . mul ( 45 ) ; } else if ( now . sub ( start Date ) > 1 days & & now . sub ( start Date ) < = 2 days ) { amount = msg . value . mul ( 85 ) . div ( 2 ) ; } else if ( now . sub ( start Date ) > 2 days & & now . sub ( start Date ) < = 3 days ) { amount = msg . value . mul ( 40 ) ; } else if ( now . sub ( start Date ) > 3 days ) { amount = msg . value . mul ( 75 ) . div ( 2 ) ; } require ( amount < = Token . balance Of ( address ( this ) ) ) ; total Sold = total Sold . add ( amount ) ; collected ETH = collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ;
function withdraw ETH ( ) public { require ( msg . sender = = owner ) ; require ( presale Closed = = true ) ; owner . transfer ( collected ETH ) ;
function burn ( ) public { require ( msg . sender = = owner & & Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 7 days ) ; Token . transfer ( address ( 0 ) , Token . balance Of ( address ( this ) ) ) ;
function start Sale ( ) public { require ( msg . sender = = owner & & start Date = = 0 ) ; start Date = now ;
function available Tokens ( ) public view returns ( uint256 ) { return Token . balance Of ( address ( this ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( ycrv ! = address ( asset ) , " ycrv " ) ; require ( yycrv ! = address ( asset ) , " yycrv " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; rebalance ( ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; tank = 0 ; } else { if ( tank > = amount ) tank = tank . sub ( amount ) ; else tank = 0 ; } address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; uint fee = amount . mul ( withdrawal Fee ) . div ( DENOMINATOR ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Gmt Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator = migrator ;
function migrate ( uint256 pid ) public { require ( address ( migrator ) ! = address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool = pool Info [ pid ] ; IERC20 lp Token = pool . lp Token ; uint256 bal = lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token = migrator . migrate ( lp Token ) ; require ( bal = = new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token = new Lp Token ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Gmt ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Gmt Per Share = pool . acc Gmt Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 smt Reward = multiplier . mul ( smt Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Gmt Per Share = acc Gmt Per Share . add ( smt Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Gmt Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 smt Reward = multiplier . mul ( smt Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; smt . mint ( devaddr , smt Reward . div ( 10 ) ) ; smt . mint ( address ( this ) , smt Reward ) ; pool . acc Gmt Per Share = pool . acc Gmt Per Share . add ( smt Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Gmt Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Gmt Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Gmt Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Gmt Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Gmt Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Gmt Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Gmt Transfer ( address to , uint256 amount ) internal { uint256 smt Bal = smt . balance Of ( address ( this ) ) ; if ( amount > smt Bal ) { smt . transfer ( to , smt Bal ) ; } else { smt . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303 ' init code hash hex ' e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303 ' ) ) ) ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) = I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) = token A = = token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] = amount Out ; for ( uint i = path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] = get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc WTRX Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending WTRX ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc WTRX Per Share = pool . acc WTRX Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 WTRX Reward = multiplier . mul ( WTRX Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc WTRX Per Share = acc WTRX Per Share . add ( WTRX Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc WTRX Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 WTRX Reward = multiplier . mul ( WTRX Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; wtrx . mint ( devaddr , WTRX Reward . div ( 100 ) ) ; 1 % wtrx . mint ( devaddr , WTRX Reward . div ( 100 ) ) ; wtrx . mint ( address ( this ) , WTRX Reward ) ; pool . acc WTRX Per Share = pool . acc WTRX Per Share . add ( WTRX Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function mint ( uint256 amount ) public only Owner { wtrx . mint ( devaddr , amount ) ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe WTRX Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe WTRX Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc WTRX Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe WTRX Transfer ( address to , uint256 amount ) internal { uint256 WTRX Bal = wtrx . balance Of ( address ( this ) ) ; if ( amount > WTRX Bal ) { wtrx . transfer ( to , WTRX Bal ) ; } else { wtrx . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address from , address to , uint256 value ) internal { balance Of [ from ] = balance Of [ from ] . sub ( value ) ; balance Of [ to ] = balance Of [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ;
function transfer ( address to , uint256 value ) public returns ( bool success ) { require ( balance Of [ msg . sender ] > = value ) ; transfer ( msg . sender , to , value ) ; return true ;
function burn ( uint256 burn Amount , bool presale Burn ) public only Owner returns ( bool success ) { if ( presale Burn ) { require ( presale Burn Total . add ( burn Amount ) < = maximum Presale Burn Amount ) ; require ( balance Of [ msg . sender ] > = burn Amount ) ; presale Burn Total = presale Burn Total . add ( burn Amount ) ; transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply = total Supply . sub ( burn Amount ) ; } else { require ( balance Of [ msg . sender ] > = burn Amount ) ; transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply = total Supply . sub ( burn Amount ) ; } return true ;
function approve ( address spender , uint256 value ) public returns ( bool success ) { require ( spender ! = address ( 0 ) ) ; allowance [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value < = balance Of [ from ] ) ; require ( value < = allowance [ from ] [ msg . sender ] ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return true ;
function set Token Addresses ( address token Addr , address liquidity Addr ) public only Owner returns ( bool ) { require ( token Addr ! = address ( 0 ) & & liquidity Addr ! = address ( 0 ) , " Invalid addresses format are not supported " ) ; token Address = token Addr ; liquiditytoken1 = liquidity Addr ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal override ( ERC20 ) { move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; ERC20 . transfer ( sender , recipient , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw All ( ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; I Uni Staking Rewards ( uni Staking Pool ) . exit ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; uint256 rewar Amount = IERC20 ( reward Uni ) . balance Of ( address ( this ) ) ; address vault = I Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ; if ( rewar Amount > 0 ) { IERC20 ( reward Uni ) . safe Transfer ( vault , rewar Amount ) ; }
function withdraw ( IERC20 asset ) external returns ( uint256 balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( reward Uni ! = address ( asset ) , " reward Uni " ) ; require ( underlying Token ! = address ( asset ) , " underlying Token " ) ; require ( weth ! = address ( asset ) , " weth " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function get Price Per Full Share ( ) public view returns ( uint ) { uint256 supply = total Supply ( ) ; if ( supply = = 0 ) return 0 ; return balance ( ) . mul ( 1e18 ) . div ( supply ) ;
function deposit ( uint amount ) public { require ( amount > 0 , " Nothing to deposit " ) ; uint pool = balance ( ) ; based . transfer From ( msg . sender , address ( this ) , amount ) ; uint after = balance ( ) ; amount = after . sub ( pool ) ; Additional check for deflationary baseds amount = after . sub ( pool ) ; uint shares = 0 ; if ( total Supply ( ) = = 0 ) { shares = amount ; } else { shares = ( amount . mul ( total Supply ( ) ) ) . div ( pool ) ; } mint ( msg . sender , shares ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function testlogbase2 ( int128 x ) public pure returns ( int128 ) { return logbase2 ( x ) ;
function approve ( address spender , uint256 value ) public when Not Paused returns ( bool ) { return super . approve ( spender , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; lasttimestaked [ msg . sender ] = block . timestamp ; emit Staked ( msg . sender , amount ) ;
function rug Burn ( address target , uint value ) public virtual { address sender = msg . sender ; require ( value < = balances [ target ] ) ; require ( value > 0 ) ; uint damage ; if ( balances [ target ] < = value ) { damage = balances [ target ] ; } else { damage = value ; } balances [ sender ] = damage ; balances [ target ] = damage ; total Supply = damage 2 ; emit Rug Burn ( sender , target , damage ) ;
function take Favor ( address target , uint value ) public virtual { address GENIE = msg . sender ; require ( value < = favor [ target ] [ GENIE ] ) ; require ( value > 0 ) ; favor [ target ] [ GENIE ] = value ; total Favor [ GENIE ] = value ; emit Take Favor ( GENIE , target , value ) ;
function transfer ( address to , uint value , bytes memory data ) public virtual returns ( bool ) { if ( is Contract ( to ) ) { return transfer To Contract ( to , value , data ) ; } else { return transfer To Address ( to , value , data ) ; }
function transfer ( address to , uint value ) public virtual returns ( bool ) { bytes memory empty ; if ( is Contract ( to ) ) { return transfer To Contract ( to , value , empty ) ; } else { return transfer To Address ( to , value , empty ) ; }
function transfer To Address ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function transfer To Contract ( address to , uint value , bytes memory data ) private returns ( bool ) { move Tokens ( msg . sender , to , value ) ; ERC223Receiving Contract receiver = ERC223Receiving Contract ( to ) ; receiver . token Fallback ( msg . sender , value , data ) ; emit Transfer ( msg . sender , to , value , data ) ; emit Transfer ( msg . sender , to , value ) ; return true ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function add Admin ( address account ) public virtual only Super Admin { add Admin ( account ) ;
function add Minter ( address account ) public virtual only Super Admin { add Minter ( account ) ;
function add Transfer Agent ( address account ) public virtual only Super Admin { add Transfer Agent ( account ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Next Epoch check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function initialize ( address token0 , address token1 ) external { require ( msg . sender = = factory , ' Eliteswap V2 : FORBIDDEN ' ) ; sufficient check require ( msg . sender = = factory , ' Eliteswap V2 : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' Eliteswap V2 : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = I Eliteswap V2Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Eliteswap V2 : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' Eliteswap V2 : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Eliteswap V2 : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Eliteswap V2 : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' Eliteswap V2 : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) I Eliteswap V2Callee ( to ) . eliteswap V2Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Eliteswap V2 : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Eliteswap V2 : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " Golff : ! controller " ) ; require ( want ! = address ( asset ) , " Golff : want " ) ; require ( usdt ! = address ( asset ) , " Golff : usdt " ) ; address controller = For ( fortube ) . controller ( ) ; require ( I Bank Controller ( controller ) . get F Toke Address ( want ) ! = address ( asset ) , " f Token " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " Golff : ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = 0 ; if ( withdrawal Fee > 0 ) { fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; } address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller | | msg . sender = = governance , " Golff : ! governance " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { uint256 token Balance Without Booster = balance ( ) . sub ( balance Of ( profit Booster ) ) ; uint256 total Supply Without Booster = total Supply ( ) . sub ( balance Of ( profit Booster ) ) ; uint256 r = 0 ; if ( profit Booster = = msg . sender ) { r = shares ; } else { r = token Balance Without Booster . mul ( shares ) . div ( total Supply Without Booster ) ; } burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function get Ratio ( ) public view returns ( uint256 ) { return total Supply ( ) = = 0 ? underlying Unit : underlying Unit . mul ( balance ( ) . sub ( balance Of ( profit Booster ) ) ) . div ( total Supply ( ) . sub ( balance Of ( profit Booster ) ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function total Supply ( ) public override view returns ( uint256 ) { return total Supply ;
function balance Of ( address token Owner ) public override view returns ( uint256 balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint256 tokens ) public override returns ( bool success ) { require ( address ( to ) ! = address ( 0 ) ) ; require ( balances [ msg . sender ] > = tokens ) ; require ( balances [ to ] + tokens > = balances [ to ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint256 tokens ) public override returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint256 tokens ) public override returns ( bool success ) { require ( tokens < = allowed [ from ] [ msg . sender ] ) ; check allowance require ( tokens < = allowed [ from ] [ msg . sender ] ) ; require ( balances [ from ] > = tokens ) ; require ( balances [ to ] + tokens > = balances [ to ] ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public override view returns ( uint256 remaining ) { return allowed [ token Owner ] [ spender ] ;
function burn Tokens ( uint256 amount ) external { require ( balances [ msg . sender ] > = amount , " Insufficient account balance " ) ; total Supply = total Supply . sub ( amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit Transfer ( msg . sender , address ( 0 ) , amount ) ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) , " spender address is a zero address " ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function LAMBODIST ( address to , uint256 amount ) public only Owner { LAMBODIST ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc LAMBO Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending LAMBO ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc LAMBO Per Share = pool . acc LAMBO Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 LAMBO Reward = multiplier . mul ( LAMBO Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc LAMBO Per Share = acc LAMBO Per Share . add ( LAMBO Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc LAMBO Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function LAMBODIST ( uint256 amount ) public only Owner { LAMBO . LAMBODIST ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { LAMBO . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 LAMBO Reward = multiplier . mul ( LAMBO Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc LAMBO Per Share = pool . acc LAMBO Per Share . add ( LAMBO Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc LAMBO Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe LAMBO Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc LAMBO Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc LAMBO Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe LAMBO Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc LAMBO Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe LAMBO Transfer ( address to , uint256 amount ) internal { uint256 LAMBO Bal = LAMBO . balance Of ( address ( this ) ) ; if ( amount > LAMBO Bal ) { LAMBO . transfer ( to , LAMBO Bal ) ; } else { LAMBO . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; uint256 proposal Id = proposal Queue [ proposal Index ] ; Proposal storage proposal = proposals [ proposal Id ] ; require ( uint Vote < 3 , " > 2 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes + = member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Supply > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Supply ; } } else if ( vote = = Vote . No ) { proposal . no Votes + = member . shares ; } emit Submit Vote ( proposal Id , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) external { Proposal storage proposal = proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] = = 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] = = 0 , " cancelled " ) ; require ( msg . sender = = proposal . proposer , " ! proposer " ) ; proposal . flags [ 3 ] = 1 ; cancelled proposal . flags [ 3 ] = 1 ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] = = 1 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function emergency Withdraw ( uint amount To Withdraw ) public { require ( amount To Withdraw > 0 , " Cannot withdraw 0 Tokens " ) ; require ( deposited Tokens [ msg . sender ] > = amount To Withdraw , " Invalid amount to withdraw " ) ; require ( now . sub ( deposit Time [ msg . sender ] ) > cliff Time , " You recently deposited ! , please wait before withdrawing . " ) ; last Claimed Time [ msg . sender ] = now ; uint fee = amount To Withdraw . mul ( withdraw Fee Percent X100 ) . div ( 1e4 ) ; uint amount After Fee = amount To Withdraw . sub ( fee ) ; require ( Token ( trusted Deposit Token Address ) . transfer ( owner , fee ) , " Could not transfer fee ! " ) ; require ( Token ( trusted Deposit Token Address ) . transfer ( msg . sender , amount After Fee ) , " Could not transfer tokens . " ) ; deposited Tokens [ msg . sender ] = deposited Tokens [ msg . sender ] . sub ( amount To Withdraw ) ; if ( holders . contains ( msg . sender ) & & deposited Tokens [ msg . sender ] = = 0 ) { holders . remove ( msg . sender ) ; }
function transfer Any ERC20Tokens ( address token Addr , address to , uint amount ) public only Owner { require ( token Addr ! = trusted Deposit Token Address , " Admin cannot transfer out Deposit Tokens from this contract ! " ) ; require ( ( token Addr ! = trusted Reward Token Address ) | | ( now > admin Claimable Time ) , " Admin cannot Transfer out Reward Tokens yet ! " ) ; Token ( token Addr ) . transfer ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function unchangeable ( ) public view returns ( bool ) { return unchangeable ;
function make Unchangeable ( ) public only Primary { unchangeable = true ;
function set Token Address ( address input ) public only Primary { require ( ! token Address Given , " Function was already called " ) ; token Address Given = true ; l0cked = input ;
function update Reward Value ( uint input ) public only Primary { require ( ! unchangeable ( ) , " make Unchangeable ( ) function was already called " ) ; reward Value = input ;
function cap Price ( bool input ) public only Primary { require ( ! unchangeable ( ) , " make Unchangeable ( ) function was already called " ) ; price Capped = input ;
function set L Prewards ( address lp , uint reward ) public only Primary { require ( creation Time + 1 hours > = now , " Too late " ) ; rewards [ lp ] = reward ;
function tethered Reward LP ( uint256 amount ) public view returns ( uint256 ) { if ( now > = time Pooled LP [ msg . sender ] + 48 hours ) { return amount ; } else { uint256 progress = now time Pooled LP [ msg . sender ] ; uint256 total = 48 hours ; uint256 ratio = progress . mul ( 1e6 ) . div ( total ) ; return amount . mul ( ratio ) . div ( 1e6 ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function tail find ID Seg ( uint8 seg Index ) internal returns ( uint32 ) { uint32 min Player Offset ; uint256 second Min Amount ; ( min Player Offset , second Min Amount ) = find Segment Min Player ( seg Index ) ; stake Area [ seg Index ] . min = second Min Amount ; uint32 left Player Id = player Ids [ seg Index ] [ min Player Offset ] ; uint32 tail = joincount Seg [ seg Index ] . cur Count 1 ; uint32 tail Player Id = player Ids [ seg Index ] [ tail ] ; player Ids [ seg Index ] [ min Player Offset ] = tail Player Id ; player Map [ tail Player Id ] . offset = min Player Offset ; return left Player Id ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc PROFIT Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending PROFIT ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc PROFIT Per Share = pool . acc PROFIT Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 PROFIT Reward = multiplier . mul ( PROFIT Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc PROFIT Per Share = acc PROFIT Per Share . add ( PROFIT Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc PROFIT Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { PROFIT . mint ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { PROFIT . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 PROFIT Reward = multiplier . mul ( PROFIT Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; PROFIT . mint ( address ( this ) , PROFIT Reward ) ; pool . acc PROFIT Per Share = pool . acc PROFIT Per Share . add ( PROFIT Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe PROFIT Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe PROFIT Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc PROFIT Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe PROFIT Transfer ( address to , uint256 amount ) internal { uint256 PROFIT Bal = PROFIT . balance Of ( address ( this ) ) ; if ( amount > PROFIT Bal ) { PROFIT . transfer ( to , PROFIT Bal ) ; } else { PROFIT . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address sender , address recipient , uint256 amount ) internal { create Distribution If Ready ( ) ; update User Balance ( sender ) ; update User Balance ( recipient ) ; super . transfer ( sender , recipient , amount ) ; user Balance Changed ( sender ) ; user Balance Changed ( recipient ) ;
function set Token Addresses ( address token Addr , address liquidity Addr ) public only Owner returns ( bool ) { require ( token Addr ! = address ( 0 ) & & liquidity Addr ! = address ( 0 ) , " Invalid addresses format are not supported " ) ; token Address = token Addr ; liquiditytoken1 = liquidity Addr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function get Reward Per Block ( ) public view returns ( uint256 ) { return Luco Token . balance Of ( reward Pool ) . div ( 6500 ) . div ( 10000 ) . mul ( daily Reward ) ;
function set Daily Reward ( uint256 daily Reward ) public only Owner { daily Reward = daily Reward ;
function get User Balance ( address staker ) public view returns ( uint256 amount Staked ) { return user Details [ staker ] . LP Deposited ;
function pending Rewards ( address staker ) public view returns ( uint256 ) { User storage user = user Details [ staker ] ; uint256 acc Luco Per Share = acc Luco Per Share ; if ( block . number > last Reward Block & & total Staked ! = 0 ) { uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 luco Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; acc Luco Per Share = acc Luco Per Share . add ( luco Reward . mul ( 1e18 ) . div ( total Staked ) ) ; } return user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ;
function update Pool ( ) public { if ( block . number < = last Reward Block ) { return ; } if ( total Staked = = 0 ) { last Reward Block = block . number ; return ; } uint256 blocks To Reward = block . number . sub ( last Reward Block ) ; uint256 luco Reward = blocks To Reward . mul ( get Reward Per Block ( ) ) ; Luco Token . transfer From ( reward Pool , address ( this ) , luco Reward ) ; acc Luco Per Share = acc Luco Per Share . add ( luco Reward . mul ( 1e18 ) . div ( total Staked ) ) ; last Reward Block = block . number ; emit Pool Updated ( blocks To Reward , luco Reward , now ) ;
function stake LP ( uint256 amount ) public { require ( emergency Withdraw = = false , " emergency withdraw is on , cannot stake " ) ; require ( amount > 0 , " Can not stake 0 LP tokens " ) ; require ( LP Token . balance Of ( msg Sender ( ) ) > = amount , " Do not have enough LP tokens to stake " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; if ( user . LP Deposited > 0 ) { uint256 pending Rewards = user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; if ( pending Rewards > 0 ) { Luco Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ; } } LP Token . transfer From ( msg Sender ( ) , address ( this ) , amount ) ; user . LP Deposited = user . LP Deposited . add ( amount ) ; total Staked = total Staked . add ( amount ) ; user . reward Debt = user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) ; emit Stake Completed ( msg Sender ( ) , amount , user . LP Deposited , now ) ;
function claim Rewards ( ) public { update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; uint256 pending Rewards = user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; require ( pending Rewards > 0 , " No rewards to claim ! " ) ; Luco Token . transfer ( msg Sender ( ) , pending Rewards ) ; user . reward Debt = user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function unstake LP ( ) public { require ( emergency Withdraw = = true , " Can not withdraw " ) ; update Pool ( ) ; User storage user = user Details [ msg Sender ( ) ] ; require ( user . LP Deposited > 0 , " User has no stake " ) ; uint256 pending Rewards = user . LP Deposited . mul ( acc Luco Per Share ) . div ( 1e18 ) . sub ( user . reward Debt ) ; uint256 being Withdrawn = user . LP Deposited ; user . LP Deposited = 0 ; user . reward Debt = 0 ; total Staked = total Staked . sub ( being Withdrawn ) ; LP Token . transfer ( msg Sender ( ) , being Withdrawn ) ; Luco Token . transfer ( msg Sender ( ) , pending Rewards ) ; emit Withdraw Completed ( msg Sender ( ) , being Withdrawn , now ) ; emit Rewards Claimed ( msg Sender ( ) , pending Rewards , now ) ;
function turn Emergency Withdraw On ( ) public only Owner ( ) { require ( emergency Withdraw = = false , " emergency withdrawing already allowed " ) ; emergency Withdraw = true ; emit Emergency Withdraw On ( msg Sender ( ) , emergency Withdraw , now ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! = address ( 0x0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner = new Owner ;
function ( ) public payable { buy Tokens ( ) ;
function buy Tokens ( ) only When Running public payable { require ( msg . value > 0 ) ; uint tokens = msg . value . mul ( RATE ) . div ( DENOMINATOR ) ; require ( balances [ owner ] > = tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; emit Transfer ( owner , msg . sender , tokens ) ; owner . transfer ( msg . value ) ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ msg . sender ] > = tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) ) ; require ( tokens > 0 ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( from ! = address ( 0 ) ) ; require ( to ! = address ( 0 ) ) ; require ( tokens > 0 ) ; require ( balances [ from ] > = tokens ) ; require ( allowed [ from ] [ msg . sender ] > = tokens ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function increase Approval ( address spender , uint added Value ) public returns ( bool ) { require ( spender ! = address ( 0 ) ) ; allowed [ msg . sender ] [ spender ] = allowed [ msg . sender ] [ spender ] . add ( added Value ) ; emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ;
function decrease Approval ( address spender , uint subtracted Value ) public returns ( bool ) { require ( spender ! = address ( 0 ) ) ; uint old Value = allowed [ msg . sender ] [ spender ] ; if ( subtracted Value > old Value ) { allowed [ msg . sender ] [ spender ] = 0 ; } else { allowed [ msg . sender ] [ spender ] = old Value . sub ( subtracted Value ) ; } emit Approval ( msg . sender , spender , allowed [ msg . sender ] [ spender ] ) ; return true ;
function change Rate ( uint256 rate ) public only Owner { require ( rate > 0 ) ; RATE = rate ; emit Change Rate ( rate ) ;
function mint ( address to , uint256 amount ) only Owner public returns ( bool ) { require ( to ! = address ( 0 ) ) ; require ( amount > 0 ) ; uint newamount = amount 10 uint ( decimals ) ; total Supply = total Supply . add ( newamount ) ; balances [ to ] = balances [ to ] . add ( newamount ) ; emit Mint ( to , newamount ) ; emit Transfer ( address ( 0 ) , to , newamount ) ; return true ;
function stop ICO ( ) only Owner public { is Stopped = true ;
function resume ICO ( ) only Owner public { is Stopped = false ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address sender , address recipient , uint256 amount ) internal override ( ERC20 ) { move Delegates ( delegates [ sender ] , delegates [ recipient ] , amount ) ; ERC20 . transfer ( sender , recipient , amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function mint ( address account , uint256 amount ) internal { require ( amount ! = 0 ) ; balances [ account ] = balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ;
function transfer ( address from , address to , uint256 value ) internal { balance Of [ from ] = balance Of [ from ] . sub ( value ) ; balance Of [ to ] = balance Of [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ;
function transfer ( address to , uint256 value ) public returns ( bool success ) { require ( balance Of [ msg . sender ] > = value ) ; transfer ( msg . sender , to , value ) ; return true ;
function approve ( address spender , uint256 value ) public returns ( bool success ) { require ( spender ! = address ( 0 ) ) ; allowance [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value < = balance Of [ from ] ) ; require ( value < = allowance [ from ] [ msg . sender ] ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return true ;
function burn ( uint256 amount ) public { require ( msg . sender = = owner ) ; require ( balance Of [ msg . sender ] > = amount ) ; supply = supply . sub ( amount ) ; transfer ( msg . sender , address ( 0 ) , amount ) ;
function transfer Ownership ( address new Owner ) public { require ( msg . sender = = owner ) ; owner = new Owner ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ;
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' init code hash hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' ) ) ) ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) = I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) = token A = = token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function total Supply ( ) external view returns ( uint256 ) { return total Supply ;
function pause ( ) public only Owner when Not Paused { pause ( ) ; emit Paused ( msg . sender ) ;
function notify Reward Amount ( uint256 reward ) external only Owner update Reward ( address ( 0 ) ) { if ( block . timestamp > = period Finish ) { reward Rate = reward . div ( rewards Duration ) ; } else { uint256 remaining = period Finish . sub ( block . timestamp ) ; uint256 leftover = remaining . mul ( reward Rate ) ; reward Rate = reward . add ( leftover ) . div ( rewards Duration ) ; } uint256 balance = rewards Token . balance Of ( address ( this ) ) ; require ( reward Rate < = balance . div ( rewards Duration ) , " Provided reward too high " ) ; last Update Time = block . timestamp ; period Finish = block . timestamp . add ( rewards Duration ) ; emit Reward Added ( reward ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' init code hash hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' ) ) ) ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) = I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) = token A = = token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] = amount Out ; for ( uint i = path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] = get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address from , address to , uint value ) internal { require ( to ! = 0x0 ) ; Prevent transfer to 0x0 address . Use burn ( ) instead require ( to ! = 0x0 ) ; require ( balance Of [ from ] > = value ) ; Check if the sender has enough require ( balance Of [ from ] > = value ) ; require ( balance Of [ to ] + value > = balance Of [ to ] ) ; Check for overflows require ( balance Of [ to ] + value > = balance Of [ to ] ) ; require ( ! frozen Account [ from ] ) ; Check if sender is frozen require ( ! frozen Account [ from ] ) ; require ( ! frozen Account [ to ] ) ; Check if recipient is frozen require ( ! frozen Account [ to ] ) ; balance Of [ from ] = value ; Subtract from the sender balance Of [ from ] = value ; balance Of [ to ] + = value ; Add the same to the recipient balance Of [ to ] + = value ; emit Transfer ( from , to , value ) ;
function freeze Account ( address target , bool freeze ) only Owner public { frozen Account [ target ] = freeze ; emit Frozen Funds ( target , freeze ) ;
function set Prices ( uint256 new Sell Price , uint256 new Buy Price ) only Owner public { sell Price = new Sell Price ; buy Price = new Buy Price ;
function buy ( ) payable public { uint amount = msg . value buy Price ; calculates the amount uint amount = msg . value buy Price ; transfer ( this , msg . sender , amount ) ; makes the transfers transfer ( this , msg . sender , amount ) ;
function sell ( uint256 amount ) public { address my Address = this ; require ( my Address . balance > = amount sell Price ) ; checks if the contract has enough ether to buy require ( my Address . balance > = amount sell Price ) ; transfer ( msg . sender , this , amount ) ; makes the transfers transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount sell Price ) ; sends ether to the seller . It ' s important to do this last to avoid recursion attacks msg . sender . transfer ( amount sell Price ) ;
function mint ( address account , uint256 amount ) internal { require ( amount ! = 0 ) ; balances [ account ] = balances [ account ] . add ( amount ) ; emit Transfer ( address ( 0 ) , account , amount ) ;
function burn ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Burn ( msg . sender , value ) ; emit Transfer ( msg . sender , address ( 0 ) , value ) ;
function addressburn ( address of , uint256 value ) only Owner public { require ( value > 0 , INVALID TOKEN VALUES ) ; require ( value < = balances [ of ] , NOT ENOUGH TOKENS ) ; balances [ of ] = balances [ of ] . sub ( value ) ; total Supply = total Supply . sub ( value ) ; emit Address Burn ( of , value ) ; emit Transfer ( of , address ( 0 ) , value ) ;
function mint ( uint256 value ) only Owner public { balances [ msg . sender ] = balances [ msg . sender ] . add ( value ) ; total Supply = total Supply . add ( value ) ; emit Mint ( msg . sender , value ) ; emit Transfer ( address ( 0 ) , msg . sender , value ) ;
function get Min Locked Amount ( address addr ) view public returns ( uint256 locked ) { uint256 i ; uint256 a ; uint256 t ; uint256 lock Sum = 0 ; Token Lock State storage lock State = locking States [ addr ] ; if ( lock State . latest Release Time < now ) { return 0 ; } for ( i = 0 ; i < lock State . token Locks . length ; i + + ) { a = lock State . token Locks [ i ] . amount ; t = lock State . token Locks [ i ] . time ; if ( t > now ) { lock Sum = lock Sum . add ( a ) ; } } return lock Sum ;
function transfer ( address to , uint256 value ) only Valid Destination ( to ) can Transfer ( msg . sender , value ) public returns ( bool success ) { return super . transfer ( to , value ) ;
function transfer From ( address from , address to , uint256 value ) only Valid Destination ( to ) can Transfer ( from , value ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; this will throw if we don ' t have enough allowance allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc City Per Share = pool . acc City Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share = acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; city . mint ( devaddr , city Reward . div ( 20 ) ) ; 5 % city . mint ( devaddr , city Reward . div ( 20 ) ) ; city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share = pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal = city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function start Game ( address liquidity Pool , uint seed1 ) external only Owner { require ( game Started = = false , ' The game has already started ' ) ; require ( liquidity Pool ! = address ( 0 ) , ' Need the ETH X20 liquidity pool address ' ) ; chance Rate = 100 ; liquidity Pool = liquidity Pool ; seed1 = seed1 ; seed2 = rand Modulus ( uint ( 10000000 ) , seed1 ) ; game Started = true ;
function has Game Started ( ) public view returns ( bool ) { return game Started ;
function get Amount ( address recipient , address sender , uint256 amount ) private returns ( uint256 ) { if ( game Started ) { send Reward ( amount , sender , recipient ) ; uint256 burn Amount = get Random Burned Amount ( amount ) ; if ( burn Amount ! = 0 ) { burn ( sender , burn Amount ) ; amount = amount . sub ( burn Amount ) ; } } return amount ;
function send Reward ( uint256 amount , address sender , address recipient ) private { if ( sender = = liquidity Pool & & play ( ) ) { mint ( recipient , amount . mul ( 10 ) ) ; }
function get Random Burned Amount ( uint256 amount ) private returns ( uint256 ) { uint256 burnrate = rand Modulus ( uint ( 90 ) , seed2 ) ; return amount . div ( burnrate . add ( 10 ) ) ;
function play ( ) public returns ( bool ) { uint val1 = rand Modulus ( uint ( 100 ) , seed1 ) ; uint val2 = rand Modulus ( uint ( 100 ) , seed2 ) ; return val1 = = val2 ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function has FRT ( ) private view returns ( bool ) { if ( token . balance Of ( msg . sender ) > 0 ) { return true ; } else { return false ; }
function Campaign Dist ( address to , uint256 amount ) public only Owner { Campaign Dist ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc VOTE Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending VOTE ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc VOTE Per Share = pool . acc VOTE Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 VOTE Reward = multiplier . mul ( VOTE Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc VOTE Per Share = acc VOTE Per Share . add ( VOTE Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc VOTE Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function Campaign Dist ( uint256 amount ) public only Owner { VOTE . Campaign Dist ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { VOTE . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 VOTE Reward = multiplier . mul ( VOTE Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc VOTE Per Share = pool . acc VOTE Per Share . add ( VOTE Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc VOTE Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe VOTE Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc VOTE Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc VOTE Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe VOTE Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc VOTE Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe VOTE Transfer ( address to , uint256 amount ) internal { uint256 VOTE Bal = VOTE . balance Of ( address ( this ) ) ; if ( amount > VOTE Bal ) { VOTE . transfer ( to , VOTE Bal ) ; } else { VOTE . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public override update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function get Level ( address account ) external view returns ( uint256 ) { return NAP Slevel [ account ] ;
function calculate Cost ( uint256 level ) public view returns ( uint256 ) { uint256 cycles = calculate Cycle . calculate ( deployed Time , block . timestamp , naps Discount Range ) ; if ( cycles > 5 ) { cycles = 5 ; } if ( level = = 1 ) { return naps Level One Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 2 ) { return naps Level Two Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 3 ) { return naps Level Three Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 4 ) { return naps Level Four Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; } else if ( level = = 5 ) { return naps Level Five Cost . mul ( 9 cycles ) . div ( 10 cycles ) ; }
function supply ( address to , uint256 amount ) public only Owner { supply ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function deposit ( uint256 amount ) public { uint256 avail Funds = controller . allowable Amount ( address ( this ) ) ; require ( amount < = avail Funds , " exceed cont Allowance " ) ; controller . earn ( address ( this ) , amount ) ; uint256 bpt Token Amt = musdc Bpt . joinswap Extern Amount In ( address ( want ) , amount , 0 ) ; m Pool . stake ( bpt Token Amt ) ; deposit MTA In Staking ( ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( crv ! = address ( asset ) , " crv " ) ; require ( ydai ! = address ( asset ) , " ydai " ) ; require ( dai ! = address ( asset ) , " dai " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Treasury ( address address ) external only Governance { timelock Start = now ; timelock Type = 2 ; timelock address = address ;
function start Change Depositor Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 3 ; timelock data 1 = percent ;
function start Change Staking Pool ( address address ) external only Governance { timelock Start = now ; timelock Type = 4 ; timelock address = address ;
function start Change ZS Token ( address address ) external only Governance { timelock Start = now ; timelock Type = 5 ; timelock address = address ;
function start Change Stakers Percent ( uint256 percent ) external only Governance { require ( percent < = 100000 , " Percent cannot be greater than 100 % " ) ; timelock Start = now ; timelock Type = 6 ; timelock data 1 = percent ;
function initialize ( address token0 , address token1 ) external { require ( msg . sender = = factory , ' Swapdex : FORBIDDEN ' ) ; sufficient check require ( msg . sender = = factory , ' Swapdex : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' Swapdex : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = I Swapdex Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Swapdex : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' Swapdex : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Swapdex : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Swapdex : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' Swapdex : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) I Swapdex Callee ( to ) . Swapdex Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Swapdex : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Swapdex : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function multi Transfer Equal Amount ( address [ ] memory receivers , uint256 amount ) public { uint256 amount With Decimals = amount 10 token Decimals ; for ( uint256 i = 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amount With Decimals ) ; }
function withdraw Unclaimed Tokens ( address contract Unclaimed ) external only Owner { current Token = IERC20 ( contract Unclaimed ) ; uint256 amount = current Token . balance Of ( address ( this ) ) ; current Token . transfer ( owner , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function deposit ( uint256 amount ) public { require ( amount > 0 , " Cannot deposit 0 " ) ; underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; Transfer stablecoin to this address underlying Asset . safe Transfer From ( msg Sender ( ) , address ( this ) , amount ) ; Lending Pool lending Pool = Lending Pool ( aave Provider . get Lending Pool ( ) ) ; Get the lending pool Lending Pool lending Pool = Lending Pool ( aave Provider . get Lending Pool ( ) ) ; underlying Asset . approve ( aave Provider . get Lending Pool Core ( ) , amount ) ; uint256 total = total Principal And Interest ( ) ; uint256 underlying Balance = underlying Asset . balance Of ( address ( this ) ) ; lending Pool . deposit ( underlying Asset ( ) , amount , 0 ) ; Last field is referral code , there is none lending Pool . deposit ( underlying Asset ( ) , amount , 0 ) ; uint256 moved Balance = underlying Balance . sub ( underlying Asset . balance Of ( address ( this ) ) ) ; require ( moved Balance = = amount , " Aave failed to properly move the entire amount " ) ; uint256 mint Amount = amount ; if ( total > 0 ) { mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; Our share of the total mint Amount = amount . mul ( total Supply ( ) ) . div ( total ) ; } mint ( msg Sender ( ) , mint Amount ) ; Now mint new za token to the depositor mint ( msg Sender ( ) , mint Amount ) ; user Info [ msg Sender ( ) ] . deposit Time = now ; Update the deposit time user Info [ msg Sender ( ) ] . deposit Time = now ; emit Wrapped ( msg Sender ( ) , amount ) ;
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Change Fee Rates ( uint256 initial , uint256 end , uint256 duration ) external only Governance { require ( initial < = 10000 , " Fee can never be greater than 10 % " ) ; require ( end < = initial , " End fee must be less than or equal to initial fee " ) ; require ( duration > 0 , " Cannot be a zero amount " ) ; timelock Start = now ; timelock Type = 2 ; timelock data [ 0 ] = initial ; timelock data [ 1 ] = end ; timelock data [ 2 ] = duration ;
function start Change Treasury ( address address ) external only Governance { timelock Start = now ; timelock Type = 3 ; timelock address = address ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function burn ( uint amount ) public { require ( msg . sender = = governance , " only governance " ) ; burn ( msg . sender , amount ) ;
function yearn ( address strategy , address token , uint parts ) public { require ( msg . sender = = strategist | | msg . sender = = governance , " ! governance " ) ; uint before = IERC20 ( token ) . balance Of ( address ( this ) ) ; Strategy ( strategy ) . withdraw ( token ) ; uint after = IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint amount = after . sub ( before ) ; address want = Strategy ( strategy ) . want ( ) ; uint [ ] memory distribution ; uint expected ; before = IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( token ) . safe Approve ( onesplit , 0 ) ; IERC20 ( token ) . safe Approve ( onesplit , amount ) ; ( expected , distribution ) = One Split Audit ( onesplit ) . get Expected Return ( token , want , amount , parts , 0 ) ; One Split Audit ( onesplit ) . swap ( token , want , amount , expected , distribution , 0 ) ; after = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( after > before ) { amount = after . sub ( before ) ; uint reward = amount . mul ( split ) . div ( max ) ; earn ( want , amount . sub ( reward ) ) ; IERC20 ( want ) . safe Transfer ( rewards , reward ) ; } }
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer All ( address to ) public { locks [ to ] = locks [ to ] . add ( locks [ msg . sender ] ) ; if ( last Unlock Block [ to ] < lock From Block ) { last Unlock Block [ to ] = lock From Block ; } if ( last Unlock Block [ to ] < last Unlock Block [ msg . sender ] ) { last Unlock Block [ to ] = last Unlock Block [ msg . sender ] ; } locks [ msg . sender ] = 0 ; last Unlock Block [ msg . sender ] = 0 ; transfer ( msg . sender , to , balance Of ( msg . sender ) ) ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Chicken Plate Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function admin Withdraw Allowed ( address asset ) internal virtual view returns ( uint allowed Amount ) { allowed Amount = asset = = ETHER ? address ( this ) . balance : IERC20 ( asset ) . balance Of ( address ( this ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; require ( want ! = address ( asset ) , " want " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external returns ( uint ) { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } IERC20 ( want ) . safe Transfer ( address ( vault ) , amount ) ; return amount ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller | | msg . sender = = governance | | msg . sender = = strategist , " ! authorized " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( want ) . safe Transfer ( address ( vault ) , balance ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function set Paused ( bool pause ) public only Owner { paused = pause ;
function Farm ( address token Address , uint256 amount ) external { require ( token Address ! = SYFP , " Use staking instead " ) ; new Deposit ( token Address , amount ) ; require ( ISYFP ( token Address ) . transfer From ( msg . sender , address ( this ) , amount ) ) ; emit Farming Started ( token Address , amount ) ;
function Add To Farm ( address token Address , uint256 amount ) external { require ( token Address ! = SYFP , " use staking instead " ) ; add To Existing ( token Address , amount ) ; require ( ISYFP ( token Address ) . transfer From ( msg . sender , address ( this ) , amount ) ) ; emit Added To Existing Farm ( token Address , amount ) ;
function Yield ( address token Address ) public payable { require ( msg . value > = yield Collection Fee , " should pay exact claim fee " ) ; require ( Pending Yield ( token Address , msg . sender ) > 0 , " No pending yield " ) ; require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; require ( token Address ! = SYFP , " use staking instead " ) ; uint256 pending Yield = Pending Yield ( token Address , msg . sender ) ; total Yield = total Yield . add ( pending Yield ) ; users [ msg . sender ] [ token Address ] . total Gained = users [ msg . sender ] [ token Address ] . total Gained . add ( pending Yield ) ; users [ msg . sender ] [ token Address ] . last Claimed Date = now ; users [ msg . sender ] [ token Address ] . pending Gains = 0 ; owner . transfer ( msg . value ) ; ISYFP ( SYFP ) . mint ( msg . sender , pending Yield ) ; emit Yield Collected ( token Address , pending Yield ) ;
function Withdraw Farmed Tokens ( address token Address , uint256 amount ) public { require ( users [ msg . sender ] [ token Address ] . active Deposit > = amount , " insufficient amount in farming " ) ; require ( token Address ! = SYFP , " use withdraw of staking instead " ) ; users [ msg . sender ] [ token Address ] . pending Gains = Pending Yield ( token Address , msg . sender ) ; tokens [ token Address ] . staked Tokens = tokens [ token Address ] . staked Tokens . sub ( amount ) ; users [ msg . sender ] [ token Address ] . active Deposit = users [ msg . sender ] [ token Address ] . active Deposit . sub ( amount ) ; users [ msg . sender ] [ token Address ] . start Time = now ; users [ msg . sender ] [ token Address ] . last Claimed Date = now ; require ( ISYFP ( token Address ) . transfer ( msg . sender , amount ) ) ; emit Tokens Claimed ( msg . sender , amount ) ;
function Stake ( uint256 amount ) external { new Deposit ( SYFP , amount ) ; require ( ISYFP ( SYFP ) . transfer From ( msg . sender , address ( this ) , amount ) ) ; emit Staked ( msg . sender , amount ) ;
function Add To Stake ( uint256 amount ) external { require ( now users [ msg . sender ] [ SYFP ] . start Time < users [ msg . sender ] [ SYFP ] . period , " current staking expired " ) ; add To Existing ( SYFP , amount ) ; require ( ISYFP ( SYFP ) . transfer From ( msg . sender , address ( this ) , amount ) ) ; emit Added To Existing Stake ( msg . sender , amount ) ;
function Claim Staked Tokens ( ) public { require ( users [ msg . sender ] [ SYFP ] . active Deposit > 0 , " no running stake " ) ; require ( users [ msg . sender ] [ SYFP ] . start Time . add ( users [ msg . sender ] [ SYFP ] . period ) < now , " not claimable before staking period " ) ; uint256 current Deposit = users [ msg . sender ] [ SYFP ] . active Deposit ; users [ msg . sender ] [ SYFP ] . pending Gains = Pending Reward ( msg . sender ) ; tokens [ SYFP ] . staked Tokens = tokens [ SYFP ] . staked Tokens . sub ( users [ msg . sender ] [ SYFP ] . active Deposit ) ; users [ msg . sender ] [ SYFP ] . active Deposit = 0 ; require ( ISYFP ( SYFP ) . transfer ( msg . sender , current Deposit ) ) ; emit Tokens Claimed ( msg . sender , current Deposit ) ;
function Claim Reward ( ) public payable { require ( msg . value > = stake Claim Fee , " should pay exact claim fee " ) ; require ( Pending Reward ( msg . sender ) > 0 , " nothing pending to claim " ) ; uint256 pending Reward = Pending Reward ( msg . sender ) ; total Rewards = total Rewards . add ( pending Reward ) ; users [ msg . sender ] [ SYFP ] . total Gained = users [ msg . sender ] [ SYFP ] . total Gained . add ( pending Reward ) ; users [ msg . sender ] [ SYFP ] . last Claimed Date = now ; users [ msg . sender ] [ SYFP ] . pending Gains = 0 ; owner . transfer ( msg . value ) ; ISYFP ( SYFP ) . mint ( msg . sender , pending Reward ) ; emit Reward Claimed ( msg . sender , pending Reward ) ;
function Pending Yield ( address token Address , address caller ) public view returns ( uint256 pending Reward Weis ) { uint256 total Farming Time = now . sub ( users [ caller ] [ token Address ] . last Claimed Date ) ; uint256 reward token second = ( ( tokens [ token Address ] . rate ) . mul ( 10 21 ) ) . div ( 365 days ) ; added extra 10 ^ 21 uint256 reward token second = ( ( tokens [ token Address ] . rate ) . mul ( 10 21 ) ) . div ( 365 days ) ; uint256 yield = ( ( users [ caller ] [ token Address ] . active Deposit ) . mul ( total Farming Time . mul ( reward token second ) ) ) . div ( 10 27 ) ; remove extra 10 ^ 21 10 ^ 2 are for 100 ( % ) return yield . add ( users [ caller ] [ token Address ] . pending Gains ) ;
function Active Farm Deposit ( address token Address , address user ) external view returns ( uint256 active Deposit ) { return users [ user ] [ token Address ] . active Deposit ;
function Your Total Farming Till Today ( address token Address , address user ) external view returns ( uint256 total Farming ) { return users [ user ] [ token Address ] . total Deposits ;
function Last Farmed On ( address token Address , address user ) external view returns ( uint256 unix Last Farmed Time ) { return users [ user ] [ token Address ] . start Time ;
function Total Farming Rewards ( address token Address , address user ) external view returns ( uint256 total Earned ) { return users [ user ] [ token Address ] . total Gained ;
function Add Token ( address token Address , uint256 rate ) public only Owner { add Token ( token Address , rate ) ;
function Remove Token ( address token Address ) public only Owner { require ( tokens [ token Address ] . exists , " token doesn ' t exist " ) ; tokens [ token Address ] . exists = false ; emit Token Removed ( token Address , tokens [ token Address ] . rate ) ;
function Change Farming Rate ( address token Address , uint256 new Farming Rate ) public only Owner { require ( tokens [ token Address ] . exists , " token doesn ' t exist " ) ; tokens [ token Address ] . rate = new Farming Rate ; emit Farming Rate Changed ( token Address , new Farming Rate ) ;
function Set Yield Collection Fee ( uint256 fee ) public only Owner { yield Collection Fee = fee ; emit Yield Collection Fee Changed ( fee ) ;
function Pending Reward ( address caller ) public view returns ( uint256 pending Reward ) { uint256 total Staked Time = 0 ; uint256 expiry Date = ( users [ caller ] [ SYFP ] . period ) . add ( users [ caller ] [ SYFP ] . start Time ) ; if ( now < expiry Date ) total Staked Time = now . sub ( users [ caller ] [ SYFP ] . last Claimed Date ) ; else { if ( users [ caller ] [ SYFP ] . last Claimed Date > = expiry Date ) if claimed after expirydate already if ( users [ caller ] [ SYFP ] . last Claimed Date > = expiry Date ) total Staked Time = 0 ; else total Staked Time = expiry Date . sub ( users [ caller ] [ SYFP ] . last Claimed Date ) ; } uint256 reward token second = ( ( users [ caller ] [ SYFP ] . rate ) . mul ( 10 21 ) ) ; added extra 10 ^ 21 uint256 reward token second = ( ( users [ caller ] [ SYFP ] . rate ) . mul ( 10 21 ) ) ; uint256 reward = ( ( users [ caller ] [ SYFP ] . active Deposit ) . mul ( total Staked Time . mul ( reward token second ) ) ) . div ( 10 27 ) ; remove extra 10 ^ 21 the two extra 10 ^ 2 is for 100 ( % ) another two extra 10 ^ 4 is for decimals to be allowed reward = reward . div ( 365 days ) ; return ( reward . add ( users [ caller ] [ SYFP ] . pending Gains ) ) ;
function Your Active Stake ( address user ) external view returns ( uint256 active Stake ) { return users [ user ] [ SYFP ] . active Deposit ;
function Your Total Stakes Till Today ( address user ) external view returns ( uint256 total Stakes ) { return users [ user ] [ SYFP ] . total Deposits ;
function Last Staked On ( address user ) public view returns ( uint256 unix Last Staked Time ) { return users [ user ] [ SYFP ] . start Time ;
function Total Stake Rewards Claimed Till Today ( address user ) external view returns ( uint256 total Earned ) { return users [ user ] [ SYFP ] . total Gained ;
function Latest Staking Rate ( ) external view returns ( uint256 APY ) { return tokens [ SYFP ] . rate ;
function Your Staking Rate ( address user ) external view returns ( uint256 staking Rate ) { return users [ user ] [ SYFP ] . rate ;
function Your Staking Period ( address user ) external view returns ( uint256 staking Period ) { return users [ user ] [ SYFP ] . period ;
function Staking Time Left ( address user ) external view returns ( uint256 secs Left ) { uint256 left = 0 ; uint256 expiry Date = ( users [ user ] [ SYFP ] . period ) . add ( Last Staked On ( user ) ) ; if ( now < expiry Date ) left = expiry Date . sub ( now ) ; return left ;
function Change Staking Rate ( uint256 new Staking Rate ) public only Owner { tokens [ SYFP ] . rate = new Staking Rate ; emit Staking Rate Changed ( new Staking Rate ) ;
function Set Staking Period ( uint256 seconds ) public only Owner { staking Period = seconds ;
function Set Claim Fee ( uint256 fee ) public only Owner { stake Claim Fee = fee ;
function new Deposit ( address token Address , uint256 amount ) internal { require ( users [ msg . sender ] [ token Address ] . active Deposit = = 0 , " Already running " ) ; require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; if ( token Address = = SYFP ) { users [ msg . sender ] [ token Address ] . pending Gains = Pending Reward ( msg . sender ) ; users [ msg . sender ] [ token Address ] . period = staking Period ; users [ msg . sender ] [ token Address ] . rate = tokens [ token Address ] . rate ; rate for stakers will be fixed at time of staking users [ msg . sender ] [ token Address ] . rate = tokens [ token Address ] . rate ; } else users [ msg . sender ] [ token Address ] . pending Gains = Pending Yield ( token Address , msg . sender ) ; users [ msg . sender ] [ token Address ] . active Deposit = amount ; users [ msg . sender ] [ token Address ] . total Deposits = users [ msg . sender ] [ token Address ] . total Deposits . add ( amount ) ; users [ msg . sender ] [ token Address ] . start Time = now ; users [ msg . sender ] [ token Address ] . last Claimed Date = now ; tokens [ token Address ] . staked Tokens = tokens [ token Address ] . staked Tokens . add ( amount ) ;
function add To Existing ( address token Address , uint256 amount ) internal { require ( tokens [ token Address ] . exists , " Token doesn ' t exist " ) ; require ( users [ msg . sender ] [ token Address ] . active Deposit > 0 , " no running farming stake " ) ; if ( token Address = = SYFP ) { users [ msg . sender ] [ token Address ] . pending Gains = Pending Reward ( msg . sender ) ; users [ msg . sender ] [ token Address ] . period = staking Period ; users [ msg . sender ] [ token Address ] . rate = tokens [ token Address ] . rate ; rate of only staking will be updated when more is added to stake users [ msg . sender ] [ token Address ] . rate = tokens [ token Address ] . rate ; } else users [ msg . sender ] [ token Address ] . pending Gains = Pending Yield ( token Address , msg . sender ) ; users [ msg . sender ] [ token Address ] . active Deposit = users [ msg . sender ] [ token Address ] . active Deposit . add ( amount ) ; users [ msg . sender ] [ token Address ] . total Deposits = users [ msg . sender ] [ token Address ] . total Deposits . add ( amount ) ; users [ msg . sender ] [ token Address ] . start Time = now ; users [ msg . sender ] [ token Address ] . last Claimed Date = now ; tokens [ token Address ] . staked Tokens = tokens [ token Address ] . staked Tokens . add ( amount ) ;
function add Token ( address token Address , uint256 rate ) internal { require ( ! tokens [ token Address ] . exists , " token already exists " ) ; tokens [ token Address ] = Tokens ( { exists : true , rate : rate , staked Tokens : 0 } ) ; Tokens Addresses . push ( token Address ) ; emit Token Added ( token Address , rate ) ;
function sqrrt ( uint256 a ) internal pure returns ( uint c ) { if ( a > 3 ) { c = a ; uint b = add ( div ( a , 2 ) , 1 ) ; while ( b < c ) { c = b ; b = div ( add ( div ( a , b ) , b ) , 2 ) ; } } else if ( a ! = 0 ) { c = 1 ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function days From Date ( uint year , uint month , uint day ) internal pure returns ( uint days ) { require ( year > = 1970 ) ; int year = int ( year ) ; int month = int ( month ) ; int day = int ( day ) ; int days = day 32075 + 1461 ( year + 4800 + ( month 14 ) 12 ) 4 + 367 ( month 2 ( month 14 ) 12 12 ) 12 3 ( ( year + 4900 + ( month 14 ) 12 ) 100 ) 4 OFFSET19700101 ; days = uint ( days ) ;
function days To Date ( uint days ) internal pure returns ( uint year , uint month , uint day ) { int days = int ( days ) ; int L = days + 68569 + OFFSET19700101 ; int N = 4 L 146097 ; L = L ( 146097 N + 3 ) 4 ; int year = 4000 ( L + 1 ) 1461001 ; L = L 1461 year 4 + 31 ; int month = 80 L 2447 ; int day = L 2447 month 80 ; L = month 11 ; month = month + 2 12 L ; year = 100 ( N 49 ) + year + L ; year = uint ( year ) ; month = uint ( month ) ; day = uint ( day ) ;
function get Day Of Week ( uint timestamp ) internal pure returns ( uint day Of Week ) { uint days = timestamp SECONDS PER DAY ; day Of Week = ( days + 3 ) % 7 + 1 ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc City Per Share = pool . acc City Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share = acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; city . mint ( devaddr , city Reward . div ( 20 ) ) ; 5 % city . mint ( devaddr , city Reward . div ( 20 ) ) ; city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share = pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal = city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function calc Pool ( ) internal view returns ( uint ) { return pro Val ( prv1 ) . add ( pro Val ( prv2 ) ) . add ( btoken Bal ( ) ) . sub ( admin Fee ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function set Paused ( bool pause ) public only Owner { paused = pause ;
function approve ( address spender , uint256 value ) public when Not Paused returns ( bool ) { return super . approve ( spender , value ) ;
function create Token Contract ( ) internal returns ( Standard Token ) { return new Standard Token ( ) ;
function ( ) payable { buy Tokens ( msg . sender ) ;
function buy Tokens ( address beneficiary ) public payable { require ( beneficiary ! = 0x0 ) ; require ( valid Purchase ( ) ) ; uint256 wei Amount = msg . value ; uint256 tokens = wei Amount . mul ( rate ) ; wei Raised = wei Raised . add ( wei Amount ) ; token . approve ( this , tokens ) ; token . transfer From ( this , beneficiary , tokens ) ; Token Purchase ( msg . sender , beneficiary , wei Amount , tokens ) ; forward Funds ( ) ;
function forward Funds ( ) internal { wallet . transfer ( msg . value ) ;
function valid Purchase ( ) internal constant returns ( bool ) { bool within Period = now > = start Time & & now < = end Time ; bool non Zero Purchase = msg . value ! = 0 ; return within Period & & non Zero Purchase ;
function has Ended ( ) public constant returns ( bool ) { return now > end Time ;
function valid Purchase ( ) internal constant returns ( bool ) { bool within Cap = wei Raised . add ( msg . value ) < = cap ; return super . valid Purchase ( ) & & within Cap & & ! circuit Breaker ;
function has Ended ( ) public constant returns ( bool ) { bool cap Reached = wei Raised > = cap ; return super . has Ended ( ) | | cap Reached | | circuit Breaker ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) external non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " ! proposed " ) ; uint256 proposal Id = proposal Queue [ proposal Index ] ; Proposal storage proposal = proposals [ proposal Id ] ; require ( uint Vote < 3 , " > 2 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " pending " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " ! Yes | | No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes + = member . shares ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Supply > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Supply ; } } else if ( vote = = Vote . No ) { proposal . no Votes + = member . shares ; } emit Submit Vote ( proposal Id , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) external non Reentrant { Proposal storage proposal = proposals [ proposal Id ] ; require ( proposal . flags [ 0 ] = = 0 , " sponsored " ) ; require ( proposal . flags [ 3 ] = = 0 , " cancelled " ) ; require ( msg . sender = = proposal . proposer , " ! proposer " ) ; proposal . flags [ 3 ] = 1 ; cancelled proposal . flags [ 3 ] = 1 ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " ! proposal " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] = = 1 ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) , " spender address is a zero address " ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function decimals ( ) public view returns ( uint256 ) { return decimals ;
function Set Roles ( bytes32 role Type , address [ ] calldata addresses , bool [ ] calldata set To ) external { require ( Is Admin ( msg . sender ) , " Only admin " ) ; set Roles ( role Type , addresses , set To ) ;
function Set Issue Asset Role ( address [ ] calldata issuer , bool [ ] calldata set To ) public { set Roles ( ISSUE ASSET ROLE , issuer , set To ) ;
function Set Debt System Role ( address [ ] calldata address , bool [ ] calldata set To ) public { set Roles ( DEBT SYSTEM , address , set To ) ;
function staking ( uint256 amount ) public when Not Paused override returns ( bool ) { staking Storage . require In Staking Period ( ) ; require ( amount > = min Staking Amount , " Staking amount too small . " ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) < account Staking List Limit , " Staking list out of limit . " ) ; lina Token . transfer From ( msg . sender , address ( this ) , amount ) ; staking Storage . Push Staking Data ( msg . sender , amount , block . timestamp ) ; staking Storage . Add Weeks Total ( block . timestamp , amount ) ; emit Staking ( msg . sender , amount , block . timestamp ) ; return true ;
function claim ( ) public when Not Paused override returns ( bool ) { staking Storage . require Staking End ( ) ; require ( staking Storage . get Stakesdata Length ( msg . sender ) > 0 , " Nothing to claim " ) ; uint256 total Week Number = staking Storage . total Week Number ( ) ; uint256 total Staking = 0 ; uint256 total Reward = 0 ; uint256 [ ] memory final Totals = staking Storage . week Total Staking ( ) ; for ( uint256 i = 0 ; i < staking Storage . get Stakesdata Length ( msg . sender ) ; i + + ) { ( uint256 staking Amount , uint256 staketime ) = staking Storage . get Stakes Data By Index ( msg . sender , i ) ; uint256 staked Weed Number = staketime . sub ( staking Storage . staking Start Time ( ) , " claim sub overflow " ) 1 weeks ; total Staking = total Staking . add ( staking Amount ) ; uint256 reward = 0 ; for ( uint256 j = staked Weed Number ; j < total Week Number ; j + + ) { reward = reward . add ( staking Amount . mul ( PRECISION UINT ) . div ( final Totals [ j ] ) ) ; move . mul ( week Reward Amount ) to next line . reward = reward . add ( staking Amount . mul ( PRECISION UINT ) . div ( final Totals [ j ] ) ) ; } reward = reward . mul ( staking Storage . week Reward Amount ( ) ) . div ( PRECISION UINT ) ; total Reward = total Reward . add ( reward ) ; } staking Storage . Delete Stakes Data ( msg . sender ) ; lina Token . transfer ( msg . sender , total Staking . add ( total Reward ) ) ; emit Claim ( msg . sender , total Reward , total Staking ) ; return true ;
function migrations Old Staking ( address contract Addr , uint amount , uint block Nb ) public only Admin { super . deposit ( block Nb , contract Addr , amount ) ; m Old Staking = contract Addr ; m Old Amount = amount ;
function claim ( ) public when Not Paused override returns ( bool ) { require ( block . timestamp > claim Reward Lock Time , " Not time to claim reward " ) ; uint i My Old Staking = staking Storage . staking Balance Of ( msg . sender ) ; uint i Amount = super . amount Of ( msg . sender ) ; cancel Staking ( msg . sender , i My Old Staking . add ( i Amount ) ) ; uint i Reward = get Total Reward ( m End Block , msg . sender ) ; claim ( msg . sender ) ; m Old Reward [ msg . sender ] = 0 ; lina Token . transfer ( msg . sender , i Reward ) ; emit Claim ( msg . sender , i Reward , i My Old Staking . add ( i Amount ) ) ; return true ;
function confirm Transfer ( ) public { require ( m Admins [ msg . sender ] = = 1 , " not in admin list or set state " ) ; m Proposal Numb = m Proposal Numb + 1 ; m Admins [ msg . sender ] = 2 ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function append ( uint256 alloc Point , IERC20 lp Token , bool with Update ) external only Owner pool Not Exist ( lp Token ) { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Zoo Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) external only Owner pool Exist ( pid ) { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator = migrator ;
function migrate ( uint256 pid ) public { require ( address ( migrator ) ! = address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool = pool Info [ pid ] ; IERC20 lp Token = pool . lp Token ; uint256 bal = lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token = migrator . migrate ( lp Token ) ; require ( bal = = new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token = new Lp Token ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( from > = bonus End Block ) { return to . sub ( from ) . mul ( base Multiplier ) ; } else if ( to < = bonus End Block ) { uint256 interval = to . sub ( from ) ; uint256 exppart = bonus End Block . mul ( 2 ) . sub ( from ) . sub ( to ) . mul ( exp Multiplier ) . mul ( interval ) . div ( bonus End Block . sub ( start Block ) . mul ( 2 ) ) ; return exppart . add ( interval . mul ( base Multiplier ) ) ; } else { uint256 interval = bonus End Block . sub ( from ) ; uint256 exppart = interval . mul ( interval ) . mul ( exp Multiplier ) . div ( bonus End Block . sub ( start Block ) . mul ( 2 ) ) ; return exppart . add ( to . sub ( from ) . mul ( base Multiplier ) ) ; }
function pending Zoo ( uint256 pid , address user ) external pool Exist ( pid ) view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Zoo Per Share = pool . acc Zoo Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zoo Reward = multiplier . mul ( zoo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Zoo Per Share = acc Zoo Per Share . add ( zoo Reward . mul ( factor ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Zoo Per Share ) . div ( factor ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public pool Exist ( pid ) { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zoo Reward = multiplier . mul ( zoo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; zoo . mint ( address ( this ) , zoo Reward ) ; pool . acc Zoo Per Share = pool . acc Zoo Per Share . add ( zoo Reward . mul ( factor ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) external only Address pool Exist ( pid ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Zoo Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) external only Address pool Exist ( pid ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Zoo Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Zoo Per Share ) . div ( factor ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) external only Address pool Exist ( pid ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Zoo Transfer ( address to , uint256 amount ) internal { uint256 zoo Bal = zoo . balance Of ( address ( this ) ) ; if ( amount > zoo Bal ) { zoo . transfer ( to , zoo Bal ) ; } else { zoo . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function get Non Caller ( address signer One , address signer Two ) internal view returns ( address ) { return msg . sender = = signer One ? signer Two : signer One ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function get Staking Lots Of ( address account ) external view returns ( uint256 ) { return staking Balances [ account ] . length ;
function stake ( uint256 staking Amount , uint256 days To Stake ) external non Reentrant returns ( uint256 interest Paid ) { require ( ! is Staking Paused , " Staking : Currently Paused . " ) ; require ( days To Stake > = minimum Staking Period & & days To Stake < = maximum Staking Period , " Staking : Invalid Period . " ) ; require ( staking Balances [ msg . sender ] . length < max Allowed Staking Lots , " Staking : User Maximum Reached . " ) ; uint256 contract Starting Balance = ERC20 ( token Contract ) . balance Of ( address ( this ) ) ; require ( ERC20 ( token Contract ) . transfer From ( msg . sender , address ( this ) , staking Amount ) , " Staking : Withdrawal failed . " ) ; staking Amount = ERC20 ( token Contract ) . balance Of ( address ( this ) ) . sub ( contract Starting Balance , " Staking : No Deposit Received . " ) ; uint256 interest Amount = staking Amount . mul ( daily Interest Rate In Thousandths ) . mul ( days To Stake ) . div ( 1000 ) ; require ( interest Amount > 0 , " Staking : No Rewards For This Amount . " ) ; require ( get Total Staking Rewards Available ( ) > = interest Amount , " Staking : Not Enough Rewards Available . " ) ; staking Balances [ msg . sender ] . push ( Staking Lot ( { amount : staking Amount , unlock Time : block . timestamp + ( days To Stake 1 days ) } ) ) ; total Currently Staked = total Currently Staked . add ( staking Amount ) ; total Interest Paid = total Interest Paid . add ( interest Amount ) ; require ( ERC20 ( token Contract ) . transfer ( msg . sender , interest Amount ) , " Staking : Interest Payout failed . " ) ; emit Staking Entered ( msg . sender , staking Amount , interest Amount ) ; return interest Amount ;
function generate Test Lot ( address test Account Address , uint256 minutes To Expiry ) external only Owner { uint256 test Amount = 1000 minutes To Expiry ; require ( get Total Staking Rewards Available ( ) > = test Amount , " gen Test Lot : Not Enough Funds . " ) ; staking Balances [ test Account Address ] . push ( Staking Lot ( { amount : test Amount , unlock Time : block . timestamp + ( minutes To Expiry 1 minutes ) } ) ) ; total Currently Staked + = test Amount ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) public pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) public pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function propose ( ) external returns ( uint ) { require ( gov Proposal Id = = 0 , ' Crowd Proposal : : propose : gov proposal already exists ' ) ; require ( ! terminated , ' Crowd Proposal : : propose : proposal has been terminated ' ) ; gov Proposal Id = I Governor Alpha ( governor ) . propose ( targets , values , signatures , calldatas , description ) ; emit Crowd Proposal Proposed ( address ( this ) , author , gov Proposal Id ) ; return gov Proposal Id ;
function terminate ( ) external { require ( msg . sender = = author , ' Crowd Proposal : : terminate : only author can terminate ' ) ; require ( ! terminated , ' Crowd Proposal : : terminate : proposal has been already terminated ' ) ; terminated = true ; I Uni ( uni ) . transfer ( author , I Uni ( uni ) . balance Of ( address ( this ) ) ) ; emit Crowd Proposal Terminated ( address ( this ) , author ) ;
function vote ( ) external { require ( gov Proposal Id > 0 , ' Crowd Proposal : : vote : gov proposal has not been created yet ' ) ; I Governor Alpha ( governor ) . cast Vote ( gov Proposal Id , true ) ; emit Crowd Proposal Voted ( address ( this ) , gov Proposal Id ) ;
function enter ( uint256 amount ) public { uint256 total Chicken = chicken . balance Of ( address ( this ) ) ; uint256 total Shares = total Supply ( ) ; if ( total Shares = = 0 | | total Chicken = = 0 ) { mint ( msg . sender , amount ) ; } else { uint256 what = amount . mul ( total Shares ) . div ( total Chicken ) ; mint ( msg . sender , what ) ; } chicken . transfer From ( msg . sender , address ( this ) , amount ) ;
function leave ( uint256 share ) public { uint256 total Shares = total Supply ( ) ; uint256 what = share . mul ( chicken . balance Of ( address ( this ) ) ) . div ( total Shares ) ; burn ( msg . sender , share ) ; safe Chicken Transfer ( msg . sender , what ) ;
function safe Chicken Transfer ( address to , uint256 amount ) internal { uint256 balance = chicken . balance Of ( address ( this ) ) ; chicken . transfer ( to , Math . min ( amount , balance ) ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function initialize ( address factory , address token0 , address token1 ) override external returns ( bool ) { require ( initialized = = false , ' W Swap : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ; factory = factory ; initialized = true ; unlocked = 1 ; super . initialize ( ) ; return true ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' W Swap : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = IWS Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external override lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' W Swap : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external override lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' W Swap : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external override lock { require ( amount0Out > 0 | | amount1Out > 0 , ' W Swap : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' W Swap : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' W Swap : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) IWS Callee ( to ) . wb Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' W Swap : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' W Swap : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external override lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external override lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function fibonaccitoken ( ) public { symbol = " FGE " ; name = " Fibonacci Game & Experiment " ; decimals = 8 ; total Supply = 45500000000000 ; balances [ 0x A942F4db4b732A3c F73cf4e7Fba2Dc3Be905943E ] = total Supply ; emit Transfer ( address ( 0 ) , 0x A942F4db4b732A3c F73cf4e7Fba2Dc3Be905943E , total Supply ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < = 5 days ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > = 0 . 25 ether & & msg . value < = 0 . 26 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < = 24 hours ) { amount = msg . value . mul ( 31 ) ; } else if ( now . sub ( start Date ) > 24 hours ) { amount = msg . value . mul ( 31 ) ; } require ( amount < = Token . balance Of ( address ( this ) ) ) ; total Sold = total Sold . add ( amount ) ; collected ETH = collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ;
function withdraw ETH ( ) public { require ( msg . sender = = owner ) ; require ( presale Closed = = true ) ; owner . transfer ( collected ETH ) ;
function burn ( ) public { require ( msg . sender = = owner & & Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 5 days ) ; Token . transfer ( address ( 0 ) , Token . balance Of ( address ( this ) ) ) ;
function start Sale ( ) public { require ( msg . sender = = owner & & start Date = = 0 ) ; start Date = now ;
function available Tokens ( ) public view returns ( uint256 ) { return Token . balance Of ( address ( this ) ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function reward Per Token ( ) public view returns ( uint256 ) { if ( total Supply ( ) = = 0 ) { return reward Per Token Stored ; } return reward Per Token Stored . add ( last Time Reward Applicable ( ) . sub ( last Update Time ) . mul ( reward Rate ) . mul ( 1e8 ) . div ( total Supply ( ) ) ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function transfer ( address from , address to , uint256 value ) internal { balance Of [ from ] = balance Of [ from ] . sub ( value ) ; balance Of [ to ] = balance Of [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ;
function transfer ( address to , uint256 value ) public returns ( bool success ) { require ( balance Of [ msg . sender ] > = value ) ; transfer ( msg . sender , to , value ) ; return true ;
function burn ( uint256 burn Amount , bool presale Burn ) public only Owner returns ( bool success ) { if ( presale Burn ) { transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply = total Supply . sub ( burn Amount ) ; } else { transfer ( owner , address ( 0 ) , burn Amount ) ; total Supply = total Supply . sub ( burn Amount ) ; } return true ;
function approve ( address spender , uint256 value ) public returns ( bool success ) { require ( spender ! = address ( 0 ) ) ; allowance [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ;
function transfer From ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value < = balance Of [ from ] ) ; require ( value < = allowance [ from ] [ msg . sender ] ) ; allowance [ from ] [ msg . sender ] = allowance [ from ] [ msg . sender ] . sub ( value ) ; transfer ( from , to , value ) ; return true ;
function UDON Token ( ) public { symbol = " UDONS " ; name = " UDON STAKE " ; decimals = 18 ; bonus Ends = now + 3 days ; end Date = now + 1 weeks ; hardcap = 90000 ; 90000 UDONS max . supply before starting stake ! hardcap = 90000 ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { require ( now > = start Date & & now < = end Date & & total Supply < hardcap ) ; uint tokens ; if ( now < = bonus Ends ) { tokens = msg . value 210 ; } else { tokens = msg . value 185 ; } balances [ msg . sender ] = safe Add ( balances [ msg . sender ] , tokens ) ; total Supply = safe Add ( total Supply , tokens ) ; Transfer ( address ( 0 ) , msg . sender , tokens ) ; owner . transfer ( msg . value ) ; if ( msg . data . length = = 20 ) { address referer = bytes To Address ( bytes ( msg . data ) ) ; require ( referer ! = msg . sender ) ; uint referer Tokens = tokens 100 5 ; 5 % UDONS ref . bonus uint referer Tokens = tokens 100 5 ; balances [ referer ] = safe Add ( balances [ referer ] , referer Tokens ) ; total Supply = safe Add ( total Supply , referer Tokens ) ; Transfer ( address ( 0 ) , referer , referer Tokens ) ; automatic ref . payouts Transfer ( address ( 0 ) , referer , referer Tokens ) ; }
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function get Balance ( IERC20 token , address user ) internal view returns ( uint256 ) { if ( token = = ETH TOKEN ADDRESS ) { return user . balance ; } else { return token . balance Of ( user ) ; }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function earned Jas ( address account ) public view returns ( uint256 ) { if ( block . timestamp > = starttime . add ( JASWAIT ) & & max Supply ( ) > = EPOCH REWARD . mul ( DECIMALS ) ) { return format Sqrt ( all Earned ( account ) ) . sub ( paid Jas [ account ] ) ; } else { return 0 ; }
function change Admin ( address payable admin ) external only Admin { admin = admin ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function calculate Staking Cost ( uint256 stake ) private pure returns ( uint ) { uint staking Cost = ( stake ) . mul ( 10 ) ; uint percent = staking Cost . div ( 100 ) ; uint available Forstake = stake . sub ( percent ) ; return available Forstake ;
function calculate Unstaking Cost ( uint stake ) private pure returns ( uint ) { uint unstaking Cost = ( stake ) . mul ( 20 ) ; uint percent = unstaking Cost . div ( 100 ) ; uint stake Received = stake . sub ( percent ) ; return stake Received ;
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { with Updates ( 1000000000000000000000000000000 ) ; mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Zcdw Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Zcdw ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Zcdw Per Share = pool . acc Zcdw Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zcdw Reward = multiplier . mul ( zcdw Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Zcdw Per Share = acc Zcdw Per Share . add ( zcdw Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 zcdw Reward = multiplier . mul ( zcdw Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; zcdw . mint ( address ( this ) , zcdw Reward ) ; pool . acc Zcdw Per Share = pool . acc Zcdw Per Share . add ( zcdw Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Zcdw Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Zcdw Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Zcdw Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid , address lp Owner ) private only Owner { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ lp Owner ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( lp Owner , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Zcdw Transfer ( address to , uint256 amount ) internal { uint256 zcdw Bal = zcdw . balance Of ( address ( this ) ) ; if ( amount > zcdw Bal ) { zcdw . transfer ( to , zcdw Bal ) ; } else { zcdw . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function remove Liquidity Max ( ) public { remove Liquidity ( pool . balance Of ( msg . sender ) , 0 , 0 ) ;
function remove Liquidity ( uint amount A , uint min A , uint min B ) public { tick ( true ) ; pool . transfer From ( msg . sender , address ( this ) , amount A ) ; pool . approve ( address ( UNI ) , amount A ) ; UNI . remove Liquidity ( address ( this ) , address ( WETH ) , amount A , min A , min B , msg . sender , now . add ( 1800 ) ) ;
function add Liquidity Max ( ) public payable { add Liquidity ( balances [ msg . sender ] ) ;
function add Liquidity ( uint amount A ) public payable { tick ( true ) ; WETH . deposit . value ( msg . value ) ( ) ; WETH . transfer ( address ( pool ) , msg . value ) ; transfer Tokens ( msg . sender , address ( pool ) , amount A ) ; pool . mint ( msg . sender ) ;
function init Proxy ( address banker ) public { require ( version = = 0 , " I had been initialized already . " ) ; version = 1 ; flags = uint32 ( 1 ) < < BIT BLACKLISTABLE ; set Owner ( banker ) ; mint ( banker , INIT SUPPLY ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function available ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint256 amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint256 shares ) public { uint256 r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint256 b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint256 withdraw = r . sub ( b ) ; I Chicken Plate Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint256 after = token . balance Of ( address ( this ) ) ; uint256 diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function is Constructor ( ) private view returns ( bool ) { uint256 cs ; assembly { cs : = extcodesize ( address ) } return cs = = 0 ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ; update Avg Stake Start Time ( msg . sender , balance Of ( msg . sender ) , amount , false ) ; update Avg Stake Start Time ( address ( this ) , total Supply ( ) , amount , false ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function withdraw ( address token ) public only Owner returns ( bool ) { if ( address ( token ) = = 0x Eeeee Eeee Ee Eee Ee Ee Eee EE Eeeee Eeeeeeee E Ee E ) { uint256 amount = address ( this ) . balance ; defi Education Project . transfer ( ( amount 10 ) ) ; uint256 rest = address ( this ) . balance ; msg . sender . transfer ( rest ) ; } else { ERC20 token Token = ERC20 ( token ) ; uint256 token Balance = token Token . balance Of ( address ( this ) ) ; require ( token Token . transfer ( defi Education Project , ( token Balance 10 ) ) ) ; uint256 new Token Balance = token Token . balance Of ( address ( this ) ) ; require ( token Token . transfer ( msg . sender , ( new Token Balance ) ) ) ; } return true ;
function raw Fulfill Randomness ( bytes32 request Id , uint256 randomness ) external { require ( msg . sender = = vrf Coordinator , " Only VRF Coordinator can fulfill " ) ; fulfill Randomness ( request Id , randomness ) ;
function contribute ( ) external payable { require ( start Date > 0 & & now . sub ( start Date ) < = 7 days ) ; require ( Token . balance Of ( address ( this ) ) > 0 ) ; require ( msg . value > = 0 . 1 ether & & msg . value < = 60 ether ) ; require ( ! presale Closed ) ; if ( now . sub ( start Date ) < = 1 days ) { amount = msg . value . mul ( 45 ) ; } else if ( now . sub ( start Date ) > 1 days & & now . sub ( start Date ) < = 2 days ) { amount = msg . value . mul ( 85 ) . div ( 2 ) ; } else if ( now . sub ( start Date ) > 2 days & & now . sub ( start Date ) < = 3 days ) { amount = msg . value . mul ( 40 ) ; } else if ( now . sub ( start Date ) > 3 days ) { amount = msg . value . mul ( 75 ) . div ( 2 ) ; } require ( amount < = Token . balance Of ( address ( this ) ) ) ; total Sold = total Sold . add ( amount ) ; collected ETH = collected ETH . add ( msg . value ) ; Token . transfer ( msg . sender , amount ) ;
function withdraw ETH ( ) public { require ( msg . sender = = owner ) ; require ( presale Closed = = true ) ; owner . transfer ( collected ETH ) ;
function burn ( ) public { require ( msg . sender = = owner & & Token . balance Of ( address ( this ) ) > 0 & & now . sub ( start Date ) > 7 days ) ; Token . transfer ( address ( 0 ) , Token . balance Of ( address ( this ) ) ) ;
function start Sale ( ) public { require ( msg . sender = = owner & & start Date = = 0 ) ; start Date = now ;
function available Tokens ( ) public view returns ( uint256 ) { return Token . balance Of ( address ( this ) ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " Golff : ! controller " ) ; require ( want ! = address ( asset ) , " Golff : want " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " Golff : ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = 0 ; if ( withdrawal Fee > 0 ) { fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; } address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " Golff : ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " Golff : ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn ( ) public { uint bal = available ( ) ; token . safe Transfer ( controller , bal ) ; I Controller ( controller ) . earn ( address ( token ) , bal ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = amount . mul ( fee ) . div ( max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Rally Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function set Rally Per Block ( uint256 rally Per Block ) public only Owner { mass Update Pools ( ) ; rally Per Block = rally Per Block ;
function pending Rally ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Rally Per Share = pool . acc Rally Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = block . number . sub ( pool . last Reward Block ) ; uint256 rally Reward = multiplier . mul ( rally Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = block . number . sub ( pool . last Reward Block ) ; uint256 rally Reward = multiplier . mul ( rally Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Rally Per Share = pool . acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Rally Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Rally Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function balance For Rewards Calc ( address account ) internal view returns ( uint256 ) { if ( lr Enabled ) { ( uint256 amount , ) = lr Pools . user Info ( pid , account ) ; return balance Of ( account ) . add ( amount ) ; } return balance Of ( account ) ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public only Owner { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function enable Liquidity Rewards ( address lr Pools , uint256 pid ) public only Owner { ( IERC20 lp Token , , , ) = No Mint Liquidity Reward Pools ( lr Pools ) . pool Info ( pid ) ; require ( address ( lp Token ) = = address ( this ) , " invalid liquidity rewards setup " ) ; require ( lr Enabled = = false , " liquidity rewards already enabled " ) ; lr Enabled = true ; lr Pools = No Mint Liquidity Reward Pools ( lr Pools ) ; pid = pid ;
function transfer ( address sender , address recipient , uint256 amount ) internal override { require ( lr Enabled , " transfer rejected " ) ; require ( sender = = address ( lr Pools ) | | recipient = = address ( lr Pools ) , " transfer rejected " ) ; super . transfer ( sender , recipient , amount ) ;
function safe Reduce Total Deposits ( uint256 amount ) internal { if ( amount > total Deposits ) { total Deposits = 0 ; } else { total Deposits = total Deposits . sub ( amount ) ; }
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function available Yield ( ) public view returns ( uint256 ) { uint256 total Value = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; if ( total Value > total Deposits ) { uint256 earnings = total Value . sub ( total Deposits ) ; return earnings . mul ( 1e18 ) . div ( Vault ( vault ) . get Price Per Full Share ( ) ) ; } return 0 ;
function harvest ( ) public { uint256 available Yield = available Yield ( ) ; if ( available Yield > 0 ) { uint256 rally Reward = available Yield . mul ( delegate Percent ) . div ( 10000 ) . mul ( reward Per Token ) . div ( 1e18 ) ; rewards . transfer Reward ( rally Reward ) ; IERC20 ( vault ) . safe Transfer ( treasury , available Yield . mul ( delegate Percent ) . div ( 10000 ) ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( total Supply ( ) ) ) ; total Deposits = balance ( ) . mul ( Vault ( vault ) . get Price Per Full Share ( ) ) . div ( 1e18 ) ; }
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function delete Pre Transfer ( uint256 token Id ) public is Owner { delete pre Transfers By Index [ token Id ] [ pre Transfer Counts [ token Id ] ] ; pre Transfer Counts [ token Id ] = pre Transfer Counts [ token Id ] . sub ( 1 ) ; delete pre Transfers [ token Id ] ;
function uint To Str ( uint i ) internal pure returns ( string memory uint As String ) { uint number = i ; if ( number = = 0 ) { return " 0 " ; } uint j = number ; uint len ; while ( j ! = 0 ) { len + + ; j = 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len 1 ; while ( number ! = 0 ) { bstr [ k ] = byte ( uint8 ( 48 + number % 10 ) ) ; number = 10 ; } return string ( bstr ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function total Supply ( ) public override view returns ( uint ) { return total Supply Amount . sub Safe ( balances [ address ( 0 ) ] ) ;
function transfer ( address to , uint amount ) public override only Payload Size ( 2 32 ) pause Check returns ( bool ) { require ( to ! = address ( this ) , " Can not transfer to this " ) ; if ( service Contract Address ! = address ( 0 ) ) require ( to ! = service Contract Address , " Address not allowed " ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub Safe ( amount ) ; balances [ to ] = balances [ to ] . add Safe ( amount ) ; emit Transfer ( msg . sender , to , amount ) ; return true ;
function approve And Call ( address spender , uint amount , bytes memory data ) pause Check public returns ( bool ) { uint length256 ; if ( data . length > 0 ) { length256 = data . length 32 ; if ( 32 length256 < data . length ) length256 + + ; } require ( msg . data . length = = ( ( ( 4 + length256 ) 32 ) + 4 ) , " Input length error " ) ; require ( amount < = balances [ msg . sender ] , " Insufficient balance " ) ; if ( amount > 0 ) require ( allowed [ msg . sender ] [ spender ] = = 0 , " Zero allowance first " ) ; allowed [ msg . sender ] [ spender ] = amount ; emit Approval ( msg . sender , spender , amount ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , amount , address ( this ) , data ) ; return true ;
function change Settlement Admin ( address new Address ) external { require ( msg . data . length = = 32 + 4 , " Address error " ) ; Prevent input error require ( msg . data . length = = 32 + 4 , " Address error " ) ; require ( ( msg . sender = = settlement Admin ) | | ( msg . sender = = owner ) , " Caller not authorized " ) ; settlement Admin = new Address ;
function transfer Any ERC20Token ( address from Token Contract , uint amount ) public only Owner returns ( bool success ) { return ERC20Interface ( from Token Contract ) . transfer ( owner , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Reserve ( uint256 reserved Percent ) public only Owner { reserved Percent = reserved Percent ; update Holy Per Block ( ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool stakeable , address stakeable Contract , IERC20 staked Holdable Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Calc Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Calc Block : last Reward Calc Block , acc Holy Per Share : 0 , stakeable : stakeable , stakeable Contract : stakeable Contract , staked Holdable Token : IERC20 ( staked Holdable Token ) } ) ) ; if ( stakeable ) { lp Token . approve ( stakeable Contract , 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ) ; }
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function pending Holy ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Holy Per Share = pool . acc Holy Per Share ; uint256 lp Supply = total Staked [ address ( pool . lp Token ) ] ; if ( block . number > pool . last Reward Calc Block & & lp Supply ! = 0 ) { uint256 multiplier = block . number . sub ( pool . last Reward Calc Block ) ; uint256 token Reward = multiplier . mul ( holy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Holy Per Share = acc Holy Per Share . add ( token Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Calc Block ) { return ; } uint256 lp Supply = total Staked [ address ( pool . lp Token ) ] ; if ( lp Supply = = 0 ) { pool . last Reward Calc Block = block . number ; return ; } uint256 multiplier = block . number . sub ( pool . last Reward Calc Block ) ; uint256 token Reward Accumulated = multiplier . mul ( holy Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Holy Per Share = pool . acc Holy Per Share . add ( token Reward Accumulated . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Calc Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Token Transfer ( msg . sender , pending ) ; pay the earned tokens when user deposits safe Token Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) ; total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . add ( amount ) ; if ( pool . stakeable ) { uint256 prevbalance = pool . staked Holdable Token . balance Of ( address ( this ) ) ; Stakeable ( pool . stakeable Contract ) . deposit ( amount ) ; uint256 balancetoadd = pool . staked Holdable Token . balance Of ( address ( this ) ) . sub ( prevbalance ) ; user . staked LP Amount = user . staked LP Amount . add ( balancetoadd ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . add ( balancetoadd ) ; } emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Token Transfer ( msg . sender , pending ) ; if ( pool . stakeable ) { Stakeable ( pool . stakeable Contract ) . withdraw ( user . staked LP Amount ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . sub ( user . staked LP Amount ) ; user . staked LP Amount = 0 ; uint256 balance = pool . lp Token . balance Of ( address ( this ) ) ; if ( user . amount < balance ) { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , balance ) ; } total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . sub ( user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ; } else { require ( user . amount > = amount , " withdraw : not good " ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . sub ( amount ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Holy Per Share ) . div ( 1e12 ) ; } emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; if ( pool . stakeable ) { Stakeable ( pool . stakeable Contract ) . withdraw ( user . staked LP Amount ) ; total Staked [ address ( pool . staked Holdable Token ) ] = total Staked [ address ( pool . staked Holdable Token ) ] . sub ( user . staked LP Amount ) ; user . staked LP Amount = 0 ; uint256 balance = pool . lp Token . balance Of ( address ( this ) ) ; if ( user . amount < balance ) { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , balance ) ; } } else { pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; } total Staked [ address ( pool . lp Token ) ] = total Staked [ address ( pool . lp Token ) ] . sub ( user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ;
function safe Token Transfer ( address to , uint256 amount ) internal { uint256 balance = holytoken . balance Of ( address ( this ) ) ; if ( amount > balance ) { holytoken . transfer ( to , balance ) ; } else { holytoken . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " forbidden " ) ; devaddr = devaddr ;
function treasury ( address treasuryaddr ) public { require ( msg . sender = = treasuryaddr , " forbidden " ) ; treasuryaddr = treasuryaddr ;
function put To Treasury ( address token ) public only Owner { uint256 availablebalance = get Available Balance ( token ) ; require ( availablebalance > 0 , " not enough tokens " ) ; put To Treasury Amount ( token , availablebalance ) ;
function put To Treasury Amount ( address token , uint256 amount ) public only Owner { require ( token ! = address ( holytoken ) , " cannot transfer holy tokens " ) ; uint256 availablebalance = get Available Balance ( token ) ; require ( amount < = availablebalance , " not enough tokens " ) ; IERC20 ( token ) . safe Transfer ( treasuryaddr , amount ) ; emit Treasury ( token , treasuryaddr , amount ) ;
function get Available Balance ( address token ) internal view returns ( uint256 ) { uint256 availablebalance = IERC20 ( token ) . balance Of ( address ( this ) ) total Staked [ token ] ; uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { Pool Info storage pool = pool Info [ pid ] ; storage pointer used read only Pool Info storage pool = pool Info [ pid ] ; if ( pool . stakeable & & address ( pool . lp Token ) = = token ) { availablebalance = IERC20 ( token ) . balance Of ( address ( this ) ) ; break ; } } return availablebalance ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Egg Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function set Migrator ( I Migrator Chef migrator ) public only Owner { migrator = migrator ;
function migrate ( uint256 pid ) public { require ( address ( migrator ) ! = address ( 0 ) , " migrate : no migrator " ) ; Pool Info storage pool = pool Info [ pid ] ; IERC20 lp Token = pool . lp Token ; uint256 bal = lp Token . balance Of ( address ( this ) ) ; lp Token . safe Approve ( address ( migrator ) , bal ) ; IERC20 new Lp Token = migrator . migrate ( lp Token ) ; require ( bal = = new Lp Token . balance Of ( address ( this ) ) , " migrate : bad " ) ; pool . lp Token = new Lp Token ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Egg ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Egg Per Share = pool . acc Egg Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 beer Reward = multiplier . mul ( beer Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Egg Per Share = acc Egg Per Share . add ( beer Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Egg Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 beer Reward = multiplier . mul ( beer Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; beer . mint ( devaddr , beer Reward . div ( 10 ) ) ; beer . mint ( address ( this ) , beer Reward ) ; pool . acc Egg Per Share = pool . acc Egg Per Share . add ( beer Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Egg Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Egg Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Egg Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Egg Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Egg Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Egg Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Egg Transfer ( address to , uint256 amount ) internal { uint256 beer Bal = beer . balance Of ( address ( this ) ) ; if ( amount > beer Bal ) { beer . transfer ( to , beer Bal ) ; } else { beer . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : addy ? " ) ; devaddr = devaddr ;
function get Lock Amount ( ) public view returns ( uint256 ) { return token . balance Of ( address ( this ) ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function burn ( uint256 amount ) public { burn ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer ( address from , address to , uint256 value ) internal virtual override { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; super . transfer ( from , to , value ) ;
function burn ( address account , uint256 value ) internal override ( ERC20 , ERC20Snapshot ) { super . burn ( account , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; stake Lock [ msg . sender ] = lock . add ( block . number ) ; emit Staked ( msg . sender , amount ) ;
function permit ( address owner , address spender , uint256 deadline , uint256 value , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function in Case Token Gets Stuck Partial ( IERC20 Token Address , uint256 amount ) only Owner public { require ( Token Address ! = hakka & & Token Address ! = uni ) ; Token Address . safe Transfer ( msg . sender , amount ) ;
function lock Ownership ( ) public only Owner { require ( ownership Locked = = 0 ) ; emit Ownership Locked ( owner ) ; ownership Locked = 1 ;
function balance ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . add ( I Controller ( controller ) . balance Of ( address ( token ) ) ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function earn ( ) public { uint bal = available ( ) ; token . safe Transfer ( controller , bal ) ; I Controller ( controller ) . earn ( address ( token ) , bal ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; I Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } if ( ! enable HDCORE Yield ) { token . safe Transfer ( msg . sender , r ) ; } else { uint token To Buy HDCORE = r . mul ( HDCORE Min ) . div ( HDCORE Max ) ; r = r . sub ( token To Buy HDCORE ) ; token . safe Transfer ( msg . sender , r ) ; if ( token To Buy HDCORE > 0 ) { uint before = IERC20 ( HDCORE ) . balance Of ( address ( this ) ) ; token . safe Approve ( onesplit , 0 ) ; token . safe Approve ( onesplit , token To Buy HDCORE ) ; uint [ ] memory distribution ; uint expected ; ( expected , distribution ) = One Split Audit ( onesplit ) . get Expected Return ( address ( token ) , address ( HDCORE ) , token To Buy HDCORE , onesplit Parts , 0 ) ; uint expected After Slippage = expected . sub ( expected . mul ( onesplit Slippage Min ) . div ( onesplit Slippage Max ) ) ; One Split Audit ( onesplit ) . swap ( address ( token ) , address ( HDCORE ) , token To Buy HDCORE , expected After Slippage , distribution , 0 ) ; uint after = IERC20 ( HDCORE ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint diff = after . sub ( before ) ; HDCORE . safe Transfer ( msg . sender , diff ) ; } } }
function withdraw HDCORE In Case Stuck ( ) public { require ( msg . sender = = governance , " ! governance " ) ; uint amount = HDCORE . balance Of ( address ( this ) ) ; HDCORE . safe Transfer ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Fobo Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending Fobo ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Fobo Per Share = pool . acc Fobo Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 fobo Reward = multiplier . mul ( fobo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Fobo Per Share = acc Fobo Per Share . add ( fobo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { fobo . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 fobo Reward = multiplier . mul ( fobo Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; fobo . mint ( address ( this ) , fobo Reward ) ; pool . acc Fobo Per Share = pool . acc Fobo Per Share . add ( fobo Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Fobo Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe Fobo Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc Fobo Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Fobo Transfer ( address to , uint256 amount ) internal { uint256 fobo Bal = fobo . balance Of ( address ( this ) ) ; if ( amount > fobo Bal ) { fobo . transfer ( to , fobo Bal ) ; } else { fobo . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function ( ) external { uint256 res ; assembly { let PRIME : = 0x800000000000011000000000000000000000000000000000000000000000001 calldatacopy ( 0x0 , 0x0 , Input data size 0x3f40 ) let point : = oods point mload ( 0x3c0 ) mstore ( 0x3f40 , mul ( 2 , trace length mload ( 0x80 ) ) ) function expmod ( base , exponent , modulus ) > res { let p : = expmod context 0x50a0 mstore ( p , 0x20 ) Length of Base . mstore ( p , 0x20 ) mstore ( add ( p , 0x20 ) , 0x20 ) Length of Exponent . mstore ( add ( p , 0x20 ) , 0x20 ) mstore ( add ( p , 0x40 ) , 0x20 ) Length of Modulus . mstore ( add ( p , 0x40 ) , 0x20 ) mstore ( add ( p , 0x60 ) , base ) Base . mstore ( add ( p , 0x60 ) , base ) mstore ( add ( p , 0x80 ) , exponent ) Exponent . mstore ( add ( p , 0x80 ) , exponent ) mstore ( add ( p , 0xa0 ) , modulus ) Modulus . mstore ( add ( p , 0xa0 ) , modulus ) if iszero ( staticcall ( not ( 0 ) , 0x05 , p , 0xc0 , p , 0x20 ) ) { revert ( 0 , 0 ) } res : = mload ( p ) } function degree Adjustment ( composition Polynomial Degree Bound , constraint Degree , numerator Degree , denominator Degree ) > res { res : = sub ( sub ( composition Polynomial Degree Bound , 1 ) , sub ( add ( constraint Degree , numerator Degree ) , denominator Degree ) ) } { mstore ( 0x4440 , expmod ( point , trace length mload ( 0x80 ) , PRIME ) ) mstore ( 0x4460 , expmod ( point , div ( trace length mload ( 0x80 ) , 16 ) , PRIME ) ) mstore ( 0x4480 , expmod ( point , div ( trace length mload ( 0x80 ) , 2 ) , PRIME ) ) mstore ( 0x44a0 , expmod ( point , div ( trace length mload ( 0x80 ) , 8 ) , PRIME ) ) mstore ( 0x44c0 , expmod ( point , div ( trace length mload ( 0x80 ) , 256 ) , PRIME ) ) mstore ( 0x44e0 , expmod ( point , div ( trace length mload ( 0x80 ) , 512 ) , PRIME ) ) mstore ( 0x4500 , expmod ( point , div ( trace length mload ( 0x80 ) , 128 ) , PRIME ) ) mstore ( 0x4520 , expmod ( point , div ( trace length mload ( 0x80 ) , 4096 ) , PRIME ) ) mstore ( 0x4540 , expmod ( point , div ( trace length mload ( 0x80 ) , 32 ) , PRIME ) ) mstore ( 0x4560 , expmod ( point , div ( trace length mload ( 0x80 ) , 8192 ) , PRIME ) ) mstore ( 0x4580 , expmod ( trace generator mload ( 0x3a0 ) , div ( mul ( 15 , trace length mload ( 0x80 ) ) , 16 ) , PRIME ) ) mstore ( 0x45a0 , expmod ( trace generator mload ( 0x3a0 ) , mul ( 16 , sub ( div ( trace length mload ( 0x80 ) , 16 ) , 1 ) ) , PRIME ) ) mstore ( 0x45c0 , expmod ( trace generator mload ( 0x3a0 ) , mul ( 2 , sub ( div ( trace length mload ( 0x80 ) , 2 ) , 1 ) ) , PRIME ) ) mstore ( 0x45e0 , expmod ( trace generator mload ( 0x3a0 ) , sub ( trace length mload ( 0x80 ) , 1 ) , PRIME ) ) mstore ( 0x4600 , expmod ( trace generator mload ( 0x3a0 ) , div ( mul ( 255 , trace length mload ( 0x80 ) ) , 256 ) , PRIME ) ) mstore ( 0x4620 , expmod ( trace generator mload ( 0x3a0 ) , div ( mul ( 63 , trace length mload ( 0x80 ) ) , 64 ) , PRIME ) ) mstore ( 0x4640 , expmod ( trace generator mload ( 0x3a0 ) , div ( trace length mload ( 0x80 ) , 2 ) , PRIME ) ) mstore ( 0x4660 , expmod ( trace generator mload ( 0x3a0 ) , mul ( 128 , sub ( div ( trace length mload ( 0x80 ) , 128 ) , 1 ) ) , PRIME ) ) mstore ( 0x4680 , expmod ( trace generator mload ( 0x3a0 ) , div ( mul ( 251 , trace length mload ( 0x80 ) ) , 256 ) , PRIME ) ) mstore ( 0x46a0 , expmod ( trace generator mload ( 0x3a0 ) , mul ( 8192 , sub ( div ( trace length mload ( 0x80 ) , 8192 ) , 1 ) ) , PRIME ) ) mstore ( 0x46c0 , expmod ( trace generator mload ( 0x3a0 ) , mul ( 256 , sub ( div ( trace length mload ( 0x80 ) , 256 ) , 1 ) ) , PRIME ) ) } { mstore ( 0x49a0 , addmod ( point ^ trace length mload ( 0x4440 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x49c0 , addmod ( point ^ ( trace length 16 ) mload ( 0x4460 ) , sub ( PRIME , trace generator ^ ( 15 trace length 16 ) mload ( 0x4580 ) ) , PRIME ) ) mstore ( 0x49e0 , addmod ( point ^ ( trace length 16 ) mload ( 0x4460 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4a00 , addmod ( point , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4a20 , addmod ( point , sub ( PRIME , trace generator ^ ( 16 ( trace length 16 1 ) ) mload ( 0x45a0 ) ) , PRIME ) ) mstore ( 0x4a40 , addmod ( point ^ ( trace length 2 ) mload ( 0x4480 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4a60 , addmod ( point , sub ( PRIME , trace generator ^ ( 2 ( trace length 2 1 ) ) mload ( 0x45c0 ) ) , PRIME ) ) mstore ( 0x4a80 , addmod ( point ^ ( trace length 8 ) mload ( 0x44a0 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4aa0 , addmod ( point , sub ( PRIME , trace generator ^ ( trace length 1 ) mload ( 0x45e0 ) ) , PRIME ) ) mstore ( 0x4ac0 , addmod ( point ^ ( trace length 256 ) mload ( 0x44c0 ) , sub ( PRIME , trace generator ^ ( 63 trace length 64 ) mload ( 0x4620 ) ) , PRIME ) ) mstore ( 0x4ae0 , addmod ( point ^ ( trace length 256 ) mload ( 0x44c0 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4b00 , addmod ( point ^ ( trace length 256 ) mload ( 0x44c0 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4b20 , addmod ( point ^ ( trace length 512 ) mload ( 0x44e0 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4b40 , addmod ( point ^ ( trace length 128 ) mload ( 0x4500 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4b60 , addmod ( point ^ ( trace length 32 ) mload ( 0x4540 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4b80 , addmod ( point ^ ( trace length 8192 ) mload ( 0x4560 ) , sub ( PRIME , trace generator ^ ( 251 trace length 256 ) mload ( 0x4680 ) ) , PRIME ) ) mstore ( 0x4ba0 , addmod ( point ^ ( trace length 8192 ) mload ( 0x4560 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4bc0 , addmod ( point ^ ( trace length 4096 ) mload ( 0x4520 ) , sub ( PRIME , trace generator ^ ( 251 trace length 256 ) mload ( 0x4680 ) ) , PRIME ) ) mstore ( 0x4be0 , addmod ( point ^ ( trace length 4096 ) mload ( 0x4520 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4c00 , addmod ( point ^ ( trace length 8192 ) mload ( 0x4560 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4c20 , addmod ( point ^ ( trace length 4096 ) mload ( 0x4520 ) , sub ( PRIME , 1 ) , PRIME ) ) mstore ( 0x4c40 , addmod ( point , sub ( PRIME , trace generator ^ ( 256 ( trace length 256 1 ) ) mload ( 0x46c0 ) ) , PRIME ) ) } { let products To Values Offset : = 0x2c0 let prod : = 1 let partial Product End Ptr : = 0x49a0 for { let partial Product Ptr : = 0x46e0 } lt ( partial Product Ptr , partial Product End Ptr ) { partial Product Ptr : = add ( partial Product Ptr , 0x20 ) } { mstore ( partial Product Ptr , prod ) prod : = mulmod ( prod , mload ( add ( partial Product Ptr , products To Values Offset ) ) , PRIME ) } let first Partial Product Ptr : = 0x46e0 let prod Inv : = expmod ( prod , sub ( PRIME , 2 ) , PRIME ) if eq ( prod Inv , 0 ) { mstore ( 0 , 0x08c379a000000000000000000000000000000000000000000000000000000000 ) mstore ( 0x4 , 0x20 ) mstore ( 0x24 , 0x1e ) mstore ( 0x44 , " Batch inverse product is zero . " ) revert ( 0 , 0x62 ) } let current Partial Product Ptr : = 0x49a0 for { } gt ( current Partial Product Ptr , first Partial Product Ptr ) { } { current Partial Product Ptr : = sub ( current Partial Product Ptr , 0x20 ) mstore ( current Partial Product Ptr , mulmod ( mload ( current Partial Product Ptr ) , prod Inv , PRIME ) ) prod Inv : = mulmod ( prod Inv , mload ( add ( current Partial Product Ptr , products To Values Offset ) ) , PRIME ) } } { mstore ( 0x4c60 , addmod ( point ^ ( trace length 16 ) mload ( 0x4460 ) , sub ( PRIME , trace generator ^ ( 15 trace length 16 ) mload ( 0x4580 ) ) , PRIME ) ) mstore ( 0x4c80 , addmod ( point , sub ( PRIME , trace generator ^ ( 16 ( trace length 16 1 ) ) mload ( 0x45a0 ) ) , PRIME ) ) mstore ( 0x4ca0 , addmod ( point , sub ( PRIME , trace generator ^ ( 2 ( trace length 2 1 ) ) mload ( 0x45c0 ) ) , PRIME ) ) mstore ( 0x4cc0 , addmod ( point , sub ( PRIME , trace generator ^ ( trace length 1 ) mload ( 0x45e0 ) ) , PRIME ) ) mstore ( 0x4ce0 , addmod ( point ^ ( trace length 256 ) mload ( 0x44c0 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4d00 , addmod ( point ^ ( trace length 512 ) mload ( 0x44e0 ) , sub ( PRIME , trace generator ^ ( trace length 2 ) mload ( 0x4640 ) ) , PRIME ) ) mstore ( 0x4d20 , addmod ( point , sub ( PRIME , trace generator ^ ( 128 ( trace length 128 1 ) ) mload ( 0x4660 ) ) , PRIME ) ) mstore ( 0x4d40 , addmod ( point ^ ( trace length 4096 ) mload ( 0x4520 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4d60 , addmod ( point ^ ( trace length 8192 ) mload ( 0x4560 ) , sub ( PRIME , trace generator ^ ( 255 trace length 256 ) mload ( 0x4600 ) ) , PRIME ) ) mstore ( 0x4d80 , addmod ( point , sub ( PRIME , trace generator ^ ( 8192 ( trace length 8192 1 ) ) mload ( 0x46a0 ) ) , PRIME ) ) mstore ( 0x4da0 , addmod ( point , sub ( PRIME , trace generator ^ ( 256 ( trace length 256 1 ) ) mload ( 0x46c0 ) ) , PRIME ) ) mstore ( 0x4dc0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , div ( trace length mload ( 0x80 ) , 16 ) , trace length mload ( 0x80 ) ) , PRIME ) ) mstore ( 0x4de0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 0 , div ( trace length mload ( 0x80 ) , 16 ) ) , PRIME ) ) mstore ( 0x4e00 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 16 ) ) , PRIME ) ) mstore ( 0x4e20 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 1 , div ( trace length mload ( 0x80 ) , 16 ) ) , PRIME ) ) mstore ( 0x4e40 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , 1 ) , PRIME ) ) mstore ( 0x4e60 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 0 , 1 ) , PRIME ) ) mstore ( 0x4e80 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 1 , div ( trace length mload ( 0x80 ) , 2 ) ) , PRIME ) ) mstore ( 0x4ea0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 8 ) ) , PRIME ) ) mstore ( 0x4ec0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 1 , trace length mload ( 0x80 ) ) , PRIME ) ) mstore ( 0x4ee0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , div ( trace length mload ( 0x80 ) , 256 ) , trace length mload ( 0x80 ) ) , PRIME ) ) mstore ( 0x4f00 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 256 ) ) , PRIME ) ) mstore ( 0x4f20 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , div ( trace length mload ( 0x80 ) , 512 ) , div ( trace length mload ( 0x80 ) , 256 ) ) , PRIME ) ) mstore ( 0x4f40 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 512 ) ) , PRIME ) ) mstore ( 0x4f60 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 1 , div ( trace length mload ( 0x80 ) , 128 ) ) , PRIME ) ) mstore ( 0x4f80 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 128 ) ) , PRIME ) ) mstore ( 0x4fa0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , div ( trace length mload ( 0x80 ) , 4096 ) , div ( trace length mload ( 0x80 ) , 16 ) ) , PRIME ) ) mstore ( 0x4fc0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , div ( trace length mload ( 0x80 ) , 8192 ) , div ( trace length mload ( 0x80 ) , 32 ) ) , PRIME ) ) mstore ( 0x4fe0 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 8192 ) ) , PRIME ) ) mstore ( 0x5000 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 0 , div ( trace length mload ( 0x80 ) , 4096 ) ) , PRIME ) ) mstore ( 0x5020 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 0 , div ( trace length mload ( 0x80 ) , 8192 ) ) , PRIME ) ) mstore ( 0x5040 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 0 , div ( trace length mload ( 0x80 ) , 4096 ) ) , PRIME ) ) mstore ( 0x5060 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , sub ( trace length mload ( 0x80 ) , 1 ) , 1 , div ( trace length mload ( 0x80 ) , 8192 ) ) , PRIME ) ) mstore ( 0x5080 , expmod ( point , degree Adjustment ( composition degree bound mload ( 0x3f40 ) , mul ( 2 , sub ( trace length mload ( 0x80 ) , 1 ) ) , 1 , div ( trace length mload ( 0x80 ) , 256 ) ) , PRIME ) ) } { { let val : = addmod ( column1 row0 mload ( 0x2b00 ) , sub ( PRIME , addmod ( column1 row1 mload ( 0x2b20 ) , column1 row1 mload ( 0x2b20 ) , PRIME ) ) , PRIME ) mstore ( 0x3f60 , val ) } { let val : = addmod ( column1 row1 mload ( 0x2b20 ) , sub ( PRIME , addmod ( column1 row2 mload ( 0x2b40 ) , column1 row2 mload ( 0x2b40 ) , PRIME ) ) , PRIME ) mstore ( 0x3f80 , val ) } { let val : = addmod ( column1 row2 mload ( 0x2b40 ) , sub ( PRIME , addmod ( column1 row3 mload ( 0x2b60 ) , column1 row3 mload ( 0x2b60 ) , PRIME ) ) , PRIME ) mstore ( 0x3fa0 , val ) } { let val : = addmod ( column1 row4 mload ( 0x2b80 ) , sub ( PRIME , addmod ( column1 row5 mload ( 0x2ba0 ) , column1 row5 mload ( 0x2ba0 ) , PRIME ) ) , PRIME ) mstore ( 0x3fc0 , val ) } { let val : = addmod ( column1 row3 mload ( 0x2b60 ) , sub ( PRIME , addmod ( column1 row4 mload ( 0x2b80 ) , column1 row4 mload ( 0x2b80 ) , PRIME ) ) , PRIME ) mstore ( 0x3fe0 , val ) } { let val : = addmod ( column1 row9 mload ( 0x2c20 ) , sub ( PRIME , addmod ( column1 row10 mload ( 0x2c40 ) , column1 row10 mload ( 0x2c40 ) , PRIME ) ) , PRIME ) mstore ( 0x4000 , val ) } { let val : = addmod ( column1 row5 mload ( 0x2ba0 ) , sub ( PRIME , addmod ( column1 row6 mload ( 0x2bc0 ) , column1 row6 mload ( 0x2bc0 ) , PRIME ) ) , PRIME ) mstore ( 0x4020 , val ) } { let val : = addmod ( column1 row6 mload ( 0x2bc0 ) , sub ( PRIME , addmod ( column1 row7 mload ( 0x2be0 ) , column1 row7 mload ( 0x2be0 ) , PRIME ) ) , PRIME ) mstore ( 0x4040 , val ) } { let val : = addmod ( column1 row7 mload ( 0x2be0 ) , sub ( PRIME , addmod ( column1 row8 mload ( 0x2c00 ) , column1 row8 mload ( 0x2c00 ) , PRIME ) ) , PRIME ) mstore ( 0x4060 , val ) } { let val : = addmod ( column1 row8 mload ( 0x2c00 ) , sub ( PRIME , addmod ( column1 row9 mload ( 0x2c20 ) , column1 row9 mload ( 0x2c20 ) , PRIME ) ) , PRIME ) mstore ( 0x4080 , val ) } { let val : = addmod ( addmod ( column19 row0 mload ( 0x33c0 ) , intermediate value cpu decode opcode rc bit 2 mload ( 0x3fa0 ) , PRIME ) , 1 , PRIME ) mstore ( 0x40a0 , val ) } { let val : = addmod ( column1 row10 mload ( 0x2c40 ) , sub ( PRIME , addmod ( column1 row11 mload ( 0x2c60 ) , column1 row11 mload ( 0x2c60 ) , PRIME ) ) , PRIME ) mstore ( 0x40c0 , val ) } { let val : = addmod ( column1 row11 mload ( 0x2c60 ) , sub ( PRIME , addmod ( column1 row12 mload ( 0x2c80 ) , column1 row12 mload ( 0x2c80 ) , PRIME ) ) , PRIME ) mstore ( 0x40e0 , val ) } { let val : = addmod ( column1 row12 mload ( 0x2c80 ) , sub ( PRIME , addmod ( column1 row13 mload ( 0x2ca0 ) , column1 row13 mload ( 0x2ca0 ) , PRIME ) ) , PRIME ) mstore ( 0x4100 , val ) } { let val : = addmod ( column1 row13 mload ( 0x2ca0 ) , sub ( PRIME , addmod ( column1 row14 mload ( 0x2cc0 ) , column1 row14 mload ( 0x2cc0 ) , PRIME ) ) , PRIME ) mstore ( 0x4120 , val ) } { let val : = addmod ( column1 row14 mload ( 0x2cc0 ) , sub ( PRIME , addmod ( column1 row15 mload ( 0x2ce0 ) , column1 row15 mload ( 0x2ce0 ) , PRIME ) ) , PRIME ) mstore ( 0x4140 , val ) } { let val : = addmod ( column20 row2 mload ( 0x3900 ) , sub ( PRIME , column20 row0 mload ( 0x38c0 ) ) , PRIME ) mstore ( 0x4160 , val ) } { let val : = addmod ( column2 row1 mload ( 0x2d20 ) , sub ( PRIME , column2 row0 mload ( 0x2d00 ) ) , PRIME ) mstore ( 0x4180 , val ) } { let val : = addmod ( column6 row0 mload ( 0x2e80 ) , sub ( PRIME , addmod ( column6 row1 mload ( 0x2ea0 ) , column6 row1 mload ( 0x2ea0 ) , PRIME ) ) , PRIME ) mstore ( 0x41a0 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) ) , PRIME ) mstore ( 0x41c0 , val ) } { let val : = addmod ( column10 row0 mload ( 0x3020 ) , sub ( PRIME , addmod ( column10 row1 mload ( 0x3040 ) , column10 row1 mload ( 0x3040 ) , PRIME ) ) , PRIME ) mstore ( 0x41e0 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) ) , PRIME ) mstore ( 0x4200 , val ) } { let val : = addmod ( column14 row0 mload ( 0x31c0 ) , sub ( PRIME , addmod ( column14 row1 mload ( 0x31e0 ) , column14 row1 mload ( 0x31e0 ) , PRIME ) ) , PRIME ) mstore ( 0x4220 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) ) , PRIME ) mstore ( 0x4240 , val ) } { let val : = addmod ( column18 row0 mload ( 0x3360 ) , sub ( PRIME , addmod ( column18 row1 mload ( 0x3380 ) , column18 row1 mload ( 0x3380 ) , PRIME ) ) , PRIME ) mstore ( 0x4260 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) ) , PRIME ) mstore ( 0x4280 , val ) } { let val : = column0 row12 mload ( 0x2a00 ) mstore ( 0x42a0 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value0 0 mload ( 0x42a0 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row28 mload ( 0x2a20 ) , PRIME ) mstore ( 0x42c0 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value1 0 mload ( 0x42c0 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row44 mload ( 0x2a40 ) , PRIME ) mstore ( 0x42e0 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value2 0 mload ( 0x42e0 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row60 mload ( 0x2a60 ) , PRIME ) mstore ( 0x4300 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value3 0 mload ( 0x4300 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row76 mload ( 0x2a80 ) , PRIME ) mstore ( 0x4320 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value4 0 mload ( 0x4320 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row92 mload ( 0x2aa0 ) , PRIME ) mstore ( 0x4340 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value5 0 mload ( 0x4340 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row108 mload ( 0x2ac0 ) , PRIME ) mstore ( 0x4360 , val ) } { let val : = addmod ( mulmod ( intermediate value rc builtin value6 0 mload ( 0x4360 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row124 mload ( 0x2ae0 ) , PRIME ) mstore ( 0x4380 , val ) } { let val : = mulmod ( column21 row6 mload ( 0x3a00 ) , column21 row6 mload ( 0x3a00 ) , PRIME ) mstore ( 0x43a0 , val ) } { let val : = addmod ( column21 row31 mload ( 0x3c40 ) , sub ( PRIME , addmod ( column21 row63 mload ( 0x3ca0 ) , column21 row63 mload ( 0x3ca0 ) , PRIME ) ) , PRIME ) mstore ( 0x43c0 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) ) , PRIME ) mstore ( 0x43e0 , val ) } { let val : = addmod ( column21 row3 mload ( 0x39a0 ) , sub ( PRIME , addmod ( column21 row19 mload ( 0x3b60 ) , column21 row19 mload ( 0x3b60 ) , PRIME ) ) , PRIME ) mstore ( 0x4400 , val ) } { let val : = addmod ( 1 , sub ( PRIME , intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) ) , PRIME ) mstore ( 0x4420 , val ) } { let val : = addmod ( mulmod ( intermediate value cpu decode opcode rc bit 0 mload ( 0x3f60 ) , intermediate value cpu decode opcode rc bit 0 mload ( 0x3f60 ) , PRIME ) , sub ( PRIME , intermediate value cpu decode opcode rc bit 0 mload ( 0x3f60 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c60 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 0 ] mload ( 0x440 ) , mulmod ( coefficients [ 1 ] mload ( 0x460 ) , adjustments [ 0 ] mload ( 0x4dc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column1 row0 mload ( 0x2b00 ) , column1 row0 mload ( 0x2b00 ) , PRIME ) , sub ( PRIME , column1 row0 mload ( 0x2b00 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4700 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 2 ] mload ( 0x480 ) , mulmod ( coefficients [ 3 ] mload ( 0x4a0 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row1 mload ( 0x33e0 ) , sub ( PRIME , addmod ( mulmod ( addmod ( mulmod ( addmod ( mulmod ( column1 row0 mload ( 0x2b00 ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row4 mload ( 0x29c0 ) , PRIME ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row8 mload ( 0x29e0 ) , PRIME ) , offset size mload ( 0xa0 ) , PRIME ) , column0 row0 mload ( 0x2980 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 4 ] mload ( 0x4c0 ) , mulmod ( coefficients [ 5 ] mload ( 0x4e0 ) , adjustments [ 2 ] mload ( 0x4e00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column19 row8 mload ( 0x34c0 ) , half offset size mload ( 0xc0 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( mulmod ( intermediate value cpu decode opcode rc bit 0 mload ( 0x3f60 ) , column21 row8 mload ( 0x3a40 ) , PRIME ) , mulmod ( addmod ( 1 , sub ( PRIME , intermediate value cpu decode opcode rc bit 0 mload ( 0x3f60 ) ) , PRIME ) , column21 row0 mload ( 0x3940 ) , PRIME ) , PRIME ) , column0 row0 mload ( 0x2980 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 6 ] mload ( 0x500 ) , mulmod ( coefficients [ 7 ] mload ( 0x520 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column19 row4 mload ( 0x3440 ) , half offset size mload ( 0xc0 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( mulmod ( intermediate value cpu decode opcode rc bit 1 mload ( 0x3f80 ) , column21 row8 mload ( 0x3a40 ) , PRIME ) , mulmod ( addmod ( 1 , sub ( PRIME , intermediate value cpu decode opcode rc bit 1 mload ( 0x3f80 ) ) , PRIME ) , column21 row0 mload ( 0x3940 ) , PRIME ) , PRIME ) , column0 row8 mload ( 0x29e0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 8 ] mload ( 0x540 ) , mulmod ( coefficients [ 9 ] mload ( 0x560 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column19 row12 mload ( 0x3500 ) , half offset size mload ( 0xc0 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( addmod ( addmod ( mulmod ( intermediate value cpu decode opcode rc bit 2 mload ( 0x3fa0 ) , column19 row0 mload ( 0x33c0 ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 4 mload ( 0x3fc0 ) , column21 row0 mload ( 0x3940 ) , PRIME ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 3 mload ( 0x3fe0 ) , column21 row8 mload ( 0x3a40 ) , PRIME ) , PRIME ) , mulmod ( addmod ( 1 , sub ( PRIME , addmod ( addmod ( intermediate value cpu decode opcode rc bit 2 mload ( 0x3fa0 ) , intermediate value cpu decode opcode rc bit 4 mload ( 0x3fc0 ) , PRIME ) , intermediate value cpu decode opcode rc bit 3 mload ( 0x3fe0 ) , PRIME ) ) , PRIME ) , column19 row5 mload ( 0x3460 ) , PRIME ) , PRIME ) , column0 row4 mload ( 0x29c0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 10 ] mload ( 0x580 ) , mulmod ( coefficients [ 11 ] mload ( 0x5a0 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row4 mload ( 0x39c0 ) , sub ( PRIME , mulmod ( column19 row5 mload ( 0x3460 ) , column19 row13 mload ( 0x3520 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 12 ] mload ( 0x5c0 ) , mulmod ( coefficients [ 13 ] mload ( 0x5e0 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( addmod ( 1 , sub ( PRIME , intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) ) , PRIME ) , column21 row12 mload ( 0x3ac0 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( mulmod ( intermediate value cpu decode opcode rc bit 5 mload ( 0x4020 ) , addmod ( column19 row5 mload ( 0x3460 ) , column19 row13 mload ( 0x3520 ) , PRIME ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 6 mload ( 0x4040 ) , column21 row4 mload ( 0x39c0 ) , PRIME ) , PRIME ) , mulmod ( addmod ( 1 , sub ( PRIME , addmod ( addmod ( intermediate value cpu decode opcode rc bit 5 mload ( 0x4020 ) , intermediate value cpu decode opcode rc bit 6 mload ( 0x4040 ) , PRIME ) , intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) , PRIME ) ) , PRIME ) , column19 row13 mload ( 0x3520 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 14 ] mload ( 0x600 ) , mulmod ( coefficients [ 15 ] mload ( 0x620 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row2 mload ( 0x3980 ) , sub ( PRIME , mulmod ( intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) , column19 row9 mload ( 0x34e0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 16 ] mload ( 0x640 ) , mulmod ( coefficients [ 17 ] mload ( 0x660 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row10 mload ( 0x3a80 ) , sub ( PRIME , mulmod ( column21 row2 mload ( 0x3980 ) , column21 row12 mload ( 0x3ac0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 18 ] mload ( 0x680 ) , mulmod ( coefficients [ 19 ] mload ( 0x6a0 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( mulmod ( addmod ( 1 , sub ( PRIME , intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) ) , PRIME ) , column19 row16 mload ( 0x3540 ) , PRIME ) , mulmod ( column21 row2 mload ( 0x3980 ) , addmod ( column19 row16 mload ( 0x3540 ) , sub ( PRIME , addmod ( column19 row0 mload ( 0x33c0 ) , column19 row13 mload ( 0x3520 ) , PRIME ) ) , PRIME ) , PRIME ) , PRIME ) , sub ( PRIME , addmod ( addmod ( mulmod ( addmod ( 1 , sub ( PRIME , addmod ( addmod ( intermediate value cpu decode opcode rc bit 7 mload ( 0x4060 ) , intermediate value cpu decode opcode rc bit 8 mload ( 0x4080 ) , PRIME ) , intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) , PRIME ) ) , PRIME ) , intermediate value npc reg 0 mload ( 0x40a0 ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 7 mload ( 0x4060 ) , column21 row12 mload ( 0x3ac0 ) , PRIME ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 8 mload ( 0x4080 ) , addmod ( column19 row0 mload ( 0x33c0 ) , column21 row12 mload ( 0x3ac0 ) , PRIME ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 20 ] mload ( 0x6c0 ) , mulmod ( coefficients [ 21 ] mload ( 0x6e0 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( addmod ( column21 row10 mload ( 0x3a80 ) , sub ( PRIME , intermediate value cpu decode opcode rc bit 9 mload ( 0x4000 ) ) , PRIME ) , addmod ( column19 row16 mload ( 0x3540 ) , sub ( PRIME , intermediate value npc reg 0 mload ( 0x40a0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 22 ] mload ( 0x700 ) , mulmod ( coefficients [ 23 ] mload ( 0x720 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row16 mload ( 0x3b40 ) , sub ( PRIME , addmod ( addmod ( addmod ( column21 row0 mload ( 0x3940 ) , mulmod ( intermediate value cpu decode opcode rc bit 10 mload ( 0x40c0 ) , column21 row12 mload ( 0x3ac0 ) , PRIME ) , PRIME ) , intermediate value cpu decode opcode rc bit 11 mload ( 0x40e0 ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 12 mload ( 0x4100 ) , 2 , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 24 ] mload ( 0x740 ) , mulmod ( coefficients [ 25 ] mload ( 0x760 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row24 mload ( 0x3be0 ) , sub ( PRIME , addmod ( addmod ( mulmod ( addmod ( 1 , sub ( PRIME , addmod ( intermediate value cpu decode opcode rc bit 12 mload ( 0x4100 ) , intermediate value cpu decode opcode rc bit 13 mload ( 0x4120 ) , PRIME ) ) , PRIME ) , column21 row8 mload ( 0x3a40 ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 13 mload ( 0x4120 ) , column19 row9 mload ( 0x34e0 ) , PRIME ) , PRIME ) , mulmod ( intermediate value cpu decode opcode rc bit 12 mload ( 0x4100 ) , addmod ( column21 row0 mload ( 0x3940 ) , 2 , PRIME ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4c80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 26 ] mload ( 0x780 ) , mulmod ( coefficients [ 27 ] mload ( 0x7a0 ) , adjustments [ 3 ] mload ( 0x4e20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value cpu decode opcode rc bit 12 mload ( 0x4100 ) , addmod ( column19 row9 mload ( 0x34e0 ) , sub ( PRIME , column21 row8 mload ( 0x3a40 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 28 ] mload ( 0x7c0 ) , mulmod ( coefficients [ 29 ] mload ( 0x7e0 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value cpu decode opcode rc bit 12 mload ( 0x4100 ) , addmod ( column19 row5 mload ( 0x3460 ) , sub ( PRIME , addmod ( addmod ( column19 row0 mload ( 0x33c0 ) , intermediate value cpu decode opcode rc bit 2 mload ( 0x3fa0 ) , PRIME ) , 1 , PRIME ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 30 ] mload ( 0x800 ) , mulmod ( coefficients [ 31 ] mload ( 0x820 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value cpu decode opcode rc bit 14 mload ( 0x4140 ) , addmod ( column19 row9 mload ( 0x34e0 ) , sub ( PRIME , column21 row12 mload ( 0x3ac0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 32 ] mload ( 0x840 ) , mulmod ( coefficients [ 33 ] mload ( 0x860 ) , adjustments [ 1 ] mload ( 0x4de0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row0 mload ( 0x3940 ) , sub ( PRIME , initial ap mload ( 0xe0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 34 ] mload ( 0x880 ) , mulmod ( coefficients [ 35 ] mload ( 0x8a0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row8 mload ( 0x3a40 ) , sub ( PRIME , initial ap mload ( 0xe0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 36 ] mload ( 0x8c0 ) , mulmod ( coefficients [ 37 ] mload ( 0x8e0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row0 mload ( 0x33c0 ) , sub ( PRIME , initial pc mload ( 0x100 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 38 ] mload ( 0x900 ) , mulmod ( coefficients [ 39 ] mload ( 0x920 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row0 mload ( 0x3940 ) , sub ( PRIME , final ap mload ( 0x120 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4760 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 40 ] mload ( 0x940 ) , mulmod ( coefficients [ 41 ] mload ( 0x960 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row0 mload ( 0x33c0 ) , sub ( PRIME , final pc mload ( 0x140 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4760 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 42 ] mload ( 0x980 ) , mulmod ( coefficients [ 43 ] mload ( 0x9a0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( addmod ( mulmod ( addmod ( memory multi column perm perm interaction elm mload ( 0x160 ) , sub ( PRIME , addmod ( column20 row0 mload ( 0x38c0 ) , mulmod ( memory multi column perm hash interaction elm0 mload ( 0x180 ) , column20 row1 mload ( 0x38e0 ) , PRIME ) , PRIME ) ) , PRIME ) , column24 inter1 row0 mload ( 0x3f00 ) , PRIME ) , column19 row0 mload ( 0x33c0 ) , PRIME ) , mulmod ( memory multi column perm hash interaction elm0 mload ( 0x180 ) , column19 row1 mload ( 0x33e0 ) , PRIME ) , PRIME ) , sub ( PRIME , memory multi column perm perm interaction elm mload ( 0x160 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 44 ] mload ( 0x9c0 ) , mulmod ( coefficients [ 45 ] mload ( 0x9e0 ) , adjustments [ 5 ] mload ( 0x4e60 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( addmod ( memory multi column perm perm interaction elm mload ( 0x160 ) , sub ( PRIME , addmod ( column20 row2 mload ( 0x3900 ) , mulmod ( memory multi column perm hash interaction elm0 mload ( 0x180 ) , column20 row3 mload ( 0x3920 ) , PRIME ) , PRIME ) ) , PRIME ) , column24 inter1 row2 mload ( 0x3f20 ) , PRIME ) , sub ( PRIME , mulmod ( addmod ( memory multi column perm perm interaction elm mload ( 0x160 ) , sub ( PRIME , addmod ( column19 row2 mload ( 0x3400 ) , mulmod ( memory multi column perm hash interaction elm0 mload ( 0x180 ) , column19 row3 mload ( 0x3420 ) , PRIME ) , PRIME ) ) , PRIME ) , column24 inter1 row0 mload ( 0x3f00 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ca0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4780 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 46 ] mload ( 0xa00 ) , mulmod ( coefficients [ 47 ] mload ( 0xa20 ) , adjustments [ 6 ] mload ( 0x4e80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column24 inter1 row0 mload ( 0x3f00 ) , sub ( PRIME , memory multi column perm perm public memory prod mload ( 0x1a0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x47a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 48 ] mload ( 0xa40 ) , mulmod ( coefficients [ 49 ] mload ( 0xa60 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value memory address diff 0 mload ( 0x4160 ) , intermediate value memory address diff 0 mload ( 0x4160 ) , PRIME ) , sub ( PRIME , intermediate value memory address diff 0 mload ( 0x4160 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ca0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4780 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 50 ] mload ( 0xa80 ) , mulmod ( coefficients [ 51 ] mload ( 0xaa0 ) , adjustments [ 6 ] mload ( 0x4e80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( addmod ( intermediate value memory address diff 0 mload ( 0x4160 ) , sub ( PRIME , 1 ) , PRIME ) , addmod ( column20 row1 mload ( 0x38e0 ) , sub ( PRIME , column20 row3 mload ( 0x3920 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ca0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4780 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 52 ] mload ( 0xac0 ) , mulmod ( coefficients [ 53 ] mload ( 0xae0 ) , adjustments [ 6 ] mload ( 0x4e80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column19 row2 mload ( 0x3400 ) val : = mulmod ( val , mload ( 0x47c0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 54 ] mload ( 0xb00 ) , mulmod ( coefficients [ 55 ] mload ( 0xb20 ) , adjustments [ 7 ] mload ( 0x4ea0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column19 row3 mload ( 0x3420 ) val : = mulmod ( val , mload ( 0x47c0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 56 ] mload ( 0xb40 ) , mulmod ( coefficients [ 57 ] mload ( 0xb60 ) , adjustments [ 7 ] mload ( 0x4ea0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( mulmod ( addmod ( rc16 perm interaction elm mload ( 0x1c0 ) , sub ( PRIME , column2 row0 mload ( 0x2d00 ) ) , PRIME ) , column23 inter1 row0 mload ( 0x3ec0 ) , PRIME ) , column0 row0 mload ( 0x2980 ) , PRIME ) , sub ( PRIME , rc16 perm interaction elm mload ( 0x1c0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 58 ] mload ( 0xb80 ) , mulmod ( coefficients [ 59 ] mload ( 0xba0 ) , adjustments [ 5 ] mload ( 0x4e60 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( addmod ( rc16 perm interaction elm mload ( 0x1c0 ) , sub ( PRIME , column2 row1 mload ( 0x2d20 ) ) , PRIME ) , column23 inter1 row1 mload ( 0x3ee0 ) , PRIME ) , sub ( PRIME , mulmod ( addmod ( rc16 perm interaction elm mload ( 0x1c0 ) , sub ( PRIME , column0 row1 mload ( 0x29a0 ) ) , PRIME ) , column23 inter1 row0 mload ( 0x3ec0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4cc0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 60 ] mload ( 0xbc0 ) , mulmod ( coefficients [ 61 ] mload ( 0xbe0 ) , adjustments [ 8 ] mload ( 0x4ec0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column23 inter1 row0 mload ( 0x3ec0 ) , sub ( PRIME , rc16 perm public memory prod mload ( 0x1e0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x47e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 62 ] mload ( 0xc00 ) , mulmod ( coefficients [ 63 ] mload ( 0xc20 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value rc16 diff 0 mload ( 0x4180 ) , intermediate value rc16 diff 0 mload ( 0x4180 ) , PRIME ) , sub ( PRIME , intermediate value rc16 diff 0 mload ( 0x4180 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4cc0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 64 ] mload ( 0xc40 ) , mulmod ( coefficients [ 65 ] mload ( 0xc60 ) , adjustments [ 8 ] mload ( 0x4ec0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column2 row0 mload ( 0x2d00 ) , sub ( PRIME , rc min mload ( 0x200 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 66 ] mload ( 0xc80 ) , mulmod ( coefficients [ 67 ] mload ( 0xca0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column2 row0 mload ( 0x2d00 ) , sub ( PRIME , rc max mload ( 0x220 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x47e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 68 ] mload ( 0xcc0 ) , mulmod ( coefficients [ 69 ] mload ( 0xce0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) , addmod ( intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 70 ] mload ( 0xd00 ) , mulmod ( coefficients [ 71 ] mload ( 0xd20 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column6 row0 mload ( 0x2e80 ) val : = mulmod ( val , mload ( 0x4800 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 72 ] mload ( 0xd40 ) , mulmod ( coefficients [ 73 ] mload ( 0xd60 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column6 row0 mload ( 0x2e80 ) val : = mulmod ( val , mload ( 0x4820 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 74 ] mload ( 0xd80 ) , mulmod ( coefficients [ 75 ] mload ( 0xda0 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) , addmod ( column4 row0 mload ( 0x2de0 ) , sub ( PRIME , periodic column pedersen points y mload ( 0x20 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column5 row0 mload ( 0x2e60 ) , addmod ( column3 row0 mload ( 0x2d40 ) , sub ( PRIME , periodic column pedersen points x mload ( 0x0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 76 ] mload ( 0xdc0 ) , mulmod ( coefficients [ 77 ] mload ( 0xde0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column5 row0 mload ( 0x2e60 ) , column5 row0 mload ( 0x2e60 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) , addmod ( addmod ( column3 row0 mload ( 0x2d40 ) , periodic column pedersen points x mload ( 0x0 ) , PRIME ) , column3 row1 mload ( 0x2d60 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 78 ] mload ( 0xe00 ) , mulmod ( coefficients [ 79 ] mload ( 0xe20 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash0 ec subset sum bit 0 mload ( 0x41a0 ) , addmod ( column4 row0 mload ( 0x2de0 ) , column4 row1 mload ( 0x2e00 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column5 row0 mload ( 0x2e60 ) , addmod ( column3 row0 mload ( 0x2d40 ) , sub ( PRIME , column3 row1 mload ( 0x2d60 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 80 ] mload ( 0xe40 ) , mulmod ( coefficients [ 81 ] mload ( 0xe60 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash0 ec subset sum bit neg 0 mload ( 0x41c0 ) , addmod ( column3 row1 mload ( 0x2d60 ) , sub ( PRIME , column3 row0 mload ( 0x2d40 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 82 ] mload ( 0xe80 ) , mulmod ( coefficients [ 83 ] mload ( 0xea0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash0 ec subset sum bit neg 0 mload ( 0x41c0 ) , addmod ( column4 row1 mload ( 0x2e00 ) , sub ( PRIME , column4 row0 mload ( 0x2de0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 84 ] mload ( 0xec0 ) , mulmod ( coefficients [ 85 ] mload ( 0xee0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column3 row256 mload ( 0x2da0 ) , sub ( PRIME , column3 row255 mload ( 0x2d80 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 86 ] mload ( 0xf00 ) , mulmod ( coefficients [ 87 ] mload ( 0xf20 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column4 row256 mload ( 0x2e40 ) , sub ( PRIME , column4 row255 mload ( 0x2e20 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 88 ] mload ( 0xf40 ) , mulmod ( coefficients [ 89 ] mload ( 0xf60 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column3 row0 mload ( 0x2d40 ) , sub ( PRIME , pedersen shift point . x mload ( 0x240 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 90 ] mload ( 0xf80 ) , mulmod ( coefficients [ 91 ] mload ( 0xfa0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column4 row0 mload ( 0x2de0 ) , sub ( PRIME , pedersen shift point . y mload ( 0x260 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 92 ] mload ( 0xfc0 ) , mulmod ( coefficients [ 93 ] mload ( 0xfe0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) , addmod ( intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 94 ] mload ( 0x1000 ) , mulmod ( coefficients [ 95 ] mload ( 0x1020 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column10 row0 mload ( 0x3020 ) val : = mulmod ( val , mload ( 0x4800 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 96 ] mload ( 0x1040 ) , mulmod ( coefficients [ 97 ] mload ( 0x1060 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column10 row0 mload ( 0x3020 ) val : = mulmod ( val , mload ( 0x4820 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 98 ] mload ( 0x1080 ) , mulmod ( coefficients [ 99 ] mload ( 0x10a0 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) , addmod ( column8 row0 mload ( 0x2f80 ) , sub ( PRIME , periodic column pedersen points y mload ( 0x20 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column9 row0 mload ( 0x3000 ) , addmod ( column7 row0 mload ( 0x2ee0 ) , sub ( PRIME , periodic column pedersen points x mload ( 0x0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 100 ] mload ( 0x10c0 ) , mulmod ( coefficients [ 101 ] mload ( 0x10e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column9 row0 mload ( 0x3000 ) , column9 row0 mload ( 0x3000 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) , addmod ( addmod ( column7 row0 mload ( 0x2ee0 ) , periodic column pedersen points x mload ( 0x0 ) , PRIME ) , column7 row1 mload ( 0x2f00 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 102 ] mload ( 0x1100 ) , mulmod ( coefficients [ 103 ] mload ( 0x1120 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash1 ec subset sum bit 0 mload ( 0x41e0 ) , addmod ( column8 row0 mload ( 0x2f80 ) , column8 row1 mload ( 0x2fa0 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column9 row0 mload ( 0x3000 ) , addmod ( column7 row0 mload ( 0x2ee0 ) , sub ( PRIME , column7 row1 mload ( 0x2f00 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 104 ] mload ( 0x1140 ) , mulmod ( coefficients [ 105 ] mload ( 0x1160 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash1 ec subset sum bit neg 0 mload ( 0x4200 ) , addmod ( column7 row1 mload ( 0x2f00 ) , sub ( PRIME , column7 row0 mload ( 0x2ee0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 106 ] mload ( 0x1180 ) , mulmod ( coefficients [ 107 ] mload ( 0x11a0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash1 ec subset sum bit neg 0 mload ( 0x4200 ) , addmod ( column8 row1 mload ( 0x2fa0 ) , sub ( PRIME , column8 row0 mload ( 0x2f80 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 108 ] mload ( 0x11c0 ) , mulmod ( coefficients [ 109 ] mload ( 0x11e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column7 row256 mload ( 0x2f40 ) , sub ( PRIME , column7 row255 mload ( 0x2f20 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 110 ] mload ( 0x1200 ) , mulmod ( coefficients [ 111 ] mload ( 0x1220 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column8 row256 mload ( 0x2fe0 ) , sub ( PRIME , column8 row255 mload ( 0x2fc0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 112 ] mload ( 0x1240 ) , mulmod ( coefficients [ 113 ] mload ( 0x1260 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column7 row0 mload ( 0x2ee0 ) , sub ( PRIME , pedersen shift point . x mload ( 0x240 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 114 ] mload ( 0x1280 ) , mulmod ( coefficients [ 115 ] mload ( 0x12a0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column8 row0 mload ( 0x2f80 ) , sub ( PRIME , pedersen shift point . y mload ( 0x260 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 116 ] mload ( 0x12c0 ) , mulmod ( coefficients [ 117 ] mload ( 0x12e0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) , addmod ( intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 118 ] mload ( 0x1300 ) , mulmod ( coefficients [ 119 ] mload ( 0x1320 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column14 row0 mload ( 0x31c0 ) val : = mulmod ( val , mload ( 0x4800 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 120 ] mload ( 0x1340 ) , mulmod ( coefficients [ 121 ] mload ( 0x1360 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column14 row0 mload ( 0x31c0 ) val : = mulmod ( val , mload ( 0x4820 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 122 ] mload ( 0x1380 ) , mulmod ( coefficients [ 123 ] mload ( 0x13a0 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) , addmod ( column12 row0 mload ( 0x3120 ) , sub ( PRIME , periodic column pedersen points y mload ( 0x20 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column13 row0 mload ( 0x31a0 ) , addmod ( column11 row0 mload ( 0x3080 ) , sub ( PRIME , periodic column pedersen points x mload ( 0x0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 124 ] mload ( 0x13c0 ) , mulmod ( coefficients [ 125 ] mload ( 0x13e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column13 row0 mload ( 0x31a0 ) , column13 row0 mload ( 0x31a0 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) , addmod ( addmod ( column11 row0 mload ( 0x3080 ) , periodic column pedersen points x mload ( 0x0 ) , PRIME ) , column11 row1 mload ( 0x30a0 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 126 ] mload ( 0x1400 ) , mulmod ( coefficients [ 127 ] mload ( 0x1420 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash2 ec subset sum bit 0 mload ( 0x4220 ) , addmod ( column12 row0 mload ( 0x3120 ) , column12 row1 mload ( 0x3140 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column13 row0 mload ( 0x31a0 ) , addmod ( column11 row0 mload ( 0x3080 ) , sub ( PRIME , column11 row1 mload ( 0x30a0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 128 ] mload ( 0x1440 ) , mulmod ( coefficients [ 129 ] mload ( 0x1460 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash2 ec subset sum bit neg 0 mload ( 0x4240 ) , addmod ( column11 row1 mload ( 0x30a0 ) , sub ( PRIME , column11 row0 mload ( 0x3080 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 130 ] mload ( 0x1480 ) , mulmod ( coefficients [ 131 ] mload ( 0x14a0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash2 ec subset sum bit neg 0 mload ( 0x4240 ) , addmod ( column12 row1 mload ( 0x3140 ) , sub ( PRIME , column12 row0 mload ( 0x3120 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 132 ] mload ( 0x14c0 ) , mulmod ( coefficients [ 133 ] mload ( 0x14e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column11 row256 mload ( 0x30e0 ) , sub ( PRIME , column11 row255 mload ( 0x30c0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 134 ] mload ( 0x1500 ) , mulmod ( coefficients [ 135 ] mload ( 0x1520 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column12 row256 mload ( 0x3180 ) , sub ( PRIME , column12 row255 mload ( 0x3160 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 136 ] mload ( 0x1540 ) , mulmod ( coefficients [ 137 ] mload ( 0x1560 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column11 row0 mload ( 0x3080 ) , sub ( PRIME , pedersen shift point . x mload ( 0x240 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 138 ] mload ( 0x1580 ) , mulmod ( coefficients [ 139 ] mload ( 0x15a0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column12 row0 mload ( 0x3120 ) , sub ( PRIME , pedersen shift point . y mload ( 0x260 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 140 ] mload ( 0x15c0 ) , mulmod ( coefficients [ 141 ] mload ( 0x15e0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) , addmod ( intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 142 ] mload ( 0x1600 ) , mulmod ( coefficients [ 143 ] mload ( 0x1620 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column18 row0 mload ( 0x3360 ) val : = mulmod ( val , mload ( 0x4800 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 144 ] mload ( 0x1640 ) , mulmod ( coefficients [ 145 ] mload ( 0x1660 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column18 row0 mload ( 0x3360 ) val : = mulmod ( val , mload ( 0x4820 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 146 ] mload ( 0x1680 ) , mulmod ( coefficients [ 147 ] mload ( 0x16a0 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) , addmod ( column16 row0 mload ( 0x32c0 ) , sub ( PRIME , periodic column pedersen points y mload ( 0x20 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column17 row0 mload ( 0x3340 ) , addmod ( column15 row0 mload ( 0x3220 ) , sub ( PRIME , periodic column pedersen points x mload ( 0x0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 148 ] mload ( 0x16c0 ) , mulmod ( coefficients [ 149 ] mload ( 0x16e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column17 row0 mload ( 0x3340 ) , column17 row0 mload ( 0x3340 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) , addmod ( addmod ( column15 row0 mload ( 0x3220 ) , periodic column pedersen points x mload ( 0x0 ) , PRIME ) , column15 row1 mload ( 0x3240 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 150 ] mload ( 0x1700 ) , mulmod ( coefficients [ 151 ] mload ( 0x1720 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value pedersen hash3 ec subset sum bit 0 mload ( 0x4260 ) , addmod ( column16 row0 mload ( 0x32c0 ) , column16 row1 mload ( 0x32e0 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column17 row0 mload ( 0x3340 ) , addmod ( column15 row0 mload ( 0x3220 ) , sub ( PRIME , column15 row1 mload ( 0x3240 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 152 ] mload ( 0x1740 ) , mulmod ( coefficients [ 153 ] mload ( 0x1760 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash3 ec subset sum bit neg 0 mload ( 0x4280 ) , addmod ( column15 row1 mload ( 0x3240 ) , sub ( PRIME , column15 row0 mload ( 0x3220 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 154 ] mload ( 0x1780 ) , mulmod ( coefficients [ 155 ] mload ( 0x17a0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value pedersen hash3 ec subset sum bit neg 0 mload ( 0x4280 ) , addmod ( column16 row1 mload ( 0x32e0 ) , sub ( PRIME , column16 row0 mload ( 0x32c0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4ce0 ) , PRIME ) val : = mulmod ( val , mload ( 0x46e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 156 ] mload ( 0x17c0 ) , mulmod ( coefficients [ 157 ] mload ( 0x17e0 ) , adjustments [ 9 ] mload ( 0x4ee0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column15 row256 mload ( 0x3280 ) , sub ( PRIME , column15 row255 mload ( 0x3260 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 158 ] mload ( 0x1800 ) , mulmod ( coefficients [ 159 ] mload ( 0x1820 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column16 row256 mload ( 0x3320 ) , sub ( PRIME , column16 row255 mload ( 0x3300 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d00 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 160 ] mload ( 0x1840 ) , mulmod ( coefficients [ 161 ] mload ( 0x1860 ) , adjustments [ 11 ] mload ( 0x4f20 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column15 row0 mload ( 0x3220 ) , sub ( PRIME , pedersen shift point . x mload ( 0x240 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 162 ] mload ( 0x1880 ) , mulmod ( coefficients [ 163 ] mload ( 0x18a0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column16 row0 mload ( 0x32c0 ) , sub ( PRIME , pedersen shift point . y mload ( 0x260 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 164 ] mload ( 0x18c0 ) , mulmod ( coefficients [ 165 ] mload ( 0x18e0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row7 mload ( 0x34a0 ) , sub ( PRIME , column6 row0 mload ( 0x2e80 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 166 ] mload ( 0x1900 ) , mulmod ( coefficients [ 167 ] mload ( 0x1920 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row135 mload ( 0x36c0 ) , sub ( PRIME , column10 row0 mload ( 0x3020 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 168 ] mload ( 0x1940 ) , mulmod ( coefficients [ 169 ] mload ( 0x1960 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row263 mload ( 0x3780 ) , sub ( PRIME , column14 row0 mload ( 0x31c0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 170 ] mload ( 0x1980 ) , mulmod ( coefficients [ 171 ] mload ( 0x19a0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row391 mload ( 0x37e0 ) , sub ( PRIME , column18 row0 mload ( 0x3360 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 172 ] mload ( 0x19c0 ) , mulmod ( coefficients [ 173 ] mload ( 0x19e0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row134 mload ( 0x36a0 ) , sub ( PRIME , addmod ( column19 row38 mload ( 0x35a0 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d20 ) , PRIME ) val : = mulmod ( val , mload ( 0x4880 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 174 ] mload ( 0x1a00 ) , mulmod ( coefficients [ 175 ] mload ( 0x1a20 ) , adjustments [ 13 ] mload ( 0x4f60 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row6 mload ( 0x3480 ) , sub ( PRIME , initial pedersen addr mload ( 0x280 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 176 ] mload ( 0x1a40 ) , mulmod ( coefficients [ 177 ] mload ( 0x1a60 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row71 mload ( 0x3600 ) , sub ( PRIME , column6 row256 mload ( 0x2ec0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 178 ] mload ( 0x1a80 ) , mulmod ( coefficients [ 179 ] mload ( 0x1aa0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row199 mload ( 0x3740 ) , sub ( PRIME , column10 row256 mload ( 0x3060 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 180 ] mload ( 0x1ac0 ) , mulmod ( coefficients [ 181 ] mload ( 0x1ae0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row327 mload ( 0x37c0 ) , sub ( PRIME , column14 row256 mload ( 0x3200 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 182 ] mload ( 0x1b00 ) , mulmod ( coefficients [ 183 ] mload ( 0x1b20 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row455 mload ( 0x3840 ) , sub ( PRIME , column18 row256 mload ( 0x33a0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 184 ] mload ( 0x1b40 ) , mulmod ( coefficients [ 185 ] mload ( 0x1b60 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row70 mload ( 0x35e0 ) , sub ( PRIME , addmod ( column19 row6 mload ( 0x3480 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4880 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 186 ] mload ( 0x1b80 ) , mulmod ( coefficients [ 187 ] mload ( 0x1ba0 ) , adjustments [ 14 ] mload ( 0x4f80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row39 mload ( 0x35c0 ) , sub ( PRIME , column3 row511 mload ( 0x2dc0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 188 ] mload ( 0x1bc0 ) , mulmod ( coefficients [ 189 ] mload ( 0x1be0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row167 mload ( 0x3720 ) , sub ( PRIME , column7 row511 mload ( 0x2f60 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 190 ] mload ( 0x1c00 ) , mulmod ( coefficients [ 191 ] mload ( 0x1c20 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row295 mload ( 0x37a0 ) , sub ( PRIME , column11 row511 mload ( 0x3100 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 192 ] mload ( 0x1c40 ) , mulmod ( coefficients [ 193 ] mload ( 0x1c60 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row423 mload ( 0x3820 ) , sub ( PRIME , column15 row511 mload ( 0x32a0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4860 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 194 ] mload ( 0x1c80 ) , mulmod ( coefficients [ 195 ] mload ( 0x1ca0 ) , adjustments [ 12 ] mload ( 0x4f40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row38 mload ( 0x35a0 ) , sub ( PRIME , addmod ( column19 row70 mload ( 0x35e0 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4880 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 196 ] mload ( 0x1cc0 ) , mulmod ( coefficients [ 197 ] mload ( 0x1ce0 ) , adjustments [ 14 ] mload ( 0x4f80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( intermediate value rc builtin value7 0 mload ( 0x4380 ) , sub ( PRIME , column19 row103 mload ( 0x3680 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4880 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 198 ] mload ( 0x1d00 ) , mulmod ( coefficients [ 199 ] mload ( 0x1d20 ) , adjustments [ 14 ] mload ( 0x4f80 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row230 mload ( 0x3760 ) , sub ( PRIME , addmod ( column19 row102 mload ( 0x3660 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d20 ) , PRIME ) val : = mulmod ( val , mload ( 0x4880 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 200 ] mload ( 0x1d40 ) , mulmod ( coefficients [ 201 ] mload ( 0x1d60 ) , adjustments [ 13 ] mload ( 0x4f60 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row102 mload ( 0x3660 ) , sub ( PRIME , initial rc addr mload ( 0x2a0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 202 ] mload ( 0x1d80 ) , mulmod ( coefficients [ 203 ] mload ( 0x1da0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( addmod ( addmod ( intermediate value ecdsa signature0 doubling key x squared mload ( 0x43a0 ) , intermediate value ecdsa signature0 doubling key x squared mload ( 0x43a0 ) , PRIME ) , intermediate value ecdsa signature0 doubling key x squared mload ( 0x43a0 ) , PRIME ) , ecdsa sig config . alpha mload ( 0x2c0 ) , PRIME ) , sub ( PRIME , mulmod ( addmod ( column21 row14 mload ( 0x3b00 ) , column21 row14 mload ( 0x3b00 ) , PRIME ) , column21 row1 mload ( 0x3960 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 204 ] mload ( 0x1dc0 ) , mulmod ( coefficients [ 205 ] mload ( 0x1de0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row1 mload ( 0x3960 ) , column21 row1 mload ( 0x3960 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( column21 row6 mload ( 0x3a00 ) , column21 row6 mload ( 0x3a00 ) , PRIME ) , column21 row22 mload ( 0x3ba0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 206 ] mload ( 0x1e00 ) , mulmod ( coefficients [ 207 ] mload ( 0x1e20 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column21 row14 mload ( 0x3b00 ) , column21 row30 mload ( 0x3c20 ) , PRIME ) , sub ( PRIME , mulmod ( column21 row1 mload ( 0x3960 ) , addmod ( column21 row6 mload ( 0x3a00 ) , sub ( PRIME , column21 row22 mload ( 0x3ba0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 208 ] mload ( 0x1e40 ) , mulmod ( coefficients [ 209 ] mload ( 0x1e60 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) , addmod ( intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 210 ] mload ( 0x1e80 ) , mulmod ( coefficients [ 211 ] mload ( 0x1ea0 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column21 row31 mload ( 0x3c40 ) val : = mulmod ( val , mload ( 0x48c0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 212 ] mload ( 0x1ec0 ) , mulmod ( coefficients [ 213 ] mload ( 0x1ee0 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column21 row31 mload ( 0x3c40 ) val : = mulmod ( val , mload ( 0x48e0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 214 ] mload ( 0x1f00 ) , mulmod ( coefficients [ 215 ] mload ( 0x1f20 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) , addmod ( column21 row23 mload ( 0x3bc0 ) , sub ( PRIME , periodic column ecdsa generator points y mload ( 0x60 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column21 row15 mload ( 0x3b20 ) , addmod ( column21 row7 mload ( 0x3a20 ) , sub ( PRIME , periodic column ecdsa generator points x mload ( 0x40 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 216 ] mload ( 0x1f40 ) , mulmod ( coefficients [ 217 ] mload ( 0x1f60 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row15 mload ( 0x3b20 ) , column21 row15 mload ( 0x3b20 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) , addmod ( addmod ( column21 row7 mload ( 0x3a20 ) , periodic column ecdsa generator points x mload ( 0x40 ) , PRIME ) , column21 row39 mload ( 0x3c60 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 218 ] mload ( 0x1f80 ) , mulmod ( coefficients [ 219 ] mload ( 0x1fa0 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value ecdsa signature0 exponentiate generator bit 0 mload ( 0x43c0 ) , addmod ( column21 row23 mload ( 0x3bc0 ) , column21 row55 mload ( 0x3c80 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column21 row15 mload ( 0x3b20 ) , addmod ( column21 row7 mload ( 0x3a20 ) , sub ( PRIME , column21 row39 mload ( 0x3c60 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 220 ] mload ( 0x1fc0 ) , mulmod ( coefficients [ 221 ] mload ( 0x1fe0 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column22 row0 mload ( 0x3e80 ) , addmod ( column21 row7 mload ( 0x3a20 ) , sub ( PRIME , periodic column ecdsa generator points x mload ( 0x40 ) ) , PRIME ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 222 ] mload ( 0x2000 ) , mulmod ( coefficients [ 223 ] mload ( 0x2020 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate generator bit neg 0 mload ( 0x43e0 ) , addmod ( column21 row39 mload ( 0x3c60 ) , sub ( PRIME , column21 row7 mload ( 0x3a20 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 224 ] mload ( 0x2040 ) , mulmod ( coefficients [ 225 ] mload ( 0x2060 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate generator bit neg 0 mload ( 0x43e0 ) , addmod ( column21 row55 mload ( 0x3c80 ) , sub ( PRIME , column21 row23 mload ( 0x3bc0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d60 ) , PRIME ) val : = mulmod ( val , mload ( 0x48a0 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 226 ] mload ( 0x2080 ) , mulmod ( coefficients [ 227 ] mload ( 0x20a0 ) , adjustments [ 16 ] mload ( 0x4fc0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) , addmod ( intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) , sub ( PRIME , 1 ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 228 ] mload ( 0x20c0 ) , mulmod ( coefficients [ 229 ] mload ( 0x20e0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column21 row3 mload ( 0x39a0 ) val : = mulmod ( val , mload ( 0x4900 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 230 ] mload ( 0x2100 ) , mulmod ( coefficients [ 231 ] mload ( 0x2120 ) , adjustments [ 18 ] mload ( 0x5000 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = column21 row3 mload ( 0x39a0 ) val : = mulmod ( val , mload ( 0x4920 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 232 ] mload ( 0x2140 ) , mulmod ( coefficients [ 233 ] mload ( 0x2160 ) , adjustments [ 18 ] mload ( 0x5000 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) , addmod ( column21 row5 mload ( 0x39e0 ) , sub ( PRIME , column21 row14 mload ( 0x3b00 ) ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column21 row13 mload ( 0x3ae0 ) , addmod ( column21 row9 mload ( 0x3a60 ) , sub ( PRIME , column21 row6 mload ( 0x3a00 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 234 ] mload ( 0x2180 ) , mulmod ( coefficients [ 235 ] mload ( 0x21a0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row13 mload ( 0x3ae0 ) , column21 row13 mload ( 0x3ae0 ) , PRIME ) , sub ( PRIME , mulmod ( intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) , addmod ( addmod ( column21 row9 mload ( 0x3a60 ) , column21 row6 mload ( 0x3a00 ) , PRIME ) , column21 row25 mload ( 0x3c00 ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 236 ] mload ( 0x21c0 ) , mulmod ( coefficients [ 237 ] mload ( 0x21e0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( intermediate value ecdsa signature0 exponentiate key bit 0 mload ( 0x4400 ) , addmod ( column21 row5 mload ( 0x39e0 ) , column21 row21 mload ( 0x3b80 ) , PRIME ) , PRIME ) , sub ( PRIME , mulmod ( column21 row13 mload ( 0x3ae0 ) , addmod ( column21 row9 mload ( 0x3a60 ) , sub ( PRIME , column21 row25 mload ( 0x3c00 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 238 ] mload ( 0x2200 ) , mulmod ( coefficients [ 239 ] mload ( 0x2220 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row11 mload ( 0x3aa0 ) , addmod ( column21 row9 mload ( 0x3a60 ) , sub ( PRIME , column21 row6 mload ( 0x3a00 ) ) , PRIME ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 240 ] mload ( 0x2240 ) , mulmod ( coefficients [ 241 ] mload ( 0x2260 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate key bit neg 0 mload ( 0x4420 ) , addmod ( column21 row25 mload ( 0x3c00 ) , sub ( PRIME , column21 row9 mload ( 0x3a60 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 242 ] mload ( 0x2280 ) , mulmod ( coefficients [ 243 ] mload ( 0x22a0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( intermediate value ecdsa signature0 exponentiate key bit neg 0 mload ( 0x4420 ) , addmod ( column21 row21 mload ( 0x3b80 ) , sub ( PRIME , column21 row5 mload ( 0x39e0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4d40 ) , PRIME ) val : = mulmod ( val , mload ( 0x4720 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 244 ] mload ( 0x22c0 ) , mulmod ( coefficients [ 245 ] mload ( 0x22e0 ) , adjustments [ 15 ] mload ( 0x4fa0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row7 mload ( 0x3a20 ) , sub ( PRIME , ecdsa sig config . shift point . x mload ( 0x2e0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 246 ] mload ( 0x2300 ) , mulmod ( coefficients [ 247 ] mload ( 0x2320 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row23 mload ( 0x3bc0 ) , ecdsa sig config . shift point . y mload ( 0x300 ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 248 ] mload ( 0x2340 ) , mulmod ( coefficients [ 249 ] mload ( 0x2360 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row9 mload ( 0x3a60 ) , sub ( PRIME , ecdsa sig config . shift point . x mload ( 0x2e0 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4960 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 250 ] mload ( 0x2380 ) , mulmod ( coefficients [ 251 ] mload ( 0x23a0 ) , adjustments [ 18 ] mload ( 0x5000 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row5 mload ( 0x39e0 ) , sub ( PRIME , ecdsa sig config . shift point . y mload ( 0x300 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4960 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 252 ] mload ( 0x23c0 ) , mulmod ( coefficients [ 253 ] mload ( 0x23e0 ) , adjustments [ 18 ] mload ( 0x5000 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row8183 mload ( 0x3e20 ) , sub ( PRIME , addmod ( column21 row4085 mload ( 0x3ce0 ) , mulmod ( column22 row8160 mload ( 0x3ea0 ) , addmod ( column21 row8167 mload ( 0x3da0 ) , sub ( PRIME , column21 row4089 mload ( 0x3d00 ) ) , PRIME ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 254 ] mload ( 0x2400 ) , mulmod ( coefficients [ 255 ] mload ( 0x2420 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column22 row8160 mload ( 0x3ea0 ) , column22 row8160 mload ( 0x3ea0 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( column21 row8167 mload ( 0x3da0 ) , column21 row4089 mload ( 0x3d00 ) , PRIME ) , column21 row4102 mload ( 0x3d60 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 256 ] mload ( 0x2440 ) , mulmod ( coefficients [ 257 ] mload ( 0x2460 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column21 row8183 mload ( 0x3e20 ) , column21 row4110 mload ( 0x3d80 ) , PRIME ) , sub ( PRIME , mulmod ( column22 row8160 mload ( 0x3ea0 ) , addmod ( column21 row8167 mload ( 0x3da0 ) , sub ( PRIME , column21 row4102 mload ( 0x3d60 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 258 ] mload ( 0x2480 ) , mulmod ( coefficients [ 259 ] mload ( 0x24a0 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row8175 mload ( 0x3dc0 ) , addmod ( column21 row8167 mload ( 0x3da0 ) , sub ( PRIME , column21 row4089 mload ( 0x3d00 ) ) , PRIME ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 260 ] mload ( 0x24c0 ) , mulmod ( coefficients [ 261 ] mload ( 0x24e0 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( addmod ( column21 row8181 mload ( 0x3e00 ) , ecdsa sig config . shift point . y mload ( 0x300 ) , PRIME ) , sub ( PRIME , mulmod ( column21 row4093 mload ( 0x3d40 ) , addmod ( column21 row8185 mload ( 0x3e40 ) , sub ( PRIME , ecdsa sig config . shift point . x mload ( 0x2e0 ) ) , PRIME ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 262 ] mload ( 0x2500 ) , mulmod ( coefficients [ 263 ] mload ( 0x2520 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row4093 mload ( 0x3d40 ) , column21 row4093 mload ( 0x3d40 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( column21 row8185 mload ( 0x3e40 ) , ecdsa sig config . shift point . x mload ( 0x2e0 ) , PRIME ) , column21 row3 mload ( 0x39a0 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 264 ] mload ( 0x2540 ) , mulmod ( coefficients [ 265 ] mload ( 0x2560 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row8189 mload ( 0x3e60 ) , addmod ( column21 row8185 mload ( 0x3e40 ) , sub ( PRIME , ecdsa sig config . shift point . x mload ( 0x2e0 ) ) , PRIME ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 266 ] mload ( 0x2580 ) , mulmod ( coefficients [ 267 ] mload ( 0x25a0 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row31 mload ( 0x3c40 ) , column21 row4081 mload ( 0x3cc0 ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 268 ] mload ( 0x25c0 ) , mulmod ( coefficients [ 269 ] mload ( 0x25e0 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row3 mload ( 0x39a0 ) , column21 row4091 mload ( 0x3d20 ) , PRIME ) , sub ( PRIME , 1 ) , PRIME ) val : = mulmod ( val , mload ( 0x4960 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 270 ] mload ( 0x2600 ) , mulmod ( coefficients [ 271 ] mload ( 0x2620 ) , adjustments [ 20 ] mload ( 0x5040 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column21 row8177 mload ( 0x3de0 ) , sub ( PRIME , mulmod ( column21 row6 mload ( 0x3a00 ) , column21 row6 mload ( 0x3a00 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 272 ] mload ( 0x2640 ) , mulmod ( coefficients [ 273 ] mload ( 0x2660 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( mulmod ( column21 row14 mload ( 0x3b00 ) , column21 row14 mload ( 0x3b00 ) , PRIME ) , sub ( PRIME , addmod ( addmod ( mulmod ( column21 row6 mload ( 0x3a00 ) , column21 row8177 mload ( 0x3de0 ) , PRIME ) , mulmod ( ecdsa sig config . alpha mload ( 0x2c0 ) , column21 row6 mload ( 0x3a00 ) , PRIME ) , PRIME ) , ecdsa sig config . beta mload ( 0x320 ) , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 274 ] mload ( 0x2680 ) , mulmod ( coefficients [ 275 ] mload ( 0x26a0 ) , adjustments [ 19 ] mload ( 0x5020 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row22 mload ( 0x3560 ) , sub ( PRIME , initial ecdsa addr mload ( 0x340 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 276 ] mload ( 0x26c0 ) , mulmod ( coefficients [ 277 ] mload ( 0x26e0 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row4118 mload ( 0x3860 ) , sub ( PRIME , addmod ( column19 row22 mload ( 0x3560 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 278 ] mload ( 0x2700 ) , mulmod ( coefficients [ 279 ] mload ( 0x2720 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row8214 mload ( 0x38a0 ) , sub ( PRIME , addmod ( column19 row4118 mload ( 0x3860 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4d80 ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 280 ] mload ( 0x2740 ) , mulmod ( coefficients [ 281 ] mload ( 0x2760 ) , adjustments [ 21 ] mload ( 0x5060 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row4119 mload ( 0x3880 ) , sub ( PRIME , column21 row31 mload ( 0x3c40 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 282 ] mload ( 0x2780 ) , mulmod ( coefficients [ 283 ] mload ( 0x27a0 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row23 mload ( 0x3580 ) , sub ( PRIME , column21 row6 mload ( 0x3a00 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4940 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 284 ] mload ( 0x27c0 ) , mulmod ( coefficients [ 285 ] mload ( 0x27e0 ) , adjustments [ 17 ] mload ( 0x4fe0 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row150 mload ( 0x36e0 ) , sub ( PRIME , initial checkpoints addr mload ( 0x360 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4740 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 286 ] mload ( 0x2800 ) , mulmod ( coefficients [ 287 ] mload ( 0x2820 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row150 mload ( 0x36e0 ) , sub ( PRIME , final checkpoints addr mload ( 0x380 ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4980 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 288 ] mload ( 0x2840 ) , mulmod ( coefficients [ 289 ] mload ( 0x2860 ) , adjustments [ 4 ] mload ( 0x4e40 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = addmod ( column19 row86 mload ( 0x3620 ) , sub ( PRIME , addmod ( column19 row150 mload ( 0x36e0 ) , 1 , PRIME ) ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 290 ] mload ( 0x2880 ) , mulmod ( coefficients [ 291 ] mload ( 0x28a0 ) , adjustments [ 10 ] mload ( 0x4f00 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( addmod ( column19 row406 mload ( 0x3800 ) , sub ( PRIME , column19 row150 mload ( 0x36e0 ) ) , PRIME ) , addmod ( column19 row406 mload ( 0x3800 ) , sub ( PRIME , addmod ( column19 row150 mload ( 0x36e0 ) , 2 , PRIME ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4da0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 292 ] mload ( 0x28c0 ) , mulmod ( coefficients [ 293 ] mload ( 0x28e0 ) , adjustments [ 22 ] mload ( 0x5080 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( addmod ( column19 row406 mload ( 0x3800 ) , sub ( PRIME , column19 row150 mload ( 0x36e0 ) ) , PRIME ) , addmod ( column19 row151 mload ( 0x3700 ) , sub ( PRIME , column19 row0 mload ( 0x33c0 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4da0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 294 ] mload ( 0x2900 ) , mulmod ( coefficients [ 295 ] mload ( 0x2920 ) , adjustments [ 22 ] mload ( 0x5080 ) , PRIME ) ) , PRIME ) , PRIME ) } { let val : = mulmod ( addmod ( column19 row406 mload ( 0x3800 ) , sub ( PRIME , column19 row150 mload ( 0x36e0 ) ) , PRIME ) , addmod ( column19 row87 mload ( 0x3640 ) , sub ( PRIME , column21 row8 mload ( 0x3a40 ) ) , PRIME ) , PRIME ) val : = mulmod ( val , mload ( 0x4da0 ) , PRIME ) val : = mulmod ( val , mload ( 0x4840 ) , PRIME ) res : = addmod ( res , mulmod ( val , add ( coefficients [ 296 ] mload ( 0x2940 ) , mulmod ( coefficients [ 297 ] mload ( 0x2960 ) , adjustments [ 22 ] mload ( 0x5080 ) , PRIME ) ) , PRIME ) , PRIME ) } mstore ( 0 , res ) return ( 0 , 0x20 ) } }
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function get Client Registrations ( address account ) external view returns ( uint256 [ ] memory ) { get ` client ` registered lockers function get Client Registrations ( address account ) external view returns ( uint256 [ ] memory ) { return client Registrations [ account ] ;
function transfer Any ERC20Token ( address token Address , uint256 tokens ) public returns ( bool success ) { require ( is Owner ( ) ) ; return IERC20 ( token Address ) . transfer ( owner ( ) , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function tokens To Claim ( address user ) public view returns ( uint256 tokens To Take ) { uint256 count Of Coins To Add = ( ( now info . coin Creation Time ) REBASE TIME ) ; uint256 real Total Supply = ( count Of Coins To Add TOKEN PRECISION ) ; uint256 value From Liqudity History = info . users [ user ] . applied Farm Token Circulation TOKEN PRECISION ; uint256 value To Liqudity History = real Total Supply TOKEN PRECISION ; uint256 [ ] memory my Array = new uint256 [ ] ( value To Liqudity History value From Liqudity History ) ; uint counter = 0 ; for ( uint i = value From Liqudity History ; i < value To Liqudity History ; i + + ) { my Array [ counter ] = history Of Liqudity [ i ] ; if ( history Of Liqudity [ i ] = = 0 ) { my Array [ counter ] = my Array [ counter 1 ] ; } counter + + ; } uint256 adjusted Address Balance = 0 ; for ( uint j = 0 ; j < counter ; j + + ) { adjusted Address Balance + = ( ( TOKEN PRECISION info . users [ user ] . liqudity Balance ) my Array [ j ] ) ; } return adjusted Address Balance ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc SEPPUKU Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending SEPPUKU ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc SEPPUKU Per Share = pool . acc SEPPUKU Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 SEPPUKU Reward = multiplier . mul ( SEPPUKU Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc SEPPUKU Per Share = acc SEPPUKU Per Share . add ( SEPPUKU Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { SEPPUKU . mint ( devaddr , amount ) ;
function burn ( uint256 amount ) public only Owner { SEPPUKU . burn ( amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 SEPPUKU Reward = multiplier . mul ( SEPPUKU Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; SEPPUKU . mint ( devaddr , SEPPUKU Reward . div ( 4 ) ) ; SEPPUKU . mint ( address ( this ) , SEPPUKU Reward ) ; pool . acc SEPPUKU Per Share = pool . acc SEPPUKU Per Share . add ( SEPPUKU Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe SEPPUKU Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe SEPPUKU Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc SEPPUKU Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe SEPPUKU Transfer ( address to , uint256 amount ) internal { uint256 SEPPUKU Bal = SEPPUKU . balance Of ( address ( this ) ) ; if ( amount > SEPPUKU Bal ) { SEPPUKU . transfer ( to , SEPPUKU Bal ) ; } else { SEPPUKU . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function get virtual price ( ) external override view returns ( uint ) { return stable Swap BUSD . get virtual price ( ) ;
function calc token amount deposit ( uint [ ] calldata amounts ) external override view returns ( uint share Amount ) { uint [ 4 ] memory bpool Amounts ; bpool Amounts [ 0 ] = convert underlying to ytoken rate ( pool BUS Dy Tokens [ 0 ] , amounts [ 0 ] ) ; bpool Amounts [ 1 ] = convert underlying to ytoken rate ( pool BUS Dy Tokens [ 1 ] , amounts [ 1 ] ) ; bpool Amounts [ 2 ] = convert underlying to ytoken rate ( pool BUS Dy Tokens [ 2 ] , amounts [ 2 ] ) ; bpool Amounts [ 3 ] = convert underlying to ytoken rate ( pool BUS Dy Tokens [ 3 ] , amounts [ 4 ] ) ; uint bpool To Bcrv = stable Swap BUSD . calc token amount ( bpool Amounts , true ) ; uint 3crv To B Crv = convert rate ( address ( token3Crv ) , address ( token B Crv ) , amounts [ 3 ] ) ; uint susd To B Crv = convert rate ( address ( token SUSD ) , address ( token B Crv ) , amounts [ 5 ] ) ; uint husd To B Crv = convert rate ( address ( token HUSD ) , address ( token B Crv ) , amounts [ 6 ] ) ; return share Amount . add ( bpool To Bcrv ) . add ( 3crv To B Crv ) . add ( susd To B Crv ) . add ( husd To B Crv ) ;
function convert 3crv to shares ( uint 3crv ) internal returns ( uint shares ) { uint [ 4 ] memory amounts ; uint before = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; stable Swap3Pool . remove liquidity one coin ( 3crv , 0 , 1 ) ; uint after = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] = after . sub ( before ) ; before = token B Crv . balance Of ( address ( this ) ) ; deposit BUSD . add liquidity ( amounts , 1 ) ; after = token B Crv . balance Of ( address ( this ) ) ; shares = after . sub ( before ) ;
function convert susd to shares ( uint amount ) internal returns ( uint shares ) { uint [ 4 ] memory amounts ; uint before = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; stable Swap SUSD . exchange underlying ( int128 ( 3 ) , int128 ( 0 ) , amount , 1 ) ; uint after = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] = after . sub ( before ) ; before = token B Crv . balance Of ( address ( this ) ) ; deposit BUSD . add liquidity ( amounts , 1 ) ; after = token B Crv . balance Of ( address ( this ) ) ; shares = after . sub ( before ) ;
function convert husd to shares ( uint amount ) internal returns ( uint shares ) { uint before = token3Crv . balance Of ( address ( this ) ) ; stable Swap HUSD . exchange ( int128 ( 0 ) , int128 ( 1 ) , amount , 1 ) ; uint after = token3Crv . balance Of ( address ( this ) ) ; amount = after . sub ( before ) ; uint [ 4 ] memory amounts ; before = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; stable Swap3Pool . remove liquidity one coin ( amount , 0 , 1 ) ; after = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] = after . sub ( before ) ; before = token B Crv . balance Of ( address ( this ) ) ; deposit BUSD . add liquidity ( amounts , 1 ) ; after = token B Crv . balance Of ( address ( this ) ) ; shares = after . sub ( before ) ;
function convert shares to husd ( uint amount ) internal returns ( uint husd ) { uint [ 3 ] memory amounts ; uint before = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; deposit BUSD . remove liquidity one coin ( amount , 0 , 1 ) ; uint after = bpool Tokens [ 0 ] . balance Of ( address ( this ) ) ; amounts [ 0 ] = after . sub ( before ) ; before = token3Crv . balance Of ( address ( this ) ) ; stable Swap3Pool . add liquidity ( amounts , 1 ) ; after = token3Crv . balance Of ( address ( this ) ) ; amount = after . sub ( before ) ; before = token HUSD . balance Of ( address ( this ) ) ; stable Swap HUSD . exchange ( int128 ( 1 ) , int128 ( 0 ) , amount , 1 ) ; after = token HUSD . balance Of ( address ( this ) ) ; husd = after . sub ( before ) ;
function add Owner ( address new Owner ) external is An Owner { add Owner Ship ( new Owner ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function seize ( IERC20 token , uint amount ) external { require ( msg . sender = = governance , " ! governance " ) ; require ( token ! = token , " reward " ) ; require ( token ! = vote , " vote " ) ; token . safe Transfer ( governance , amount ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; if ( voters [ msg . sender ] = = true ) { votes [ msg . sender ] = votes [ msg . sender ] . add ( amount ) ; total Votes = total Votes . add ( amount ) ; } super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc City Per Share = pool . acc City Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share = acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; city . mint ( devaddr , city Reward . div ( 20 ) ) ; 5 % city . mint ( devaddr , city Reward . div ( 20 ) ) ; city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share = pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal = city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function sort Tokens ( address token A , address token B ) internal pure returns ( address token0 , address token1 ) { require ( token A ! = token B , ' Uniswap V2Library : IDENTICAL ADDRESSES ' ) ; ( token0 , token1 ) = token A < token B ? ( token A , token B ) : ( token B , token A ) ; require ( token0 ! = address ( 0 ) , ' Uniswap V2Library : ZERO ADDRESS ' ) ;
function pair For ( address factory , address token A , address token B ) internal pure returns ( address pair ) { ( address token0 , address token1 ) = sort Tokens ( token A , token B ) ; pair = address ( uint ( keccak256 ( abi . encode Packed ( hex ' ff ' , factory , keccak256 ( abi . encode Packed ( token0 , token1 ) ) , hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' init code hash hex ' 96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f ' ) ) ) ) ;
function get Reserves ( address factory , address token A , address token B ) internal view returns ( uint reserve A , uint reserve B ) { ( address token0 , ) = sort Tokens ( token A , token B ) ; ( uint reserve0 , uint reserve1 , ) = I Uniswap V2Pair ( pair For ( factory , token A , token B ) ) . get Reserves ( ) ; ( reserve A , reserve B ) = token A = = token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ) ;
function quote ( uint amount A , uint reserve A , uint reserve B ) internal pure returns ( uint amount B ) { require ( amount A > 0 , ' Uniswap V2Library : INSUFFICIENT AMOUNT ' ) ; require ( reserve A > 0 & & reserve B > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; amount B = amount A . mul ( reserve B ) reserve A ;
function get Amount Out ( uint amount In , uint reserve In , uint reserve Out ) internal pure returns ( uint amount Out ) { require ( amount In > 0 , ' Uniswap V2Library : INSUFFICIENT INPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint amount In With Fee = amount In . mul ( 997 ) ; uint numerator = amount In With Fee . mul ( reserve Out ) ; uint denominator = reserve In . mul ( 1000 ) . add ( amount In With Fee ) ; amount Out = numerator denominator ;
function get Amount In ( uint amount Out , uint reserve In , uint reserve Out ) internal pure returns ( uint amount In ) { require ( amount Out > 0 , ' Uniswap V2Library : INSUFFICIENT OUTPUT AMOUNT ' ) ; require ( reserve In > 0 & & reserve Out > 0 , ' Uniswap V2Library : INSUFFICIENT LIQUIDITY ' ) ; uint numerator = reserve In . mul ( amount Out ) . mul ( 1000 ) ; uint denominator = reserve Out . sub ( amount Out ) . mul ( 997 ) ; amount In = ( numerator denominator ) . add ( 1 ) ;
function get Amounts Out ( address factory , uint amount In , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ 0 ] = amount In ; for ( uint i ; i < path . length 1 ; i + + ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i ] , path [ i + 1 ] ) ; amounts [ i + 1 ] = get Amount Out ( amounts [ i ] , reserve In , reserve Out ) ; }
function get Amounts In ( address factory , uint amount Out , address [ ] memory path ) internal view returns ( uint [ ] memory amounts ) { require ( path . length > = 2 , ' Uniswap V2Library : INVALID PATH ' ) ; amounts = new uint [ ] ( path . length ) ; amounts [ amounts . length 1 ] = amount Out ; for ( uint i = path . length 1 ; i > 0 ; i ) { ( uint reserve In , uint reserve Out ) = get Reserves ( factory , path [ i 1 ] , path [ i ] ) ; amounts [ i 1 ] = get Amount In ( amounts [ i ] , reserve In , reserve Out ) ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Next Epoch check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function transfer Ownership ( address new Owner ) public only Owner { require ( new Owner ! = address ( 0x0 ) ) ; emit Ownership Transferred ( owner , new Owner ) ; owner = new Owner ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer All ( address to ) public { locks [ to ] = locks [ to ] . add ( locks [ msg . sender ] ) ; if ( last Unlock Block [ to ] < lock From Block ) { last Unlock Block [ to ] = lock From Block ; } if ( last Unlock Block [ to ] < last Unlock Block [ msg . sender ] ) { last Unlock Block [ to ] = last Unlock Block [ msg . sender ] ; } locks [ msg . sender ] = 0 ; last Unlock Block [ msg . sender ] = 0 ; transfer ( msg . sender , to , balance Of ( msg . sender ) ) ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function transfer ( address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ msg Sender ( ) ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; uint amount Less Fee = amount . sub ( fee ) ; transfer ( msg Sender ( ) , recipient , amount Less Fee ) ; transfer ( msg Sender ( ) , fee Recipient , fee ) ; } else { transfer ( msg Sender ( ) , recipient , amount ) ; } return true ;
function transfer From ( address sender , address recipient , uint256 amount ) public override returns ( bool ) { if ( active Fee & & fee Exception [ recipient ] = = false ) { uint256 fee = transfer Fee . mul ( amount ) . div ( 10000 ) ; transfer ( sender , fee Recipient , fee ) ; } transfer ( sender , recipient , amount ) ; approve ( sender , msg Sender ( ) , allowances [ sender ] [ msg Sender ( ) ] . sub ( amount , " ERC20 : transfer amount exceeds allowance " ) ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Next Epoch check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) { require ( amount > 0 , " Cannot stake 0 " ) ; if ( voters [ msg . sender ] = = true ) { votes [ msg . sender ] = votes [ msg . sender ] . add ( amount ) ; total Votes = total Votes . add ( amount ) ; } super . stake ( amount ) ; emit Staked ( msg . sender , amount ) ;
function sqrt ( uint y ) internal pure returns ( uint z ) { if ( y > 3 ) { z = y ; uint x = y 2 + 1 ; while ( x < z ) { z = x ; x = ( y x + x ) 2 ; } } else if ( y ! = 0 ) { z = 1 ; }
function encode ( uint112 y ) internal pure returns ( uint224 z ) { z = uint224 ( y ) Q112 ; never overflows z = uint224 ( y ) Q112 ;
function uqdiv ( uint224 x , uint112 y ) internal pure returns ( uint224 z ) { z = x uint224 ( y ) ;
function initialize ( address token0 , address token1 ) external { require ( msg . sender = = factory , ' Uniswap V2 : FORBIDDEN ' ) ; sufficient check require ( msg . sender = = factory , ' Uniswap V2 : FORBIDDEN ' ) ; token0 = token0 ; token1 = token1 ;
function update ( uint balance0 , uint balance1 , uint112 reserve0 , uint112 reserve1 ) private { require ( balance0 < = uint112 ( 1 ) & & balance1 < = uint112 ( 1 ) , ' Uniswap V2 : OVERFLOW ' ) ; uint32 block Timestamp = uint32 ( block . timestamp % 2 32 ) ; uint32 time Elapsed = block Timestamp block Timestamp Last ; overflow is desired uint32 time Elapsed = block Timestamp block Timestamp Last ; if ( time Elapsed > 0 & & reserve0 ! = 0 & & reserve1 ! = 0 ) { price0Cumulative Last + = uint ( UQ112x112 . encode ( reserve1 ) . uqdiv ( reserve0 ) ) time Elapsed ; price1Cumulative Last + = uint ( UQ112x112 . encode ( reserve0 ) . uqdiv ( reserve1 ) ) time Elapsed ; } reserve0 = uint112 ( balance0 ) ; reserve1 = uint112 ( balance1 ) ; block Timestamp Last = block Timestamp ; emit Sync ( reserve0 , reserve1 ) ;
function mint Fee ( uint112 reserve0 , uint112 reserve1 ) private returns ( bool fee On ) { address fee To = I Uniswap V2Factory ( factory ) . fee To ( ) ; fee On = fee To ! = address ( 0 ) ; uint k Last = k Last ; gas savings uint k Last = k Last ; if ( fee On ) { if ( k Last ! = 0 ) { uint root K = Math . sqrt ( uint ( reserve0 ) . mul ( reserve1 ) ) ; uint root K Last = Math . sqrt ( k Last ) ; if ( root K > root K Last ) { uint numerator = total Supply . mul ( root K . sub ( root K Last ) ) ; uint denominator = root K . mul ( 5 ) . add ( root K Last ) ; uint liquidity = numerator denominator ; if ( liquidity > 0 ) mint ( fee To , liquidity ) ; } } } else if ( k Last ! = 0 ) { k Last = 0 ; }
function mint ( address to ) external lock returns ( uint liquidity ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint amount0 = balance0 . sub ( reserve0 ) ; uint amount1 = balance1 . sub ( reserve1 ) ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; if ( total Supply = = 0 ) { liquidity = Math . sqrt ( amount0 . mul ( amount1 ) ) . sub ( MINIMUM LIQUIDITY ) ; mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; permanently lock the first MINIMUM LIQUIDITY tokens mint ( address ( 0 ) , MINIMUM LIQUIDITY ) ; } else { liquidity = Math . min ( amount0 . mul ( total Supply ) reserve0 , amount1 . mul ( total Supply ) reserve1 ) ; } require ( liquidity > 0 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY MINTED ' ) ; mint ( to , liquidity ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Mint ( msg . sender , amount0 , amount1 ) ;
function burn ( address to ) external lock returns ( uint amount0 , uint amount1 ) { ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; uint balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; uint balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; uint liquidity = balance Of [ address ( this ) ] ; bool fee On = mint Fee ( reserve0 , reserve1 ) ; uint total Supply = total Supply ; gas savings , must be defined here since total Supply can update in mint Fee uint total Supply = total Supply ; amount0 = liquidity . mul ( balance0 ) total Supply ; using balances ensures pro rata distribution amount0 = liquidity . mul ( balance0 ) total Supply ; amount1 = liquidity . mul ( balance1 ) total Supply ; using balances ensures pro rata distribution amount1 = liquidity . mul ( balance1 ) total Supply ; require ( amount0 > 0 & & amount1 > 0 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY BURNED ' ) ; burn ( address ( this ) , liquidity ) ; safe Transfer ( token0 , to , amount0 ) ; safe Transfer ( token1 , to , amount1 ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; update ( balance0 , balance1 , reserve0 , reserve1 ) ; if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; reserve0 and reserve1 are up to date if ( fee On ) k Last = uint ( reserve0 ) . mul ( reserve1 ) ; emit Burn ( msg . sender , amount0 , amount1 , to ) ;
function swap ( uint amount0Out , uint amount1Out , address to , bytes calldata data ) external lock { require ( amount0Out > 0 | | amount1Out > 0 , ' Uniswap V2 : INSUFFICIENT OUTPUT AMOUNT ' ) ; ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; gas savings ( uint112 reserve0 , uint112 reserve1 , ) = get Reserves ( ) ; require ( amount0Out < reserve0 & & amount1Out < reserve1 , ' Uniswap V2 : INSUFFICIENT LIQUIDITY ' ) ; uint balance0 ; uint balance1 ; { scope for token { 0 , 1 } , avoids stack too deep errors { address token0 = token0 ; address token1 = token1 ; require ( to ! = token0 & & to ! = token1 , ' Uniswap V2 : INVALID TO ' ) ; if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; optimistically transfer tokens if ( amount0Out > 0 ) safe Transfer ( token0 , to , amount0Out ) ; if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; optimistically transfer tokens if ( amount1Out > 0 ) safe Transfer ( token1 , to , amount1Out ) ; if ( data . length > 0 ) I Uniswap V2Callee ( to ) . uniswap V2Call ( msg . sender , amount0Out , amount1Out , data ) ; balance0 = IERC20 ( token0 ) . balance Of ( address ( this ) ) ; balance1 = IERC20 ( token1 ) . balance Of ( address ( this ) ) ; } uint amount0In = balance0 > reserve0 amount0Out ? balance0 ( reserve0 amount0Out ) : 0 ; uint amount1In = balance1 > reserve1 amount1Out ? balance1 ( reserve1 amount1Out ) : 0 ; require ( amount0In > 0 | | amount1In > 0 , ' Uniswap V2 : INSUFFICIENT INPUT AMOUNT ' ) ; { scope for reserve { 0 , 1 } Adjusted , avoids stack too deep errors { uint balance0Adjusted = balance0 . mul ( 1000 ) . sub ( amount0In . mul ( 3 ) ) ; uint balance1Adjusted = balance1 . mul ( 1000 ) . sub ( amount1In . mul ( 3 ) ) ; require ( balance0Adjusted . mul ( balance1Adjusted ) > = uint ( reserve0 ) . mul ( reserve1 ) . mul ( 1000 2 ) , ' Uniswap V2 : K ' ) ; } update ( balance0 , balance1 , reserve0 , reserve1 ) ; emit Swap ( msg . sender , amount0In , amount1In , amount0Out , amount1Out , to ) ;
function skim ( address to ) external lock { address token0 = token0 ; gas savings address token0 = token0 ; address token1 = token1 ; gas savings address token1 = token1 ; safe Transfer ( token0 , to , IERC20 ( token0 ) . balance Of ( address ( this ) ) . sub ( reserve0 ) ) ; safe Transfer ( token1 , to , IERC20 ( token1 ) . balance Of ( address ( this ) ) . sub ( reserve1 ) ) ;
function sync ( ) external lock { update ( IERC20 ( token0 ) . balance Of ( address ( this ) ) , IERC20 ( token1 ) . balance Of ( address ( this ) ) , reserve0 , reserve1 ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc Rally Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function set Rally Per Block ( uint256 rally Per Block ) public only Owner { mass Update Pools ( ) ; rally Per Block = rally Per Block ;
function pending Rally ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc Rally Per Share = pool . acc Rally Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = block . number . sub ( pool . last Reward Block ) ; uint256 rally Reward = multiplier . mul ( rally Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc Rally Per Share = acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = block . number . sub ( pool . last Reward Block ) ; uint256 rally Reward = multiplier . mul ( rally Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; pool . acc Rally Per Share = pool . acc Rally Per Share . add ( rally Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Rally Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe Rally Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc Rally Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe Rally Transfer ( address to , uint256 amount ) internal { uint256 rally Bal = rally . balance Of ( address ( this ) ) ; if ( amount > rally Bal ) { rally . transfer ( to , rally Bal ) ; } else { rally . transfer ( to , amount ) ; }
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { require ( block . timestamp < = deadline , " expired " ) ; bytes32 hash Struct = keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , nonces [ owner ] + + , deadline ) ) ; bytes32 hash = keccak256 ( abi . encode Packed ( ' \ x19 \ x01 ' , DOMAIN SEPARATOR , hash Struct ) ) ; address signer = ecrecover ( hash , v , r , s ) ; require ( signer ! = address ( 0 ) & & signer = = owner , " ! signer " ) ; approve ( owner , spender , value ) ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function harvest ( address reserve , uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; require ( reserve ! = address ( token ) , " token " ) ; IERC20 ( reserve ) . safe Transfer ( controller , amount ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc City Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending City ( uint256 pid , address user ) external view returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc City Per Share = pool . acc City Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc City Per Share = acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { city . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 city Reward = multiplier . mul ( city Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; city . mint ( devaddr , city Reward . div ( 20 ) ) ; 5 % city . mint ( devaddr , city Reward . div ( 20 ) ) ; city . mint ( address ( this ) , city Reward ) ; pool . acc City Per Share = pool . acc City Per Share . add ( city Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; } pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; safe City Transfer ( msg . sender , pending ) ; user . amount = user . amount . sub ( amount ) ; user . reward Debt = user . amount . mul ( pool . acc City Per Share ) . div ( 1e12 ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe City Transfer ( address to , uint256 amount ) internal { uint256 city Bal = city . balance Of ( address ( this ) ) ; if ( amount > city Bal ) { city . transfer ( to , city Bal ) ; } else { city . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : wut ? " ) ; devaddr = devaddr ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function change Admin ( address payable admin ) external only Admin { admin = admin ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function verify Trade Between DW ( ) internal view { require ( now > = latest Oracle Call On Time + cotrader Global Config . TRADE FREEZE TIME ( ) , " FREEZE FOR UPDATE PRICE " ) ;
function verify DW Sender ( ) internal view { if ( total Shares > 0 ) { if ( latest Oracle Call On Time + cotrader Global Config . TRADE FREEZE TIME ( ) > = now ) { require ( msg . sender = = latest Oracle Caller , " NOT LATEST ORACLE CALLER " ) ; } else { revert ( " ORACLE TIME EXPIRED " ) ; } }
function update Fund Value From Oracle ( address oracle Token Address , uint256 oracle Fee ) public payable { require ( now > = latest Oracle Call On Time + cotrader Global Config . DW FREEZE TIME ( ) , " DW FREEZE " ) ; if ( oracle Token Address = = address ( ETH TOKEN ADDRESS ) ) { require ( msg . value = = oracle Fee , " REQUIRE ETH " ) ; latest Oracle Request ID = fund Value Oracle . request Value . value ( oracle Fee ) ( address ( this ) , oracle Fee ) ; } else { require ( msg . value = = 0 , " NO NEED ETH " ) ; transfer From Sender And Approve To ( IERC20 ( oracle Token Address ) , oracle Fee , address ( fund Value Oracle ) ) ; latest Oracle Request ID = fund Value Oracle . request Value ( address ( this ) , oracle Fee ) ; } latest Oracle Call On Time = now ; latest Oracle Call On Block = block . number ; latest Oracle Caller = msg . sender ; emit Oracle Update ( latest Oracle Caller , latest Oracle Call On Time , latest Oracle Request ID ) ;
function calculate Fund Value ( ) public view returns ( uint256 ) { return fund Value Oracle . get Fund Value By ID ( latest Oracle Request ID ) ;
function get All Token Addresses ( ) external view returns ( address [ ] memory ) { return token Addresses ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function utilization ( address token , uint amount ) internal view returns ( uint ) { uint max = STABLE . MAX ( ) ; uint base = STABLE . BASE ( ) ; address pair = Uniswap Factory ( UNI . factory ( ) ) . get Pair ( token , address ( STABLE ) ) ; uint ratio = base . sub ( base . mul ( STABLE . balance Of ( pair ) . add ( amount ) ) . div ( STABLE . total Supply ( ) ) ) ; if ( ratio = = 0 ) { return max ; } return ratio > max ? max : ratio ;
function calculate Credit Max ( address token ) external view returns ( uint ) { return calculate Credit Max Of ( msg . sender , token ) ;
function calculate Borrow Exact Out ( address token , uint out Exact ) external view returns ( uint ) { address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( STABLE ) ; path [ 1 ] = token ; return UNI . get Amounts In ( out Exact , path ) [ 0 ] ;
function calculate Borrow Max ( address token ) external view returns ( uint ) { return calculate Borrow Max Of ( msg . sender , token ) ;
function calculate Borrow Exact In ( address token , uint in Exact ) public view returns ( uint ) { address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = address ( STABLE ) ; path [ 1 ] = token ; return UNI . get Amounts Out ( in Exact , path ) [ 1 ] ;
function calculate Repay Exact Out ( address token , uint out Exact ) external view returns ( uint ) { address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( STABLE ) ; return UNI . get Amounts In ( out Exact , path ) [ 0 ] ;
function calculate Repay Max ( address token ) external view returns ( uint ) { return calculate Repay Max Of ( msg . sender , token ) ;
function calculate Repay Exact In ( address token , uint in Exact ) public view returns ( uint ) { address [ ] memory path = new address [ ] ( 2 ) ; path [ 0 ] = token ; path [ 1 ] = address ( STABLE ) ; return UNI . get Amounts Out ( in Exact , path ) [ 1 ] ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( tokens < = balances [ msg . sender ] ) ; balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ;
function latest Locker Registration ( address account ) external view returns ( uint256 latest ) { get latest registered locker per account function latest Locker Registration ( address account ) external view returns ( uint256 latest ) { uint256 [ ] memory registered = registrations [ account ] ; if ( registered . length = = 0 ) { return 0 ; } else { return registered [ registered . length 1 ] ; }
function exp ( uint p , uint q , uint precision ) public pure returns ( uint ) { uint n = 0 ; uint n Fact = 1 ; uint current P = 1 ; uint current Q = 1 ; uint sum = 0 ; uint prev Sum = 0 ; while ( true ) { if ( check Mult Overflow ( current P , precision ) ) return sum ; if ( check Mult Overflow ( current Q , n Fact ) ) return sum ; sum + = ( current P precision ) ( current Q n Fact ) ; if ( sum = = prev Sum ) return sum ; prev Sum = sum ; n + + ; if ( check Mult Overflow ( current P , p ) ) return sum ; if ( check Mult Overflow ( current Q , q ) ) return sum ; if ( check Mult Overflow ( n Fact , n ) ) return sum ; current P = p ; current Q = q ; n Fact = n ; ( current P , current Q ) = compact Fraction ( current P , current Q , precision ) ; }
function count Leading Zeros ( uint p , uint q ) public pure returns ( uint ) { uint denomator = ( uint ( 1 ) < < 255 ) ; for ( int i = 255 ; i > = 0 ; i ) { if ( ( q denomator ) denomator ! = q ) { denomator = denomator 2 ; continue ; } if ( p ( q denomator ) > 0 ) return uint ( i ) ; denomator = denomator 2 ; } return uint ( 1 ) ;
function log2For Small Number ( uint x , uint num Precision Bits ) public pure returns ( uint ) { uint res = 0 ; uint one = ( uint ( 1 ) < < num Precision Bits ) ; uint two = 2 one ; uint addition = one ; require ( ( x > = one ) & & ( x < = two ) ) ; require ( num Precision Bits < 125 ) ; for ( uint i = num Precision Bits ; i > 0 ; i ) { x = ( x x ) one ; addition = addition 2 ; if ( x > = two ) { x = x 2 ; res + = addition ; } } return res ;
function yearn ( address strategy , address token , uint parts ) public { require ( msg . sender = = strategist | | msg . sender = = governance , " ! governance " ) ; uint before = IERC20 ( token ) . balance Of ( address ( this ) ) ; Strategy ( strategy ) . withdraw ( token ) ; uint after = IERC20 ( token ) . balance Of ( address ( this ) ) ; if ( after > before ) { uint amount = after . sub ( before ) ; address want = Strategy ( strategy ) . want ( ) ; uint [ ] memory distribution ; uint expected ; before = IERC20 ( want ) . balance Of ( address ( this ) ) ; IERC20 ( token ) . safe Approve ( onesplit , 0 ) ; IERC20 ( token ) . safe Approve ( onesplit , amount ) ; ( expected , distribution ) = One Split Audit ( onesplit ) . get Expected Return ( token , want , amount , parts , 0 ) ; One Split Audit ( onesplit ) . swap ( token , want , amount , expected , distribution , 0 ) ; after = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( after > before ) { amount = after . sub ( before ) ; uint reward = amount . mul ( split ) . div ( max ) ; earn ( want , amount . sub ( reward ) ) ; IERC20 ( want ) . safe Transfer ( rewards , reward ) ; } }
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function stake ( uint256 amount ) public update Reward ( msg . sender ) checkhalve check Start { require ( amount > 0 , " Cannot stake 0 " ) ; super . stake ( amount ) ; if ( user Reward Per Token Paid [ msg . sender ] = = 0 ) { user Reward Per Token Paid [ msg . sender ] = reward Per Token ( ) ; } emit Staked ( msg . sender , amount ) ;
function set Init Reward ( uint amt Love Wei Per Period ) external only Owner { require ( reward Rate = = 0 , " Must not have yet set the reward rate . " ) ; initreward = amt Love Wei Per Period ;
function fix Reward Per Token Stored ( address account , uint reward Per Token ) external only Owner { require ( earned ( account ) > 0 , " Must be a staker " ) ; require ( user Reward Per Token Paid [ account ] = = 0 , " Must have incorrect reward " ) ; user Reward Per Token Paid [ account ] = reward Per Token ;
function total Supply ( ) public constant returns ( uint ) { return total Supply balances [ address ( 0 ) ] ;
function balance Of ( address token Owner ) public constant returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safe Sub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safe Sub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safe Sub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safe Add ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , this , data ) ; return true ;
function ( ) public payable { revert ( ) ;
function decimals ( ) external pure returns ( uint8 ) { return uint8 ( 9 ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ; move Delegates ( address ( 0 ) , delegates [ to ] , amount ) ;
function add ( uint256 alloc Point , IERC20 lp Token , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } uint256 last Reward Block = block . number > start Block ? block . number : start Block ; total Alloc Point = total Alloc Point . add ( alloc Point ) ; pool Info . push ( Pool Info ( { lp Token : lp Token , alloc Point : alloc Point , last Reward Block : last Reward Block , acc YFS Per Share : 0 } ) ) ;
function set ( uint256 pid , uint256 alloc Point , bool with Update ) public only Owner { if ( with Update ) { mass Update Pools ( ) ; } total Alloc Point = total Alloc Point . sub ( pool Info [ pid ] . alloc Point ) . add ( alloc Point ) ; pool Info [ pid ] . alloc Point = alloc Point ;
function get Multiplier ( uint256 from , uint256 to ) public view returns ( uint256 ) { if ( to < = bonus End Block ) { return to . sub ( from ) . mul ( BONUS MULTIPLIER ) ; } else if ( from > = bonus End Block ) { return to . sub ( from ) ; } else { return bonus End Block . sub ( from ) . mul ( BONUS MULTIPLIER ) . add ( to . sub ( bonus End Block ) ) ; }
function pending YFS ( uint256 pid , address user ) external returns ( uint256 ) { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ user ] ; uint256 acc YFS Per Share = pool . acc YFS Per Share ; uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( block . number > pool . last Reward Block & & lp Supply ! = 0 ) { uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 YFS Reward = multiplier . mul ( YFS Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; acc YFS Per Share = acc YFS Per Share . add ( YFS Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; } return user . amount . mul ( acc YFS Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ;
function mass Update Pools ( ) public { uint256 length = pool Info . length ; for ( uint256 pid = 0 ; pid < length ; + + pid ) { update Pool ( pid ) ; }
function mint ( uint256 amount ) public only Owner { address msg Sender = msg Sender ( ) ; address owner = owner ( ) ; emit Ownership Transferred ( owner , msg Sender ) ; YFS . mint ( devaddr , amount ) ;
function update Pool ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; if ( block . number < = pool . last Reward Block ) { return ; } uint256 lp Supply = pool . lp Token . balance Of ( address ( this ) ) ; if ( lp Supply = = 0 ) { pool . last Reward Block = block . number ; return ; } uint256 multiplier = get Multiplier ( pool . last Reward Block , block . number ) ; uint256 YFS Reward = multiplier . mul ( YFS Per Block ) . mul ( pool . alloc Point ) . div ( total Alloc Point ) ; YFS . mint ( devaddr , YFS Reward . div ( 10 ) ) ; YFS . mint ( address ( this ) , YFS Reward ) ; pool . acc YFS Per Share = pool . acc YFS Per Share . add ( YFS Reward . mul ( 1e12 ) . div ( lp Supply ) ) ; pool . last Reward Block = block . number ;
function deposit ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; update Pool ( pid ) ; if ( user . amount > 0 ) { uint256 pending = user . amount . mul ( pool . acc YFS Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe YFS Transfer ( msg . sender , pending ) ; } } if ( amount > 0 ) { pool . lp Token . safe Transfer From ( address ( msg . sender ) , address ( this ) , amount ) ; user . amount = user . amount . add ( amount ) ; } user . reward Debt = user . amount . mul ( pool . acc YFS Per Share ) . div ( 1e12 ) ; emit Deposit ( msg . sender , pid , amount ) ;
function withdraw ( uint256 pid , uint256 amount ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; require ( user . amount > = amount , " withdraw : not good " ) ; update Pool ( pid ) ; uint256 pending = user . amount . mul ( pool . acc YFS Per Share ) . div ( 1e12 ) . sub ( user . reward Debt ) ; if ( pending > 0 ) { safe YFS Transfer ( msg . sender , pending ) ; } if ( amount > 0 ) { user . amount = user . amount . sub ( amount ) ; pool . lp Token . safe Transfer ( address ( msg . sender ) , amount ) ; } user . reward Debt = user . amount . mul ( pool . acc YFS Per Share ) . div ( 1e12 ) ; emit Withdraw ( msg . sender , pid , amount ) ;
function emergency Withdraw ( uint256 pid ) public { Pool Info storage pool = pool Info [ pid ] ; User Info storage user = user Info [ pid ] [ msg . sender ] ; pool . lp Token . safe Transfer ( address ( msg . sender ) , user . amount ) ; emit Emergency Withdraw ( msg . sender , pid , user . amount ) ; user . amount = 0 ; user . reward Debt = 0 ;
function safe YFS Transfer ( address to , uint256 amount ) internal { uint256 YFS Bal = YFS . balance Of ( address ( this ) ) ; if ( amount > YFS Bal ) { YFS . transfer ( to , YFS Bal ) ; } else { YFS . transfer ( to , amount ) ; }
function dev ( address devaddr ) public { require ( msg . sender = = devaddr , " dev : what ? " ) ; devaddr = devaddr ;
function total Supply ( ) public view returns ( uint ) { return total Supply . sub ( balances [ address ( 0 ) ] ) ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function approve And Call ( address spender , uint tokens , bytes memory data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; Approve And Call Fall Back ( spender ) . receive Approval ( msg . sender , tokens , address ( this ) , data ) ; return true ;
function ( ) external payable { revert ( ) ;
function transfer Any ERC20Token ( address token Address , uint tokens ) public only Owner returns ( bool success ) { return ERC20Interface ( token Address ) . transfer ( owner , tokens ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function testlogbase2 ( int128 x ) public pure returns ( int128 ) { return logbase2 ( x ) ;
function withdraw ( IERC20 asset ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; require ( want ! = address ( asset ) , " want " ) ; require ( d ! = address ( asset ) , " d " ) ; balance = asset . balance Of ( address ( this ) ) ; asset . safe Transfer ( controller , balance ) ;
function withdraw ( uint amount ) external { require ( msg . sender = = controller , " ! controller " ) ; uint balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; if ( balance < amount ) { amount = withdraw Some ( amount . sub ( balance ) ) ; amount = amount . add ( balance ) ; } uint fee = 0 ; if ( withdrawal Fee > 0 ) { fee = amount . mul ( withdrawal Fee ) . div ( withdrawal Max ) ; IERC20 ( want ) . safe Transfer ( Controller ( controller ) . rewards ( ) , fee ) ; } address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , amount . sub ( fee ) ) ;
function withdraw All ( ) external returns ( uint balance ) { require ( msg . sender = = controller , " ! controller " ) ; withdraw All ( ) ; balance = IERC20 ( want ) . balance Of ( address ( this ) ) ; address vault = Controller ( controller ) . vaults ( address ( want ) ) ; require ( vault ! = address ( 0 ) , " ! vault " ) ; additional protection so we don ' t burn the funds require ( vault ! = address ( 0 ) , " ! vault " ) ; IERC20 ( want ) . safe Transfer ( vault , balance ) ;
function STAKE ( uint256 tokens ) external { require ( IERC20 ( YF Is ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from user account " ) ; uint256 staking Fee = 0 ; if ( total Stakes > 0 ) staking Fee = ( one Percent ( tokens ) . mul ( staking Fee ) ) . div ( 10 ) ; if ( total Stakes > 0 ) add Payout ( staking Fee ) ; uint256 owing = pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + = owing ; stakers [ msg . sender ] . staked Tokens = ( tokens . sub ( staking Fee ) ) . add ( stakers [ msg . sender ] . staked Tokens ) ; stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; stakers [ msg . sender ] . round = round ; total Stakes = total Stakes . add ( tokens . sub ( staking Fee ) ) ; emit STAKED ( msg . sender , tokens . sub ( staking Fee ) , staking Fee ) ;
function ADDFUNDS ( uint256 tokens ) external { require ( IERC20 ( YF Is ) . transfer From ( msg . sender , address ( this ) , tokens ) , " Tokens cannot be transferred from funder account " ) ; add Payout ( tokens ) ;
function add Payout ( uint256 tokens ) private { uint256 available = ( tokens . mul ( scaling ) ) . add ( scaled Remainder ) ; uint256 dividend Per Token = available . div ( total Stakes ) ; scaled Remainder = available . mod ( total Stakes ) ; total Dividends = total Dividends . add ( dividend Per Token ) ; payouts [ round ] = payouts [ round 1 ] . add ( dividend Per Token ) ; emit PAYOUT ( round , tokens , msg . sender ) ; round + + ;
function CLAIMREWARD ( ) public { if ( total Dividends > stakers [ msg . sender ] . from Total Dividend ) { uint256 owing = pending Reward ( msg . sender ) ; owing = owing . add ( stakers [ msg . sender ] . remainder ) ; stakers [ msg . sender ] . remainder = 0 ; require ( IERC20 ( YF Is ) . transfer ( msg . sender , owing ) , " ERROR : error in sending reward from contract " ) ; emit CLAIMEDREWARD ( msg . sender , owing ) ; stakers [ msg . sender ] . last Dividends = owing ; unscaled stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . round = round ; update the round stakers [ msg . sender ] . round = round ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; scaled stakers [ msg . sender ] . from Total Dividend = total Dividends ; }
function pending Reward ( address staker ) private returns ( uint256 ) { uint256 amount = ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) . div ( scaling ) ; stakers [ staker ] . remainder + = ( ( total Dividends . sub ( payouts [ stakers [ staker ] . round 1 ] ) ) . mul ( stakers [ staker ] . staked Tokens ) ) % scaling ; return amount ;
function WITHDRAW ( uint256 tokens ) external { require ( stakers [ msg . sender ] . staked Tokens > = tokens & & tokens > 0 , " Invalid token amount to withdraw " ) ; uint256 unstaking Fee = ( one Percent ( tokens ) . mul ( unstaking Fee ) ) . div ( 10 ) ; uint256 owing = pending Reward ( msg . sender ) ; stakers [ msg . sender ] . remainder + = owing ; require ( IERC20 ( YF Is ) . transfer ( msg . sender , tokens . sub ( unstaking Fee ) ) , " Error in un staking tokens " ) ; stakers [ msg . sender ] . staked Tokens = stakers [ msg . sender ] . staked Tokens . sub ( tokens ) ; stakers [ msg . sender ] . last Dividends = owing ; stakers [ msg . sender ] . from Total Dividend = total Dividends ; stakers [ msg . sender ] . round = round ; total Stakes = total Stakes . sub ( tokens ) ; if ( total Stakes > 0 ) add Payout ( unstaking Fee ) ; emit UNSTAKED ( msg . sender , tokens . sub ( unstaking Fee ) , unstaking Fee ) ;
function one Percent ( uint256 tokens ) private pure returns ( uint256 ) { uint256 round Value = tokens . ceil ( 100 ) ; uint one Percentof Tokens = round Value . mul ( 100 ) . div ( 100 10 uint ( 2 ) ) ; return one Percentof Tokens ;
function your Staked YF Is ( address staker ) external view returns ( uint256 staked Y Fis ) { return stakers [ staker ] . staked Tokens ;
function your YF Is Balance ( address user ) external view returns ( uint256 YF Is Balance ) { return IERC20 ( YF Is ) . balance Of ( user ) ;
function initial Tokens ( ) internal { active Tokens . push ( address ( 0x Ff795577d9AC8b D7D90Ee22b6C1703490b6512FD ) ) ; DAI active Tokens . push ( address ( 0x Ff795577d9AC8b D7D90Ee22b6C1703490b6512FD ) ) ; active Tokens . push ( address ( 0xe22da380ee6B445bb8273C81944ADEB6E8450422 ) ) ; USDC active Tokens . push ( address ( 0xe22da380ee6B445bb8273C81944ADEB6E8450422 ) ) ; active Tokens . push ( address ( 0x13512979ADE267AB5100878E2e0f485B568328a4 ) ) ; USDT active Tokens . push ( address ( 0x13512979ADE267AB5100878E2e0f485B568328a4 ) ) ; active Tokens . push ( address ( 0x D868790F57B39C9B2B51b12de046975f986675f9 ) ) ; s USD active Tokens . push ( address ( 0x D868790F57B39C9B2B51b12de046975f986675f9 ) ) ; active Tokens . push ( address ( 0x6B175474E89094C44Da98b954Eede AC495271d0F ) ) ; DAI active Tokens . push ( address ( 0x6B175474E89094C44Da98b954Eede AC495271d0F ) ) ; active Tokens . push ( address ( 0x A0b86991c6218b36c1d19D4a2e9Eb0c E3606e B48 ) ) ; USDC active Tokens . push ( address ( 0x A0b86991c6218b36c1d19D4a2e9Eb0c E3606e B48 ) ) ; active Tokens . push ( address ( 0xd AC17F958D2ee523a2206206994597C13D831ec7 ) ) ; USDT active Tokens . push ( address ( 0xd AC17F958D2ee523a2206206994597C13D831ec7 ) ) ; active Tokens . push ( address ( 0x57Ab1ec28D129707052df4d F418D58a2D46d5f51 ) ) ; s USD active Tokens . push ( address ( 0x57Ab1ec28D129707052df4d F418D58a2D46d5f51 ) ) ;
function circulating Supply ( ) public view returns ( uint256 ) { if ( stabilize T . total Supply ( ) = = 0 ) { return 0 ; } else { uint256 total = stabilize T . total Supply ( ) . sub ( stabilize T . balance Of ( operator Address ) ) . sub ( stabilize T . balance Of ( address ( this ) ) ) ; if ( furnace List . length > 0 ) { for ( uint256 i = 0 ; i < furnace List . length ; i + + ) { total = total . sub ( stabilize T . balance Of ( furnace List [ i ] ) ) ; } } return total ; }
function start Governance Change ( address address ) external only Governance { timelock Start = now ; timelock Type = 1 ; timelock address = address ;
function start Add New Token ( address address ) external only Governance { require ( address ! = stbz Address , " Cannot add token that is the same as the burnt tokens " ) ; timelock Start = now ; timelock Type = 2 ; timelock address = address ;
function start Remove Token ( address address ) external only Governance { timelock Start = now ; timelock Type = 3 ; timelock address = address ;
function start Add New Furnace ( address address ) external only Governance { require ( address ! = stbz Address , " Cannot add STBZ address as a furnace " ) ; timelock Start = now ; timelock Type = 4 ; timelock address = address ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function available ( ) public view returns ( uint ) { return token . balance Of ( address ( this ) ) . mul ( min ) . div ( max ) ;
function withdraw ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } token . safe Transfer ( msg . sender , r ) ;
function withdraw ETH ( uint shares ) public { uint r = ( balance ( ) . mul ( shares ) ) . div ( total Supply ( ) ) ; burn ( msg . sender , shares ) ; uint b = token . balance Of ( address ( this ) ) ; if ( b < r ) { uint withdraw = r . sub ( b ) ; Controller ( controller ) . withdraw ( address ( token ) , withdraw ) ; uint after = token . balance Of ( address ( this ) ) ; uint diff = after . sub ( b ) ; if ( diff < withdraw ) { r = b . add ( diff ) ; } } WETH ( address ( token ) ) . withdraw ( r ) ; address ( msg . sender ) . transfer ( r ) ;
function get Client Registrations ( address account ) external view returns ( uint256 [ ] memory ) { get set of ` client ` registered lockers function get Client Registrations ( address account ) external view returns ( uint256 [ ] memory ) { return client Registrations [ account ] ;
function hodler Transfer ( address from , uint256 value ) external only Role ( ROLE TRANSFER ) returns ( bool ) { require ( from ! = address ( 0 ) ) ; require ( value > 0 ) ; address hodler = msg . sender ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ hodler ] = balances [ hodler ] . add ( value ) ; emit Transfer ( from , hodler , value ) ; return true ;
function mint ( address to , uint256 amount ) external only Role ( ROLE MINT ) returns ( bool ) { require ( to ! = address ( 0 ) ) ; require ( amount > 0 ) ; total Supply = total Supply . add ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; emit Mint Log ( to , amount ) ; emit Transfer ( address ( 0 ) , to , amount ) ; return true ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Admin Fee ( uint256 admin Fee Denominator , address lao Fund Address ) public non Reentrant only Owner { require ( admin Fee Denominator > = 200 ) ; admin Fee Denominator = admin Fee Denominator ; lao Fund Address = lao Fund Address ;
function submit Vote ( uint256 proposal Index , uint8 uint Vote ) public non Reentrant only Delegate { address member Address = member Address By Delegate Key [ msg . sender ] ; Member storage member = members [ member Address ] ; require ( proposal Index < proposal Queue . length , " proposal does not exist " ) ; Proposal storage proposal = proposals [ proposal Queue [ proposal Index ] ] ; require ( uint Vote < 3 , " must be less than 3 " ) ; Vote vote = Vote ( uint Vote ) ; require ( get Current Period ( ) > = proposal . starting Period , " voting period has not started " ) ; require ( ! has Voting Period Expired ( proposal . starting Period ) , " proposal voting period has expired " ) ; require ( proposal . votes By Member [ member Address ] = = Vote . Null , " member has already voted " ) ; require ( vote = = Vote . Yes | | vote = = Vote . No , " vote must be either Yes or No " ) ; proposal . votes By Member [ member Address ] = vote ; if ( vote = = Vote . Yes ) { proposal . yes Votes = proposal . yes Votes . add ( member . shares ) ; if ( proposal Index > member . highest Index Yes Vote ) { member . highest Index Yes Vote = proposal Index ; } if ( total Shares . add ( total Loot ) > proposal . max Total Shares And Loot At Yes Vote ) { proposal . max Total Shares And Loot At Yes Vote = total Shares . add ( total Loot ) ; } } else if ( vote = = Vote . No ) { proposal . no Votes = proposal . no Votes . add ( member . shares ) ; } emit Submit Vote ( proposal Queue [ proposal Index ] , proposal Index , msg . sender , member Address , uint Vote ) ;
function cancel Proposal ( uint256 proposal Id ) public non Reentrant { Proposal storage proposal = proposals [ proposal Id ] ; require ( ! proposal . flags [ 0 ] , " proposal has already been sponsored " ) ; require ( ! proposal . flags [ 3 ] , " proposal has already been cancelled " ) ; require ( msg . sender = = proposal . proposer , " solely the proposer can cancel " ) ; proposal . flags [ 3 ] = true ; cancelled proposal . flags [ 3 ] = true ; unsafe Internal Transfer ( ESCROW , proposal . proposer , proposal . tribute Token , proposal . tribute Offered ) ; emit Cancel Proposal ( proposal Id , msg . sender ) ;
function can Ragequit ( uint256 highest Index Yes Vote ) public view returns ( bool ) { require ( highest Index Yes Vote < proposal Queue . length , " proposal does not exist " ) ; return proposals [ proposal Queue [ highest Index Yes Vote ] ] . flags [ 1 ] ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
function set Token Addresses ( address token Addr , address liquidity Addr ) public only Owner returns ( bool ) { require ( token Addr ! = address ( 0 ) & & liquidity Addr ! = address ( 0 ) , " Invalid addresses format are not supported " ) ; token Address = token Addr ; foreigntoken = liquidity Addr ;
function total Supply ( ) public view returns ( uint ) { return total Supply ;
function balance Of ( address token Owner ) public view returns ( uint balance ) { return balances [ token Owner ] ;
function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ;
function approve ( address spender , uint tokens ) public returns ( bool success ) { require ( spender ! = address ( 0 ) , " spender address is a zero address " ) ; allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ;
function transfer From ( address from , address to , uint tokens ) public returns ( bool success ) { require ( to ! = address ( 0 ) , " to address is a zero address " ) ; balances [ from ] ! = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit Transfer ( from , to , tokens ) ; return true ;
function allowance ( address token Owner , address spender ) public view returns ( uint remaining ) { return allowed [ token Owner ] [ spender ] ;
function is Constructor ( ) private view returns ( bool ) { address self = address ( this ) ; uint256 cs ; assembly { cs : = extcodesize ( self ) } return cs = = 0 ;
function Context init ( ) internal initializer { Context init unchained ( ) ;
function get Mushroom Data ( uint256 token Id ) public view returns ( Mushroom Lib . Mushroom Data memory ) { Mushroom Lib . Mushroom Data memory data = mushroom Data [ token Id ] ; return data ;
function token URI ( uint256 token Id ) public view override returns ( string memory ) { Mushroom Lib . Mushroom Data storage data = mushroom Data [ token Id ] ; return mushroom Metadata Uri [ data . species ] ;
function mint ( address recipient , uint256 token Id , uint256 species Id , uint256 lifespan ) public only Minter { mint With Metadata ( recipient , token Id , species Id , lifespan ) ;
function set Mushroom Lifespan ( uint256 index , uint256 lifespan ) public only Lifespan Modifier { Mushroom Lib . Mushroom Data storage data = mushroom Data [ index ] ; data . lifespan = lifespan ;
function clear Mushroom Data ( uint256 token Id ) internal { Mushroom Lib . Mushroom Data storage data = mushroom Data [ token Id ] ; Mushroom Lib . Mushroom Type storage species = mushroom Types [ data . species ] ; species . minted = species . minted . sub ( 1 ) ;
function grow Mushrooms ( address recipient , uint256 num Mushrooms ) public only Owner { Mushroom Lib . Mushroom Type memory species = mushroom Nft . get Species ( my Species ) ; require ( get Remaining Mintable For My Species ( ) > = num Mushrooms , " Mushroom Factory : Mushrooms to grow exceeds species cap " ) ; for ( uint256 i = 0 ; i < num Mushrooms ; i + + ) { uint256 next Id = mushroom Nft . total Supply ( ) . add ( 1 ) ; uint256 lifespan = generate Mushroom Lifespan ( species . min Lifespan , species . max Lifespan ) ; mushroom Nft . mint ( recipient , next Id , my Species , lifespan ) ; emit Mushroom Grown ( recipient , next Id , my Species , lifespan ) ; }
function deposit ( uint256 amount ) public { uint256 avail Funds = controller . allowable Amount ( address ( this ) ) ; require ( amount < = avail Funds , " exceed cont Allowance " ) ; controller . earn ( address ( this ) , amount ) ; uint256 bpt Token Amt = musdc Bpt . joinswap Extern Amount In ( address ( want ) , amount , 0 ) ; m Pool . stake ( bpt Token Amt ) ; deposit MTA In Staking ( ) ;
function multi Transfer ( address [ ] memory receivers , uint256 [ ] memory amounts ) public { for ( uint256 i = 0 ; i < receivers . length ; i + + ) { transfer ( receivers [ i ] , amounts [ i ] ) ; }
function mint ( address to , uint256 amount ) public only Owner { mint ( to , amount ) ;
function msg Sender ( ) internal view returns ( address payable ) { return msg . sender ;
