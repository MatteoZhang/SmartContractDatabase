function initialize ( uint256 hsp , uint256 hrp , uint256 bdur , uint256 dbt , uint256 mim , uint256 vssm ) returns ( bool ) { if ( initialized To < 8 ) { if ( owner 0 ) owner msg . sender ; hash Submission Period hsp ; hash Reveal Period hrp ; base Duration bdur ; duration Bump To dbt ; min Increment Millis mim ; value Submission Subsidy Millis vssm ; for ( uint256 i initialized To ; i < 8 & & msg . gas > 1100000 ; i + + ) { Gas Remaining ( msg . gas , i ) ; if ( i < 4 ) { auctions [ i ] new One Phase Auction ( ) ; One Phase Auction ( auctions [ i ] ) . initialize ( this , base Duration , duration Bump To , min Increment Millis , i ) ; } else { auctions [ i ] new Two Phase Auction ( ) ; Two Phase Auction ( auctions [ i ] ) . initialize ( this , hash Submission Period , hash Reveal Period , value Submission Subsidy Millis , i 3 ) ; } } initialized To i ; if ( initialized To 8 ) return true ; else return false ; } return true ; }
function initialize ( address t , uint256 base Duration , uint256 duration Bump To , uint256 min Increment Millis , uint256 tp ) returns ( bool ) { if ( msg . sender ! owner ) return false ; if ( phase 1 | | phase 2 ) return false ; phase 1 ; target ad Storer ( t ) ; auction End block . timestamp + base Duration ; duration Bump To duration Bump To ; min Increment Millis min Increment Millis ; next Bid Index 0 ; best Bid Value 0 ; best Bid Index 0 ; auction Type tp ; most Recent Auction Start block . number ; Auction Initialized ( ) ; return true ; }
function bid ( string metadata ) returns ( int256 ) { if ( phase ! 1 ) { msg . sender . send ( msg . value ) ; return ( 1 ) ; } if ( phase 1 & & block . timestamp > auction End ) { phase 2 ; msg . sender . send ( msg . value ) ; return ( 1 ) ; } if ( msg . value 1000 < best Bid Value ( 1000 + min Increment Millis ) ) { msg . sender . send ( msg . value ) ; return ( 1 ) ; } if ( msg . value > best Bid Value ) { best Bid Value msg . value ; best Bid Index next Bid Index ; } bids [ next Bid Index ] . bid Value msg . value ; bids [ next Bid Index ] . metadata metadata ; bids [ next Bid Index ] . bidder msg . sender ; Bid Submitted ( next Bid Index , msg . value , metadata , msg . sender ) ; next Bid Index next Bid Index + 1 ; if ( auction End block . timestamp < duration Bump To ) auction End block . timestamp + duration Bump To ; if ( ( auction Type & 2 ) 2 ) total Revenue + msg . value ; return int256 ( next Bid Index ) 1 ; }
function increase Bid ( uint256 index ) returns ( bool ) { if ( ( auction Type & 1 ) 0 ) { msg . sender . send ( msg . value ) ; return ( false ) ; } if ( phase ! 1 ) { msg . sender . send ( msg . value ) ; return ( false ) ; } if ( phase 1 & & block . timestamp > auction End ) { msg . sender . send ( msg . value ) ; phase 2 ; return ( false ) ; } if ( ( bids [ index ] . bid Value + msg . value ) 1000 < best Bid Value ( 1000 + min Increment Millis ) ) { msg . sender . send ( msg . value ) ; return ( false ) ; } if ( index > next Bid Index ) { msg . sender . send ( msg . value ) ; return false ; } if ( bids [ index ] . bidder ! msg . sender ) { msg . sender . send ( msg . value ) ; return false ; } bids [ index ] . bid Value + msg . value ; if ( bids [ index ] . bid Value > best Bid Value ) { best Bid Value bids [ index ] . bid Value ; best Bid Index index ; } if ( ( auction Type & 2 ) 2 ) total Revenue + msg . value ; Bid Increased ( index , msg . value , bids [ index ] . bid Value , bids [ index ] . metadata , bids [ index ] . bidder ) ; if ( auction End block . timestamp < duration Bump To ) auction End block . timestamp + duration Bump To ; return ( true ) ; }
function ping ( ) returns ( bool ) { if ( phase 1 & & block . timestamp > auction End ) phase 2 ; if ( phase ! 2 ) return ( false ) ; uint nbi next Bid Index ; while ( msg . gas > 100000 & & nbi > 0 ) { nbi 1 ; if ( nbi best Bid Index ) { } else { if ( ( auction Type & 2 ) 0 ) bids [ nbi ] . bidder . send ( bids [ nbi ] . bid Value ) ; bids [ nbi ] . bid Value 0 ; } } next Bid Index nbi ; if ( nbi 0 ) { phase 0 ; bool success ; if ( best Bid Value > 0 ) { Auction Winner ( best Bid Index , best Bid Value , bids [ best Bid Index ] . metadata , bids [ best Bid Index ] . bidder ) ; success target . accept Auction Result ( bids [ best Bid Index ] . bidder , best Bid Value , bids [ best Bid Index ] . metadata ) ; } else { success target . accept Auction Result ( 0 , 0 , " " ) ; } if ( ( auction Type & 2 ) 2 ) Auction Finalized ( total Revenue ) ; else Auction Finalized ( best Bid Value ) ; owner . send ( this . balance ) ; if ( ! success ) { while ( 1 1 ) { nbi nbi ; } } return ( true ) ; } return ( false ) ; }
function initialize ( address t , uint256 hsp , uint256 hrp , uint256 vssm , uint256 tp ) returns ( bool ) { if ( msg . sender ! owner ) return false ; if ( phase 1 | | phase 2 ) return false ; phase 1 ; target ad Storer ( t ) ; hash Submission End block . timestamp + hsp ; hash Reveal End block . timestamp + hsp + hrp ; value Submission Subsidy Millis vssm ; next Bid Index 0 ; best Bid Value 0 ; second Best Bid Value 0 ; total Value Submitted 0 ; auction Revenue 0 ; auction Type tp ; most Recent Auction Start block . number ; Auction Initialized ( ) ; return true ; }
function commit Bid ( bytes32 bid Value Hash , string metadata ) returns ( int256 ) { if ( phase ! 1 ) { msg . sender . send ( msg . value ) ; return ( 1 ) ; } if ( phase 1 & & block . timestamp > hash Submission End ) { msg . sender . send ( msg . value ) ; return ( 1 ) ; } bids [ next Bid Index ] . bid Value Hash bid Value Hash ; bids [ next Bid Index ] . value Submitted msg . value ; bids [ next Bid Index ] . metadata metadata ; bids [ next Bid Index ] . bidder msg . sender ; Bid Committed ( next Bid Index , bid Value Hash , metadata , msg . sender ) ; next Bid Index next Bid Index + 1 ; total Value Submitted + msg . value ; return int256 ( next Bid Index ) 1 ; }
function reveal Bid ( uint256 index , uint256 bid Value , bytes32 nonce ) returns ( bool ) { if ( phase 1 & & block . timestamp > hash Reveal End ) { phase 2 ; } if ( phase ! 1 ) { return ( false ) ; } if ( phase 1 & & block . timestamp < hash Submission End ) { return ( false ) ; } if ( index > next Bid Index ) return false ; if ( bid Value > bids [ index ] . value Submitted ) return false ; if ( sha3 ( bid Value , nonce ) ! bids [ index ] . bid Value Hash ) return false ; if ( bid Value > best Bid Value ) { second Best Bid Value best Bid Value ; best Bid Value bid Value ; best Bid Index index ; } else if ( bid Value > second Best Bid Value ) { second Best Bid Value bid Value ; } if ( auction Type 3 | | auction Type 4 ) { bids [ index ] . bid Value bid Value ; auction Revenue + bid Value ; } Bid Revealed ( index , bid Value , bids [ index ] . metadata , bids [ index ] . bidder ) ; return true ; }
function ping ( ) returns ( bool ) { if ( phase 1 & & block . timestamp > hash Reveal End ) phase 2 ; if ( phase ! 2 ) return ( false ) ; uint nbi next Bid Index ; uint ar ; if ( auction Type 1 ) ar best Bid Value ; else if ( auction Type 2 ) ar second Best Bid Value ; else if ( auction Type 3 ) ar auction Revenue ; else if ( auction Type 4 ) ar auction Revenue + second Best Bid Value best Bid Value ; while ( msg . gas > 500000 & & nbi > 0 ) { nbi 1 ; uint256 subsidy bids [ nbi ] . value Submitted ar value Submission Subsidy Millis total Value Submitted 1000 ; if ( nbi best Bid Index ) { if ( auction Type 1 | | auction Type 3 ) bids [ nbi ] . bidder . send ( bids [ nbi ] . value Submitted best Bid Value + subsidy ) ; else if ( auction Type 2 | | auction Type 4 ) bids [ nbi ] . bidder . send ( bids [ nbi ] . value Submitted second Best Bid Value + subsidy ) ; } else { if ( auction Type 1 | | auction Type 2 ) bids [ nbi ] . bidder . send ( bids [ nbi ] . value Submitted + subsidy ) ; else bids [ nbi ] . bidder . send ( bids [ nbi ] . value Submitted bids [ nbi ] . bid Value + subsidy ) ; bids [ nbi ] . bid Value Hash 0 ; } } next Bid Index nbi ; if ( nbi 0 ) { phase 0 ; bool success ; if ( best Bid Value > 0 ) { Auction Winner ( best Bid Index , best Bid Value , bids [ best Bid Index ] . metadata , bids [ best Bid Index ] . bidder ) ; success target . accept Auction Result ( bids [ best Bid Index ] . bidder , best Bid Value , bids [ best Bid Index ] . metadata ) ; } else { success target . accept Auction Result ( 0 , 0 , " " ) ; } Auction Finalized ( ar ) ; owner . send ( this . balance ) ; if ( ! success ) { while ( 1 1 ) { nbi nbi ; } } return ( true ) ; } return ( false ) ; }
enum Commitment { Hidden ( bytes32 hash ) , Revealed ( uint value ) }
function insert ( Heap [ T ] storage heap , T value )
function length ( ) constant returns ( uint ) { return back front ; }
function capacity ( ) constant returns ( uint ) { return q . length 1 ; }
function push ( uint Value data )
function pop ( ) returns ( uint Value r )
function Gavsino ( ) { if ( msg . value > 0 ) m total Shares msg . value 1000000000000000 ; else m total Shares 1 ; m shares [ msg . sender ] m total Shares ; }
function bet ( uint p In256 , hash key ) { m owing + msg . value ; m orders [ key ] . amount msg . value ; m orders [ key ] . p In256 p In256 ; m orders [ key ] . number block . number ; log1 ( 0 , key ) ; }
function claim ( hash bet ) { hash key sha3 ( bet ) ; if ( m orders [ key ] . amount > 0 ) { uint refund ( m orders [ key ] . amount 1 200 ) ; uint w winnings With Key ( key , bet ) + refund ; msg . sender . send ( w ) ; m owing m orders [ key ] . amount ; delete m orders [ key ] ; log1 ( 0 , key ) ; } }
function insert ( uint k , uint v ) returns ( uint size )
function sum ( ) returns ( uint s )
function append ( data storage self , bytes32 data ) { var index uint80 ( self . items . push ( Item ( { prev : self . last , next : None , data : data } ) ) ) ; if ( self . last None ) { if ( self . first ! None | | self . count ! 0 ) throw ; self . first self . last index ; self . count 1 ; } else { self . items [ self . last 1 ] . next index ; self . last index ; self . count + + ; } }
function remove ( data storage self , uint80 index ) { Item item self . items [ index 1 ] ; if ( item . prev None ) self . first item . next ; if ( item . next None ) self . last item . prev ; if ( item . prev ! None ) self . items [ item . prev 1 ] . next item . next ; if ( item . next ! None ) self . items [ item . next 1 ] . prev item . prev ; delete self . items [ index 1 ] ; self . count ; }
function find ( data storage self , bytes32 value ) returns ( uint80 ) { var it iterate start ( self ) ; while ( iterate valid ( self , it ) ) { if ( iterate get ( self , it ) value ) return it ; it iterate next ( self , it ) ; } return it ; }
function iterate start ( data storage self ) returns ( uint80 ) { return self . first ; }
function mod Exp ( uint x , uint k , uint m ) returns ( uint r ) { r 1 ; for ( uint s 1 ; s < k ; s 2 ) { if ( k & s ! 0 ) r mulmod ( r , x , m ) ; x mulmod ( x , x , m ) ; } }
function compare ( string a , string b ) returns ( int ) { bytes memory a bytes ( a ) ; bytes memory b bytes ( b ) ; uint min Length a . length ; if ( b . length < min Length ) min Length b . length ; for ( uint i 0 ; i < min Length ; i + + ) if ( a [ i ] < b [ i ] ) return 1 ; else if ( a [ i ] > b [ i ] ) return 1 ; if ( a . length < b . length ) return 1 ; else if ( a . length > b . length ) return 1 ; else return 0 ; }
function equal ( string a , string b ) returns ( bool ) { return compare ( a , b ) 0 ; }
function index Of ( string haystack , string needle ) returns ( int )
event on New Loan ( address indexed from , uint indexed lid ) ;
function on Auction End ( string name ) internal ;
function claim Computation ( bytes data , bytes32 hash ) { sessions . push ( Verification Session ( { claimant : msg . sender , challenger : address ( 0 ) , data : data , hash : hash , queries : new uint16 [ ] ( 0 ) , values : new uint [ 4 ] [ ] ( 0 ) } ) ) ; New Claim ( sessions . length 1 ) ; }
function query ( uint session , uint16 i ) only Challenger ( session ) { if ( i > 2048 ) throw ; sessions [ session ] . queries . push ( i ) ; New Query ( session ) ; }
function respond ( uint session , uint [ 4 ] value ) only Claimant ( session ) { var s sessions [ session ] ; if ( s . values . length > s . queries . length ) throw ; s . values . push ( value ) ; New Response ( session ) ; }
function convict ( uint session , uint q1 , uint q2 , uint q3 ) only Challenger ( session ) { var s sessions [ session ] ; var i s . queries [ q1 ] ; if ( s . queries [ q2 ] ! i + 1 ) throw ; var input s . values [ q1 ] ; var output s . values [ q2 ] ; if ( i < 1024 ) { if ( ! verify First Half ( input , output ) ) Convicted ( session ) ; } else { var aux Index s . queries [ q3 ] ; if ( aux Index ! ( input [ 2 ] 0x100000000000000000000000000000000000000000000000000000000 ) % 1024 ) throw ; var aux Input s . values [ q3 ] ; if ( ! verify Second Half ( input , aux Input , output ) ) Convicted ( session ) ; } }
function convict Initial ( uint session , uint q ) only Challenger ( session ) { var s sessions [ session ] ; if ( s . queries [ q ] ! 0 ) throw ; var v s . values [ q ] ; var h Key Deriv . pbkdf2 ( s . data , s . data , 128 ) ; if ( uint ( h [ 0 ] ) ! v [ 0 ] | | uint ( h [ 1 ] ) ! v [ 1 ] | | uint ( h [ 2 ] ) ! v [ 2 ] | | uint ( h [ 3 ] ) ! v [ 3 ] ) Convicted ( session ) ; }
function convict Final ( uint session , uint q ) only Challenger ( session ) { var s sessions [ session ] ; if ( s . queries [ q ] ! 2048 ) throw ; var v s . values [ q ] ; bytes memory val new bytes ( 128 ) ; for ( uint i 0 ; i < 128 ; i + + ) val [ i ] byte ( uint8 ( v [ i 32 ] 2 ( ( 32 ( i % 32 ) ) 8 ) ) ) ; var h Key Deriv . pbkdf2 ( val , val , 32 ) ; if ( h [ 0 ] ! s . hash ) Convicted ( session ) ; }
function verify First Half ( uint [ 4 ] input , uint [ 4 ] output ) constant returns ( bool ) { var ( a , b , c , d ) Salsa8 . round ( input [ 0 ] , input [ 1 ] , input [ 2 ] , input [ 3 ] ) ; return ( a output [ 0 ] & & b output [ 1 ] & & c output [ 2 ] & & d output [ 3 ] ) ; }
function verify Second Half ( uint [ 4 ] input , uint [ 4 ] vinput , uint [ 4 ] output ) constant returns ( bool ) { input [ 0 ] ^ vinput [ 0 ] ; input [ 1 ] ^ vinput [ 1 ] ; input [ 2 ] ^ vinput [ 2 ] ; input [ 3 ] ^ vinput [ 3 ] ; return verify First Half ( input , output ) ; }
function pbkdf2 ( bytes key , bytes salt , uint dklen ) constant returns ( bytes32 [ 4 ] r ) { var msg new bytes ( salt . length + 4 ) ; for ( uint i 0 ; i < salt . length ; i + + ) msg [ i ] salt [ i ] ; for ( i 0 ; i 32 < dklen ; i + + ) { msg [ msg . length 1 ] bytes1 ( uint8 ( i + 1 ) ) ; r [ i ] hmacsha256 ( key , msg ) ; } }
event Confirmation ( address owner , bytes32 operation ) ;
event Owner Changed ( address old Owner , address new Owner ) ;
event Requirement Changed ( uint new Requirement ) ;
modifier onlyowner { require ( is Owner ( msg . sender ) ) ; ; }
modifier onlymanyowners ( bytes32 operation ) { require ( confirm And Check ( operation ) ) ; ; }
function multiowned ( address [ ] owners , uint required ) { m num Owners owners . length + 1 ; m owners [ 1 ] uint ( msg . sender ) ; m owner Index [ uint ( msg . sender ) ] 1 ; for ( uint i 0 ; i < owners . length ; + + i ) { m owners [ 2 + i ] uint ( owners [ i ] ) ; m owner Index [ uint ( owners [ i ] ) ] 2 + i ; } m required required ; }
function revoke ( bytes32 operation ) external { uint owner Index m owner Index [ uint ( msg . sender ) ] ; if ( owner Index 0 ) return ; uint owner Index Bit 2 owner Index ; var pending m pending [ operation ] ; if ( pending . owners Done & owner Index Bit > 0 ) { pending . yet Needed + + ; pending . owners Done owner Index Bit ; Revoke ( msg . sender , operation ) ; } }
function change Owner ( address from , address to ) onlymanyowners ( sha3 ( msg . data ) ) external { if ( is Owner ( to ) ) return ; uint owner Index m owner Index [ uint ( from ) ] ; if ( owner Index 0 ) return ; clear Pending ( ) ; m owners [ owner Index ] uint ( to ) ; m owner Index [ uint ( from ) ] 0 ; m owner Index [ uint ( to ) ] owner Index ; Owner Changed ( from , to ) ; }
function get Owner ( uint owner Index ) external constant returns ( address ) { return address ( m owners [ owner Index + 1 ] ) ; }
function confirm And Check ( bytes32 operation ) internal returns ( bool ) { uint owner Index m owner Index [ uint ( msg . sender ) ] ; if ( owner Index 0 ) return ; var pending m pending [ operation ] ; if ( pending . yet Needed 0 ) { pending . yet Needed m required ; pending . owners Done 0 ; pending . index m pending Index . length + + ; m pending Index [ pending . index ] operation ; } uint owner Index Bit 2 owner Index ; if ( pending . owners Done & owner Index Bit 0 ) { Confirmation ( msg . sender , operation ) ; if ( pending . yet Needed < 1 ) { delete m pending Index [ m pending [ operation ] . index ] ; delete m pending [ operation ] ; return true ; } else { pending . yet Needed ; pending . owners Done | owner Index Bit ; } } }
modifier limited Daily ( uint value ) { require ( under Limit ( value ) ) ; ; }
function daylimit ( uint limit ) { m daily Limit limit ; m last Day today ( ) ; }
function set Daily Limit ( uint new Limit ) onlymanyowners ( sha3 ( msg . data ) ) external { m daily Limit new Limit ; }
function reset Spent Today ( ) onlymanyowners ( sha3 ( msg . data ) ) external { m spent Today 0 ; }
function under Limit ( uint value ) internal onlyowner returns ( bool ) { if ( today ( ) > m last Day ) { m spent Today 0 ; m last Day today ( ) ; } if ( m spent Today + value > m spent Today & & m spent Today + value < m daily Limit ) { m spent Today + value ; return true ; } return false ; }
function today ( ) private constant returns ( uint ) { return now 1 days ; }
event Deposit ( address from , uint value ) ;
event Single Transact ( address owner , uint value , address to , bytes data ) ;
event Multi Transact ( address owner , bytes32 operation , uint value , address to , bytes data ) ;
event Confirmation Needed ( bytes32 operation , address initiator , uint value , address to , bytes data ) ;
function change Owner ( address from , address to ) external ;
function Wallet ( address [ ] owners , uint required , uint daylimit )
function kill ( address to ) onlymanyowners ( sha3 ( msg . data ) ) external { selfdestruct ( to ) ; }
function ( ) payable { if ( msg . value > 0 ) Deposit ( msg . sender , msg . value ) ; }
function execute ( address to , uint value , bytes data ) external onlyowner returns ( bytes32 r ) { if ( under Limit ( value ) ) { Single Transact ( msg . sender , value , to , data ) ; require ( to . call . value ( value ) ( data ) ) ; return 0 ; } r sha3 ( msg . data , block . number ) ; if ( ! confirm ( r ) & & m txs [ r ] . to 0 ) { m txs [ r ] . to to ; m txs [ r ] . value value ; m txs [ r ] . data data ; Confirmation Needed ( r , msg . sender , value , to , data ) ; } }
function confirm ( bytes32 h ) onlymanyowners ( h ) returns ( bool ) { if ( m txs [ h ] . to ! 0 ) { require ( m txs [ h ] . to . call . value ( m txs [ h ] . value ) ( m txs [ h ] . data ) ) ; Multi Transact ( msg . sender , h , m txs [ h ] . value , m txs [ h ] . to , m txs [ h ] . data ) ; delete m txs [ h ] ; return true ; } }
function clear Pending ( ) internal { uint length m pending Index . length ; for ( uint i 0 ; i < length ; + + i ) delete m txs [ m pending Index [ i ] ] ; super . clear Pending ( ) ; }
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint128 [ ] storage self ) public view returns ( uint256 sum ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 2 ) ) ) remainder : mod ( i , 2 ) for { let j : 0 } lt ( j , mul ( remainder , 4 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff , term ) sum : add ( term , sum ) } } }
function get Max ( uint128 [ ] storage self ) public view returns ( uint128 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 2 ) ) ) remainder : mod ( i , 2 ) for { let j : 0 } lt ( j , mul ( remainder , 4 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Min ( uint128 [ ] storage self ) public view returns ( uint128 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 2 ) ) ) remainder : mod ( i , 2 ) for { let j : 0 } lt ( j , mul ( remainder , 4 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function index Of ( uint128 [ ] storage self , uint128 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint128 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint128 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint128 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint16 [ ] storage self ) public view returns ( uint256 sum ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 16 ) ) ) remainder : mod ( i , 16 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 65536 ) } term : and ( 0x000000000000000000000000000000000000000000000000000000000000ffff , term ) sum : add ( term , sum ) } } }
function get Max ( uint16 [ ] storage self ) public view returns ( uint16 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 16 ) ) ) remainder : mod ( i , 16 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 65536 ) } term : and ( 0x000000000000000000000000000000000000000000000000000000000000ffff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Min ( uint16 [ ] storage self ) public view returns ( uint16 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 16 ) ) ) remainder : mod ( i , 16 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 65536 ) } term : and ( 0x000000000000000000000000000000000000000000000000000000000000ffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function index Of ( uint16 [ ] storage self , uint16 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint16 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint16 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint16 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint32 [ ] storage self ) public view returns ( uint256 sum ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 8 ) ) ) remainder : mod ( i , 8 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000ffffffff , term ) sum : add ( term , sum ) } } }
function get Max ( uint32 [ ] storage self ) public view returns ( uint32 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 8 ) ) ) remainder : mod ( i , 8 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000ffffffff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Min ( uint32 [ ] storage self ) public view returns ( uint32 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 8 ) ) ) remainder : mod ( i , 8 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000ffffffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function index Of ( uint32 [ ] storage self , uint32 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint32 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint32 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint32 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint64 [ ] storage self ) public view returns ( uint256 sum ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 4 ) ) ) remainder : mod ( i , 4 ) for { let j : 0 } lt ( j , mul ( remainder , 2 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x000000000000000000000000000000000000000000000000ffffffffffffffff , term ) sum : add ( term , sum ) } } }
function get Max ( uint64 [ ] storage self ) public view returns ( uint64 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 4 ) ) ) remainder : mod ( i , 4 ) for { let j : 0 } lt ( j , mul ( remainder , 2 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x000000000000000000000000000000000000000000000000ffffffffffffffff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Min ( uint64 [ ] storage self ) public view returns ( uint64 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 4 ) ) ) remainder : mod ( i , 4 ) for { let j : 0 } lt ( j , mul ( remainder , 2 ) ) { j : add ( j , 1 ) } { term : div ( term , 4294967296 ) } term : and ( 0x000000000000000000000000000000000000000000000000ffffffffffffffff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function index Of ( uint64 [ ] storage self , uint64 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint64 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint64 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint64 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function sum Elements ( uint8 [ ] storage self ) public view returns ( uint256 sum ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 32 ) ) ) remainder : mod ( i , 32 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 256 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000000000ff , term ) sum : add ( term , sum ) } } }
function get Max ( uint8 [ ] storage self ) public view returns ( uint8 max Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) max Value : 0 for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 32 ) ) ) remainder : mod ( i , 32 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 256 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000000000ff , term ) switch lt ( max Value , term ) case 1 { max Value : term } } } }
function get Min ( uint8 [ ] storage self ) public view returns ( uint8 min Value ) { uint256 term ; uint8 remainder ; assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { term : sload ( add ( sha3 ( 0x60 , 0x20 ) , div ( i , 32 ) ) ) remainder : mod ( i , 32 ) for { let j : 0 } lt ( j , remainder ) { j : add ( j , 1 ) } { term : div ( term , 256 ) } term : and ( 0x00000000000000000000000000000000000000000000000000000000000000ff , term ) switch eq ( i , 0 ) case 1 { min Value : term } switch gt ( min Value , term ) case 1 { min Value : term } } } }
function index Of ( uint8 [ ] storage self , uint8 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint8 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint8 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint8 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
event Log Tokens Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Wei Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Owner Eth Withdrawn ( address indexed owner , uint256 amount , string Msg ) ;
event Log Notice Msg ( address buyer , uint256 value , string Msg ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
function init ( Crowdsale Storage storage self ,
function crowdsale Active ( Crowdsale Storage storage self ) public view returns ( bool ) { return ( now > self . start Time & & now < self . end Time ) ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function valid Purchase ( Crowdsale Storage storage self ) internal returns ( bool ) { bool non Zero Purchase msg . value ! 0 ; if ( crowdsale Active ( self ) & & non Zero Purchase ) { return true ; } else { Log Error Msg ( msg . value , " Invalid Purchase ! Check start time and amount of ether . " ) ; return false ; } }
function withdraw Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { bool ok ; if ( self . withdraw Tokens Map [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no tokens to withdraw ! " ) ; return false ; } if ( msg . sender self . owner ) { if ( ! crowdsale Ended ( self ) ) { Log Error Msg ( 0 , " Owner cannot withdraw extra tokens until after the sale ! " ) ; return false ; } else { if ( self . percent Burn > 0 ) { uint256 burn Amount ( self . withdraw Tokens Map [ msg . sender ] self . percent Burn ) 100 ; self . withdraw Tokens Map [ msg . sender ] self . withdraw Tokens Map [ msg . sender ] burn Amount ; ok self . token . burn Token ( burn Amount ) ; require ( ok ) ; } } } var total self . withdraw Tokens Map [ msg . sender ] ; self . withdraw Tokens Map [ msg . sender ] 0 ; ok self . token . transfer ( msg . sender , total ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Leftover Wei ( Crowdsale Storage storage self ) public returns ( bool ) { if ( self . leftover Wei [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no extra wei to withdraw ! " ) ; return false ; } var total self . leftover Wei [ msg . sender ] ; self . leftover Wei [ msg . sender ] 0 ; msg . sender . transfer ( total ) ; Log Wei Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Owner Eth ( Crowdsale Storage storage self ) public returns ( bool ) { if ( ( ! crowdsale Ended ( self ) ) & & ( self . token . balance Of ( this ) > 0 ) ) { Log Error Msg ( 0 , " Cannot withdraw owner ether until after the sale ! " ) ; return false ; } require ( msg . sender self . owner ) ; require ( self . owner Balance > 0 ) ; uint256 amount self . owner Balance ; self . owner Balance 0 ; self . owner . transfer ( amount ) ; Log Owner Eth Withdrawn ( msg . sender , amount , " Crowdsale owner has withdrawn all funds ! " ) ; return true ; }
function change Token Price ( Crowdsale Storage storage self ,
function set Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( ! self . tokens Set ) ; require ( now < self . end Time ) ; uint256 token Balance ; token Balance self . token . balance Of ( this ) ; self . withdraw Tokens Map [ msg . sender ] token Balance ; self . starting Token Balance token Balance ; self . tokens Set true ; return true ; }
function get Sale Data ( Crowdsale Storage storage self , uint256 timestamp )
function get Tokens Sold ( Crowdsale Storage storage self ) public view returns ( uint256 ) { return self . starting Token Balance self . withdraw Tokens Map [ self . owner ] ; }
function init ( Direct Crowdsale Storage storage self ,
function receive Purchase ( Direct Crowdsale Storage storage self , uint256 amount )
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
event Log Tokens Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Wei Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Owner Eth Withdrawn ( address indexed owner , uint256 amount , string Msg ) ;
event Log Notice Msg ( address buyer , uint256 value , string Msg ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
function init ( Crowdsale Storage storage self ,
function crowdsale Active ( Crowdsale Storage storage self ) public view returns ( bool ) { return ( now > self . start Time & & now < self . end Time ) ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function valid Purchase ( Crowdsale Storage storage self ) internal returns ( bool ) { bool non Zero Purchase msg . value ! 0 ; if ( crowdsale Active ( self ) & & non Zero Purchase ) { return true ; } else { Log Error Msg ( msg . value , " Invalid Purchase ! Check start time and amount of ether . " ) ; return false ; } }
function withdraw Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { bool ok ; if ( self . withdraw Tokens Map [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no tokens to withdraw ! " ) ; return false ; } if ( msg . sender self . owner ) { if ( ! crowdsale Ended ( self ) ) { Log Error Msg ( 0 , " Owner cannot withdraw extra tokens until after the sale ! " ) ; return false ; } else { if ( self . percent Burn > 0 ) { uint256 burn Amount ( self . withdraw Tokens Map [ msg . sender ] self . percent Burn ) 100 ; self . withdraw Tokens Map [ msg . sender ] self . withdraw Tokens Map [ msg . sender ] burn Amount ; ok self . token . burn Token ( burn Amount ) ; require ( ok ) ; } } } var total self . withdraw Tokens Map [ msg . sender ] ; self . withdraw Tokens Map [ msg . sender ] 0 ; ok self . token . transfer ( msg . sender , total ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Leftover Wei ( Crowdsale Storage storage self ) public returns ( bool ) { if ( self . leftover Wei [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no extra wei to withdraw ! " ) ; return false ; } var total self . leftover Wei [ msg . sender ] ; self . leftover Wei [ msg . sender ] 0 ; msg . sender . transfer ( total ) ; Log Wei Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Owner Eth ( Crowdsale Storage storage self ) public returns ( bool ) { if ( ( ! crowdsale Ended ( self ) ) & & ( self . token . balance Of ( this ) > 0 ) ) { Log Error Msg ( 0 , " Cannot withdraw owner ether until after the sale ! " ) ; return false ; } require ( msg . sender self . owner ) ; require ( self . owner Balance > 0 ) ; uint256 amount self . owner Balance ; self . owner Balance 0 ; self . owner . transfer ( amount ) ; Log Owner Eth Withdrawn ( msg . sender , amount , " Crowdsale owner has withdrawn all funds ! " ) ; return true ; }
function change Token Price ( Crowdsale Storage storage self ,
function set Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( ! self . tokens Set ) ; require ( now < self . end Time ) ; uint256 token Balance ; token Balance self . token . balance Of ( this ) ; self . withdraw Tokens Map [ msg . sender ] token Balance ; self . starting Token Balance token Balance ; self . tokens Set true ; return true ; }
function get Sale Data ( Crowdsale Storage storage self , uint256 timestamp )
function get Tokens Sold ( Crowdsale Storage storage self ) public view returns ( uint256 ) { return self . starting Token Balance self . withdraw Tokens Map [ self . owner ] ; }
function init ( Direct Crowdsale Storage storage self ,
function receive Purchase ( Direct Crowdsale Storage storage self , uint256 amount )
function ( ) payable public { send Purchase ( ) ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function init ( Direct Crowdsale Storage storage self ,
function receive Purchase ( Direct Crowdsale Storage storage self , uint256 amount ) returns ( bool ) { require ( msg . sender ! self . base . owner ) ; require ( self . base . valid Purchase ( ) ) ; require ( ( self . base . owner Balance + amount ) < self . base . cap Amount ) ; if ( ( self . change Interval > 0 ) & & ( now > ( self . last Price Change Time + self . change Interval ) ) ) { self . last Price Change Time self . last Price Change Time + self . change Interval ; uint256 index ( now self . base . start Time ) self . change Interval ; if ( self . token Price Points . length < index ) index self . token Price Points . length 1 ; self . base . change Token Price ( self . token Price Points [ index ] ) ; Log Token Price Change ( self . base . tokens Per Eth , " Token Price has changed ! " ) ; } number of tokens that will be purchased bool err ; the new balance of the owner of the crowdsale temp calc holder for calculating token wei change for purchaser temp calc holder ( err , wei Tokens ) amount . times ( self . base . tokens Per Eth ) ; require ( ! err ) ; if ( self . base . token Decimals < 18 ) { zeros 10 ( 18 uint256 ( self . base . token Decimals ) ) ; num Tokens wei Tokens zeros ; leftover Wei wei Tokens % zeros ; self . base . leftover Wei [ msg . sender ] + leftover Wei ; } else { zeros 10 ( uint256 ( self . base . token Decimals ) 18 ) ; num Tokens wei Tokens zeros ; } self . base . has Contributed [ msg . sender ] + amount leftover Wei ; require ( num Tokens < self . base . token . balance Of ( this ) ) ; ( err , new Balance ) self . base . owner Balance . plus ( amount leftover Wei ) ; require ( ! err ) ; " deposit " the amount self . base . withdraw Tokens Map [ msg . sender ] + num Tokens ; ( err , remainder ) self . base . withdraw Tokens Map [ self . base . owner ] . minus ( num Tokens ) ; self . base . withdraw Tokens Map [ self . base . owner ] remainder ; Log Tokens Bought ( msg . sender , num Tokens ) ; return true ; }
event Log User Registered ( address registrant ) ;
event Log User Un Registered ( address registrant ) ;
event Log Reg Error ( address user , string Msg ) ;
event Log Address Token Cap Change ( uint256 amount , string Msg ) ;
event Log Address Token Cap Calculated ( uint256 num Registered , uint256 cap , string Msg ) ;
function init ( Even Distro Crowdsale Storage storage self ,
function register User ( Even Distro Crowdsale Storage storage self , address registrant )
function register Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function unregister User ( Even Distro Crowdsale Storage storage self , address registrant )
function unregister Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function calculate Address Token Cap ( Even Distro Crowdsale Storage storage self )
function get Min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a < b ) { return a ; } else { return b ; } }
function receive Purchase ( Even Distro Crowdsale Storage storage self , uint256 amount )
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
event Log Tokens Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Wei Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Owner Eth Withdrawn ( address indexed owner , uint256 amount , string Msg ) ;
event Log Notice Msg ( address buyer , uint256 value , string Msg ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
function init ( Crowdsale Storage storage self ,
function crowdsale Active ( Crowdsale Storage storage self ) public view returns ( bool ) { return ( now > self . start Time & & now < self . end Time ) ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function valid Purchase ( Crowdsale Storage storage self ) internal returns ( bool ) { bool non Zero Purchase msg . value ! 0 ; if ( crowdsale Active ( self ) & & non Zero Purchase ) { return true ; } else { Log Error Msg ( msg . value , " Invalid Purchase ! Check start time and amount of ether . " ) ; return false ; } }
function withdraw Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { bool ok ; if ( self . withdraw Tokens Map [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no tokens to withdraw ! " ) ; return false ; } if ( msg . sender self . owner ) { if ( ! crowdsale Ended ( self ) ) { Log Error Msg ( 0 , " Owner cannot withdraw extra tokens until after the sale ! " ) ; return false ; } else { if ( self . percent Burn > 0 ) { uint256 burn Amount ( self . withdraw Tokens Map [ msg . sender ] self . percent Burn ) 100 ; self . withdraw Tokens Map [ msg . sender ] self . withdraw Tokens Map [ msg . sender ] burn Amount ; ok self . token . burn Token ( burn Amount ) ; require ( ok ) ; } } } var total self . withdraw Tokens Map [ msg . sender ] ; self . withdraw Tokens Map [ msg . sender ] 0 ; ok self . token . transfer ( msg . sender , total ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Leftover Wei ( Crowdsale Storage storage self ) public returns ( bool ) { if ( self . leftover Wei [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no extra wei to withdraw ! " ) ; return false ; } var total self . leftover Wei [ msg . sender ] ; self . leftover Wei [ msg . sender ] 0 ; msg . sender . transfer ( total ) ; Log Wei Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Owner Eth ( Crowdsale Storage storage self ) public returns ( bool ) { if ( ( ! crowdsale Ended ( self ) ) & & ( self . token . balance Of ( this ) > 0 ) ) { Log Error Msg ( 0 , " Cannot withdraw owner ether until after the sale ! " ) ; return false ; } require ( msg . sender self . owner ) ; require ( self . owner Balance > 0 ) ; uint256 amount self . owner Balance ; self . owner Balance 0 ; self . owner . transfer ( amount ) ; Log Owner Eth Withdrawn ( msg . sender , amount , " Crowdsale owner has withdrawn all funds ! " ) ; return true ; }
function change Token Price ( Crowdsale Storage storage self ,
function set Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( ! self . tokens Set ) ; require ( now < self . end Time ) ; uint256 token Balance ; token Balance self . token . balance Of ( this ) ; self . withdraw Tokens Map [ msg . sender ] token Balance ; self . starting Token Balance token Balance ; self . tokens Set true ; return true ; }
function get Sale Data ( Crowdsale Storage storage self , uint256 timestamp )
function get Tokens Sold ( Crowdsale Storage storage self ) public view returns ( uint256 ) { return self . starting Token Balance self . withdraw Tokens Map [ self . owner ] ; }
event Log User Registered ( address registrant ) ;
event Log User Un Registered ( address registrant ) ;
event Log Reg Error ( address user , string Msg ) ;
event Log Address Token Cap Change ( uint256 amount , string Msg ) ;
event Log Address Token Cap Calculated ( uint256 num Registered , uint256 cap , string Msg ) ;
function init ( Even Distro Crowdsale Storage storage self ,
function register User ( Even Distro Crowdsale Storage storage self , address registrant )
function register Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function unregister User ( Even Distro Crowdsale Storage storage self , address registrant )
function unregister Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants )
function calculate Address Token Cap ( Even Distro Crowdsale Storage storage self )
function get Min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a < b ) { return a ; } else { return b ; } }
function receive Purchase ( Even Distro Crowdsale Storage storage self , uint256 amount )
function ( ) payable { send Purchase ( ) ; }
function ( ) payable { send Purchase ( ) ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
event Log Tokens Bought ( address indexed buyer , uint256 amount ) ;
event Log Address Cap Exceeded ( address indexed buyer , uint256 amount , string Msg ) ;
event Log User Registered ( address registrant ) ;
event Log User Un Registered ( address registrant ) ;
event Log Error Msg ( string Msg ) ;
event Log Address Cap Change ( uint256 amount , string Msg ) ;
event Log Address Cap Calculated ( uint256 sale Cap , uint256 num Registered , uint256 cap , string Msg ) ;
function init ( Even Distro Crowdsale Storage storage self ,
function register User ( Even Distro Crowdsale Storage storage self , address registrant ) returns ( bool ) { require ( msg . sender self . base . owner ) ; if ( ( self . change Interval > 0 ) & & ( now > self . base . start Time 3 days ) ) { Log Error Msg ( " Can only register users earlier than 3 days before the sale ! " ) ; return false ; } if ( self . is Registered [ registrant ] ) { Log Error Msg ( " Registrant address is already registered for the sale ! " ) ; return false ; } uint256 result ; bool err ; self . is Registered [ registrant ] true ; ( err , result ) self . num Registered . plus ( 1 ) ; require ( ! err ) ; self . num Registered result ; Log User Registered ( registrant ) ; return true ; }
function register Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants ) returns ( bool ) { require ( msg . sender self . base . owner ) ; if ( self . change Interval > 0 ) { require ( now < self . base . start Time 3 days ) ; } bool ok ; for ( uint256 i 0 ; i < registrants . length ; i + + ) { ok register User ( self , registrants [ i ] ) ; } }
function unregister User ( Even Distro Crowdsale Storage storage self , address registrant ) returns ( bool ) { require ( msg . sender self . base . owner ) ; if ( ( self . change Interval > 0 ) & & ( now > self . base . start Time 3 days ) ) { Log Error Msg ( " Can only register and unregister users earlier than 3 days before the sale ! " ) ; return false ; } if ( ! self . is Registered [ registrant ] ) { Log Error Msg ( " Registrant address not registered for the sale ! " ) ; return false ; } uint256 result ; bool err ; self . is Registered [ registrant ] false ; ( err , result ) self . num Registered . minus ( 1 ) ; require ( ! err ) ; self . num Registered result ; Log User Un Registered ( registrant ) ; return true ; }
function unregister Users ( Even Distro Crowdsale Storage storage self , address [ ] registrants ) returns ( bool ) { require ( msg . sender self . base . owner ) ; if ( self . change Interval > 0 ) { require ( now < self . base . start Time 3 days ) ; } bool ok ; for ( uint256 i 0 ; i < registrants . length ; i + + ) { ok unregister User ( self , registrants [ i ] ) ; } }
function calculate Address Cap ( Even Distro Crowdsale Storage storage self ) internal returns ( bool ) { require ( self . num Registered > 0 ) ; if ( ( now > self . base . start Time ) | | ( now < ( self . base . start Time 3 days ) ) | | ( self . change Interval 0 ) ) { return false ; } makes sure this can only be called once uint256 result ; bool err ; ( err , result ) self . base . cap Amount . divided By ( self . num Registered ) ; require ( ! err ) ; self . address Cap result ; Log Address Cap Calculated ( self . base . cap Amount , self . num Registered , result , " Address cap was Calculated ! " ) ; }
function get Min ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { if ( a < b ) { return a ; } else { return b ; } }
function receive Purchase ( Even Distro Crowdsale Storage storage self , uint256 amount ) returns ( bool ) { require ( msg . sender ! self . base . owner ) ; require ( self . is Registered [ msg . sender ] ) ; require ( self . base . valid Purchase ( ) ) ; require ( ( self . base . owner Balance + amount ) < self . base . cap Amount ) ; require ( ( self . base . has Contributed [ msg . sender ] ) < self . address Cap ) ; bool err ; uint256 result ; if ( ( self . change Interval > 0 ) & & ( now > ( self . last Cap Change Time + self . change Interval ) ) ) { uint256 num Intervals ( ( ( now ( now % self . change Interval ) ) self . last Cap Change Time ) self . change Interval ) ; ( err , result ) self . address Cap . times ( self . cap Percent Multiplier ( num Intervals ) ) ; require ( ! err ) ; ( err , result ) result . divided By ( 100 num Intervals ) ; require ( ! err ) ; self . address Cap result ; self . last Cap Change Time self . last Cap Change Time + ( self . change Interval num Intervals ) ; Log Address Cap Change ( result , " Address cap has increased ! " ) ; } number of tokens that will be purchased for calculating token wei change for purchaser if they went over the address cap temp calc holder for division remainder for leftover wei and then later for tokens remaining for the owner tells how much more the buyer can contribute up to their cap ( err , allowed Wei ) self . address Cap . minus ( self . base . has Contributed [ msg . sender ] ) ; require ( ! err ) ; allowed Wei get Min ( amount , allowed Wei ) ; leftover Wei amount allowed Wei ; ( err , result ) allowed Wei . times ( self . base . tokens Per Eth ) ; require ( ! err ) ; if ( self . base . token Decimals < 18 ) { zeros 10 ( 18 uint256 ( self . base . token Decimals ) ) ; num Tokens result zeros ; remainder result % zeros ; } else { zeros 10 ( uint256 ( self . base . token Decimals ) 18 ) ; num Tokens result zeros ; } self . base . leftover Wei [ msg . sender ] + leftover Wei + remainder ; if ( ( ( self . base . has Contributed [ msg . sender ] + amount ) ) > self . address Cap ) { Log Address Cap Exceeded ( msg . sender , self . base . leftover Wei [ msg . sender ] , " Cap Per Address has been exceeded ! Please withdraw leftover Wei ! " ) ; } self . base . has Contributed [ msg . sender ] + allowed Wei remainder ; require ( num Tokens < self . base . token . balance Of ( this ) ) ; self . base . owner Balance self . base . owner Balance + ( allowed Wei remainder ) ; self . base . withdraw Tokens Map [ msg . sender ] + num Tokens ; ( err , remainder ) self . base . withdraw Tokens Map [ self . base . owner ] . minus ( num Tokens ) ; require ( ! err ) ; self . base . withdraw Tokens Map [ self . base . owner ] remainder ; Log Tokens Bought ( msg . sender , num Tokens ) ; return true ; }
event Log Bid Accepted ( address indexed bidder , uint256 amount , uint256 personal Valuation ) ;
event Log Bid Withdrawn ( address indexed bidder , uint256 amount , uint256 personal Valuation ) ;
event Log Bid Removed ( address indexed bidder , uint256 personal Valuation ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log Token Price Change ( uint256 amount , string Msg ) ;
event Bucket And Valuation And Committed ( uint256 bucket , uint256 valuation , uint256 committed ) ;
function init ( Interactive Crowdsale Storage storage self ,
function num Digits ( uint256 number ) public pure returns ( uint256 ) { uint256 digits 0 ; while ( number ! 0 ) { number 10 ; digits + + ; } return digits ; }
function calculate Token Purchase ( uint256 amount ,
function get Current Bonus ( Interactive Crowdsale Storage storage self ) internal view returns ( uint256 ) { uint256 bonus Time self . end Withdrawal Time self . base . start Time ; uint256 elapsed now self . base . start Time ; uint256 percent Elapsed ( elapsed 100 ) bonus Time ; bool err ; uint256 current Bonus ; ( err , current Bonus ) self . price Bonus Percent . minus ( ( ( percent Elapsed self . price Bonus Percent ) 100 ) ) ; require ( ! err ) ; return current Bonus ; }
function submit Bid ( Interactive Crowdsale Storage storage self ,
function withdraw Bid ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( self . personal Caps [ msg . sender ] > 0 ) ; uint256 refund Wei ; if ( now > self . end Withdrawal Time ) { require ( self . personal Caps [ msg . sender ] < self . total Valuation ) ; refund Wei self . base . has Contributed [ msg . sender ] ; } else { manual withdrawals are only allowed once The following lines were commented out due to stack depth , but they represent the variables and calculations from the paper . The actual code is the same thing spelled out using current variables . See section 4 of the white paper for formula used uint256 multiplier Percent ( 100 ( self . end Withdrawal Time now ) ) ( self . end Withdrawal Time self . base . start Time ) ; refund Wei ( multiplier Percent self . base . has Contributed [ msg . sender ] ) 100 ; self . valuation Sums [ self . personal Caps [ msg . sender ] ] refund Wei ; self . num Bids At Valuation [ self . personal Caps [ msg . sender ] ] 1 ; self . price Purchased At [ msg . sender ] self . price Purchased At [ msg . sender ] ( ( self . price Purchased At [ msg . sender ] self . base . tokens Per Eth ) 3 ) ; self . has Manually Withdrawn [ msg . sender ] true ; } self . base . leftover Wei [ msg . sender ] + refund Wei ; self . base . has Contributed [ msg . sender ] refund Wei ; uint256 proposed Commit ; uint256 proposed Value ; uint256 current Bucket ; bool loop ; bool exists ; if ( self . personal Caps [ msg . sender ] > self . total Valuation ) { proposed Commit self . value Committed refund Wei ; if ( proposed Commit < self . current Bucket ) { if ( self . total Valuation > self . current Bucket ) { proposed Commit + self . valuation Sums [ self . current Bucket ] ; } if ( proposed Commit > self . current Bucket ) { proposed Value self . current Bucket ; } else { loop true ; } } else { if ( self . total Valuation self . current Bucket ) { proposed Value self . total Valuation ; } else { proposed Value proposed Commit ; } } if ( loop ) { ( exists , current Bucket ) self . valuations List . get Adjacent ( self . current Bucket , PREV ) ; while ( proposed Commit < current Bucket ) { proposed Commit + self . valuation Sums [ current Bucket ] ; if ( proposed Commit > current Bucket ) { proposed Value current Bucket ; } else { ( exists , current Bucket ) self . valuations List . get Adjacent ( current Bucket , PREV ) ; } } if ( proposed Value 0 ) { proposed Value proposed Commit ; } self . current Bucket current Bucket ; } self . total Valuation proposed Value ; self . value Committed proposed Commit ; } Log Bid Withdrawn ( msg . sender , refund Wei , self . personal Caps [ msg . sender ] ) ; Bucket And Valuation And Committed ( self . current Bucket , self . total Valuation , self . value Committed ) ; return true ; }
function finalize Sale ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( now > self . base . end Time ) ; can only be called once require ( set Canceled ( self ) ) ; self . is Finalized true ; require ( launch Token ( self ) ) ; uint256 computed Value ; if ( ! self . is Canceled ) { if ( self . total Valuation self . current Bucket ) { self . q ( 100 ( self . value Committed self . total Valuation ) ( self . valuation Sums [ self . total Valuation ] ) ) + 1 ; computed Value self . value Committed self . valuation Sums [ self . total Valuation ] ; computed Value + ( self . q self . valuation Sums [ self . total Valuation ] ) 100 ; } else { computed Value self . total Valuation ; } sets ETH raised in the sale to be ready for withdrawal } }
function launch Token ( Interactive Crowdsale Storage storage self ) internal returns ( bool ) { uint256 full Value ( self . total Valuation 100 ) uint256 ( self . percent Being Sold ) ; uint256 bonus Value ( ( self . total Valuation ( 100 + self . price Bonus Percent ) ) 100 ) self . total Valuation ; uint256 supply ( full Value self . base . tokens Per Eth ) 1000000000000000000 ; uint256 bonus Tokens ( bonus Value self . base . tokens Per Eth ) 1000000000000000000 ; uint256 owner Tokens supply ( ( supply uint256 ( self . percent Being Sold ) ) 100 ) ; uint256 total Supply supply + bonus Tokens ; self . base . token new Crowdsale Token ( address ( this ) , self . token Info . name , self . token Info . symbol , self . token Info . decimals , total Supply , self . token Info . still Minting ) ; if ( ! self . is Canceled ) { self . base . token . transfer ( self . base . owner , owner Tokens ) ; } else { self . base . token . transfer ( self . base . owner , supply ) ; self . base . token . burn Token ( bonus Tokens ) ; } self . base . token . change Owner ( self . base . owner ) ; self . base . starting Token Balance supply owner Tokens ; return true ; }
function set Canceled ( Interactive Crowdsale Storage storage self ) internal returns ( bool ) { bool canceled ( self . total Valuation < self . minimum Raise ) | | ( ( now > ( self . base . end Time + 30 days ) ) & & ! self . is Finalized ) ; if ( canceled ) { self . is Canceled true ; } return true ; }
function retreive Final Result ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( now > self . base . end Time ) ; require ( self . personal Caps [ msg . sender ] > 0 ) ; uint256 num Tokens ; uint256 remainder ; if ( ! self . is Finalized ) { require ( set Canceled ( self ) ) ; require ( self . is Canceled ) ; } if ( self . is Canceled ) { self . base . leftover Wei [ msg . sender ] + self . base . has Contributed [ msg . sender ] ; self . base . has Contributed [ msg . sender ] 0 ; Log Error Msg ( self . total Valuation , " Sale is canceled , all bids have been refunded ! " ) ; return true ; } if ( self . personal Caps [ msg . sender ] < self . total Valuation ) { self . base . leftover Wei [ msg . sender ] + self . base . has Contributed [ msg . sender ] ; self . base . has Contributed [ msg . sender ] 0 ; return self . base . withdraw Leftover Wei ( ) ; } else if ( self . personal Caps [ msg . sender ] self . total Valuation ) { uint256 refund Amount ( self . q self . base . has Contributed [ msg . sender ] ) 100 ; self . base . leftover Wei [ msg . sender ] + refund Amount ; self . base . has Contributed [ msg . sender ] refund Amount ; } Log Error Msg ( self . base . has Contributed [ msg . sender ] , " contribution " ) ; Log Error Msg ( self . price Purchased At [ msg . sender ] , " price " ) ; Log Error Msg ( self . q , " percentage " ) ; ( num Tokens , remainder ) calculate Token Purchase ( self . base . has Contributed [ msg . sender ] , self . price Purchased At [ msg . sender ] ) ; self . base . withdraw Tokens Map [ msg . sender ] + num Tokens ; self . value Committed self . value Committed remainder ; self . base . leftover Wei [ msg . sender ] + remainder ; uint256 full Bonus ; uint256 full Bonus Price ( self . base . tokens Per Eth ( 100 + self . price Bonus Percent ) ) 100 ; ( full Bonus , remainder ) calculate Token Purchase ( self . base . has Contributed [ msg . sender ] , full Bonus Price ) ; uint256 leftover Bonus full Bonus num Tokens ; self . base . token . burn Token ( leftover Bonus ) ; self . base . has Contributed [ msg . sender ] 0 ; self . base . withdraw Tokens ( ) ; self . base . withdraw Leftover Wei ( ) ; }
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
event Log Tokens Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Wei Withdrawn ( address indexed bidder , uint256 Amount ) ;
event Log Owner Eth Withdrawn ( address indexed owner , uint256 amount , string Msg ) ;
event Log Notice Msg ( address buyer , uint256 value , string Msg ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
function init ( Crowdsale Storage storage self ,
function crowdsale Active ( Crowdsale Storage storage self ) public view returns ( bool ) { return ( now > self . start Time & & now < self . end Time ) ; }
function crowdsale Ended ( Crowdsale Storage storage self ) public view returns ( bool ) { return now > self . end Time ; }
function valid Purchase ( Crowdsale Storage storage self ) internal returns ( bool ) { bool non Zero Purchase msg . value ! 0 ; if ( crowdsale Active ( self ) & & non Zero Purchase ) { return true ; } else { Log Error Msg ( msg . value , " Invalid Purchase ! Check start time and amount of ether . " ) ; return false ; } }
function withdraw Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { bool ok ; if ( self . withdraw Tokens Map [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no tokens to withdraw ! " ) ; return false ; } if ( msg . sender self . owner ) { if ( ! crowdsale Ended ( self ) ) { Log Error Msg ( 0 , " Owner cannot withdraw extra tokens until after the sale ! " ) ; return false ; } else { if ( self . percent Burn > 0 ) { uint256 burn Amount ( self . withdraw Tokens Map [ msg . sender ] self . percent Burn ) 100 ; self . withdraw Tokens Map [ msg . sender ] self . withdraw Tokens Map [ msg . sender ] burn Amount ; ok self . token . burn Token ( burn Amount ) ; require ( ok ) ; } } } var total self . withdraw Tokens Map [ msg . sender ] ; self . withdraw Tokens Map [ msg . sender ] 0 ; ok self . token . transfer ( msg . sender , total ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Leftover Wei ( Crowdsale Storage storage self ) public returns ( bool ) { if ( self . leftover Wei [ msg . sender ] 0 ) { Log Error Msg ( 0 , " Sender has no extra wei to withdraw ! " ) ; return false ; } var total self . leftover Wei [ msg . sender ] ; self . leftover Wei [ msg . sender ] 0 ; msg . sender . transfer ( total ) ; Log Wei Withdrawn ( msg . sender , total ) ; return true ; }
function withdraw Owner Eth ( Crowdsale Storage storage self ) public returns ( bool ) { if ( ( ! crowdsale Ended ( self ) ) & & ( self . token . balance Of ( this ) > 0 ) ) { Log Error Msg ( 0 , " Cannot withdraw owner ether until after the sale ! " ) ; return false ; } require ( msg . sender self . owner ) ; require ( self . owner Balance > 0 ) ; uint256 amount self . owner Balance ; self . owner Balance 0 ; self . owner . transfer ( amount ) ; Log Owner Eth Withdrawn ( msg . sender , amount , " Crowdsale owner has withdrawn all funds ! " ) ; return true ; }
function change Token Price ( Crowdsale Storage storage self ,
function set Tokens ( Crowdsale Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( ! self . tokens Set ) ; require ( now < self . end Time ) ; uint256 token Balance ; token Balance self . token . balance Of ( this ) ; self . withdraw Tokens Map [ msg . sender ] token Balance ; self . starting Token Balance token Balance ; self . tokens Set true ; return true ; }
function get Sale Data ( Crowdsale Storage storage self , uint256 timestamp )
function get Tokens Sold ( Crowdsale Storage storage self ) public view returns ( uint256 ) { return self . starting Token Balance self . withdraw Tokens Map [ self . owner ] ; }
event Log Bid Accepted ( address indexed bidder , uint256 amount , uint256 personal Valuation ) ;
event Log Bid Withdrawn ( address indexed bidder , uint256 amount , uint256 personal Valuation ) ;
event Log Bid Removed ( address indexed bidder , uint256 personal Valuation ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log Token Price Change ( uint256 amount , string Msg ) ;
event Bucket And Valuation And Committed ( uint256 bucket , uint256 valuation , uint256 committed ) ;
function init ( Interactive Crowdsale Storage storage self ,
function num Digits ( uint256 number ) public pure returns ( uint256 ) { uint256 digits 0 ; while ( number ! 0 ) { number 10 ; digits + + ; } return digits ; }
function calculate Token Purchase ( uint256 amount ,
function get Current Bonus ( Interactive Crowdsale Storage storage self ) internal view returns ( uint256 ) { uint256 bonus Time self . end Withdrawal Time self . base . start Time ; uint256 elapsed now self . base . start Time ; uint256 percent Elapsed ( elapsed 100 ) bonus Time ; bool err ; uint256 current Bonus ; ( err , current Bonus ) self . price Bonus Percent . minus ( ( ( percent Elapsed self . price Bonus Percent ) 100 ) ) ; require ( ! err ) ; return current Bonus ; }
function submit Bid ( Interactive Crowdsale Storage storage self ,
function withdraw Bid ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( self . personal Caps [ msg . sender ] > 0 ) ; uint256 refund Wei ; if ( now > self . end Withdrawal Time ) { require ( self . personal Caps [ msg . sender ] < self . total Valuation ) ; refund Wei self . base . has Contributed [ msg . sender ] ; } else { manual withdrawals are only allowed once The following lines were commented out due to stack depth , but they represent the variables and calculations from the paper . The actual code is the same thing spelled out using current variables . See section 4 of the white paper for formula used uint256 multiplier Percent ( 100 ( self . end Withdrawal Time now ) ) ( self . end Withdrawal Time self . base . start Time ) ; refund Wei ( multiplier Percent self . base . has Contributed [ msg . sender ] ) 100 ; self . valuation Sums [ self . personal Caps [ msg . sender ] ] refund Wei ; self . num Bids At Valuation [ self . personal Caps [ msg . sender ] ] 1 ; self . price Purchased At [ msg . sender ] self . price Purchased At [ msg . sender ] ( ( self . price Purchased At [ msg . sender ] self . base . tokens Per Eth ) 3 ) ; self . has Manually Withdrawn [ msg . sender ] true ; } self . base . leftover Wei [ msg . sender ] + refund Wei ; self . base . has Contributed [ msg . sender ] refund Wei ; uint256 proposed Commit ; uint256 proposed Value ; uint256 current Bucket ; bool loop ; bool exists ; if ( self . personal Caps [ msg . sender ] > self . total Valuation ) { proposed Commit self . value Committed refund Wei ; if ( proposed Commit < self . current Bucket ) { if ( self . total Valuation > self . current Bucket ) { proposed Commit + self . valuation Sums [ self . current Bucket ] ; } if ( proposed Commit > self . current Bucket ) { proposed Value self . current Bucket ; } else { loop true ; } } else { if ( self . total Valuation self . current Bucket ) { proposed Value self . total Valuation ; } else { proposed Value proposed Commit ; } } if ( loop ) { ( exists , current Bucket ) self . valuations List . get Adjacent ( self . current Bucket , PREV ) ; while ( proposed Commit < current Bucket ) { proposed Commit + self . valuation Sums [ current Bucket ] ; if ( proposed Commit > current Bucket ) { proposed Value current Bucket ; } else { ( exists , current Bucket ) self . valuations List . get Adjacent ( current Bucket , PREV ) ; } } if ( proposed Value 0 ) { proposed Value proposed Commit ; } self . current Bucket current Bucket ; } self . total Valuation proposed Value ; self . value Committed proposed Commit ; } Log Bid Withdrawn ( msg . sender , refund Wei , self . personal Caps [ msg . sender ] ) ; Bucket And Valuation And Committed ( self . current Bucket , self . total Valuation , self . value Committed ) ; return true ; }
function finalize Sale ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( now > self . base . end Time ) ; can only be called once require ( set Canceled ( self ) ) ; self . is Finalized true ; require ( launch Token ( self ) ) ; uint256 computed Value ; if ( ! self . is Canceled ) { if ( self . total Valuation self . current Bucket ) { self . q ( 100 ( self . value Committed self . total Valuation ) ( self . valuation Sums [ self . total Valuation ] ) ) + 1 ; computed Value self . value Committed self . valuation Sums [ self . total Valuation ] ; computed Value + ( self . q self . valuation Sums [ self . total Valuation ] ) 100 ; } else { computed Value self . total Valuation ; } sets ETH raised in the sale to be ready for withdrawal } }
function launch Token ( Interactive Crowdsale Storage storage self ) internal returns ( bool ) { uint256 full Value ( self . total Valuation 100 ) uint256 ( self . percent Being Sold ) ; uint256 bonus Value ( ( self . total Valuation ( 100 + self . price Bonus Percent ) ) 100 ) self . total Valuation ; uint256 supply ( full Value self . base . tokens Per Eth ) 1000000000000000000 ; uint256 bonus Tokens ( bonus Value self . base . tokens Per Eth ) 1000000000000000000 ; uint256 owner Tokens supply ( ( supply uint256 ( self . percent Being Sold ) ) 100 ) ; uint256 total Supply supply + bonus Tokens ; self . base . token new Crowdsale Token ( address ( this ) , self . token Info . name , self . token Info . symbol , self . token Info . decimals , total Supply , self . token Info . still Minting ) ; if ( ! self . is Canceled ) { self . base . token . transfer ( self . base . owner , owner Tokens ) ; } else { self . base . token . transfer ( self . base . owner , supply ) ; self . base . token . burn Token ( bonus Tokens ) ; } self . base . token . change Owner ( self . base . owner ) ; self . base . starting Token Balance supply owner Tokens ; return true ; }
function set Canceled ( Interactive Crowdsale Storage storage self ) internal returns ( bool ) { bool canceled ( self . total Valuation < self . minimum Raise ) | | ( ( now > ( self . base . end Time + 30 days ) ) & & ! self . is Finalized ) ; if ( canceled ) { self . is Canceled true ; } return true ; }
function retreive Final Result ( Interactive Crowdsale Storage storage self ) public returns ( bool ) { require ( now > self . base . end Time ) ; require ( self . personal Caps [ msg . sender ] > 0 ) ; uint256 num Tokens ; uint256 remainder ; if ( ! self . is Finalized ) { require ( set Canceled ( self ) ) ; require ( self . is Canceled ) ; } if ( self . is Canceled ) { self . base . leftover Wei [ msg . sender ] + self . base . has Contributed [ msg . sender ] ; self . base . has Contributed [ msg . sender ] 0 ; Log Error Msg ( self . total Valuation , " Sale is canceled , all bids have been refunded ! " ) ; return true ; } if ( self . personal Caps [ msg . sender ] < self . total Valuation ) { self . base . leftover Wei [ msg . sender ] + self . base . has Contributed [ msg . sender ] ; self . base . has Contributed [ msg . sender ] 0 ; return self . base . withdraw Leftover Wei ( ) ; } else if ( self . personal Caps [ msg . sender ] self . total Valuation ) { uint256 refund Amount ( self . q self . base . has Contributed [ msg . sender ] ) 100 ; self . base . leftover Wei [ msg . sender ] + refund Amount ; self . base . has Contributed [ msg . sender ] refund Amount ; } Log Error Msg ( self . base . has Contributed [ msg . sender ] , " contribution " ) ; Log Error Msg ( self . price Purchased At [ msg . sender ] , " price " ) ; Log Error Msg ( self . q , " percentage " ) ; ( num Tokens , remainder ) calculate Token Purchase ( self . base . has Contributed [ msg . sender ] , self . price Purchased At [ msg . sender ] ) ; self . base . withdraw Tokens Map [ msg . sender ] + num Tokens ; self . value Committed self . value Committed remainder ; self . base . leftover Wei [ msg . sender ] + remainder ; uint256 full Bonus ; uint256 full Bonus Price ( self . base . tokens Per Eth ( 100 + self . price Bonus Percent ) ) 100 ; ( full Bonus , remainder ) calculate Token Purchase ( self . base . has Contributed [ msg . sender ] , full Bonus Price ) ; uint256 leftover Bonus full Bonus num Tokens ; self . base . token . burn Token ( leftover Bonus ) ; self . base . has Contributed [ msg . sender ] 0 ; self . base . withdraw Tokens ( ) ; self . base . withdraw Leftover Wei ( ) ; }
function list Exists ( Linked List storage self )
function node Exists ( Linked List storage self , uint256 node )
function size Of ( Linked List storage self ) internal view returns ( uint256 num Elements ) { bool exists ; uint256 i ; ( exists , i ) get Adjacent ( self , HEAD , NEXT ) ; while ( i ! HEAD ) { ( exists , i ) get Adjacent ( self , i , NEXT ) ; num Elements + + ; } return ; }
function get Node ( Linked List storage self , uint256 node )
function get Adjacent ( Linked List storage self , uint256 node , bool direction )
function get Sorted Spot ( Linked List storage self , uint256 node , uint256 value , bool direction )
function create Link ( Linked List storage self , uint256 node , uint256 link , bool direction ) internal { self . list [ link ] [ ! direction ] node ; self . list [ node ] [ direction ] link ; }
function insert ( Linked List storage self , uint256 node , uint256 new , bool direction ) internal returns ( bool ) { if ( ! node Exists ( self , new ) & & node Exists ( self , node ) ) { uint256 c self . list [ node ] [ direction ] ; create Link ( self , node , new , direction ) ; create Link ( self , new , c , direction ) ; return true ; } else { return false ; } }
function remove ( Linked List storage self , uint256 node ) internal returns ( uint256 ) { if ( ( node NULL ) | | ( ! node Exists ( self , node ) ) ) { return 0 ; } create Link ( self , self . list [ node ] [ PREV ] , self . list [ node ] [ NEXT ] , NEXT ) ; delete self . list [ node ] [ PREV ] ; delete self . list [ node ] [ NEXT ] ; return node ; }
function push ( Linked List storage self , uint256 node , bool direction ) internal { insert ( self , HEAD , node , direction ) ; }
function pop ( Linked List storage self , bool direction ) internal returns ( uint256 ) { bool exists ; uint256 adj ; ( exists , adj ) get Adjacent ( self , HEAD , direction ) ; return remove ( self , adj ) ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function list Exists ( Linked List storage self )
function node Exists ( Linked List storage self , uint256 node )
function size Of ( Linked List storage self ) internal view returns ( uint256 num Elements ) { bool exists ; uint256 i ; ( exists , i ) get Adjacent ( self , HEAD , NEXT ) ; while ( i ! HEAD ) { ( exists , i ) get Adjacent ( self , i , NEXT ) ; num Elements + + ; } return ; }
function get Node ( Linked List storage self , uint256 node )
function get Adjacent ( Linked List storage self , uint256 node , bool direction )
function get Sorted Spot ( Linked List storage self , uint256 node , uint256 value , bool direction )
function create Link ( Linked List storage self , uint256 node , uint256 link , bool direction ) internal { self . list [ link ] [ ! direction ] node ; self . list [ node ] [ direction ] link ; }
function insert ( Linked List storage self , uint256 node , uint256 new , bool direction ) internal returns ( bool ) { if ( ! node Exists ( self , new ) & & node Exists ( self , node ) ) { uint256 c self . list [ node ] [ direction ] ; create Link ( self , node , new , direction ) ; create Link ( self , new , c , direction ) ; return true ; } else { return false ; } }
function remove ( Linked List storage self , uint256 node ) internal returns ( uint256 ) { if ( ( node NULL ) | | ( ! node Exists ( self , node ) ) ) { return 0 ; } create Link ( self , self . list [ node ] [ PREV ] , self . list [ node ] [ NEXT ] , NEXT ) ; delete self . list [ node ] [ PREV ] ; delete self . list [ node ] [ NEXT ] ; return node ; }
function push ( Linked List storage self , uint256 node , bool direction ) internal { insert ( self , HEAD , node , direction ) ; }
function pop ( Linked List storage self , bool direction ) internal returns ( uint256 ) { bool exists ; uint256 adj ; ( exists , adj ) get Adjacent ( self , HEAD , direction ) ; return remove ( self , adj ) ; }
function list Exists ( Linked List storage self )
function node Exists ( Linked List storage self , uint256 node )
function size Of ( Linked List storage self ) internal view returns ( uint256 num Elements ) { bool exists ; uint256 i ; ( exists , i ) get Adjacent ( self , HEAD , NEXT ) ; while ( i ! HEAD ) { ( exists , i ) get Adjacent ( self , i , NEXT ) ; num Elements + + ; } return ; }
function get Node ( Linked List storage self , uint256 node )
function get Adjacent ( Linked List storage self , uint256 node , bool direction )
function get Sorted Spot ( Linked List storage self , uint256 node , uint256 value , bool direction )
function create Link ( Linked List storage self , uint256 node , uint256 link , bool direction ) internal { self . list [ link ] [ ! direction ] node ; self . list [ node ] [ direction ] link ; }
function insert ( Linked List storage self , uint256 node , uint256 new , bool direction ) internal returns ( bool ) { if ( ! node Exists ( self , new ) & & node Exists ( self , node ) ) { uint256 c self . list [ node ] [ direction ] ; create Link ( self , node , new , direction ) ; create Link ( self , new , c , direction ) ; return true ; } else { return false ; } }
function remove ( Linked List storage self , uint256 node ) internal returns ( uint256 ) { if ( ( node NULL ) | | ( ! node Exists ( self , node ) ) ) { return 0 ; } create Link ( self , self . list [ node ] [ PREV ] , self . list [ node ] [ NEXT ] , NEXT ) ; delete self . list [ node ] [ PREV ] ; delete self . list [ node ] [ NEXT ] ; return node ; }
function push ( Linked List storage self , uint256 node , bool direction ) internal { insert ( self , HEAD , node , direction ) ; }
function pop ( Linked List storage self , bool direction ) internal returns ( uint256 ) { bool exists ; uint256 adj ; ( exists , adj ) get Adjacent ( self , HEAD , direction ) ; return remove ( self , adj ) ; }
function node Exists ( uint256 node ) view public returns ( bool ) { return list . node Exists ( node ) ; }
function size Of ( ) view public returns ( uint256 num Elements ) { return list . size Of ( ) ; }
function get Node ( uint256 node )
function get Adjacent ( uint256 node , bool direction )
function get Sorted Spot ( uint256 node , uint256 value , bool direction )
function insert ( uint256 node , uint256 new , bool direction ) public { list . insert ( node , new , direction ) ; }
function remove ( uint256 node ) public returns ( uint256 ) { return list . remove ( node ) ; }
function push ( uint256 node , bool direction ) public { list . push ( node , direction ) ; }
function pop ( bool direction ) public returns ( uint256 ) { return list . pop ( direction ) ; }
function to Slice ( string self ) internal returns ( slice ) { uint ptr ; assembly { ptr : add ( self , 0x20 ) } return slice ( bytes ( self ) . length , ptr ) ; }
function len ( bytes32 self ) internal returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( self & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( self & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( self & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( self & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( self & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function to Slice B32 ( bytes32 self ) internal returns ( slice ret ) { assembly { let ptr : mload ( 0x40 ) mstore ( 0x40 , add ( ptr , 0x20 ) ) mstore ( ptr , self ) mstore ( add ( ret , 0x20 ) , ptr ) } ret . len len ( self ) ; }
function copy ( slice self ) internal returns ( slice ) { return slice ( self . len , self . ptr ) ; }
function to String ( slice self ) internal view returns ( string ) { var ret new string ( self . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; return ret ; }
function len ( slice self ) internal view returns ( uint ) { var ptr self . ptr 31 ; var end ptr + self . len ; for ( uint len 0 ; ptr < end ; len + + ) { uint8 b ; assembly { b : and ( mload ( ptr ) , 0x FF ) } if ( b < 0x80 ) { ptr + 1 ; } else if ( b < 0x E0 ) { ptr + 2 ; } else if ( b < 0x F0 ) { ptr + 3 ; } else if ( b < 0x F8 ) { ptr + 4 ; } else if ( b < 0x FC ) { ptr + 5 ; } else { ptr + 6 ; } } return len ; }
function empty ( slice self ) internal view returns ( bool ) { return self . len 0 ; }
function compare ( slice self , slice other ) internal view returns ( int ) { uint shortest self . len ; if ( other . len < self . len ) shortest other . len ; var selfptr self . ptr ; var otherptr other . ptr ; for ( uint idx 0 ; idx < shortest ; idx + 32 ) { uint a ; uint b ; assembly { a : mload ( selfptr ) b : mload ( otherptr ) } if ( a ! b ) { uint mask ~ ( 2 ( 8 ( 32 shortest + idx ) ) 1 ) ; var diff ( a & mask ) ( b & mask ) ; if ( diff ! 0 ) return int ( diff ) ; } selfptr + 32 ; otherptr + 32 ; } return int ( self . len ) int ( other . len ) ; }
function equals ( slice self , slice other ) internal view returns ( bool ) { return compare ( self , other ) 0 ; }
function next Rune ( slice self , slice rune ) internal returns ( slice ) { rune . ptr self . ptr ; if ( self . len 0 ) { rune . len 0 ; return rune ; } uint len ; uint b ; assembly { b : and ( mload ( sub ( mload ( add ( self , 32 ) ) , 31 ) ) , 0x FF ) } if ( b < 0x80 ) { len 1 ; } else if ( b < 0x E0 ) { len 2 ; } else if ( b < 0x F0 ) { len 3 ; } else { len 4 ; } if ( len > self . len ) { rune . len self . len ; self . ptr + self . len ; self . len 0 ; return rune ; } self . ptr + len ; self . len len ; rune . len len ; return rune ; }
function next Rune ( slice self ) internal returns ( slice ret ) { next Rune ( self , ret ) ; }
function ord ( slice self ) internal view returns ( uint ret ) { if ( self . len 0 ) { return 0 ; } uint word ; uint len ; uint div 2 248 ; assembly { word : mload ( mload ( add ( self , 32 ) ) ) } var b word div ; if ( b < 0x80 ) { ret b ; len 1 ; } else if ( b < 0x E0 ) { ret b & 0x1F ; len 2 ; } else if ( b < 0x F0 ) { ret b & 0x0F ; len 3 ; } else { ret b & 0x07 ; len 4 ; } if ( len > self . len ) { return 0 ; } for ( uint i 1 ; i < len ; i + + ) { div div 256 ; b ( word div ) & 0x FF ; if ( b & 0x C0 ! 0x80 ) { return 0 ; } ret ( ret 64 ) | ( b & 0x3F ) ; } return ret ; }
function keccak ( slice self ) internal view returns ( bytes32 ret ) { assembly { ret : sha3 ( mload ( add ( self , 32 ) ) , mload ( self ) ) } }
function starts With ( slice self , slice needle ) internal view returns ( bool ) { if ( self . len < needle . len ) { return false ; } if ( self . ptr needle . ptr ) { return true ; } bool equal ; assembly { let len : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } return equal ; }
function beyond ( slice self , slice needle ) internal returns ( slice ) { if ( self . len < needle . len ) { return self ; } bool equal true ; if ( self . ptr ! needle . ptr ) { assembly { let len : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } } if ( equal ) { self . len needle . len ; self . ptr + needle . len ; } return self ; }
function ends With ( slice self , slice needle ) internal view returns ( bool ) { if ( self . len < needle . len ) { return false ; } var selfptr self . ptr + self . len needle . len ; if ( selfptr needle . ptr ) { return true ; } bool equal ; assembly { let len : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } return equal ; }
function until ( slice self , slice needle ) internal returns ( slice ) { if ( self . len < needle . len ) { return self ; } var selfptr self . ptr + self . len needle . len ; bool equal true ; if ( selfptr ! needle . ptr ) { assembly { let len : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } } if ( equal ) { self . len needle . len ; } return self ; }
function find Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr )
function rfind Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr )
function find ( slice self , slice needle ) internal returns ( slice ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; self . ptr ptr ; return self ; }
function rfind ( slice self , slice needle ) internal returns ( slice ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; return self ; }
function split ( slice self , slice needle , slice token ) internal returns ( slice ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr self . ptr ; token . len ptr self . ptr ; if ( ptr self . ptr + self . len ) { self . len 0 ; } else { self . len token . len + needle . len ; self . ptr ptr + needle . len ; } return token ; }
function split ( slice self , slice needle ) internal returns ( slice token ) { split ( self , needle , token ) ; }
function rsplit ( slice self , slice needle , slice token ) internal returns ( slice ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr ptr ; token . len self . len ( ptr self . ptr ) ; if ( ptr self . ptr ) { self . len 0 ; } else { self . len token . len + needle . len ; } return token ; }
function rsplit ( slice self , slice needle ) internal returns ( slice token ) { rsplit ( self , needle , token ) ; }
function count ( slice self , slice needle ) internal view returns ( uint count ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) + needle . len ; while ( ptr < self . ptr + self . len ) { count + + ; ptr find Ptr ( self . len ( ptr self . ptr ) , ptr , needle . len , needle . ptr ) + needle . len ; } }
function contains ( slice self , slice needle ) internal view returns ( bool ) { return rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ! self . ptr ; }
function concat ( slice self , slice other ) internal view returns ( string ) { var ret new string ( self . len + other . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; memcpy ( retptr + self . len , other . ptr , other . len ) ; return ret ; }
function join ( slice self , slice [ ] parts ) internal view returns ( string ) { if ( parts . length 0 ) return " " ; uint len self . len ( parts . length 1 ) ; for ( uint i 0 ; i < parts . length ; i + + ) len + parts [ i ] . len ; var ret new string ( len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } for ( i 0 ; i < parts . length ; i + + ) { memcpy ( retptr , parts [ i ] . ptr , parts [ i ] . len ) ; retptr + parts [ i ] . len ; if ( i < parts . length 1 ) { memcpy ( retptr , self . ptr , self . len ) ; retptr + self . len ; } } return ret ; }
function to Slice ( string self ) internal returns ( slice ) { uint ptr ; assembly { ptr : add ( self , 0x20 ) } return slice ( bytes ( self ) . length , ptr ) ; }
function len ( bytes32 self ) internal returns ( uint ) { uint ret ; if ( self 0 ) return 0 ; if ( self & 0xffffffffffffffffffffffffffffffff 0 ) { ret + 16 ; self bytes32 ( uint ( self ) 0x100000000000000000000000000000000 ) ; } if ( self & 0xffffffffffffffff 0 ) { ret + 8 ; self bytes32 ( uint ( self ) 0x10000000000000000 ) ; } if ( self & 0xffffffff 0 ) { ret + 4 ; self bytes32 ( uint ( self ) 0x100000000 ) ; } if ( self & 0xffff 0 ) { ret + 2 ; self bytes32 ( uint ( self ) 0x10000 ) ; } if ( self & 0xff 0 ) { ret + 1 ; } return 32 ret ; }
function to Slice B32 ( bytes32 self ) internal returns ( slice ret ) { assembly { let ptr : mload ( 0x40 ) mstore ( 0x40 , add ( ptr , 0x20 ) ) mstore ( ptr , self ) mstore ( add ( ret , 0x20 ) , ptr ) } ret . len len ( self ) ; }
function copy ( slice self ) internal returns ( slice ) { return slice ( self . len , self . ptr ) ; }
function to String ( slice self ) internal view returns ( string ) { var ret new string ( self . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; return ret ; }
function len ( slice self ) internal view returns ( uint ) { var ptr self . ptr 31 ; var end ptr + self . len ; for ( uint len 0 ; ptr < end ; len + + ) { uint8 b ; assembly { b : and ( mload ( ptr ) , 0x FF ) } if ( b < 0x80 ) { ptr + 1 ; } else if ( b < 0x E0 ) { ptr + 2 ; } else if ( b < 0x F0 ) { ptr + 3 ; } else if ( b < 0x F8 ) { ptr + 4 ; } else if ( b < 0x FC ) { ptr + 5 ; } else { ptr + 6 ; } } return len ; }
function empty ( slice self ) internal view returns ( bool ) { return self . len 0 ; }
function compare ( slice self , slice other ) internal view returns ( int ) { uint shortest self . len ; if ( other . len < self . len ) shortest other . len ; var selfptr self . ptr ; var otherptr other . ptr ; for ( uint idx 0 ; idx < shortest ; idx + 32 ) { uint a ; uint b ; assembly { a : mload ( selfptr ) b : mload ( otherptr ) } if ( a ! b ) { uint256 mask uint256 ( 1 ) ; if ( shortest < 32 ) { mask ~ ( 2 ( 8 ( 32 shortest + idx ) ) 1 ) ; } var diff ( a & mask ) ( b & mask ) ; if ( diff ! 0 ) return int ( diff ) ; } selfptr + 32 ; otherptr + 32 ; } return int ( self . len ) int ( other . len ) ; }
function equals ( slice self , slice other ) internal view returns ( bool ) { return compare ( self , other ) 0 ; }
function next Rune ( slice self , slice rune ) internal returns ( slice ) { rune . ptr self . ptr ; if ( self . len 0 ) { rune . len 0 ; return rune ; } uint len ; uint b ; assembly { b : and ( mload ( sub ( mload ( add ( self , 32 ) ) , 31 ) ) , 0x FF ) } if ( b < 0x80 ) { len 1 ; } else if ( b < 0x E0 ) { len 2 ; } else if ( b < 0x F0 ) { len 3 ; } else { len 4 ; } if ( len > self . len ) { rune . len self . len ; self . ptr + self . len ; self . len 0 ; return rune ; } self . ptr + len ; self . len len ; rune . len len ; return rune ; }
function next Rune ( slice self ) internal returns ( slice ret ) { next Rune ( self , ret ) ; }
function ord ( slice self ) internal view returns ( uint ret ) { if ( self . len 0 ) { return 0 ; } uint word ; uint len ; uint div 2 248 ; assembly { word : mload ( mload ( add ( self , 32 ) ) ) } var b word div ; if ( b < 0x80 ) { ret b ; len 1 ; } else if ( b < 0x E0 ) { ret b & 0x1F ; len 2 ; } else if ( b < 0x F0 ) { ret b & 0x0F ; len 3 ; } else { ret b & 0x07 ; len 4 ; } if ( len > self . len ) { return 0 ; } for ( uint i 1 ; i < len ; i + + ) { div div 256 ; b ( word div ) & 0x FF ; if ( b & 0x C0 ! 0x80 ) { return 0 ; } ret ( ret 64 ) | ( b & 0x3F ) ; } return ret ; }
function keccak ( slice self ) internal view returns ( bytes32 ret ) { assembly { ret : sha3 ( mload ( add ( self , 32 ) ) , mload ( self ) ) } }
function starts With ( slice self , slice needle ) internal view returns ( bool ) { if ( self . len < needle . len ) { return false ; } if ( self . ptr needle . ptr ) { return true ; } bool equal ; assembly { let len : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } return equal ; }
function beyond ( slice self , slice needle ) internal returns ( slice ) { if ( self . len < needle . len ) { return self ; } bool equal true ; if ( self . ptr ! needle . ptr ) { assembly { let len : mload ( needle ) let selfptr : mload ( add ( self , 0x20 ) ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } } if ( equal ) { self . len needle . len ; self . ptr + needle . len ; } return self ; }
function ends With ( slice self , slice needle ) internal view returns ( bool ) { if ( self . len < needle . len ) { return false ; } var selfptr self . ptr + self . len needle . len ; if ( selfptr needle . ptr ) { return true ; } bool equal ; assembly { let len : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } return equal ; }
function until ( slice self , slice needle ) internal returns ( slice ) { if ( self . len < needle . len ) { return self ; } var selfptr self . ptr + self . len needle . len ; bool equal true ; if ( selfptr ! needle . ptr ) { assembly { let len : mload ( needle ) let needleptr : mload ( add ( needle , 0x20 ) ) equal : eq ( sha3 ( selfptr , len ) , sha3 ( needleptr , len ) ) } } if ( equal ) { self . len needle . len ; } return self ; }
function find Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr )
function rfind Ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr )
function find ( slice self , slice needle ) internal returns ( slice ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; self . ptr ptr ; return self ; }
function rfind ( slice self , slice needle ) internal returns ( slice ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; self . len ptr self . ptr ; return self ; }
function split ( slice self , slice needle , slice token ) internal returns ( slice ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr self . ptr ; token . len ptr self . ptr ; if ( ptr self . ptr + self . len ) { self . len 0 ; } else { self . len token . len + needle . len ; self . ptr ptr + needle . len ; } return token ; }
function split ( slice self , slice needle ) internal returns ( slice token ) { split ( self , needle , token ) ; }
function rsplit ( slice self , slice needle , slice token ) internal returns ( slice ) { uint ptr rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ; token . ptr ptr ; token . len self . len ( ptr self . ptr ) ; if ( ptr self . ptr ) { self . len 0 ; } else { self . len token . len + needle . len ; } return token ; }
function rsplit ( slice self , slice needle ) internal returns ( slice token ) { rsplit ( self , needle , token ) ; }
function count ( slice self , slice needle ) internal view returns ( uint count ) { uint ptr find Ptr ( self . len , self . ptr , needle . len , needle . ptr ) + needle . len ; while ( ptr < self . ptr + self . len ) { count + + ; ptr find Ptr ( self . len ( ptr self . ptr ) , ptr , needle . len , needle . ptr ) + needle . len ; } }
function contains ( slice self , slice needle ) internal view returns ( bool ) { return rfind Ptr ( self . len , self . ptr , needle . len , needle . ptr ) ! self . ptr ; }
function concat ( slice self , slice other ) internal view returns ( string ) { var ret new string ( self . len + other . len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } memcpy ( retptr , self . ptr , self . len ) ; memcpy ( retptr + self . len , other . ptr , other . len ) ; return ret ; }
function join ( slice self , slice [ ] parts ) internal view returns ( string ) { if ( parts . length 0 ) return " " ; uint len self . len ( parts . length 1 ) ; for ( uint i 0 ; i < parts . length ; i + + ) len + parts [ i ] . len ; var ret new string ( len ) ; uint retptr ; assembly { retptr : add ( ret , 32 ) } for ( i 0 ; i < parts . length ; i + + ) { memcpy ( retptr , parts [ i ] . ptr , parts [ i ] . len ) ; retptr + parts [ i ] . len ; if ( i < parts . length 1 ) { memcpy ( retptr , self . ptr , self . len ) ; retptr + self . len ; } } return ret ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
function ( ) public { data msg . data ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) returns ( bool ) { bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) constant returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) returns ( bool ) { self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender ) constant returns ( uint256 remaining ) { return self . allowed [ owner ] [ spender ] ; }
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; }
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log User Registered ( address registrant , uint256 vest Amount , uint256 bonus ) ;
event Log User Un Registered ( address registrant ) ;
event Log Registration Replaced ( address current Registrant , address new Registrant , uint256 amount Withdrawn ) ;
event Log ETH Withdrawn ( address beneficiary , uint256 amount ) ;
event Log Tokens Withdrawn ( address beneficiary , uint256 amount ) ;
function init ( Vesting Storage storage self ,
function initialize ETH Balance ( Vesting Storage storage self , uint256 balance ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now < self . start Time ) ; require ( balance ! 0 ) ; require ( ! self . is Token ) ; require ( self . total Supply 0 ) ; self . total Supply balance ; self . contract Balance balance ; return true ; }
function initialize Token Balance ( Vesting Storage storage self , Crowdsale Token token , uint256 balance ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now < self . start Time ) ; require ( balance ! 0 ) ; require ( self . is Token ) ; require ( token . balance Of ( this ) balance ) ; require ( self . total Supply 0 ) ; self . total Supply balance ; self . contract Balance balance ; return true ; }
function register User ( Vesting Storage storage self ,
function register Users ( Vesting Storage storage self ,
function unregister User ( Vesting Storage storage self , address registrant ) public returns ( bool ) { require ( ( msg . sender self . owner ) | | ( msg . sender address ( this ) ) ) ; if ( now > self . start Time ) { Log Error Msg ( self . start Time , " Can only register and unregister users before the vesting starts ! " ) ; return false ; } uint256 total Holding ; uint256 result ; bool err ; total Holding self . holding Amount [ registrant ] [ 0 ] + self . holding Amount [ registrant ] [ 1 ] ; if ( total Holding 0 ) { Log Error Msg ( 0 , " Registrant address not registered for the vesting ! " ) ; return false ; } self . holding Amount [ registrant ] [ 0 ] 0 ; self . holding Amount [ registrant ] [ 1 ] 0 ; self . contract Balance + total Holding ; ( err , result ) self . num Registered . minus ( 1 ) ; require ( ! err ) ; self . num Registered result ; Log User Un Registered ( registrant ) ; return true ; }
function unregister Users ( Vesting Storage storage self , address [ ] registrants ) public returns ( bool ) { require ( msg . sender self . owner ) ; bool ok ; for ( uint256 i 0 ; i < registrants . length ; i + + ) { ok unregister User ( self , registrants [ i ] ) ; } return ok ; }
function swap Registration ( Vesting Storage storage self , address replacement Registrant ) public returns ( bool ) { require ( replacement Registrant ! 0 ) ; require ( self . holding Amount [ replacement Registrant ] [ 0 ] 0 ) ; uint256 vest Amount self . holding Amount [ msg . sender ] [ 0 ] ; uint256 bonus self . holding Amount [ msg . sender ] [ 1 ] ; uint256 withdrawn Amount self . has Withdrawn [ msg . sender ] ; require ( vest Amount > 0 ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . has Withdrawn [ msg . sender ] 0 ; self . holding Amount [ replacement Registrant ] [ 0 ] vest Amount ; self . holding Amount [ replacement Registrant ] [ 1 ] bonus ; self . has Withdrawn [ replacement Registrant ] withdrawn Amount ; Log Registration Replaced ( msg . sender , replacement Registrant , self . has Withdrawn [ replacement Registrant ] ) ; return true ; }
function calculate Withdrawal ( Vesting Storage storage self , address beneficiary ) internal view returns ( uint256 ) { require ( beneficiary ! 0 ) ; require ( self . holding Amount [ beneficiary ] [ 0 ] > 0 ) ; require ( self . num Registered > 0 ) ; bool err ; uint256 num Intervals ( now self . start Time ) self . time Interval ; uint256 amount Released ( ( num Intervals self . percent Per Interval ) self . holding Amount [ beneficiary ] [ 0 ] ) 100 ; ( err , amount Released ) amount Released . minus ( self . has Withdrawn [ beneficiary ] ) ; return amount Released ; }
function withdraw ETH ( Vesting Storage storage self ) public returns ( bool ) { require ( now > self . start Time ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ msg . sender ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; uint256 bonus Amount self . holding Amount [ msg . sender ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ msg . sender ] [ 0 ] + self . holding Amount [ msg . sender ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ msg . sender ] ) ; require ( ! err ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; } } self . has Withdrawn [ msg . sender ] + withdraw Amount ; msg . sender . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( msg . sender , withdraw Amount ) ; return true ; }
function withdraw Tokens ( Vesting Storage storage self , Crowdsale Token token ) public returns ( bool ) { require ( now > self . start Time ) ; require ( self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ msg . sender ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; uint256 bonus Amount self . holding Amount [ msg . sender ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; ok token . burn Token ( bonus Amount ) ; require ( ok ) ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ msg . sender ] [ 0 ] + self . holding Amount [ msg . sender ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ msg . sender ] ) ; require ( ! err ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; } } self . has Withdrawn [ msg . sender ] + withdraw Amount ; ok token . transfer ( msg . sender , withdraw Amount ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , withdraw Amount ) ; return true ; }
function send ETH ( Vesting Storage storage self , address beneficiary ) public returns ( bool ) { require ( now > self . start Time ) ; require ( msg . sender self . owner ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ beneficiary ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; uint256 bonus Amount self . holding Amount [ beneficiary ] [ 1 ] ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ beneficiary ] [ 0 ] + self . holding Amount [ beneficiary ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ beneficiary ] ) ; require ( ! err ) ; self . holding Amount [ beneficiary ] [ 0 ] 0 ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; } } self . has Withdrawn [ beneficiary ] + withdraw Amount ; beneficiary . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( beneficiary , withdraw Amount ) ; return true ; }
function send Tokens ( Vesting Storage storage self , Crowdsale Token token , address beneficiary ) public returns ( bool ) { require ( now > self . start Time ) ; require ( msg . sender self . owner ) ; require ( self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ beneficiary ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; uint256 bonus Amount self . holding Amount [ beneficiary ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; ok token . burn Token ( bonus Amount ) ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ beneficiary ] [ 0 ] + self . holding Amount [ beneficiary ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ beneficiary ] ) ; require ( ! err ) ; self . holding Amount [ beneficiary ] [ 0 ] 0 ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; } } self . has Withdrawn [ beneficiary ] + withdraw Amount ; ok token . transfer ( beneficiary , withdraw Amount ) ; require ( ok ) ; Log Tokens Withdrawn ( beneficiary , withdraw Amount ) ; return true ; }
function owner Withdraw Extra ETH ( Vesting Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now > self . end Time ) ; require ( ! self . is Token ) ; uint256 contract Balance this . balance ; self . contract Balance 0 ; self . owner . transfer ( contract Balance ) ; Log ETH Withdrawn ( self . owner , contract Balance ) ; return true ; }
function owner Withdraw Extra Tokens ( Vesting Storage storage self , Crowdsale Token token ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now > self . end Time ) ; require ( self . is Token ) ; uint256 contract Balance token . balance Of ( this ) ; self . contract Balance 0 ; token . transfer ( self . owner , contract Balance ) ; Log Tokens Withdrawn ( self . owner , contract Balance ) ; return true ; }
function get Percent Released ( Vesting Storage storage self ) public view returns ( uint256 ) { require ( now > self . start Time ) ; return self . percent Per Interval ( ( now self . start Time ) self . time Interval ) ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log User Registered ( address registrant , uint256 vest Amount , uint256 bonus ) ;
event Log User Un Registered ( address registrant ) ;
event Log Registration Replaced ( address current Registrant , address new Registrant , uint256 amount Withdrawn ) ;
event Log ETH Withdrawn ( address beneficiary , uint256 amount ) ;
event Log Tokens Withdrawn ( address beneficiary , uint256 amount ) ;
function init ( Vesting Storage storage self ,
function initialize ETH Balance ( Vesting Storage storage self , uint256 balance ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now < self . start Time ) ; require ( balance ! 0 ) ; require ( ! self . is Token ) ; require ( self . total Supply 0 ) ; self . total Supply balance ; self . contract Balance balance ; return true ; }
function initialize Token Balance ( Vesting Storage storage self , Crowdsale Token token , uint256 balance ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now < self . start Time ) ; require ( balance ! 0 ) ; require ( self . is Token ) ; require ( token . balance Of ( this ) balance ) ; require ( self . total Supply 0 ) ; self . total Supply balance ; self . contract Balance balance ; return true ; }
function register User ( Vesting Storage storage self ,
function register Users ( Vesting Storage storage self ,
function unregister User ( Vesting Storage storage self , address registrant ) public returns ( bool ) { require ( ( msg . sender self . owner ) | | ( msg . sender address ( this ) ) ) ; if ( now > self . start Time ) { Log Error Msg ( self . start Time , " Can only register and unregister users before the vesting starts ! " ) ; return false ; } uint256 total Holding ; uint256 result ; bool err ; total Holding self . holding Amount [ registrant ] [ 0 ] + self . holding Amount [ registrant ] [ 1 ] ; if ( total Holding 0 ) { Log Error Msg ( 0 , " Registrant address not registered for the vesting ! " ) ; return false ; } self . holding Amount [ registrant ] [ 0 ] 0 ; self . holding Amount [ registrant ] [ 1 ] 0 ; self . contract Balance + total Holding ; ( err , result ) self . num Registered . minus ( 1 ) ; require ( ! err ) ; self . num Registered result ; Log User Un Registered ( registrant ) ; return true ; }
function unregister Users ( Vesting Storage storage self , address [ ] registrants ) public returns ( bool ) { require ( msg . sender self . owner ) ; bool ok ; for ( uint256 i 0 ; i < registrants . length ; i + + ) { ok unregister User ( self , registrants [ i ] ) ; } return ok ; }
function swap Registration ( Vesting Storage storage self , address replacement Registrant ) public returns ( bool ) { require ( replacement Registrant ! 0 ) ; require ( self . holding Amount [ replacement Registrant ] [ 0 ] 0 ) ; uint256 vest Amount self . holding Amount [ msg . sender ] [ 0 ] ; uint256 bonus self . holding Amount [ msg . sender ] [ 1 ] ; uint256 withdrawn Amount self . has Withdrawn [ msg . sender ] ; require ( vest Amount > 0 ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . has Withdrawn [ msg . sender ] 0 ; self . holding Amount [ replacement Registrant ] [ 0 ] vest Amount ; self . holding Amount [ replacement Registrant ] [ 1 ] bonus ; self . has Withdrawn [ replacement Registrant ] withdrawn Amount ; Log Registration Replaced ( msg . sender , replacement Registrant , self . has Withdrawn [ replacement Registrant ] ) ; return true ; }
function calculate Withdrawal ( Vesting Storage storage self , address beneficiary ) internal view returns ( uint256 ) { require ( beneficiary ! 0 ) ; require ( self . holding Amount [ beneficiary ] [ 0 ] > 0 ) ; require ( self . num Registered > 0 ) ; bool err ; uint256 num Intervals ( now self . start Time ) self . time Interval ; uint256 amount Released ( ( num Intervals self . percent Per Interval ) self . holding Amount [ beneficiary ] [ 0 ] ) 100000 ; ( err , amount Released ) amount Released . minus ( self . has Withdrawn [ beneficiary ] ) ; return amount Released ; }
function withdraw ETH ( Vesting Storage storage self ) public returns ( bool ) { require ( now > self . start Time ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ msg . sender ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; uint256 bonus Amount self . holding Amount [ msg . sender ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ msg . sender ] [ 0 ] + self . holding Amount [ msg . sender ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ msg . sender ] ) ; require ( ! err ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; } } self . has Withdrawn [ msg . sender ] + withdraw Amount ; msg . sender . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( msg . sender , withdraw Amount ) ; return true ; }
function withdraw Tokens ( Vesting Storage storage self , Crowdsale Token token ) public returns ( bool ) { require ( now > self . start Time ) ; require ( self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ msg . sender ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; uint256 bonus Amount self . holding Amount [ msg . sender ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; ok token . burn Token ( bonus Amount ) ; require ( ok ) ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ msg . sender ] [ 0 ] + self . holding Amount [ msg . sender ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ msg . sender ] ) ; require ( ! err ) ; self . holding Amount [ msg . sender ] [ 0 ] 0 ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , msg . sender ) ; } } self . has Withdrawn [ msg . sender ] + withdraw Amount ; ok token . transfer ( msg . sender , withdraw Amount ) ; require ( ok ) ; Log Tokens Withdrawn ( msg . sender , withdraw Amount ) ; return true ; }
function send ETH ( Vesting Storage storage self , address beneficiary ) public returns ( bool ) { require ( now > self . start Time ) ; require ( msg . sender self . owner ) ; require ( ! self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ beneficiary ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; uint256 bonus Amount self . holding Amount [ beneficiary ] [ 1 ] ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; self . contract Balance + bonus Amount ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ beneficiary ] [ 0 ] + self . holding Amount [ beneficiary ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ beneficiary ] ) ; require ( ! err ) ; self . holding Amount [ beneficiary ] [ 0 ] 0 ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; } } self . has Withdrawn [ beneficiary ] + withdraw Amount ; beneficiary . transfer ( withdraw Amount ) ; Log ETH Withdrawn ( beneficiary , withdraw Amount ) ; return true ; }
function send Tokens ( Vesting Storage storage self , Crowdsale Token token , address beneficiary ) public returns ( bool ) { require ( now > self . start Time ) ; require ( msg . sender self . owner ) ; require ( self . is Token ) ; bool ok ; bool err ; uint256 withdraw Amount ; if ( ( now < self . end Time ) & & ( self . holding Amount [ beneficiary ] [ 1 ] > 0 ) ) { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; uint256 bonus Amount self . holding Amount [ beneficiary ] [ 1 ] ; self . holding Amount [ msg . sender ] [ 1 ] 0 ; ok token . burn Token ( bonus Amount ) ; } else { if ( now > self . end Time ) { withdraw Amount self . holding Amount [ beneficiary ] [ 0 ] + self . holding Amount [ beneficiary ] [ 1 ] ; ( ok , withdraw Amount ) withdraw Amount . minus ( self . has Withdrawn [ beneficiary ] ) ; require ( ! err ) ; self . holding Amount [ beneficiary ] [ 0 ] 0 ; self . holding Amount [ beneficiary ] [ 1 ] 0 ; } else { withdraw Amount calculate Withdrawal ( self , beneficiary ) ; } } self . has Withdrawn [ beneficiary ] + withdraw Amount ; ok token . transfer ( beneficiary , withdraw Amount ) ; require ( ok ) ; Log Tokens Withdrawn ( beneficiary , withdraw Amount ) ; return true ; }
function owner Withdraw Extra ETH ( Vesting Storage storage self ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now > self . end Time ) ; require ( ! self . is Token ) ; uint256 contract Balance this . balance ; self . contract Balance 0 ; self . owner . transfer ( contract Balance ) ; Log ETH Withdrawn ( self . owner , contract Balance ) ; return true ; }
function owner Withdraw Extra Tokens ( Vesting Storage storage self , Crowdsale Token token ) public returns ( bool ) { require ( msg . sender self . owner ) ; require ( now > self . end Time ) ; require ( self . is Token ) ; uint256 contract Balance token . balance Of ( this ) ; self . contract Balance 0 ; token . transfer ( self . owner , contract Balance ) ; Log Tokens Withdrawn ( self . owner , contract Balance ) ; return true ; }
function get Percent Released ( Vesting Storage storage self ) public view returns ( uint256 ) { require ( now > self . start Time ) ; return ( self . percent Per Interval ( ( now self . start Time ) self . time Interval ) ) 1000 ; }
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log User Registered ( address registrant ) ;
event Log User Un Registered ( address registrant ) ;
event Log Registration Replaced ( address current Registrant , address new Registrant , uint256 amount Withdrawn ) ;
event Log ETH Withdrawn ( address beneficiary , uint256 amount ) ;
event Log Error Msg ( uint256 amount , string Msg ) ;
event Log User Registered ( address registrant , uint256 vest Amount , uint256 bonus ) ;
event Log User Un Registered ( address registrant ) ;
event Log Registration Replaced ( address current Registrant , address new Registrant , uint256 amount Withdrawn ) ;
event Log Tokens Withdrawn ( address beneficiary , uint256 amount ) ;
function check Change Owner Args ( uint256 from , uint256 to )
function check New Owner Args ( uint256 index , uint256 length , uint256 max )
function check Remove Owner Args ( uint256 index , uint256 length , uint256 min )
function check Required Change ( uint256 new Required , uint256 length )
function calc Confirms Needed ( uint256 required , uint256 count ) private pure returns ( uint256 ) { return required count ; }
function change Owner ( Wallet Main Lib . Wallet Data storage self ,
function add Owner ( Wallet Main Lib . Wallet Data storage self ,
function remove Owner ( Wallet Main Lib . Wallet Data storage self ,
function change Required Admin ( Wallet Main Lib . Wallet Data storage self ,
function change Required Major ( Wallet Main Lib . Wallet Data storage self ,
function change Required Minor ( Wallet Main Lib . Wallet Data storage self ,
function change Major Threshold ( Wallet Main Lib . Wallet Data storage self ,
function get Owners ( Wallet Main Lib . Wallet Data storage self ) public view returns ( address [ 51 ] ) { address [ 51 ] memory o ; for ( uint256 i 0 ; i < self . owners . length ; i + + ) { o [ i ] self . owners [ i ] ; } return o ; }
function get Owner Index ( Wallet Main Lib . Wallet Data storage self , address owner ) public view returns ( uint256 ) { return self . owner Index [ owner ] ; }
function get Max Owners ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . max Owners ; }
function get Owner Count ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . owners . length 1 ; }
function get Required Admin ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Admin ; }
function get Required Minor ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Minor ; }
function get Required Major ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Major ; }
function get Current Spend ( Wallet Main Lib . Wallet Data storage self , address token ) public view returns ( uint256 [ 2 ] ) { uint256 [ 2 ] memory cs ; cs [ 0 ] self . current Spend [ token ] [ 0 ] ; cs [ 1 ] self . current Spend [ token ] [ 1 ] ; return cs ; }
function get Major Threshold ( Wallet Main Lib . Wallet Data storage self , address token ) public view returns ( uint256 ) { return self . major Threshold [ token ] ; }
function get Transaction Length ( Wallet Main Lib . Wallet Data storage self , bytes32 id ) public view returns ( uint256 ) { return self . transaction Info [ id ] . length ; }
function get Transaction Confirms ( Wallet Main Lib . Wallet Data storage self ,
function get Transaction Confirm Count ( Wallet Main Lib . Wallet Data storage self ,
function get Transaction Success ( Wallet Main Lib . Wallet Data storage self ,
function init ( Wallet Data storage self ,
function check Not Confirmed ( Wallet Data storage self , bytes32 id , uint256 tx Index )
function calc Confirms Needed ( uint256 required , uint256 count ) public pure returns ( uint256 ) { return required count ; }
function get Amount ( bytes tx Data ) public pure returns ( bool , uint256 ) { bytes32 get Sig ; bytes4 sig ; transfer func signature approve func signature transfer From func signature bool transfer ; bytes32 amount Data ; uint256 amount ; assembly { get Sig : mload ( add ( tx Data , 0x20 ) ) } sig bytes4 ( get Sig ) ; if ( sig t Sig | | sig a Sig ) { transfer true ; assembly { amount Data : mload ( add ( tx Data , 0x44 ) ) } amount uint256 ( amount Data ) ; } else if ( sig tf Sig ) { transfer true ; assembly { amount Data : mload ( add ( tx Data , 0x64 ) ) } amount uint256 ( amount Data ) ; } return ( transfer , amount ) ; }
function get Required ( Wallet Data storage self ,
function create Contract ( bytes tx Data , uint256 value ) public { address new Contract ; bool all Good ; assembly { new Contract : create ( value , add ( tx Data , 0x20 ) , mload ( tx Data ) ) all Good : gt ( extcodesize ( new Contract ) , 0 ) } require ( all Good ) ; Log Contract Created ( new Contract , value ) ; }
function serve Tx ( Wallet Data storage self ,
function confirm Tx ( Wallet Data storage self , bytes32 id )
function revoke Confirm ( Wallet Data storage self , bytes32 id )
function sum Elements ( uint256 [ ] storage self ) public view returns ( uint256 sum ) { assembly { mstore ( 0x60 , self slot ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { sum : add ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , sum ) } } }
function get Max ( uint256 [ ] storage self ) public view returns ( uint256 max Value ) { assembly { mstore ( 0x60 , self slot ) max Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , max Value ) case 1 { max Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function get Min ( uint256 [ ] storage self ) public view returns ( uint256 min Value ) { assembly { mstore ( 0x60 , self slot ) min Value : sload ( sha3 ( 0x60 , 0x20 ) ) for { let i : 0 } lt ( i , sload ( self slot ) ) { i : add ( i , 1 ) } { switch gt ( sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) , min Value ) case 0 { min Value : sload ( add ( sha3 ( 0x60 , 0x20 ) , i ) ) } } } }
function index Of ( uint256 [ ] storage self , uint256 value , bool is Sorted )
function get Parent I ( uint256 index ) private pure returns ( uint256 p I ) { uint256 i index 1 ; p I i 2 ; }
function get Left Child I ( uint256 index ) private pure returns ( uint256 lc I ) { uint256 i index 2 ; lc I i + 1 ; }
function heap Sort ( uint256 [ ] storage self ) public { uint256 end self . length 1 ; uint256 start get Parent I ( end ) ; uint256 root start ; uint256 l Child ; uint256 r Child ; uint256 swap ; uint256 temp ; while ( start > 0 ) { root start ; l Child get Left Child I ( start ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } if ( start 0 ) break ; else start start 1 ; } while ( end > 0 ) { temp self [ end ] ; self [ end ] self [ 0 ] ; self [ 0 ] temp ; end end 1 ; root 0 ; l Child get Left Child I ( 0 ) ; while ( l Child < end ) { r Child l Child + 1 ; swap root ; if ( self [ swap ] < self [ l Child ] ) swap l Child ; if ( ( r Child < end ) & & ( self [ swap ] < self [ r Child ] ) ) swap r Child ; if ( swap root ) l Child end + 1 ; else { temp self [ swap ] ; self [ swap ] self [ root ] ; self [ root ] temp ; root swap ; l Child get Left Child I ( root ) ; } } } }
function uniq ( uint256 [ ] storage self ) public returns ( uint256 length ) { bool contains ; uint256 index ; for ( uint256 i 0 ; i < self . length ; i + + ) { ( contains , index ) index Of ( self , self [ i ] , false ) ; if ( i > index ) { for ( uint256 j i ; j < self . length 1 ; j + + ) { self [ j ] self [ j + 1 ] ; } delete self [ self . length 1 ] ; self . length ; i ; } } length self . length ; }
function times ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : mul ( a , b ) switch or ( iszero ( b ) , eq ( div ( res , b ) , a ) ) case 0 { err : 1 res : 0 } } }
function divided By ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 i ) { uint256 res ; assembly { switch iszero ( b ) case 0 { res : div ( a , b ) let loc : mload ( 0x40 ) mstore ( add ( loc , 0x20 ) , res ) i : mload ( add ( loc , 0x20 ) ) } default { err : 1 i : 0 } } }
function plus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : add ( a , b ) switch and ( eq ( sub ( res , b ) , a ) , or ( gt ( res , b ) , eq ( res , b ) ) ) case 0 { err : 1 res : 0 } } }
function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , 1 ) case 0 { err : 1 res : 0 } } }
function init ( Token Storage storage self ,
function transfer ( Token Storage storage self , address to , uint256 value ) public returns ( bool ) { require ( to ! address ( 0 ) ) ; bool err ; uint256 balance ; ( err , balance ) self . balances [ msg . sender ] . minus ( value ) ; require ( ! err ) ; self . balances [ msg . sender ] balance ; self . balances [ to ] self . balances [ to ] + value ; Transfer ( msg . sender , to , value ) ; return true ; }
function transfer From ( Token Storage storage self ,
function balance Of ( Token Storage storage self , address owner ) public view returns ( uint256 balance ) { return self . balances [ owner ] ; }
function approve ( Token Storage storage self , address spender , uint256 value ) public returns ( bool ) { require ( ( value 0 ) | | ( self . allowed [ msg . sender ] [ spender ] 0 ) ) ; self . allowed [ msg . sender ] [ spender ] value ; Approval ( msg . sender , spender , value ) ; return true ; }
function allowance ( Token Storage storage self , address owner , address spender )
function approve Change ( Token Storage storage self , address spender , uint256 value Change , bool increase )
function change Owner ( Token Storage storage self , address new Owner ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & ( new Owner > 0 ) ) ; self . owner new Owner ; Owner Change ( msg . sender , new Owner ) ; return true ; }
function mint Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { require ( ( self . owner msg . sender ) & & self . still Minting ) ; uint256 new Amount ; bool err ; ( err , new Amount ) self . total Supply . plus ( amount ) ; require ( ! err ) ; self . total Supply new Amount ; self . balances [ self . owner ] self . balances [ self . owner ] + amount ; Transfer ( 0x0 , self . owner , amount ) ; return true ; }
function close Mint ( Token Storage storage self ) public returns ( bool ) { require ( self . owner msg . sender ) ; self . still Minting false ; Minting Closed ( true ) ; return true ; }
function burn Token ( Token Storage storage self , uint256 amount ) public returns ( bool ) { uint256 new Balance ; bool err ; ( err , new Balance ) self . balances [ msg . sender ] . minus ( amount ) ; require ( ! err ) ; self . balances [ msg . sender ] new Balance ; self . total Supply self . total Supply amount ; Burn ( msg . sender , amount ) ; Transfer ( msg . sender , 0x0 , amount ) ; return true ; }
function check Change Owner Args ( uint256 from , uint256 to )
function check New Owner Args ( uint256 index , uint256 length , uint256 max )
function check Remove Owner Args ( uint256 index , uint256 length , uint256 min )
function check Required Change ( uint256 new Required , uint256 length )
function calc Confirms Needed ( uint256 required , uint256 count ) private pure returns ( uint256 ) { return required count ; }
function change Owner ( Wallet Main Lib . Wallet Data storage self ,
function add Owner ( Wallet Main Lib . Wallet Data storage self ,
function remove Owner ( Wallet Main Lib . Wallet Data storage self ,
function change Required Admin ( Wallet Main Lib . Wallet Data storage self ,
function change Required Major ( Wallet Main Lib . Wallet Data storage self ,
function change Required Minor ( Wallet Main Lib . Wallet Data storage self ,
function change Major Threshold ( Wallet Main Lib . Wallet Data storage self ,
function get Owners ( Wallet Main Lib . Wallet Data storage self ) public view returns ( address [ 51 ] ) { address [ 51 ] memory o ; for ( uint256 i 0 ; i < self . owners . length ; i + + ) { o [ i ] self . owners [ i ] ; } return o ; }
function get Owner Index ( Wallet Main Lib . Wallet Data storage self , address owner ) public view returns ( uint256 ) { return self . owner Index [ owner ] ; }
function get Max Owners ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . max Owners ; }
function get Owner Count ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . owners . length 1 ; }
function get Required Admin ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Admin ; }
function get Required Minor ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Minor ; }
function get Required Major ( Wallet Main Lib . Wallet Data storage self ) public view returns ( uint256 ) { return self . required Major ; }
function get Current Spend ( Wallet Main Lib . Wallet Data storage self , address token ) public view returns ( uint256 [ 2 ] ) { uint256 [ 2 ] memory cs ; cs [ 0 ] self . current Spend [ token ] [ 0 ] ; cs [ 1 ] self . current Spend [ token ] [ 1 ] ; return cs ; }
function get Major Threshold ( Wallet Main Lib . Wallet Data storage self , address token ) public view returns ( uint256 ) { return self . major Threshold [ token ] ; }
function get Transaction Length ( Wallet Main Lib . Wallet Data storage self , bytes32 id ) public view returns ( uint256 ) { return self . transaction Info [ id ] . length ; }
function get Transaction Confirms ( Wallet Main Lib . Wallet Data storage self ,
function get Transaction Confirm Count ( Wallet Main Lib . Wallet Data storage self ,
function get Transaction Success ( Wallet Main Lib . Wallet Data storage self ,
function init ( Wallet Data storage self ,
function check Not Confirmed ( Wallet Data storage self , bytes32 id , uint256 tx Index )
function calc Confirms Needed ( uint256 required , uint256 count ) public pure returns ( uint256 ) { return required count ; }
function get Amount ( bytes tx Data ) public pure returns ( bool , uint256 ) { bytes32 get Sig ; bytes4 sig ; transfer func signature approve func signature transfer From func signature bool transfer ; bytes32 amount Data ; uint256 amount ; assembly { get Sig : mload ( add ( tx Data , 0x20 ) ) } sig bytes4 ( get Sig ) ; if ( sig t Sig | | sig a Sig ) { transfer true ; assembly { amount Data : mload ( add ( tx Data , 0x44 ) ) } amount uint256 ( amount Data ) ; } else if ( sig tf Sig ) { transfer true ; assembly { amount Data : mload ( add ( tx Data , 0x64 ) ) } amount uint256 ( amount Data ) ; } return ( transfer , amount ) ; }
function get Required ( Wallet Data storage self ,
function create Contract ( bytes tx Data , uint256 value ) public { address new Contract ; bool all Good ; assembly { new Contract : create ( value , add ( tx Data , 0x20 ) , mload ( tx Data ) ) all Good : gt ( extcodesize ( new Contract ) , 0 ) } require ( all Good ) ; Log Contract Created ( new Contract , value ) ; }
function serve Tx ( Wallet Data storage self ,
function confirm Tx ( Wallet Data storage self , bytes32 id )
function revoke Confirm ( Wallet Data storage self , bytes32 id )
event Role Admin Changed ( bytes32 indexed role , bytes32 indexed previous Admin Role , bytes32 indexed new Admin Role ) ;
event Role Granted ( bytes32 indexed role , address indexed account , address indexed sender ) ;
event Role Revoked ( bytes32 indexed role , address indexed account , address indexed sender ) ;
modifier only Role ( bytes32 role ) { check Role ( role , msg Sender ( ) ) ; ; }
function supports Interface ( bytes4 interface Id ) public view virtual override returns ( bool ) { return interface Id type ( I Access Control ) . interface Id | | super . supports Interface ( interface Id ) ; }
function has Role ( bytes32 role , address account ) public view override returns ( bool ) { return roles [ role ] . members [ account ] ; }
function check Role ( bytes32 role , address account ) internal view { if ( ! has Role ( role , account ) ) { revert ( string ( abi . encode Packed ( " Access Control : account " , Strings . to Hex String ( uint160 ( account ) , 20 ) , " is missing role " , Strings . to Hex String ( uint256 ( role ) , 32 ) ) ) ) ; } }
function get Role Admin ( bytes32 role ) public view override returns ( bytes32 ) { return roles [ role ] . admin Role ; }
function grant Role ( bytes32 role , address account ) public virtual override only Role ( get Role Admin ( role ) ) { grant Role ( role , account ) ; }
function revoke Role ( bytes32 role , address account ) public virtual override only Role ( get Role Admin ( role ) ) { revoke Role ( role , account ) ; }
function renounce Role ( bytes32 role , address account ) public virtual override { require ( account msg Sender ( ) , " Access Control : can only renounce roles for self " ) ; revoke Role ( role , account ) ; }
function setup Role ( bytes32 role , address account ) internal virtual { grant Role ( role , account ) ; }
function set Role Admin ( bytes32 role , bytes32 admin Role ) internal virtual { emit Role Admin Changed ( role , get Role Admin ( role ) , admin Role ) ; roles [ role ] . admin Role admin Role ; }
function supports Interface ( bytes4 interface Id ) public view virtual override returns ( bool ) { return interface Id type ( I Access Control Enumerable ) . interface Id | | super . supports Interface ( interface Id ) ; }
function get Role Member ( bytes32 role , uint256 index ) public view override returns ( address ) { return role Members [ role ] . at ( index ) ; }
function get Role Member Count ( bytes32 role ) public view override returns ( uint256 ) { return role Members [ role ] . length ( ) ; }
function grant Role ( bytes32 role , address account ) public virtual override { super . grant Role ( role , account ) ; role Members [ role ] . add ( account ) ; }
function revoke Role ( bytes32 role , address account ) public virtual override { super . revoke Role ( role , account ) ; role Members [ role ] . remove ( account ) ; }
function renounce Role ( bytes32 role , address account ) public virtual override { super . renounce Role ( role , account ) ; role Members [ role ] . remove ( account ) ; }
function setup Role ( bytes32 role , address account ) internal virtual override { super . setup Role ( role , account ) ; role Members [ role ] . add ( account ) ; }
function owner ( ) public view virtual returns ( address ) { return owner ; }
modifier only Owner ( ) { require ( owner ( ) msg Sender ( ) , " Ownable : caller is not the owner " ) ; ; }
function renounce Ownership ( ) public virtual only Owner { emit Ownership Transferred ( owner , address ( 0 ) ) ; owner address ( 0 ) ; }
function transfer Ownership ( address new Owner ) public virtual only Owner { require ( new Owner ! address ( 0 ) , " Ownable : new owner is the zero address " ) ; emit Ownership Transferred ( owner , new Owner ) ; owner new Owner ; }
function total Shares ( ) public view returns ( uint256 ) { return total Shares ; }
function total Released ( ) public view returns ( uint256 ) { return total Released ; }
function shares ( address account ) public view returns ( uint256 ) { return shares [ account ] ; }
function released ( address account ) public view returns ( uint256 ) { return released [ account ] ; }
function payee ( uint256 index ) public view returns ( address ) { return payees [ index ] ; }
function release ( address payable account ) public virtual { require ( shares [ account ] > 0 , " Payment Splitter : account has no shares " ) ; uint256 total Received address ( this ) . balance + total Released ; uint256 payment total Received shares [ account ] total Shares released [ account ] ; require ( payment ! 0 , " Payment Splitter : account is not due payment " ) ; released [ account ] released [ account ] + payment ; total Released total Released + payment ; Address . send Value ( account , payment ) ; emit Payment Released ( account , payment ) ; }
function add Payee ( address account , uint256 shares ) private { require ( account ! address ( 0 ) , " Payment Splitter : account is the zero address " ) ; require ( shares > 0 , " Payment Splitter : shares are 0 " ) ; require ( shares [ account ] 0 , " Payment Splitter : account already has shares " ) ; payees . push ( account ) ; shares [ account ] shares ; total Shares total Shares + shares ; emit Payee Added ( account , shares ) ; }
event Call Scheduled ( bytes32 indexed id , uint256 indexed index , address target , uint256 value , bytes data , bytes32 predecessor , uint256 delay ) ;
event Call Executed ( bytes32 indexed id , uint256 indexed index , address target , uint256 value , bytes data ) ;
event Cancelled ( bytes32 indexed id ) ;
event Min Delay Change ( uint256 old Duration , uint256 new Duration ) ;
modifier only Role Or Open Role ( bytes32 role ) { if ( ! has Role ( role , address ( 0 ) ) ) { check Role ( role , msg Sender ( ) ) ; } ; }
function is Operation ( bytes32 id ) public view virtual returns ( bool pending ) { return get Timestamp ( id ) > 0 ; }
function is Operation Pending ( bytes32 id ) public view virtual returns ( bool pending ) { return get Timestamp ( id ) > DONE TIMESTAMP ; }
function is Operation Ready ( bytes32 id ) public view virtual returns ( bool ready ) { uint256 timestamp get Timestamp ( id ) ; return timestamp > DONE TIMESTAMP & & timestamp < block . timestamp ; }
function is Operation Done ( bytes32 id ) public view virtual returns ( bool done ) { return get Timestamp ( id ) DONE TIMESTAMP ; }
function get Timestamp ( bytes32 id ) public view virtual returns ( uint256 timestamp ) { return timestamps [ id ] ; }
function get Min Delay ( ) public view virtual returns ( uint256 duration ) { return min Delay ; }
function hash Operation ( address target , uint256 value , bytes calldata data , bytes32 predecessor , bytes32 salt ) public pure virtual returns ( bytes32 hash ) { return keccak256 ( abi . encode ( target , value , data , predecessor , salt ) ) ; }
function hash Operation Batch ( address [ ] calldata targets , uint256 [ ] calldata values , bytes [ ] calldata datas , bytes32 predecessor , bytes32 salt ) public pure virtual returns ( bytes32 hash ) { return keccak256 ( abi . encode ( targets , values , datas , predecessor , salt ) ) ; }
function schedule ( address target , uint256 value , bytes calldata data , bytes32 predecessor , bytes32 salt , uint256 delay ) public virtual only Role ( PROPOSER ROLE ) { bytes32 id hash Operation ( target , value , data , predecessor , salt ) ; schedule ( id , delay ) ; emit Call Scheduled ( id , 0 , target , value , data , predecessor , delay ) ; }
function schedule Batch ( address [ ] calldata targets , uint256 [ ] calldata values , bytes [ ] calldata datas , bytes32 predecessor , bytes32 salt , uint256 delay ) public virtual only Role ( PROPOSER ROLE ) { require ( targets . length values . length , " Timelock Controller : length mismatch " ) ; require ( targets . length datas . length , " Timelock Controller : length mismatch " ) ; bytes32 id hash Operation Batch ( targets , values , datas , predecessor , salt ) ; schedule ( id , delay ) ; for ( uint256 i 0 ; i < targets . length ; + + i ) { emit Call Scheduled ( id , i , targets [ i ] , values [ i ] , datas [ i ] , predecessor , delay ) ; } }
function schedule ( bytes32 id , uint256 delay ) private { require ( ! is Operation ( id ) , " Timelock Controller : operation already scheduled " ) ; require ( delay > get Min Delay ( ) , " Timelock Controller : insufficient delay " ) ; timestamps [ id ] block . timestamp + delay ; }
function cancel ( bytes32 id ) public virtual only Role ( PROPOSER ROLE ) { require ( is Operation Pending ( id ) , " Timelock Controller : operation cannot be cancelled " ) ; delete timestamps [ id ] ; emit Cancelled ( id ) ; }
function execute ( address target , uint256 value , bytes calldata data , bytes32 predecessor , bytes32 salt ) public payable virtual only Role Or Open Role ( EXECUTOR ROLE ) { bytes32 id hash Operation ( target , value , data , predecessor , salt ) ; before Call ( predecessor ) ; call ( id , 0 , target , value , data ) ; after Call ( id ) ; }
function execute Batch ( address [ ] calldata targets , uint256 [ ] calldata values , bytes [ ] calldata datas , bytes32 predecessor , bytes32 salt ) public payable virtual only Role Or Open Role ( EXECUTOR ROLE ) { require ( targets . length values . length , " Timelock Controller : length mismatch " ) ; require ( targets . length datas . length , " Timelock Controller : length mismatch " ) ; bytes32 id hash Operation Batch ( targets , values , datas , predecessor , salt ) ; before Call ( predecessor ) ; for ( uint256 i 0 ; i < targets . length ; + + i ) { call ( id , i , targets [ i ] , values [ i ] , datas [ i ] ) ; } after Call ( id ) ; }
function before Call ( bytes32 predecessor ) private view { require ( predecessor bytes32 ( 0 ) | | is Operation Done ( predecessor ) , " Timelock Controller : missing dependency " ) ; }
function after Call ( bytes32 id ) private { require ( is Operation Ready ( id ) , " Timelock Controller : operation is not ready " ) ; timestamps [ id ] DONE TIMESTAMP ; }
function call ( bytes32 id , uint256 index , address target , uint256 value , bytes calldata data ) private { ( bool success , ) target . call { value : value } ( data ) ; require ( success , " Timelock Controller : underlying transaction reverted " ) ; emit Call Executed ( id , index , target , value , data ) ; }
function update Delay ( uint256 new Delay ) external virtual { require ( msg . sender address ( this ) , " Timelock Controller : caller must be timelock " ) ; emit Min Delay Change ( min Delay , new Delay ) ; min Delay new Delay ; }
function is Valid Signature ( bytes32 hash , bytes memory signature ) external view returns ( bytes4 magic Value ) ;
function on Flash Loan (
function max Flash Loan (
function flash Fee (
function flash Loan (
event Before Token Transfer ( ) ;
function call Transfer ( address dest , uint256 amount ) public { async Transfer ( dest , amount ) ; }
function do Add ( uint256 a , uint256 b ) public pure returns ( uint256 ) { return Safe Math . add ( a , b ) ; }
function supports Interface ( bytes4 interface Id ) public view override returns ( bool ) { return supported Interfaces [ interface Id ] ; }
function register Interface ( bytes4 interface Id ) internal { require ( interface Id ! 0xffffffff , " ERC165Interfaces Supported : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function authorize Upgrade ( address ) internal virtual override { }
function clone ( address implementation ) internal returns ( address instance ) { assembly { let ptr : mload ( 0x40 ) mstore ( ptr , 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000 ) mstore ( add ( ptr , 0x14 ) , shl ( 0x60 , implementation ) ) mstore ( add ( ptr , 0x28 ) , 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000 ) instance : create ( 0 , ptr , 0x37 ) } require ( instance ! address ( 0 ) , " ERC1167 : create failed " ) ; }
function clone Deterministic ( address implementation , bytes32 salt ) internal returns ( address instance ) { assembly { let ptr : mload ( 0x40 ) mstore ( ptr , 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000 ) mstore ( add ( ptr , 0x14 ) , shl ( 0x60 , implementation ) ) mstore ( add ( ptr , 0x28 ) , 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000 ) instance : create2 ( 0 , ptr , 0x37 , salt ) } require ( instance ! address ( 0 ) , " ERC1167 : create2 failed " ) ; }
function predict Deterministic Address ( address implementation , bytes32 salt , address deployer ) internal pure returns ( address predicted ) { assembly { let ptr : mload ( 0x40 ) mstore ( ptr , 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000 ) mstore ( add ( ptr , 0x14 ) , shl ( 0x60 , implementation ) ) mstore ( add ( ptr , 0x28 ) , 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000 ) mstore ( add ( ptr , 0x38 ) , shl ( 0x60 , deployer ) ) mstore ( add ( ptr , 0x4c ) , salt ) mstore ( add ( ptr , 0x6c ) , keccak256 ( ptr , 0x37 ) ) predicted : keccak256 ( add ( ptr , 0x37 ) , 0x55 ) } }
function predict Deterministic Address ( address implementation , bytes32 salt ) internal view returns ( address predicted ) { return predict Deterministic Address ( implementation , salt , address ( this ) ) ; }
function delegate ( address implementation ) internal virtual { assembly { calldatacopy ( 0 , 0 , calldatasize ( ) ) let result : delegatecall ( gas ( ) , implementation , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) switch result case 0 { revert ( 0 , returndatasize ( ) ) } default { return ( 0 , returndatasize ( ) ) } } }
function implementation ( ) internal view virtual returns ( address ) ;
function fallback ( ) internal virtual { before Fallback ( ) ; delegate ( implementation ( ) ) ; }
function before Fallback ( ) internal virtual { }
function beacon ( ) internal view virtual returns ( address ) { return get Beacon ( ) ; }
function implementation ( ) internal view virtual override returns ( address ) { return I Beacon ( get Beacon ( ) ) . implementation ( ) ; }
function set Beacon ( address beacon , bytes memory data ) internal virtual { upgrade Beacon To And Call ( beacon , data , false ) ; }
function implementation ( ) external view returns ( address ) ;
event Upgraded ( address indexed implementation ) ;
function implementation ( ) public view virtual override returns ( address ) { return implementation ; }
function upgrade To ( address new Implementation ) public virtual only Owner { set Implementation ( new Implementation ) ; emit Upgraded ( new Implementation ) ; }
function set Implementation ( address new Implementation ) private { require ( Address . is Contract ( new Implementation ) , " Upgradeable Beacon : implementation is not a contract " ) ; implementation new Implementation ; }
function implementation ( ) internal view virtual override returns ( address impl ) { return ERC1967Storage . get Implementation ( ) ; }
function get Implementation ( ) internal view returns ( address ) { return Storage Slot . get Address Slot ( IMPLEMENTATION SLOT ) . value ; }
function set Implementation ( address new Implementation ) internal { require ( Address . is Contract ( new Implementation ) , " ERC1967 : new implementation is not a contract " ) ; Storage Slot . get Address Slot ( IMPLEMENTATION SLOT ) . value new Implementation ; }
function get Beacon ( ) internal view returns ( address ) { return Storage Slot . get Address Slot ( BEACON SLOT ) . value ; }
function set Beacon ( address new Beacon ) internal { require ( Address . is Contract ( new Beacon ) , " ERC1967 : new beacon is not a contract " ) ; require ( Address . is Contract ( I Beacon ( new Beacon ) . implementation ( ) ) , " ERC1967 : beacon implementation is not a contract " ) ; Storage Slot . get Address Slot ( BEACON SLOT ) . value new Beacon ; }
function get Admin ( ) internal view returns ( address ) { return Storage Slot . get Address Slot ( ADMIN SLOT ) . value ; }
function set Admin ( address new Admin ) internal { require ( new Admin ! address ( 0 ) , " ERC1967 : new admin is the zero address " ) ; Storage Slot . get Address Slot ( ADMIN SLOT ) . value new Admin ; }
event Upgraded ( address indexed implementation ) ;
event Beacon Upgraded ( address indexed beacon ) ;
event Admin Changed ( address previous Admin , address new Admin ) ;
function upgrade To ( address new Implementation ) internal { set Implementation ( new Implementation ) ; emit Upgraded ( new Implementation ) ; }
function upgrade To And Call ( address new Implementation , bytes memory data , bool force Call ) internal { set Implementation ( new Implementation ) ; emit Upgraded ( new Implementation ) ; if ( data . length > 0 | | force Call ) { Address . function Delegate Call ( new Implementation , data ) ; } }
function upgrade To And Call Secure ( address new Implementation , bytes memory data , bool force Call ) internal { address old Implementation get Implementation ( ) ; set Implementation ( new Implementation ) ; if ( data . length > 0 | | force Call ) { Address . function Delegate Call ( new Implementation , data ) ; } Storage Slot . Boolean Slot storage rollback Testing Storage Slot . get Boolean Slot ( ROLLBACK SLOT ) ; if ( ! rollback Testing . value ) { rollback Testing . value true ; Address . function Delegate Call ( new Implementation , abi . encode With Signature ( " upgrade To ( address ) " , old Implementation ) ) ; rollback Testing . value false ; require ( old Implementation get Implementation ( ) , " ERC1967Upgrade : upgrade breaks further upgrades " ) ; set Implementation ( new Implementation ) ; emit Upgraded ( new Implementation ) ; } }
function upgrade Beacon To And Call ( address new Beacon , bytes memory data , bool force Call ) internal { set Beacon ( new Beacon ) ; emit Beacon Upgraded ( new Beacon ) ; if ( data . length > 0 | | force Call ) { Address . function Delegate Call ( I Beacon ( new Beacon ) . implementation ( ) , data ) ; } }
function change Admin ( address new Admin ) internal { emit Admin Changed ( get Admin ( ) , new Admin ) ; set Admin ( new Admin ) ; }
function get Proxy Implementation ( Transparent Upgradeable Proxy proxy ) public view virtual returns ( address ) { ( bool success , bytes memory returndata ) address ( proxy ) . staticcall ( hex " 5c60da1b " ) ; require ( success ) ; return abi . decode ( returndata , ( address ) ) ; }
function get Proxy Admin ( Transparent Upgradeable Proxy proxy ) public view virtual returns ( address ) { ( bool success , bytes memory returndata ) address ( proxy ) . staticcall ( hex " f851a440 " ) ; require ( success ) ; return abi . decode ( returndata , ( address ) ) ; }
function change Proxy Admin ( Transparent Upgradeable Proxy proxy , address new Admin ) public virtual only Owner { proxy . change Admin ( new Admin ) ; }
function upgrade ( Transparent Upgradeable Proxy proxy , address implementation ) public virtual only Owner { proxy . upgrade To ( implementation ) ; }
function upgrade And Call ( Transparent Upgradeable Proxy proxy , address implementation , bytes memory data ) public payable virtual only Owner { proxy . upgrade To And Call { value : msg . value } ( implementation , data ) ; }
modifier if Admin ( ) { if ( msg . sender get Admin ( ) ) { ; } else { fallback ( ) ; } }
function admin ( ) external if Admin returns ( address admin ) { admin get Admin ( ) ; }
function implementation ( ) external if Admin returns ( address implementation ) { implementation implementation ( ) ; }
function change Admin ( address new Admin ) external virtual if Admin { change Admin ( new Admin ) ; }
function upgrade To ( address new Implementation ) external if Admin { upgrade To And Call ( new Implementation , bytes ( " " ) , false ) ; }
function upgrade To And Call ( address new Implementation , bytes calldata data ) external payable if Admin { upgrade To And Call ( new Implementation , data , true ) ; }
function admin ( ) internal view virtual returns ( address ) { return get Admin ( ) ; }
function before Fallback ( ) internal virtual override { require ( msg . sender ! get Admin ( ) , " Transparent Upgradeable Proxy : admin cannot fallback to proxy target " ) ; super . before Fallback ( ) ; }
modifier initializer ( ) { require ( initializing | | ! initialized , " Initializable : contract is already initialized " ) ; bool is Top Level Call ! initializing ; if ( is Top Level Call ) { initializing true ; initialized true ; } ; if ( is Top Level Call ) { initializing false ; } }
event Paused ( address account ) ;
event Unpaused ( address account ) ;
function paused ( ) public view virtual returns ( bool ) { return paused ; }
modifier when Not Paused ( ) { require ( ! paused ( ) , " Pausable : paused " ) ; ; }
modifier when Paused ( ) { require ( paused ( ) , " Pausable : not paused " ) ; ; }
function pause ( ) internal virtual when Not Paused { paused true ; emit Paused ( msg Sender ( ) ) ; }
function unpause ( ) internal virtual when Paused { paused false ; emit Unpaused ( msg Sender ( ) ) ; }
function withdraw Payments ( address payable payee ) public virtual { escrow . withdraw ( payee ) ; }
function payments ( address dest ) public view returns ( uint256 ) { return escrow . deposits Of ( dest ) ; }
function async Transfer ( address dest , uint256 amount ) internal virtual { escrow . deposit { value : amount } ( dest ) ; }
modifier non Reentrant ( ) { require ( status ! ENTERED , " Reentrancy Guard : reentrant call " ) ; status ENTERED ; ; status NOT ENTERED ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( ERC165 , IERC165 ) returns ( bool ) { return interface Id type ( IERC1155 ) . interface Id | | interface Id type ( IERC1155Metadata URI ) . interface Id | | super . supports Interface ( interface Id ) ; }
function uri ( uint256 ) public view virtual override returns ( string memory ) { return uri ; }
function balance Of ( address account , uint256 id ) public view virtual override returns ( uint256 ) { require ( account ! address ( 0 ) , " ERC1155 : balance query for the zero address " ) ; return balances [ id ] [ account ] ; }
function balance Of Batch (
function set Approval For All ( address operator , bool approved ) public virtual override { require ( msg Sender ( ) ! operator , " ERC1155 : setting approval status for self " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
function is Approved For All ( address account , address operator ) public view virtual override returns ( bool ) { return operator Approvals [ account ] [ operator ] ; }
function safe Transfer From (
function safe Batch Transfer From (
function set URI ( string memory newuri ) internal virtual { uri newuri ; }
function mint ( address account , uint256 id , uint256 amount , bytes memory data ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , account , as Singleton Array ( id ) , as Singleton Array ( amount ) , data ) ; balances [ id ] [ account ] + amount ; emit Transfer Single ( operator , address ( 0 ) , account , id , amount ) ; do Safe Transfer Acceptance Check ( operator , address ( 0 ) , account , id , amount , data ) ; }
function mint Batch ( address to , uint256 [ ] memory ids , uint256 [ ] memory amounts , bytes memory data ) internal virtual { require ( to ! address ( 0 ) , " ERC1155 : mint to the zero address " ) ; require ( ids . length amounts . length , " ERC1155 : ids and amounts length mismatch " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , address ( 0 ) , to , ids , amounts , data ) ; for ( uint i 0 ; i < ids . length ; i + + ) { balances [ ids [ i ] ] [ to ] + amounts [ i ] ; } emit Transfer Batch ( operator , address ( 0 ) , to , ids , amounts ) ; do Safe Batch Transfer Acceptance Check ( operator , address ( 0 ) , to , ids , amounts , data ) ; }
function burn ( address account , uint256 id , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : burn from the zero address " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , account , address ( 0 ) , as Singleton Array ( id ) , as Singleton Array ( amount ) , " " ) ; uint256 account Balance balances [ id ] [ account ] ; require ( account Balance > amount , " ERC1155 : burn amount exceeds balance " ) ; balances [ id ] [ account ] account Balance amount ; emit Transfer Single ( operator , account , address ( 0 ) , id , amount ) ; }
function burn Batch ( address account , uint256 [ ] memory ids , uint256 [ ] memory amounts ) internal virtual { require ( account ! address ( 0 ) , " ERC1155 : burn from the zero address " ) ; require ( ids . length amounts . length , " ERC1155 : ids and amounts length mismatch " ) ; address operator msg Sender ( ) ; before Token Transfer ( operator , account , address ( 0 ) , ids , amounts , " " ) ; for ( uint i 0 ; i < ids . length ; i + + ) { uint256 id ids [ i ] ; uint256 amount amounts [ i ] ; uint256 account Balance balances [ id ] [ account ] ; require ( account Balance > amount , " ERC1155 : burn amount exceeds balance " ) ; balances [ id ] [ account ] account Balance amount ; } emit Transfer Batch ( operator , account , address ( 0 ) , ids , amounts ) ; }
function before Token Transfer (
event Transfer Single ( address indexed operator , address indexed from , address indexed to , uint256 id , uint256 value ) ;
event Transfer Batch ( address indexed operator , address indexed from , address indexed to , uint256 [ ] ids , uint256 [ ] values ) ;
event Approval For All ( address indexed account , address indexed operator , bool approved ) ;
event URI ( string value , uint256 indexed id ) ;
function balance Of ( address account , uint256 id ) external view returns ( uint256 ) ;
function balance Of Batch ( address [ ] calldata accounts , uint256 [ ] calldata ids ) external view returns ( uint256 [ ] memory ) ;
function set Approval For All ( address operator , bool approved ) external ;
function is Approved For All ( address account , address operator ) external view returns ( bool ) ;
function safe Transfer From ( address from , address to , uint256 id , uint256 amount , bytes calldata data ) external ;
function safe Batch Transfer From ( address from , address to , uint256 [ ] calldata ids , uint256 [ ] calldata amounts , bytes calldata data ) external ;
function on ERC1155Received (
function on ERC1155Batch Received (
function before Token Transfer (
function uri ( uint256 id ) external view returns ( string memory ) ;
function mint ( address to , uint256 id , uint256 amount , bytes memory data ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have minter role to mint " ) ; mint ( to , id , amount , data ) ; }
function mint Batch ( address to , uint256 [ ] memory ids , uint256 [ ] memory amounts , bytes memory data ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have minter role to mint " ) ; mint Batch ( to , ids , amounts , data ) ; }
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have pauser role to pause " ) ; pause ( ) ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC1155Preset Minter Pauser : must have pauser role to unpause " ) ; unpause ( ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( Access Control Enumerable , ERC1155 ) returns ( bool ) { return super . supports Interface ( interface Id ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( ERC165 , IERC165 ) returns ( bool ) { return interface Id type ( IERC1155Receiver ) . interface Id | | super . supports Interface ( interface Id ) ; }
function name ( ) public view virtual override returns ( string memory ) { return name ; }
function symbol ( ) public view virtual override returns ( string memory ) { return symbol ; }
function decimals ( ) public view virtual override returns ( uint8 ) { return 18 ; }
function total Supply ( ) public view virtual override returns ( uint256 ) { return total Supply ; }
function balance Of ( address account ) public view virtual override returns ( uint256 ) { return balances [ account ] ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( msg Sender ( ) , recipient , amount ) ; return true ; }
function allowance ( address owner , address spender ) public view virtual override returns ( uint256 ) { return allowances [ owner ] [ spender ] ; }
function approve ( address spender , uint256 amount ) public virtual override returns ( bool ) { approve ( msg Sender ( ) , spender , amount ) ; return true ; }
function transfer From ( address sender , address recipient , uint256 amount ) public virtual override returns ( bool ) { transfer ( sender , recipient , amount ) ; uint256 current Allowance allowances [ sender ] [ msg Sender ( ) ] ; require ( current Allowance > amount , " ERC20 : transfer amount exceeds allowance " ) ; approve ( sender , msg Sender ( ) , current Allowance amount ) ; return true ; }
function increase Allowance ( address spender , uint256 added Value ) public virtual returns ( bool ) { approve ( msg Sender ( ) , spender , allowances [ msg Sender ( ) ] [ spender ] + added Value ) ; return true ; }
function decrease Allowance ( address spender , uint256 subtracted Value ) public virtual returns ( bool ) { uint256 current Allowance allowances [ msg Sender ( ) ] [ spender ] ; require ( current Allowance > subtracted Value , " ERC20 : decreased allowance below zero " ) ; approve ( msg Sender ( ) , spender , current Allowance subtracted Value ) ; return true ; }
function transfer ( address sender , address recipient , uint256 amount ) internal virtual { require ( sender ! address ( 0 ) , " ERC20 : transfer from the zero address " ) ; require ( recipient ! address ( 0 ) , " ERC20 : transfer to the zero address " ) ; before Token Transfer ( sender , recipient , amount ) ; uint256 sender Balance balances [ sender ] ; require ( sender Balance > amount , " ERC20 : transfer amount exceeds balance " ) ; balances [ sender ] sender Balance amount ; balances [ recipient ] + amount ; emit Transfer ( sender , recipient , amount ) ; }
function mint ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : mint to the zero address " ) ; before Token Transfer ( address ( 0 ) , account , amount ) ; total Supply + amount ; balances [ account ] + amount ; emit Transfer ( address ( 0 ) , account , amount ) ; }
function burn ( address account , uint256 amount ) internal virtual { require ( account ! address ( 0 ) , " ERC20 : burn from the zero address " ) ; before Token Transfer ( account , address ( 0 ) , amount ) ; uint256 account Balance balances [ account ] ; require ( account Balance > amount , " ERC20 : burn amount exceeds balance " ) ; balances [ account ] account Balance amount ; total Supply amount ; emit Transfer ( account , address ( 0 ) , amount ) ; }
function approve ( address owner , address spender , uint256 amount ) internal virtual { require ( owner ! address ( 0 ) , " ERC20 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC20 : approve to the zero address " ) ; allowances [ owner ] [ spender ] amount ; emit Approval ( owner , spender , amount ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual { }
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address account ) external view returns ( uint256 ) ;
function transfer ( address recipient , uint256 amount ) external returns ( bool ) ;
function allowance ( address owner , address spender ) external view returns ( uint256 ) ;
function approve ( address spender , uint256 amount ) external returns ( bool ) ;
function transfer From ( address sender , address recipient , uint256 amount ) external returns ( bool ) ;
event Transfer ( address indexed from , address indexed to , uint256 value ) ;
event Approval ( address indexed owner , address indexed spender , uint256 value ) ;
function max Flash Loan ( address token ) public view override returns ( uint256 ) { return token address ( this ) ? type ( uint256 ) . max ERC20 . total Supply ( ) : 0 ; }
function flash Fee ( address token , uint256 amount ) public view virtual override returns ( uint256 ) { require ( token address ( this ) , " ERC20Flash Mint : wrong token " ) ; amount ; return 0 ; }
function flash Loan (
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) public virtual override { require ( block . timestamp < deadline , " ERC20Permit : expired deadline " ) ; bytes32 struct Hash keccak256 ( abi . encode ( PERMIT TYPEHASH , owner , spender , value , use Nonce ( owner ) , deadline ) ) ; bytes32 hash hash Typed Data V4 ( struct Hash ) ; address signer ECDSA . recover ( hash , v , r , s ) ; require ( signer owner , " ERC20Permit : invalid signature " ) ; approve ( owner , spender , value ) ; }
function nonces ( address owner ) public view virtual override returns ( uint256 ) { return nonces [ owner ] . current ( ) ; }
function DOMAIN SEPARATOR ( ) external view override returns ( bytes32 ) { return domain Separator V4 ( ) ; }
function use Nonce ( address owner ) internal virtual returns ( uint256 current ) { Counters . Counter storage nonce nonces [ owner ] ; current nonce . current ( ) ; nonce . increment ( ) ; }
function permit ( address owner , address spender , uint256 value , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external ;
function nonces ( address owner ) external view returns ( uint256 ) ;
function DOMAIN SEPARATOR ( ) external view returns ( bytes32 ) ;
function burn ( uint256 amount ) public virtual { burn ( msg Sender ( ) , amount ) ; }
function burn From ( address account , uint256 amount ) public virtual { uint256 current Allowance allowance ( account , msg Sender ( ) ) ; require ( current Allowance > amount , " ERC20 : burn amount exceeds allowance " ) ; approve ( account , msg Sender ( ) , current Allowance amount ) ; burn ( account , amount ) ; }
function cap ( ) public view virtual returns ( uint256 ) { return cap ; }
function mint ( address account , uint256 amount ) internal virtual override { require ( ERC20 . total Supply ( ) + amount < cap ( ) , " ERC20Capped : cap exceeded " ) ; super . mint ( account , amount ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; require ( ! paused ( ) , " ERC20Pausable : token transfer while paused " ) ; }
event Snapshot ( uint256 id ) ;
function snapshot ( ) internal virtual returns ( uint256 ) { current Snapshot Id . increment ( ) ; uint256 current Id current Snapshot Id . current ( ) ; emit Snapshot ( current Id ) ; return current Id ; }
function balance Of At ( address account , uint256 snapshot Id ) public view virtual returns ( uint256 ) { ( bool snapshotted , uint256 value ) value At ( snapshot Id , account Balance Snapshots [ account ] ) ; return snapshotted ? value : balance Of ( account ) ; }
function total Supply At ( uint256 snapshot Id ) public view virtual returns ( uint256 ) { ( bool snapshotted , uint256 value ) value At ( snapshot Id , total Supply Snapshots ) ; return snapshotted ? value : total Supply ( ) ; }
function before Token Transfer ( address from , address to , uint256 amount ) internal virtual override { super . before Token Transfer ( from , to , amount ) ; if ( from address ( 0 ) ) { update Account Snapshot ( to ) ; update Total Supply Snapshot ( ) ; } else if ( to address ( 0 ) ) { update Account Snapshot ( from ) ; update Total Supply Snapshot ( ) ; } else { update Account Snapshot ( from ) ; update Account Snapshot ( to ) ; } }
function name ( ) external view returns ( string memory ) ;
function symbol ( ) external view returns ( string memory ) ;
function decimals ( ) external view returns ( uint8 ) ;
function mint ( address to , uint256 amount ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have minter role to mint " ) ; mint ( to , amount ) ; }
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to pause " ) ; pause ( ) ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC20Preset Minter Pauser : must have pauser role to unpause " ) ; unpause ( ) ; }
function safe Approve ( IERC20 token , address spender , uint256 value ) internal { require ( ( value 0 ) | | ( token . allowance ( address ( this ) , spender ) 0 ) , " Safe ERC20 : approve from non zero to non zero allowance " ) ; call Optional Return ( token , abi . encode With Selector ( token . approve . selector , spender , value ) ) ; }
function call Optional Return ( IERC20 token , bytes memory data ) private { bytes memory returndata address ( token ) . function Call ( data , " Safe ERC20 : low level call failed " ) ; Return data is optional require ( abi . decode ( returndata , ( bool ) ) , " Safe ERC20 : ERC20 operation did not succeed " ) ; } }
function token ( ) public view virtual returns ( IERC20 ) { return token ; }
function beneficiary ( ) public view virtual returns ( address ) { return beneficiary ; }
function release Time ( ) public view virtual returns ( uint256 ) { return release Time ; }
function release ( ) public virtual { require ( block . timestamp > release Time ( ) , " Token Timelock : current time is before release time " ) ; uint256 amount token ( ) . balance Of ( address ( this ) ) ; require ( amount > 0 , " Token Timelock : no tokens to release " ) ; token ( ) . safe Transfer ( beneficiary ( ) , amount ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( ERC165 , IERC165 ) returns ( bool ) { return interface Id type ( IERC721 ) . interface Id | | interface Id type ( IERC721Metadata ) . interface Id | | super . supports Interface ( interface Id ) ; }
function balance Of ( address owner ) public view virtual override returns ( uint256 ) { require ( owner ! address ( 0 ) , " ERC721 : balance query for the zero address " ) ; return balances [ owner ] ; }
function owner Of ( uint256 token Id ) public view virtual override returns ( address ) { address owner owners [ token Id ] ; require ( owner ! address ( 0 ) , " ERC721 : owner query for nonexistent token " ) ; return owner ; }
function name ( ) public view virtual override returns ( string memory ) { return name ; }
function symbol ( ) public view virtual override returns ( string memory ) { return symbol ; }
function token URI ( uint256 token Id ) public view virtual override returns ( string memory ) { require ( exists ( token Id ) , " ERC721Metadata : URI query for nonexistent token " ) ; string memory base URI base URI ( ) ; return bytes ( base URI ) . length > 0 ? string ( abi . encode Packed ( base URI , token Id . to String ( ) ) ) : ' ' ; }
function base URI ( ) internal view virtual returns ( string memory ) { return " " ; }
function approve ( address to , uint256 token Id ) public virtual override { address owner ERC721 . owner Of ( token Id ) ; require ( to ! owner , " ERC721 : approval to current owner " ) ; require ( msg Sender ( ) owner | | is Approved For All ( owner , msg Sender ( ) ) , " ERC721 : approve caller is not owner nor approved for all " ) ; approve ( to , token Id ) ; }
function get Approved ( uint256 token Id ) public view virtual override returns ( address ) { require ( exists ( token Id ) , " ERC721 : approved query for nonexistent token " ) ; return token Approvals [ token Id ] ; }
function set Approval For All ( address operator , bool approved ) public virtual override { require ( operator ! msg Sender ( ) , " ERC721 : approve to caller " ) ; operator Approvals [ msg Sender ( ) ] [ operator ] approved ; emit Approval For All ( msg Sender ( ) , operator , approved ) ; }
function is Approved For All ( address owner , address operator ) public view virtual override returns ( bool ) { return operator Approvals [ owner ] [ operator ] ; }
function transfer From ( address from , address to , uint256 token Id ) public virtual override { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; transfer ( from , to , token Id ) ; }
function safe Transfer From ( address from , address to , uint256 token Id ) public virtual override { safe Transfer From ( from , to , token Id , " " ) ; }
function safe Transfer From ( address from , address to , uint256 token Id , bytes memory data ) public virtual override { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721 : transfer caller is not owner nor approved " ) ; safe Transfer ( from , to , token Id , data ) ; }
function safe Transfer ( address from , address to , uint256 token Id , bytes memory data ) internal virtual { transfer ( from , to , token Id ) ; require ( check On ERC721Received ( from , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function exists ( uint256 token Id ) internal view virtual returns ( bool ) { return owners [ token Id ] ! address ( 0 ) ; }
function is Approved Or Owner ( address spender , uint256 token Id ) internal view virtual returns ( bool ) { require ( exists ( token Id ) , " ERC721 : operator query for nonexistent token " ) ; address owner ERC721 . owner Of ( token Id ) ; return ( spender owner | | get Approved ( token Id ) spender | | is Approved For All ( owner , spender ) ) ; }
function safe Mint ( address to , uint256 token Id ) internal virtual { safe Mint ( to , token Id , " " ) ; }
function safe Mint ( address to , uint256 token Id , bytes memory data ) internal virtual { mint ( to , token Id ) ; require ( check On ERC721Received ( address ( 0 ) , to , token Id , data ) , " ERC721 : transfer to non ERC721Receiver implementer " ) ; }
function mint ( address to , uint256 token Id ) internal virtual { require ( to ! address ( 0 ) , " ERC721 : mint to the zero address " ) ; require ( ! exists ( token Id ) , " ERC721 : token already minted " ) ; before Token Transfer ( address ( 0 ) , to , token Id ) ; balances [ to ] + 1 ; owners [ token Id ] to ; emit Transfer ( address ( 0 ) , to , token Id ) ; }
function burn ( uint256 token Id ) internal virtual { address owner ERC721 . owner Of ( token Id ) ; before Token Transfer ( owner , address ( 0 ) , token Id ) ; approve ( address ( 0 ) , token Id ) ; balances [ owner ] 1 ; delete owners [ token Id ] ; emit Transfer ( owner , address ( 0 ) , token Id ) ; }
function transfer ( address from , address to , uint256 token Id ) internal virtual { require ( ERC721 . owner Of ( token Id ) from , " ERC721 : transfer of token that is not own " ) ; require ( to ! address ( 0 ) , " ERC721 : transfer to the zero address " ) ; before Token Transfer ( from , to , token Id ) ; approve ( address ( 0 ) , token Id ) ; balances [ from ] 1 ; balances [ to ] + 1 ; owners [ token Id ] to ; emit Transfer ( from , to , token Id ) ; }
function approve ( address to , uint256 token Id ) internal virtual { token Approvals [ token Id ] to ; emit Approval ( ERC721 . owner Of ( token Id ) , to , token Id ) ; }
function check On ERC721Received ( address from , address to , uint256 token Id , bytes memory data )
function before Token Transfer ( address from , address to , uint256 token Id ) internal virtual { }
event Transfer ( address indexed from , address indexed to , uint256 indexed token Id ) ;
event Approval ( address indexed owner , address indexed approved , uint256 indexed token Id ) ;
event Approval For All ( address indexed owner , address indexed operator , bool approved ) ;
function balance Of ( address owner ) external view returns ( uint256 balance ) ;
function owner Of ( uint256 token Id ) external view returns ( address owner ) ;
function safe Transfer From ( address from , address to , uint256 token Id ) external ;
function transfer From ( address from , address to , uint256 token Id ) external ;
function approve ( address to , uint256 token Id ) external ;
function get Approved ( uint256 token Id ) external view returns ( address operator ) ;
function set Approval For All ( address operator , bool approved ) external ;
function is Approved For All ( address owner , address operator ) external view returns ( bool ) ;
function safe Transfer From ( address from , address to , uint256 token Id , bytes calldata data ) external ;
function on ERC721Received ( address operator , address from , uint256 token Id , bytes calldata data ) external returns ( bytes4 ) ;
function burn ( uint256 token Id ) public virtual { require ( is Approved Or Owner ( msg Sender ( ) , token Id ) , " ERC721Burnable : caller is not owner nor approved " ) ; burn ( token Id ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( IERC165 , ERC721 ) returns ( bool ) { return interface Id type ( IERC721Enumerable ) . interface Id | | super . supports Interface ( interface Id ) ; }
function token Of Owner By Index ( address owner , uint256 index ) public view virtual override returns ( uint256 ) { require ( index < ERC721 . balance Of ( owner ) , " ERC721Enumerable : owner index out of bounds " ) ; return owned Tokens [ owner ] [ index ] ; }
function total Supply ( ) public view virtual override returns ( uint256 ) { return all Tokens . length ; }
function token By Index ( uint256 index ) public view virtual override returns ( uint256 ) { require ( index < ERC721Enumerable . total Supply ( ) , " ERC721Enumerable : global index out of bounds " ) ; return all Tokens [ index ] ; }
function before Token Transfer ( address from , address to , uint256 token Id ) internal virtual override { super . before Token Transfer ( from , to , token Id ) ; if ( from address ( 0 ) ) { add Token To All Tokens Enumeration ( token Id ) ; } else if ( from ! to ) { remove Token From Owner Enumeration ( from , token Id ) ; } if ( to address ( 0 ) ) { remove Token From All Tokens Enumeration ( token Id ) ; } else if ( to ! from ) { add Token To Owner Enumeration ( to , token Id ) ; } }
function add Token To Owner Enumeration ( address to , uint256 token Id ) private { uint256 length ERC721 . balance Of ( to ) ; owned Tokens [ to ] [ length ] token Id ; owned Tokens Index [ token Id ] length ; }
function add Token To All Tokens Enumeration ( uint256 token Id ) private { all Tokens Index [ token Id ] all Tokens . length ; all Tokens . push ( token Id ) ; }
function remove Token From Owner Enumeration ( address from , uint256 token Id ) private { uint256 last Token Index ERC721 . balance Of ( from ) 1 ; uint256 token Index owned Tokens Index [ token Id ] ; if ( token Index ! last Token Index ) { uint256 last Token Id owned Tokens [ from ] [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index } delete owned Tokens Index [ token Id ] ; delete owned Tokens [ from ] [ last Token Index ] ; }
function remove Token From All Tokens Enumeration ( uint256 token Id ) private { uint256 last Token Index all Tokens . length 1 ; uint256 token Index all Tokens Index [ token Id ] ; uint256 last Token Id all Tokens [ last Token Index ] ; Move the last token to the slot of the to delete token Update the moved token ' s index delete all Tokens Index [ token Id ] ; all Tokens . pop ( ) ; }
function before Token Transfer ( address from , address to , uint256 token Id ) internal virtual override { super . before Token Transfer ( from , to , token Id ) ; require ( ! paused ( ) , " ERC721Pausable : token transfer while paused " ) ; }
function token URI ( uint256 token Id ) public view virtual override returns ( string memory ) { require ( exists ( token Id ) , " ERC721URI Storage : URI query for nonexistent token " ) ; string memory token URI token UR Is [ token Id ] ; string memory base base URI ( ) ; if ( bytes ( base ) . length 0 ) { return token URI ; } if ( bytes ( token URI ) . length > 0 ) { return string ( abi . encode Packed ( base , token URI ) ) ; } return super . token URI ( token Id ) ; }
function set Token URI ( uint256 token Id , string memory token URI ) internal virtual { require ( exists ( token Id ) , " ERC721URI Storage : URI set of nonexistent token " ) ; token UR Is [ token Id ] token URI ; }
function burn ( uint256 token Id ) internal virtual override { super . burn ( token Id ) ; if ( bytes ( token UR Is [ token Id ] ) . length ! 0 ) { delete token UR Is [ token Id ] ; } }
function total Supply ( ) external view returns ( uint256 ) ;
function token Of Owner By Index ( address owner , uint256 index ) external view returns ( uint256 token Id ) ;
function token By Index ( uint256 index ) external view returns ( uint256 ) ;
function name ( ) external view returns ( string memory ) ;
function symbol ( ) external view returns ( string memory ) ;
function token URI ( uint256 token Id ) external view returns ( string memory ) ;
function mint ( address to ) public virtual { require ( has Role ( MINTER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have minter role to mint " ) ; mint ( to , token Id Tracker . current ( ) ) ; token Id Tracker . increment ( ) ; }
function pause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have pauser role to pause " ) ; pause ( ) ; }
function unpause ( ) public virtual { require ( has Role ( PAUSER ROLE , msg Sender ( ) ) , " ERC721Preset Minter Pauser Auto Id : must have pauser role to unpause " ) ; unpause ( ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override ( Access Control Enumerable , ERC721 , ERC721Enumerable ) returns ( bool ) { return super . supports Interface ( interface Id ) ; }
function on ERC721Received ( address , address , uint256 , bytes memory ) public virtual override returns ( bytes4 ) { return this . on ERC721Received . selector ; }
function name ( ) public view virtual override returns ( string memory ) { return name ; }
function symbol ( ) public view virtual override returns ( string memory ) { return symbol ; }
function decimals ( ) public pure virtual returns ( uint8 ) { return 18 ; }
function granularity ( ) public view virtual override returns ( uint256 ) { return 1 ; }
function total Supply ( ) public view virtual override ( IERC20 , IERC777 ) returns ( uint256 ) { return total Supply ; }
function balance Of ( address token Holder ) public view virtual override ( IERC20 , IERC777 ) returns ( uint256 ) { return balances [ token Holder ] ; }
function send ( address recipient , uint256 amount , bytes memory data ) public virtual override { send ( msg Sender ( ) , recipient , amount , data , " " , true ) ; }
function transfer ( address recipient , uint256 amount ) public virtual override returns ( bool ) { require ( recipient ! address ( 0 ) , " ERC777 : transfer to the zero address " ) ; address from msg Sender ( ) ; call Tokens To Send ( from , from , recipient , amount , " " , " " ) ; move ( from , from , recipient , amount , " " , " " ) ; call Tokens Received ( from , from , recipient , amount , " " , " " , false ) ; return true ; }
function burn ( uint256 amount , bytes memory data ) public virtual override { burn ( msg Sender ( ) , amount , data , " " ) ; }
function is Operator For ( address operator , address token Holder ) public view virtual override returns ( bool ) { return operator token Holder | | ( default Operators [ operator ] & & ! revoked Default Operators [ token Holder ] [ operator ] ) | | operators [ token Holder ] [ operator ] ; }
function authorize Operator ( address operator ) public virtual override { require ( msg Sender ( ) ! operator , " ERC777 : authorizing self as operator " ) ; if ( default Operators [ operator ] ) { delete revoked Default Operators [ msg Sender ( ) ] [ operator ] ; } else { operators [ msg Sender ( ) ] [ operator ] true ; } emit Authorized Operator ( operator , msg Sender ( ) ) ; }
function revoke Operator ( address operator ) public virtual override { require ( operator ! msg Sender ( ) , " ERC777 : revoking self as operator " ) ; if ( default Operators [ operator ] ) { revoked Default Operators [ msg Sender ( ) ] [ operator ] true ; } else { delete operators [ msg Sender ( ) ] [ operator ] ; } emit Revoked Operator ( operator , msg Sender ( ) ) ; }
function default Operators ( ) public view virtual override returns ( address [ ] memory ) { return default Operators Array ; }
function operator Send (
function operator Burn ( address account , uint256 amount , bytes memory data , bytes memory operator Data ) public virtual override { require ( is Operator For ( msg Sender ( ) , account ) , " ERC777 : caller is not an operator for holder " ) ; burn ( account , amount , data , operator Data ) ; }
function allowance ( address holder , address spender ) public view virtual override returns ( uint256 ) { return allowances [ holder ] [ spender ] ; }
function approve ( address spender , uint256 value ) public virtual override returns ( bool ) { address holder msg Sender ( ) ; approve ( holder , spender , value ) ; return true ; }
function transfer From ( address holder , address recipient , uint256 amount ) public virtual override returns ( bool ) { require ( recipient ! address ( 0 ) , " ERC777 : transfer to the zero address " ) ; require ( holder ! address ( 0 ) , " ERC777 : transfer from the zero address " ) ; address spender msg Sender ( ) ; call Tokens To Send ( spender , holder , recipient , amount , " " , " " ) ; move ( spender , holder , recipient , amount , " " , " " ) ; uint256 current Allowance allowances [ holder ] [ spender ] ; require ( current Allowance > amount , " ERC777 : transfer amount exceeds allowance " ) ; approve ( holder , spender , current Allowance amount ) ; call Tokens Received ( spender , holder , recipient , amount , " " , " " , false ) ; return true ; }
function mint (
function mint (
function send (
function burn (
function approve ( address holder , address spender , uint256 value ) internal { require ( holder ! address ( 0 ) , " ERC777 : approve from the zero address " ) ; require ( spender ! address ( 0 ) , " ERC777 : approve to the zero address " ) ; allowances [ holder ] [ spender ] value ; emit Approval ( holder , spender , value ) ; }
function call Tokens To Send (
function call Tokens Received (
function before Token Transfer ( address operator , address from , address to , uint256 amount ) internal virtual { }
function name ( ) external view returns ( string memory ) ;
function symbol ( ) external view returns ( string memory ) ;
function granularity ( ) external view returns ( uint256 ) ;
function total Supply ( ) external view returns ( uint256 ) ;
function balance Of ( address owner ) external view returns ( uint256 ) ;
function send ( address recipient , uint256 amount , bytes calldata data ) external ;
function burn ( uint256 amount , bytes calldata data ) external ;
function is Operator For ( address operator , address token Holder ) external view returns ( bool ) ;
function authorize Operator ( address operator ) external ;
function revoke Operator ( address operator ) external ;
function default Operators ( ) external view returns ( address [ ] memory ) ;
function operator Send (
function operator Burn (
function tokens Received (
function tokens To Send (
function is Contract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size : extcodesize ( account ) } return size > 0 ; }
function send Value ( address payable recipient , uint256 amount ) internal { require ( address ( this ) . balance > amount , " Address : insufficient balance " ) ; ( bool success , ) recipient . call { value : amount } ( " " ) ; require ( success , " Address : unable to send value , recipient may have reverted " ) ; }
function function Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Call ( target , data , " Address : low level call failed " ) ; }
function function Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { return function Call With Value ( target , data , 0 , error Message ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value ) internal returns ( bytes memory ) { return function Call With Value ( target , data , value , " Address : low level call with value failed " ) ; }
function function Call With Value ( address target , bytes memory data , uint256 value , string memory error Message ) internal returns ( bytes memory ) { require ( address ( this ) . balance > value , " Address : insufficient balance for call " ) ; require ( is Contract ( target ) , " Address : call to non contract " ) ; ( bool success , bytes memory returndata ) target . call { value : value } ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function function Static Call ( address target , bytes memory data ) internal view returns ( bytes memory ) { return function Static Call ( target , data , " Address : low level static call failed " ) ; }
function function Static Call ( address target , bytes memory data , string memory error Message ) internal view returns ( bytes memory ) { require ( is Contract ( target ) , " Address : static call to non contract " ) ; ( bool success , bytes memory returndata ) target . staticcall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function function Delegate Call ( address target , bytes memory data ) internal returns ( bytes memory ) { return function Delegate Call ( target , data , " Address : low level delegate call failed " ) ; }
function function Delegate Call ( address target , bytes memory data , string memory error Message ) internal returns ( bytes memory ) { require ( is Contract ( target ) , " Address : delegate call to non contract " ) ; ( bool success , bytes memory returndata ) target . delegatecall ( data ) ; return verify Call Result ( success , returndata , error Message ) ; }
function find Upper Bound ( uint256 [ ] storage array , uint256 element ) internal view returns ( uint256 ) { if ( array . length 0 ) { return 0 ; } uint256 low 0 ; uint256 high array . length ; while ( low < high ) { uint256 mid Math . average ( low , high ) ; if ( array [ mid ] > element ) { high mid ; } else { low mid + 1 ; } } if ( low > 0 & & array [ low 1 ] element ) { return low 1 ; } else { return low ; } }
function deploy ( uint256 amount , bytes32 salt , bytes memory bytecode ) internal returns ( address ) { address addr ; require ( address ( this ) . balance > amount , " Create2 : insufficient balance " ) ; require ( bytecode . length ! 0 , " Create2 : bytecode length is zero " ) ; assembly { addr : create2 ( amount , add ( bytecode , 0x20 ) , mload ( bytecode ) , salt ) } require ( addr ! address ( 0 ) , " Create2 : Failed on deploy " ) ; return addr ; }
function compute Address ( bytes32 salt , bytes32 bytecode Hash ) internal view returns ( address ) { return compute Address ( salt , bytecode Hash , address ( this ) ) ; }
function compute Address ( bytes32 salt , bytes32 bytecode Hash , address deployer ) internal pure returns ( address ) { bytes32 data keccak256 ( abi . encode Packed ( bytes1 ( 0xff ) , deployer , salt , bytecode Hash ) ) ; return address ( uint160 ( uint256 ( data ) ) ) ; }
function multicall ( bytes [ ] calldata data ) external returns ( bytes [ ] memory results ) { results new bytes [ ] ( data . length ) ; for ( uint i 0 ; i < data . length ; i + + ) { results [ i ] Address . function Delegate Call ( address ( this ) , data [ i ] ) ; } return results ; }
function get Address Slot ( bytes32 slot ) internal pure returns ( Address Slot storage r ) { assembly { r . slot : slot } }
function get Boolean Slot ( bytes32 slot ) internal pure returns ( Boolean Slot storage r ) { assembly { r . slot : slot } }
function get Bytes32Slot ( bytes32 slot ) internal pure returns ( Bytes32Slot storage r ) { assembly { r . slot : slot } }
function get Uint256Slot ( bytes32 slot ) internal pure returns ( Uint256Slot storage r ) { assembly { r . slot : slot } }
function to String ( uint256 value ) internal pure returns ( string memory ) { if ( value 0 ) { return " 0 " ; } uint256 temp value ; uint256 digits ; while ( temp ! 0 ) { digits + + ; temp 10 ; } bytes memory buffer new bytes ( digits ) ; while ( value ! 0 ) { digits 1 ; buffer [ digits ] bytes1 ( uint8 ( 48 + uint256 ( value % 10 ) ) ) ; value 10 ; } return string ( buffer ) ; }
function to Hex String ( uint256 value ) internal pure returns ( string memory ) { if ( value 0 ) { return " 0x00 " ; } uint256 temp value ; uint256 length 0 ; while ( temp ! 0 ) { length + + ; temp > > 8 ; } return to Hex String ( value , length ) ; }
function to Hex String ( uint256 value , uint256 length ) internal pure returns ( string memory ) { bytes memory buffer new bytes ( 2 length + 2 ) ; buffer [ 0 ] " 0 " ; buffer [ 1 ] " x " ; for ( uint256 i 2 length + 1 ; i > 1 ; i ) { buffer [ i ] alphabet [ value & 0xf ] ; value > > 4 ; } require ( value 0 , " Strings : hex length insufficient " ) ; return string ( buffer ) ; }
function domain Separator V4 ( ) internal view returns ( bytes32 ) { if ( block . chainid CACHED CHAIN ID ) { return CACHED DOMAIN SEPARATOR ; } else { return build Domain Separator ( TYPE HASH , HASHED NAME , HASHED VERSION ) ; } }
function hash Typed Data V4 ( bytes32 struct Hash ) internal view virtual returns ( bytes32 ) { return ECDSA . to Typed Data Hash ( domain Separator V4 ( ) , struct Hash ) ; }
function recover ( bytes32 hash , bytes memory signature ) internal pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( signature . length 65 ) { assembly { r : mload ( add ( signature , 0x20 ) ) s : mload ( add ( signature , 0x40 ) ) v : byte ( 0 , mload ( add ( signature , 0x60 ) ) ) } } else if ( signature . length 64 ) { assembly { let vs : mload ( add ( signature , 0x40 ) ) r : mload ( add ( signature , 0x20 ) ) s : and ( vs , 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ) v : add ( shr ( 255 , vs ) , 27 ) } } else { revert ( " ECDSA : invalid signature length " ) ; } return recover ( hash , v , r , s ) ; }
function to Eth Signed Message Hash ( bytes32 hash ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encode Packed ( " \ x19Ethereum Signed Message : \ n32 " , hash ) ) ; }
function to Typed Data Hash ( bytes32 domain Separator , bytes32 struct Hash ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encode Packed ( " \ x19 \ x01 " , domain Separator , struct Hash ) ) ; }
function verify ( bytes32 [ ] memory proof , bytes32 root , bytes32 leaf ) internal pure returns ( bool ) { bytes32 computed Hash leaf ; for ( uint256 i 0 ; i < proof . length ; i + + ) { bytes32 proof Element proof [ i ] ; if ( computed Hash < proof Element ) { computed Hash keccak256 ( abi . encode Packed ( computed Hash , proof Element ) ) ; } else { computed Hash keccak256 ( abi . encode Packed ( proof Element , computed Hash ) ) ; } } return computed Hash root ; }
function withdrawal Allowed ( address payee ) public view virtual returns ( bool ) ;
function deposit ( address payee ) public payable virtual only Owner { uint256 amount msg . value ; deposits [ payee ] deposits [ payee ] + amount ; emit Deposited ( payee , amount ) ; }
function withdraw ( address payable payee ) public virtual only Owner { uint256 payment deposits [ payee ] ; deposits [ payee ] 0 ; payee . send Value ( payment ) ; emit Withdrawn ( payee , payment ) ; }
function state ( ) public view virtual returns ( State ) { return state ; }
function beneficiary ( ) public view virtual returns ( address payable ) { return beneficiary ; }
function deposit ( address refundee ) public payable virtual override { require ( state ( ) State . Active , " Refund Escrow : can only deposit while active " ) ; super . deposit ( refundee ) ; }
function close ( ) public virtual only Owner { require ( state ( ) State . Active , " Refund Escrow : can only close while active " ) ; state State . Closed ; emit Refunds Closed ( ) ; }
function enable Refunds ( ) public only Owner virtual { require ( state ( ) State . Active , " Refund Escrow : can only enable refunds while active " ) ; state State . Refunding ; emit Refunds Enabled ( ) ; }
function beneficiary Withdraw ( ) public virtual { require ( state ( ) State . Closed , " Refund Escrow : beneficiary can only withdraw while closed " ) ; beneficiary ( ) . send Value ( address ( this ) . balance ) ; }
function withdrawal Allowed ( address ) public view override returns ( bool ) { return state ( ) State . Refunding ; }
function supports Interface ( bytes4 interface Id ) public view virtual override returns ( bool ) { return interface Id type ( IERC165 ) . interface Id ; }
function supports ERC165 ( address account ) internal view returns ( bool ) { return supports ERC165Interface ( account , type ( IERC165 ) . interface Id ) & & ! supports ERC165Interface ( account , INTERFACE ID INVALID ) ; }
function supports Interface ( address account , bytes4 interface Id ) internal view returns ( bool ) { return supports ERC165 ( account ) & & supports ERC165Interface ( account , interface Id ) ; }
function get Supported Interfaces ( address account , bytes4 [ ] memory interface Ids ) internal view returns ( bool [ ] memory ) { bool [ ] memory interface Ids Supported new bool [ ] ( interface Ids . length ) ; if ( supports ERC165 ( account ) ) { for ( uint256 i 0 ; i < interface Ids . length ; i + + ) { interface Ids Supported [ i ] supports ERC165Interface ( account , interface Ids [ i ] ) ; } } return interface Ids Supported ; }
function supports All Interfaces ( address account , bytes4 [ ] memory interface Ids ) internal view returns ( bool ) { if ( ! supports ERC165 ( account ) ) { return false ; } for ( uint256 i 0 ; i < interface Ids . length ; i + + ) { if ( ! supports ERC165Interface ( account , interface Ids [ i ] ) ) { return false ; } } return true ; }
function supports ERC165Interface ( address account , bytes4 interface Id ) private view returns ( bool ) { bytes memory encoded Params abi . encode With Selector ( IERC165 ( account ) . supports Interface . selector , interface Id ) ; ( bool success , bytes memory result ) account . staticcall { gas : 30000 } ( encoded Params ) ; if ( result . length < 32 ) return false ; return success & & abi . decode ( result , ( bool ) ) ; }
function supports Interface ( bytes4 interface Id ) public view virtual override returns ( bool ) { return super . supports Interface ( interface Id ) | | supported Interfaces [ interface Id ] ; }
function register Interface ( bytes4 interface Id ) internal virtual { require ( interface Id ! 0xffffffff , " ERC165 : invalid interface id " ) ; supported Interfaces [ interface Id ] true ; }
function can Implement Interface For Address ( bytes32 interface Hash , address account ) public view virtual override returns ( bytes32 ) { return supported Interfaces [ interface Hash ] [ account ] ? ERC1820 ACCEPT MAGIC : bytes32 ( 0x00 ) ; }
function register Interface For Address ( bytes32 interface Hash , address account ) internal virtual { supported Interfaces [ interface Hash ] [ account ] true ; }
function supports Interface ( bytes4 interface Id ) external view returns ( bool ) ;
function can Implement Interface For Address ( bytes32 interface Hash , address account ) external view returns ( bytes32 ) ;
function set Manager ( address account , address new Manager ) external ;
function get Manager ( address account ) external view returns ( address ) ;
function set Interface Implementer ( address account , bytes32 interface Hash , address implementer ) external ;
function get Interface Implementer ( address account , bytes32 interface Hash ) external view returns ( address ) ;
function interface Hash ( string calldata interface Name ) external pure returns ( bytes32 ) ;
function update ERC165Cache ( address account , bytes4 interface Id ) external ;
function implements ERC165Interface ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function implements ERC165Interface No Cache ( address account , bytes4 interface Id ) external view returns ( bool ) ;
function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a > b ? a : b ; }
function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }
function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a 2 ) + ( b 2 ) + ( ( a % 2 + b % 2 ) 2 ) ; }
function to Uint128 ( uint256 value ) internal pure returns ( uint128 ) { require ( value < 2 128 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return uint128 ( value ) ; }
function to Uint64 ( uint256 value ) internal pure returns ( uint64 ) { require ( value < 2 64 , " Safe Cast : value doesn \ ' t fit in 64 bits " ) ; return uint64 ( value ) ; }
function to Uint32 ( uint256 value ) internal pure returns ( uint32 ) { require ( value < 2 32 , " Safe Cast : value doesn \ ' t fit in 32 bits " ) ; return uint32 ( value ) ; }
function to Uint16 ( uint256 value ) internal pure returns ( uint16 ) { require ( value < 2 16 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return uint16 ( value ) ; }
function to Uint8 ( uint256 value ) internal pure returns ( uint8 ) { require ( value < 2 8 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return uint8 ( value ) ; }
function to Uint256 ( int256 value ) internal pure returns ( uint256 ) { require ( value > 0 , " Safe Cast : value must be positive " ) ; return uint256 ( value ) ; }
function to Int128 ( int256 value ) internal pure returns ( int128 ) { require ( value > 2 127 & & value < 2 127 , " Safe Cast : value doesn \ ' t fit in 128 bits " ) ; return int128 ( value ) ; }
function to Int64 ( int256 value ) internal pure returns ( int64 ) { require ( value > 2 63 & & value < 2 63 , " Safe Cast : value doesn \ ' t fit in 64 bits " ) ; return int64 ( value ) ; }
function to Int32 ( int256 value ) internal pure returns ( int32 ) { require ( value > 2 31 & & value < 2 31 , " Safe Cast : value doesn \ ' t fit in 32 bits " ) ; return int32 ( value ) ; }
function to Int16 ( int256 value ) internal pure returns ( int16 ) { require ( value > 2 15 & & value < 2 15 , " Safe Cast : value doesn \ ' t fit in 16 bits " ) ; return int16 ( value ) ; }
function to Int8 ( int256 value ) internal pure returns ( int8 ) { require ( value > 2 7 & & value < 2 7 , " Safe Cast : value doesn \ ' t fit in 8 bits " ) ; return int8 ( value ) ; }
function to Int256 ( uint256 value ) internal pure returns ( int256 ) { require ( value < 2 255 , " Safe Cast : value doesn ' t fit in an int256 " ) ; return int256 ( value ) ; }
function try Add ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { uint256 c a + b ; if ( c < a ) return ( false , 0 ) ; return ( true , c ) ; } }
function try Sub ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { if ( b > a ) return ( false , 0 ) ; return ( true , a b ) ; } }
function try Mul ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { if ( a 0 ) return ( true , 0 ) ; uint256 c a b ; if ( c a ! b ) return ( false , 0 ) ; return ( true , c ) ; } }
function try Div ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { if ( b 0 ) return ( false , 0 ) ; return ( true , a b ) ; } }
function try Mod ( uint256 a , uint256 b ) internal pure returns ( bool , uint256 ) { unchecked { if ( b 0 ) return ( false , 0 ) ; return ( true , a % b ) ; } }
function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a + b ; }
function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a b ; }
function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a % b ; }
function sub ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { unchecked { require ( b < a , error Message ) ; return a b ; } }
function div ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { unchecked { require ( b > 0 , error Message ) ; return a b ; } }
function mod ( uint256 a , uint256 b , string memory error Message ) internal pure returns ( uint256 ) { unchecked { require ( b > 0 , error Message ) ; return a % b ; } }
function mul ( int256 a , int256 b ) internal pure returns ( int256 ) { return a b ; }
function div ( int256 a , int256 b ) internal pure returns ( int256 ) { return a b ; }
function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { return a b ; }
function add ( int256 a , int256 b ) internal pure returns ( int256 ) { return a + b ; }
function set ( Map storage map , bytes32 key , bytes32 value ) private returns ( bool ) { map . values [ key ] value ; return map . keys . add ( key ) ; }
function remove ( Map storage map , bytes32 key ) private returns ( bool ) { delete map . values [ key ] ; return map . keys . remove ( key ) ; }
function contains ( Map storage map , bytes32 key ) private view returns ( bool ) { return map . keys . contains ( key ) ; }
function length ( Map storage map ) private view returns ( uint256 ) { return map . keys . length ( ) ; }
function at ( Map storage map , uint256 index ) private view returns ( bytes32 , bytes32 ) { bytes32 key map . keys . at ( index ) ; return ( key , map . values [ key ] ) ; }
function try Get ( Map storage map , bytes32 key ) private view returns ( bool , bytes32 ) { bytes32 value map . values [ key ] ; if ( value bytes32 ( 0 ) ) { return ( contains ( map , key ) , bytes32 ( 0 ) ) ; } else { return ( true , value ) ; } }
function get ( Map storage map , bytes32 key ) private view returns ( bytes32 ) { bytes32 value map . values [ key ] ; require ( value ! 0 | | contains ( map , key ) , " Enumerable Map : nonexistent key " ) ; return value ; }
function get ( Map storage map , bytes32 key , string memory error Message ) private view returns ( bytes32 ) { bytes32 value map . values [ key ] ; require ( value ! 0 | | contains ( map , key ) , error Message ) ; return value ; }
function set ( Uint To Address Map storage map , uint256 key , address value ) internal returns ( bool ) { return set ( map . inner , bytes32 ( key ) , bytes32 ( uint256 ( uint160 ( value ) ) ) ) ; }
function remove ( Uint To Address Map storage map , uint256 key ) internal returns ( bool ) { return remove ( map . inner , bytes32 ( key ) ) ; }
function contains ( Uint To Address Map storage map , uint256 key ) internal view returns ( bool ) { return contains ( map . inner , bytes32 ( key ) ) ; }
function length ( Uint To Address Map storage map ) internal view returns ( uint256 ) { return length ( map . inner ) ; }
function at ( Uint To Address Map storage map , uint256 index ) internal view returns ( uint256 , address ) { ( bytes32 key , bytes32 value ) at ( map . inner , index ) ; return ( uint256 ( key ) , address ( uint160 ( uint256 ( value ) ) ) ) ; }
function try Get ( Uint To Address Map storage map , uint256 key ) internal view returns ( bool , address ) { ( bool success , bytes32 value ) try Get ( map . inner , bytes32 ( key ) ) ; return ( success , address ( uint160 ( uint256 ( value ) ) ) ) ; }
function get ( Uint To Address Map storage map , uint256 key ) internal view returns ( address ) { return address ( uint160 ( uint256 ( get ( map . inner , bytes32 ( key ) ) ) ) ) ; }
function get ( Uint To Address Map storage map , uint256 key , string memory error Message ) internal view returns ( address ) { return address ( uint160 ( uint256 ( get ( map . inner , bytes32 ( key ) , error Message ) ) ) ) ; }
function add ( Set storage set , bytes32 value ) private returns ( bool ) { if ( ! contains ( set , value ) ) { set . values . push ( value ) ; set . indexes [ value ] set . values . length ; return true ; } else { return false ; } }
function remove ( Set storage set , bytes32 value ) private returns ( bool ) { uint256 value Index set . indexes [ value ] ; Equivalent to contains ( set , value ) uint256 to Delete Index value Index 1 ; uint256 last Index set . values . length 1 ; bytes32 lastvalue set . values [ last Index ] ; set . values [ to Delete Index ] lastvalue ; Replace lastvalue ' s index to value Index set . values . pop ( ) ; delete set . indexes [ value ] ; return true ; } else { return false ; } }
function contains ( Set storage set , bytes32 value ) private view returns ( bool ) { return set . indexes [ value ] ! 0 ; }
function length ( Set storage set ) private view returns ( uint256 ) { return set . values . length ; }
function at ( Set storage set , uint256 index ) private view returns ( bytes32 ) { require ( set . values . length > index , " Enumerable Set : index out of bounds " ) ; return set . values [ index ] ; }
function add ( Bytes32Set storage set , bytes32 value ) internal returns ( bool ) { return add ( set . inner , value ) ; }
function remove ( Bytes32Set storage set , bytes32 value ) internal returns ( bool ) { return remove ( set . inner , value ) ; }
function contains ( Bytes32Set storage set , bytes32 value ) internal view returns ( bool ) { return contains ( set . inner , value ) ; }
function length ( Bytes32Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function at ( Bytes32Set storage set , uint256 index ) internal view returns ( bytes32 ) { return at ( set . inner , index ) ; }
function add ( Address Set storage set , address value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( uint256 ( uint160 ( value ) ) ) ) ; }
function remove ( Address Set storage set , address value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( uint256 ( uint160 ( value ) ) ) ) ; }
function contains ( Address Set storage set , address value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( uint256 ( uint160 ( value ) ) ) ) ; }
function length ( Address Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function at ( Address Set storage set , uint256 index ) internal view returns ( address ) { return address ( uint160 ( uint256 ( at ( set . inner , index ) ) ) ) ; }
function add ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return add ( set . inner , bytes32 ( value ) ) ; }
function remove ( Uint Set storage set , uint256 value ) internal returns ( bool ) { return remove ( set . inner , bytes32 ( value ) ) ; }
function contains ( Uint Set storage set , uint256 value ) internal view returns ( bool ) { return contains ( set . inner , bytes32 ( value ) ) ; }
function length ( Uint Set storage set ) internal view returns ( uint256 ) { return length ( set . inner ) ; }
function at ( Uint Set storage set , uint256 index ) internal view returns ( uint256 ) { return uint256 ( at ( set . inner , index ) ) ; }
